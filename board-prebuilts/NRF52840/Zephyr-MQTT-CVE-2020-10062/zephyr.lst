
zephyr.elf:     file format elf32-littlearm


Disassembly of section text:

00000000 <_vector_table>:

	forced_pm_state = state;
}

enum power_states _sys_suspend(s32_t ticks)
{
   0:	20008d18 	.word	0x20008d18
	bool deep_sleep;

	pm_state = (forced_pm_state == SYS_POWER_STATE_AUTO) ?
   4:	0000a001 	.word	0x0000a001
		   sys_pm_policy_next_state(ticks) : forced_pm_state;
   8:	0001301f 	.word	0x0001301f
   c:	00009e8d 	.word	0x00009e8d
  10:	00009e8d 	.word	0x00009e8d

	if (pm_state == SYS_POWER_STATE_ACTIVE) {
  14:	00009e8d 	.word	0x00009e8d
  18:	00009e8d 	.word	0x00009e8d

	deep_sleep = IS_ENABLED(CONFIG_SYS_POWER_DEEP_SLEEP_STATES) ?
		     sys_pm_is_deep_sleep_state(pm_state) : 0;

	post_ops_done = 0;
	sys_pm_notify_power_state_entry(pm_state);
  1c:	00009e8d 	.word	0x00009e8d
	post_ops_done = 0;
  20:	00009e8d 	.word	0x00009e8d
	sys_pm_notify_power_state_entry(pm_state);
  24:	00009e8d 	.word	0x00009e8d
		_sys_pm_idle_exit_notification_disable();
	}

	/* Enter power state */
	sys_pm_debug_start_timer();
	sys_set_power_state(pm_state);
  28:	00009e8d 	.word	0x00009e8d
  2c:	00009ac9 	.word	0x00009ac9
		sys_pm_resume_devices();
	}
#endif
	sys_pm_log_debug_info(pm_state);

	if (!post_ops_done) {
  30:	0000fef9 	.word	0x0000fef9
		post_ops_done = 1;
		sys_pm_notify_power_state_exit(pm_state);
  34:	00009e8d 	.word	0x00009e8d
		post_ops_done = 1;
  38:	00009a71 	.word	0x00009a71
		sys_pm_notify_power_state_exit(pm_state);
  3c:	0001300f 	.word	0x0001300f

00000040 <_irq_vector_table>:
		_sys_pm_power_state_exit_post_ops(pm_state);
  40:	00009fc1 00009fc1 00009fc1 00009fc1     ................
	}

	return pm_state;
}
  50:	00009fc1 00009fc1 00009fc1 00009fc1     ................
  60:	00009fc1 00009fc1 00009fc1 00009fc1     ................
  70:	00009fc1 00009fc1 00009fc1 00009fc1     ................
  80:	00009fc1 00009fc1 00009fc1 00009fc1     ................
  90:	00009fc1 00009fc1 00009fc1 00009fc1     ................
  a0:	00009fc1 00009fc1 00009fc1 00009fc1     ................
  b0:	00009fc1 00009fc1 00009fc1 00009fc1     ................
  c0:	00009fc1 00009fc1 00009fc1 00009fc1     ................
  d0:	00009fc1 00009fc1 00009fc1 00009fc1     ................
  e0:	00009fc1 00009fc1 00009fc1 00009fc1     ................
  f0:	00009fc1 00009fc1 00009fc1 00009fc1     ................

Disassembly of section _TEXT_SECTION_NAME_2:

00000100 <memchr>:
     100:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     104:	2a10      	cmp	r2, #16
     106:	db2b      	blt.n	160 <CONFIG_IDLE_STACK_SIZE+0x20>
     108:	f010 0f07 	tst.w	r0, #7
     10c:	d008      	beq.n	120 <memchr+0x20>
     10e:	f810 3b01 	ldrb.w	r3, [r0], #1
     112:	3a01      	subs	r2, #1
     114:	428b      	cmp	r3, r1
     116:	d02d      	beq.n	174 <CONFIG_IDLE_STACK_SIZE+0x34>
     118:	f010 0f07 	tst.w	r0, #7
     11c:	b342      	cbz	r2, 170 <CONFIG_IDLE_STACK_SIZE+0x30>
     11e:	d1f6      	bne.n	10e <memchr+0xe>
     120:	b4f0      	push	{r4, r5, r6, r7}
     122:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
     126:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
     12a:	f022 0407 	bic.w	r4, r2, #7
     12e:	f07f 0700 	mvns.w	r7, #0
     132:	2300      	movs	r3, #0
     134:	e8f0 5602 	ldrd	r5, r6, [r0], #8
     138:	3c08      	subs	r4, #8
     13a:	ea85 0501 	eor.w	r5, r5, r1
     13e:	ea86 0601 	eor.w	r6, r6, r1
     142:	fa85 f547 	uadd8	r5, r5, r7
     146:	faa3 f587 	sel	r5, r3, r7
     14a:	fa86 f647 	uadd8	r6, r6, r7
     14e:	faa5 f687 	sel	r6, r5, r7
     152:	b98e      	cbnz	r6, 178 <CONFIG_IDLE_STACK_SIZE+0x38>
     154:	d1ee      	bne.n	134 <memchr+0x34>
     156:	bcf0      	pop	{r4, r5, r6, r7}
     158:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     15c:	f002 0207 	and.w	r2, r2, #7
     160:	b132      	cbz	r2, 170 <CONFIG_IDLE_STACK_SIZE+0x30>
     162:	f810 3b01 	ldrb.w	r3, [r0], #1
     166:	3a01      	subs	r2, #1
     168:	ea83 0301 	eor.w	r3, r3, r1
     16c:	b113      	cbz	r3, 174 <CONFIG_IDLE_STACK_SIZE+0x34>
     16e:	d1f8      	bne.n	162 <CONFIG_IDLE_STACK_SIZE+0x22>
     170:	2000      	movs	r0, #0
     172:	4770      	bx	lr
     174:	3801      	subs	r0, #1
     176:	4770      	bx	lr
     178:	2d00      	cmp	r5, #0
     17a:	bf06      	itte	eq
     17c:	4635      	moveq	r5, r6
     17e:	3803      	subeq	r0, #3
     180:	3807      	subne	r0, #7
     182:	f015 0f01 	tst.w	r5, #1
     186:	d107      	bne.n	198 <CONFIG_IDLE_STACK_SIZE+0x58>
     188:	3001      	adds	r0, #1
     18a:	f415 7f80 	tst.w	r5, #256	; 0x100
     18e:	bf02      	ittt	eq
     190:	3001      	addeq	r0, #1
     192:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
     196:	3001      	addeq	r0, #1
     198:	bcf0      	pop	{r4, r5, r6, r7}
     19a:	3801      	subs	r0, #1
     19c:	4770      	bx	lr
     19e:	bf00      	nop

000001a0 <__aeabi_frsub>:
     1a0:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
     1a4:	e002      	b.n	1ac <__addsf3>
     1a6:	bf00      	nop

000001a8 <__aeabi_fsub>:
     1a8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

000001ac <__addsf3>:
     1ac:	0042      	lsls	r2, r0, #1
     1ae:	bf1f      	itttt	ne
     1b0:	ea5f 0341 	movsne.w	r3, r1, lsl #1
     1b4:	ea92 0f03 	teqne	r2, r3
     1b8:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
     1bc:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
     1c0:	d06a      	beq.n	298 <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0x98>
     1c2:	ea4f 6212 	mov.w	r2, r2, lsr #24
     1c6:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
     1ca:	bfc1      	itttt	gt
     1cc:	18d2      	addgt	r2, r2, r3
     1ce:	4041      	eorgt	r1, r0
     1d0:	4048      	eorgt	r0, r1
     1d2:	4041      	eorgt	r1, r0
     1d4:	bfb8      	it	lt
     1d6:	425b      	neglt	r3, r3
     1d8:	2b19      	cmp	r3, #25
     1da:	bf88      	it	hi
     1dc:	4770      	bxhi	lr
     1de:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
     1e2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     1e6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
     1ea:	bf18      	it	ne
     1ec:	4240      	negne	r0, r0
     1ee:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
     1f2:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
     1f6:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
     1fa:	bf18      	it	ne
     1fc:	4249      	negne	r1, r1
     1fe:	ea92 0f03 	teq	r2, r3
     202:	d03f      	beq.n	284 <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0x84>
     204:	f1a2 0201 	sub.w	r2, r2, #1
     208:	fa41 fc03 	asr.w	ip, r1, r3
     20c:	eb10 000c 	adds.w	r0, r0, ip
     210:	f1c3 0320 	rsb	r3, r3, #32
     214:	fa01 f103 	lsl.w	r1, r1, r3
     218:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
     21c:	d502      	bpl.n	224 <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0x24>
     21e:	4249      	negs	r1, r1
     220:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
     224:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
     228:	d313      	bcc.n	252 <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0x52>
     22a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
     22e:	d306      	bcc.n	23e <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0x3e>
     230:	0840      	lsrs	r0, r0, #1
     232:	ea4f 0131 	mov.w	r1, r1, rrx
     236:	f102 0201 	add.w	r2, r2, #1
     23a:	2afe      	cmp	r2, #254	; 0xfe
     23c:	d251      	bcs.n	2e2 <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0xe2>
     23e:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
     242:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
     246:	bf08      	it	eq
     248:	f020 0001 	biceq.w	r0, r0, #1
     24c:	ea40 0003 	orr.w	r0, r0, r3
     250:	4770      	bx	lr
     252:	0049      	lsls	r1, r1, #1
     254:	eb40 0000 	adc.w	r0, r0, r0
     258:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
     25c:	f1a2 0201 	sub.w	r2, r2, #1
     260:	d1ed      	bne.n	23e <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0x3e>
     262:	fab0 fc80 	clz	ip, r0
     266:	f1ac 0c08 	sub.w	ip, ip, #8
     26a:	ebb2 020c 	subs.w	r2, r2, ip
     26e:	fa00 f00c 	lsl.w	r0, r0, ip
     272:	bfaa      	itet	ge
     274:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
     278:	4252      	neglt	r2, r2
     27a:	4318      	orrge	r0, r3
     27c:	bfbc      	itt	lt
     27e:	40d0      	lsrlt	r0, r2
     280:	4318      	orrlt	r0, r3
     282:	4770      	bx	lr
     284:	f092 0f00 	teq	r2, #0
     288:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
     28c:	bf06      	itte	eq
     28e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
     292:	3201      	addeq	r2, #1
     294:	3b01      	subne	r3, #1
     296:	e7b5      	b.n	204 <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0x4>
     298:	ea4f 0341 	mov.w	r3, r1, lsl #1
     29c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
     2a0:	bf18      	it	ne
     2a2:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
     2a6:	d021      	beq.n	2ec <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0xec>
     2a8:	ea92 0f03 	teq	r2, r3
     2ac:	d004      	beq.n	2b8 <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0xb8>
     2ae:	f092 0f00 	teq	r2, #0
     2b2:	bf08      	it	eq
     2b4:	4608      	moveq	r0, r1
     2b6:	4770      	bx	lr
     2b8:	ea90 0f01 	teq	r0, r1
     2bc:	bf1c      	itt	ne
     2be:	2000      	movne	r0, #0
     2c0:	4770      	bxne	lr
     2c2:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
     2c6:	d104      	bne.n	2d2 <CONFIG_CONSOLE_PUTCHAR_BUFSIZE+0xd2>
     2c8:	0040      	lsls	r0, r0, #1
     2ca:	bf28      	it	cs
     2cc:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
     2d0:	4770      	bx	lr
     2d2:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
     2d6:	bf3c      	itt	cc
     2d8:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
     2dc:	4770      	bxcc	lr
     2de:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
     2e2:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
     2e6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     2ea:	4770      	bx	lr
     2ec:	ea7f 6222 	mvns.w	r2, r2, asr #24
     2f0:	bf16      	itet	ne
     2f2:	4608      	movne	r0, r1
     2f4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
     2f8:	4601      	movne	r1, r0
     2fa:	0242      	lsls	r2, r0, #9
     2fc:	bf06      	itte	eq
     2fe:	ea5f 2341 	movseq.w	r3, r1, lsl #9
     302:	ea90 0f01 	teqeq	r0, r1
     306:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
     30a:	4770      	bx	lr

0000030c <__aeabi_ui2f>:
     30c:	f04f 0300 	mov.w	r3, #0
     310:	e004      	b.n	31c <__aeabi_i2f+0x8>
     312:	bf00      	nop

00000314 <__aeabi_i2f>:
     314:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
     318:	bf48      	it	mi
     31a:	4240      	negmi	r0, r0
     31c:	ea5f 0c00 	movs.w	ip, r0
     320:	bf08      	it	eq
     322:	4770      	bxeq	lr
     324:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
     328:	4601      	mov	r1, r0
     32a:	f04f 0000 	mov.w	r0, #0
     32e:	e01c      	b.n	36a <__aeabi_l2f+0x2a>

00000330 <__aeabi_ul2f>:
     330:	ea50 0201 	orrs.w	r2, r0, r1
     334:	bf08      	it	eq
     336:	4770      	bxeq	lr
     338:	f04f 0300 	mov.w	r3, #0
     33c:	e00a      	b.n	354 <__aeabi_l2f+0x14>
     33e:	bf00      	nop

00000340 <__aeabi_l2f>:
     340:	ea50 0201 	orrs.w	r2, r0, r1
     344:	bf08      	it	eq
     346:	4770      	bxeq	lr
     348:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
     34c:	d502      	bpl.n	354 <__aeabi_l2f+0x14>
     34e:	4240      	negs	r0, r0
     350:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     354:	ea5f 0c01 	movs.w	ip, r1
     358:	bf02      	ittt	eq
     35a:	4684      	moveq	ip, r0
     35c:	4601      	moveq	r1, r0
     35e:	2000      	moveq	r0, #0
     360:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
     364:	bf08      	it	eq
     366:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
     36a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
     36e:	fabc f28c 	clz	r2, ip
     372:	3a08      	subs	r2, #8
     374:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
     378:	db10      	blt.n	39c <__aeabi_l2f+0x5c>
     37a:	fa01 fc02 	lsl.w	ip, r1, r2
     37e:	4463      	add	r3, ip
     380:	fa00 fc02 	lsl.w	ip, r0, r2
     384:	f1c2 0220 	rsb	r2, r2, #32
     388:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
     38c:	fa20 f202 	lsr.w	r2, r0, r2
     390:	eb43 0002 	adc.w	r0, r3, r2
     394:	bf08      	it	eq
     396:	f020 0001 	biceq.w	r0, r0, #1
     39a:	4770      	bx	lr
     39c:	f102 0220 	add.w	r2, r2, #32
     3a0:	fa01 fc02 	lsl.w	ip, r1, r2
     3a4:	f1c2 0220 	rsb	r2, r2, #32
     3a8:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
     3ac:	fa21 f202 	lsr.w	r2, r1, r2
     3b0:	eb43 0002 	adc.w	r0, r3, r2
     3b4:	bf08      	it	eq
     3b6:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
     3ba:	4770      	bx	lr

000003bc <__aeabi_fmul>:
     3bc:	f04f 0cff 	mov.w	ip, #255	; 0xff
     3c0:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
     3c4:	bf1e      	ittt	ne
     3c6:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
     3ca:	ea92 0f0c 	teqne	r2, ip
     3ce:	ea93 0f0c 	teqne	r3, ip
     3d2:	d06f      	beq.n	4b4 <CONFIG_NET_TX_STACK_SIZE+0x4>
     3d4:	441a      	add	r2, r3
     3d6:	ea80 0c01 	eor.w	ip, r0, r1
     3da:	0240      	lsls	r0, r0, #9
     3dc:	bf18      	it	ne
     3de:	ea5f 2141 	movsne.w	r1, r1, lsl #9
     3e2:	d01e      	beq.n	422 <CONFIG_FLASH_SIZE+0x22>
     3e4:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
     3e8:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
     3ec:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
     3f0:	fba0 3101 	umull	r3, r1, r0, r1
     3f4:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
     3f8:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
     3fc:	bf3e      	ittt	cc
     3fe:	0049      	lslcc	r1, r1, #1
     400:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
     404:	005b      	lslcc	r3, r3, #1
     406:	ea40 0001 	orr.w	r0, r0, r1
     40a:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
     40e:	2afd      	cmp	r2, #253	; 0xfd
     410:	d81d      	bhi.n	44e <CONFIG_FLASH_SIZE+0x4e>
     412:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
     416:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
     41a:	bf08      	it	eq
     41c:	f020 0001 	biceq.w	r0, r0, #1
     420:	4770      	bx	lr
     422:	f090 0f00 	teq	r0, #0
     426:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
     42a:	bf08      	it	eq
     42c:	0249      	lsleq	r1, r1, #9
     42e:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
     432:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
     436:	3a7f      	subs	r2, #127	; 0x7f
     438:	bfc2      	ittt	gt
     43a:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
     43e:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
     442:	4770      	bxgt	lr
     444:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     448:	f04f 0300 	mov.w	r3, #0
     44c:	3a01      	subs	r2, #1
     44e:	dc5d      	bgt.n	50c <CONFIG_NET_TX_STACK_SIZE+0x5c>
     450:	f112 0f19 	cmn.w	r2, #25
     454:	bfdc      	itt	le
     456:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
     45a:	4770      	bxle	lr
     45c:	f1c2 0200 	rsb	r2, r2, #0
     460:	0041      	lsls	r1, r0, #1
     462:	fa21 f102 	lsr.w	r1, r1, r2
     466:	f1c2 0220 	rsb	r2, r2, #32
     46a:	fa00 fc02 	lsl.w	ip, r0, r2
     46e:	ea5f 0031 	movs.w	r0, r1, rrx
     472:	f140 0000 	adc.w	r0, r0, #0
     476:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
     47a:	bf08      	it	eq
     47c:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
     480:	4770      	bx	lr
     482:	f092 0f00 	teq	r2, #0
     486:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
     48a:	bf02      	ittt	eq
     48c:	0040      	lsleq	r0, r0, #1
     48e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
     492:	3a01      	subeq	r2, #1
     494:	d0f9      	beq.n	48a <CONFIG_FLASH_SIZE+0x8a>
     496:	ea40 000c 	orr.w	r0, r0, ip
     49a:	f093 0f00 	teq	r3, #0
     49e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
     4a2:	bf02      	ittt	eq
     4a4:	0049      	lsleq	r1, r1, #1
     4a6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
     4aa:	3b01      	subeq	r3, #1
     4ac:	d0f9      	beq.n	4a2 <CONFIG_FLASH_SIZE+0xa2>
     4ae:	ea41 010c 	orr.w	r1, r1, ip
     4b2:	e78f      	b.n	3d4 <__aeabi_fmul+0x18>
     4b4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
     4b8:	ea92 0f0c 	teq	r2, ip
     4bc:	bf18      	it	ne
     4be:	ea93 0f0c 	teqne	r3, ip
     4c2:	d00a      	beq.n	4da <CONFIG_NET_TX_STACK_SIZE+0x2a>
     4c4:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
     4c8:	bf18      	it	ne
     4ca:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
     4ce:	d1d8      	bne.n	482 <CONFIG_FLASH_SIZE+0x82>
     4d0:	ea80 0001 	eor.w	r0, r0, r1
     4d4:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
     4d8:	4770      	bx	lr
     4da:	f090 0f00 	teq	r0, #0
     4de:	bf17      	itett	ne
     4e0:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
     4e4:	4608      	moveq	r0, r1
     4e6:	f091 0f00 	teqne	r1, #0
     4ea:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
     4ee:	d014      	beq.n	51a <CONFIG_NET_TX_STACK_SIZE+0x6a>
     4f0:	ea92 0f0c 	teq	r2, ip
     4f4:	d101      	bne.n	4fa <CONFIG_NET_TX_STACK_SIZE+0x4a>
     4f6:	0242      	lsls	r2, r0, #9
     4f8:	d10f      	bne.n	51a <CONFIG_NET_TX_STACK_SIZE+0x6a>
     4fa:	ea93 0f0c 	teq	r3, ip
     4fe:	d103      	bne.n	508 <CONFIG_NET_TX_STACK_SIZE+0x58>
     500:	024b      	lsls	r3, r1, #9
     502:	bf18      	it	ne
     504:	4608      	movne	r0, r1
     506:	d108      	bne.n	51a <CONFIG_NET_TX_STACK_SIZE+0x6a>
     508:	ea80 0001 	eor.w	r0, r0, r1
     50c:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
     510:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
     514:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     518:	4770      	bx	lr
     51a:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
     51e:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
     522:	4770      	bx	lr

00000524 <__aeabi_fdiv>:
     524:	f04f 0cff 	mov.w	ip, #255	; 0xff
     528:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
     52c:	bf1e      	ittt	ne
     52e:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
     532:	ea92 0f0c 	teqne	r2, ip
     536:	ea93 0f0c 	teqne	r3, ip
     53a:	d069      	beq.n	610 <CONFIG_NET_RX_STACK_SIZE+0x34>
     53c:	eba2 0203 	sub.w	r2, r2, r3
     540:	ea80 0c01 	eor.w	ip, r0, r1
     544:	0249      	lsls	r1, r1, #9
     546:	ea4f 2040 	mov.w	r0, r0, lsl #9
     54a:	d037      	beq.n	5bc <__aeabi_fdiv+0x98>
     54c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
     550:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
     554:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
     558:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
     55c:	428b      	cmp	r3, r1
     55e:	bf38      	it	cc
     560:	005b      	lslcc	r3, r3, #1
     562:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
     566:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
     56a:	428b      	cmp	r3, r1
     56c:	bf24      	itt	cs
     56e:	1a5b      	subcs	r3, r3, r1
     570:	ea40 000c 	orrcs.w	r0, r0, ip
     574:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
     578:	bf24      	itt	cs
     57a:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
     57e:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
     582:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
     586:	bf24      	itt	cs
     588:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
     58c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
     590:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
     594:	bf24      	itt	cs
     596:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
     59a:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
     59e:	011b      	lsls	r3, r3, #4
     5a0:	bf18      	it	ne
     5a2:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
     5a6:	d1e0      	bne.n	56a <__aeabi_fdiv+0x46>
     5a8:	2afd      	cmp	r2, #253	; 0xfd
     5aa:	f63f af50 	bhi.w	44e <CONFIG_FLASH_SIZE+0x4e>
     5ae:	428b      	cmp	r3, r1
     5b0:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
     5b4:	bf08      	it	eq
     5b6:	f020 0001 	biceq.w	r0, r0, #1
     5ba:	4770      	bx	lr
     5bc:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
     5c0:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
     5c4:	327f      	adds	r2, #127	; 0x7f
     5c6:	bfc2      	ittt	gt
     5c8:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
     5cc:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
     5d0:	4770      	bxgt	lr
     5d2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     5d6:	f04f 0300 	mov.w	r3, #0
     5da:	3a01      	subs	r2, #1
     5dc:	e737      	b.n	44e <CONFIG_FLASH_SIZE+0x4e>
     5de:	f092 0f00 	teq	r2, #0
     5e2:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
     5e6:	bf02      	ittt	eq
     5e8:	0040      	lsleq	r0, r0, #1
     5ea:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
     5ee:	3a01      	subeq	r2, #1
     5f0:	d0f9      	beq.n	5e6 <CONFIG_NET_RX_STACK_SIZE+0xa>
     5f2:	ea40 000c 	orr.w	r0, r0, ip
     5f6:	f093 0f00 	teq	r3, #0
     5fa:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
     5fe:	bf02      	ittt	eq
     600:	0049      	lsleq	r1, r1, #1
     602:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
     606:	3b01      	subeq	r3, #1
     608:	d0f9      	beq.n	5fe <CONFIG_NET_RX_STACK_SIZE+0x22>
     60a:	ea41 010c 	orr.w	r1, r1, ip
     60e:	e795      	b.n	53c <__aeabi_fdiv+0x18>
     610:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
     614:	ea92 0f0c 	teq	r2, ip
     618:	d108      	bne.n	62c <CONFIG_NET_RX_STACK_SIZE+0x50>
     61a:	0242      	lsls	r2, r0, #9
     61c:	f47f af7d 	bne.w	51a <CONFIG_NET_TX_STACK_SIZE+0x6a>
     620:	ea93 0f0c 	teq	r3, ip
     624:	f47f af70 	bne.w	508 <CONFIG_NET_TX_STACK_SIZE+0x58>
     628:	4608      	mov	r0, r1
     62a:	e776      	b.n	51a <CONFIG_NET_TX_STACK_SIZE+0x6a>
     62c:	ea93 0f0c 	teq	r3, ip
     630:	d104      	bne.n	63c <CONFIG_NET_RX_STACK_SIZE+0x60>
     632:	024b      	lsls	r3, r1, #9
     634:	f43f af4c 	beq.w	4d0 <CONFIG_NET_TX_STACK_SIZE+0x20>
     638:	4608      	mov	r0, r1
     63a:	e76e      	b.n	51a <CONFIG_NET_TX_STACK_SIZE+0x6a>
     63c:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
     640:	bf18      	it	ne
     642:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
     646:	d1ca      	bne.n	5de <CONFIG_NET_RX_STACK_SIZE+0x2>
     648:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
     64c:	f47f af5c 	bne.w	508 <CONFIG_NET_TX_STACK_SIZE+0x58>
     650:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
     654:	f47f af3c 	bne.w	4d0 <CONFIG_NET_TX_STACK_SIZE+0x20>
     658:	e75f      	b.n	51a <CONFIG_NET_TX_STACK_SIZE+0x6a>
     65a:	bf00      	nop

0000065c <__aeabi_f2iz>:
     65c:	ea4f 0240 	mov.w	r2, r0, lsl #1
     660:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
     664:	d30f      	bcc.n	686 <__aeabi_f2iz+0x2a>
     666:	f04f 039e 	mov.w	r3, #158	; 0x9e
     66a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
     66e:	d90d      	bls.n	68c <__aeabi_f2iz+0x30>
     670:	ea4f 2300 	mov.w	r3, r0, lsl #8
     674:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     678:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
     67c:	fa23 f002 	lsr.w	r0, r3, r2
     680:	bf18      	it	ne
     682:	4240      	negne	r0, r0
     684:	4770      	bx	lr
     686:	f04f 0000 	mov.w	r0, #0
     68a:	4770      	bx	lr
     68c:	f112 0f61 	cmn.w	r2, #97	; 0x61
     690:	d101      	bne.n	696 <__aeabi_f2iz+0x3a>
     692:	0242      	lsls	r2, r0, #9
     694:	d105      	bne.n	6a2 <__aeabi_f2iz+0x46>
     696:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
     69a:	bf08      	it	eq
     69c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
     6a0:	4770      	bx	lr
     6a2:	f04f 0000 	mov.w	r0, #0
     6a6:	4770      	bx	lr

000006a8 <__aeabi_ldivmod>:
     6a8:	b97b      	cbnz	r3, 6ca <__aeabi_ldivmod+0x22>
     6aa:	b972      	cbnz	r2, 6ca <__aeabi_ldivmod+0x22>
     6ac:	2900      	cmp	r1, #0
     6ae:	bfbe      	ittt	lt
     6b0:	2000      	movlt	r0, #0
     6b2:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
     6b6:	e006      	blt.n	6c6 <__aeabi_ldivmod+0x1e>
     6b8:	bf08      	it	eq
     6ba:	2800      	cmpeq	r0, #0
     6bc:	bf1c      	itt	ne
     6be:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
     6c2:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     6c6:	f000 b857 	b.w	778 <__aeabi_idiv0>
     6ca:	f1ad 0c08 	sub.w	ip, sp, #8
     6ce:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     6d2:	2900      	cmp	r1, #0
     6d4:	db09      	blt.n	6ea <__aeabi_ldivmod+0x42>
     6d6:	2b00      	cmp	r3, #0
     6d8:	db1a      	blt.n	710 <__aeabi_ldivmod+0x68>
     6da:	f001 fbe3 	bl	1ea4 <__udivmoddi4>
     6de:	f8dd e004 	ldr.w	lr, [sp, #4]
     6e2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     6e6:	b004      	add	sp, #16
     6e8:	4770      	bx	lr
     6ea:	4240      	negs	r0, r0
     6ec:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     6f0:	2b00      	cmp	r3, #0
     6f2:	db1b      	blt.n	72c <__aeabi_ldivmod+0x84>
     6f4:	f001 fbd6 	bl	1ea4 <__udivmoddi4>
     6f8:	f8dd e004 	ldr.w	lr, [sp, #4]
     6fc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     700:	b004      	add	sp, #16
     702:	4240      	negs	r0, r0
     704:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     708:	4252      	negs	r2, r2
     70a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     70e:	4770      	bx	lr
     710:	4252      	negs	r2, r2
     712:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     716:	f001 fbc5 	bl	1ea4 <__udivmoddi4>
     71a:	f8dd e004 	ldr.w	lr, [sp, #4]
     71e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     722:	b004      	add	sp, #16
     724:	4240      	negs	r0, r0
     726:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     72a:	4770      	bx	lr
     72c:	4252      	negs	r2, r2
     72e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     732:	f001 fbb7 	bl	1ea4 <__udivmoddi4>
     736:	f8dd e004 	ldr.w	lr, [sp, #4]
     73a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     73e:	b004      	add	sp, #16
     740:	4252      	negs	r2, r2
     742:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     746:	4770      	bx	lr

00000748 <__aeabi_uldivmod>:
     748:	b953      	cbnz	r3, 760 <__aeabi_uldivmod+0x18>
     74a:	b94a      	cbnz	r2, 760 <__aeabi_uldivmod+0x18>
     74c:	2900      	cmp	r1, #0
     74e:	bf08      	it	eq
     750:	2800      	cmpeq	r0, #0
     752:	bf1c      	itt	ne
     754:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
     758:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     75c:	f000 b80c 	b.w	778 <__aeabi_idiv0>
     760:	f1ad 0c08 	sub.w	ip, sp, #8
     764:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     768:	f001 fb9c 	bl	1ea4 <__udivmoddi4>
     76c:	f8dd e004 	ldr.w	lr, [sp, #4]
     770:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     774:	b004      	add	sp, #16
     776:	4770      	bx	lr

00000778 <__aeabi_idiv0>:
     778:	4770      	bx	lr
     77a:	bf00      	nop

0000077c <__assert_func>:
     77c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
     77e:	461c      	mov	r4, r3
     780:	4b09      	ldr	r3, [pc, #36]	; (7a8 <__assert_func+0x2c>)
     782:	681b      	ldr	r3, [r3, #0]
     784:	4605      	mov	r5, r0
     786:	68d8      	ldr	r0, [r3, #12]
     788:	b152      	cbz	r2, 7a0 <__assert_func+0x24>
     78a:	4b08      	ldr	r3, [pc, #32]	; (7ac <__assert_func+0x30>)
     78c:	9100      	str	r1, [sp, #0]
     78e:	e9cd 3201 	strd	r3, r2, [sp, #4]
     792:	4907      	ldr	r1, [pc, #28]	; (7b0 <__assert_func+0x34>)
     794:	462b      	mov	r3, r5
     796:	4622      	mov	r2, r4
     798:	f000 f821 	bl	7de <fiprintf>
     79c:	f001 fd73 	bl	2286 <abort>
     7a0:	4b04      	ldr	r3, [pc, #16]	; (7b4 <__assert_func+0x38>)
     7a2:	461a      	mov	r2, r3
     7a4:	e7f2      	b.n	78c <__assert_func+0x10>
     7a6:	bf00      	nop
     7a8:	200109c8 	.word	0x200109c8
     7ac:	000191ca 	.word	0x000191ca
     7b0:	000191d7 	.word	0x000191d7
     7b4:	00017028 	.word	0x00017028

000007b8 <__assert>:
     7b8:	b508      	push	{r3, lr}
     7ba:	4613      	mov	r3, r2
     7bc:	2200      	movs	r2, #0
     7be:	f7ff ffdd 	bl	77c <__assert_func>
     7c2:	bf00      	nop

000007c4 <_fiprintf_r>:
     7c4:	b40c      	push	{r2, r3}
     7c6:	b507      	push	{r0, r1, r2, lr}
     7c8:	ab04      	add	r3, sp, #16
     7ca:	f853 2b04 	ldr.w	r2, [r3], #4
     7ce:	9301      	str	r3, [sp, #4]
     7d0:	f000 f8a2 	bl	918 <_vfiprintf_r>
     7d4:	b003      	add	sp, #12
     7d6:	f85d eb04 	ldr.w	lr, [sp], #4
     7da:	b002      	add	sp, #8
     7dc:	4770      	bx	lr

000007de <fiprintf>:
     7de:	b40e      	push	{r1, r2, r3}
     7e0:	b503      	push	{r0, r1, lr}
     7e2:	4601      	mov	r1, r0
     7e4:	ab03      	add	r3, sp, #12
     7e6:	4806      	ldr	r0, [pc, #24]	; (800 <fiprintf+0x22>)
     7e8:	f853 2b04 	ldr.w	r2, [r3], #4
     7ec:	6800      	ldr	r0, [r0, #0]
     7ee:	9301      	str	r3, [sp, #4]
     7f0:	f000 f892 	bl	918 <_vfiprintf_r>
     7f4:	b002      	add	sp, #8
     7f6:	f85d eb04 	ldr.w	lr, [sp], #4
     7fa:	b003      	add	sp, #12
     7fc:	4770      	bx	lr
     7fe:	bf00      	nop
     800:	200109c8 	.word	0x200109c8

00000804 <_malloc_r>:
     804:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     806:	1cce      	adds	r6, r1, #3
     808:	f026 0603 	bic.w	r6, r6, #3
     80c:	3608      	adds	r6, #8
     80e:	2e0c      	cmp	r6, #12
     810:	bf38      	it	cc
     812:	260c      	movcc	r6, #12
     814:	2e00      	cmp	r6, #0
     816:	4607      	mov	r7, r0
     818:	db01      	blt.n	81e <_malloc_r+0x1a>
     81a:	42b1      	cmp	r1, r6
     81c:	d903      	bls.n	826 <_malloc_r+0x22>
     81e:	230c      	movs	r3, #12
     820:	603b      	str	r3, [r7, #0]
     822:	2000      	movs	r0, #0
     824:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     826:	4d21      	ldr	r5, [pc, #132]	; (8ac <_malloc_r+0xa8>)
     828:	f001 fd6e 	bl	2308 <__malloc_lock>
     82c:	682a      	ldr	r2, [r5, #0]
     82e:	4614      	mov	r4, r2
     830:	b994      	cbnz	r4, 858 <_malloc_r+0x54>
     832:	686b      	ldr	r3, [r5, #4]
     834:	b923      	cbnz	r3, 840 <_malloc_r+0x3c>
     836:	4621      	mov	r1, r4
     838:	4638      	mov	r0, r7
     83a:	f000 faf9 	bl	e30 <_sbrk_r>
     83e:	6068      	str	r0, [r5, #4]
     840:	4631      	mov	r1, r6
     842:	4638      	mov	r0, r7
     844:	f000 faf4 	bl	e30 <_sbrk_r>
     848:	1c43      	adds	r3, r0, #1
     84a:	d123      	bne.n	894 <_malloc_r+0x90>
     84c:	230c      	movs	r3, #12
     84e:	603b      	str	r3, [r7, #0]
     850:	4638      	mov	r0, r7
     852:	f001 fd5a 	bl	230a <__malloc_unlock>
     856:	e7e4      	b.n	822 <_malloc_r+0x1e>
     858:	6823      	ldr	r3, [r4, #0]
     85a:	1b9b      	subs	r3, r3, r6
     85c:	d417      	bmi.n	88e <_malloc_r+0x8a>
     85e:	2b0b      	cmp	r3, #11
     860:	d903      	bls.n	86a <_malloc_r+0x66>
     862:	6023      	str	r3, [r4, #0]
     864:	441c      	add	r4, r3
     866:	6026      	str	r6, [r4, #0]
     868:	e004      	b.n	874 <_malloc_r+0x70>
     86a:	6863      	ldr	r3, [r4, #4]
     86c:	42a2      	cmp	r2, r4
     86e:	bf0c      	ite	eq
     870:	602b      	streq	r3, [r5, #0]
     872:	6053      	strne	r3, [r2, #4]
     874:	4638      	mov	r0, r7
     876:	f001 fd48 	bl	230a <__malloc_unlock>
     87a:	f104 000b 	add.w	r0, r4, #11
     87e:	1d23      	adds	r3, r4, #4
     880:	f020 0007 	bic.w	r0, r0, #7
     884:	1ac2      	subs	r2, r0, r3
     886:	d0cd      	beq.n	824 <_malloc_r+0x20>
     888:	1a1b      	subs	r3, r3, r0
     88a:	50a3      	str	r3, [r4, r2]
     88c:	e7ca      	b.n	824 <_malloc_r+0x20>
     88e:	4622      	mov	r2, r4
     890:	6864      	ldr	r4, [r4, #4]
     892:	e7cd      	b.n	830 <_malloc_r+0x2c>
     894:	1cc4      	adds	r4, r0, #3
     896:	f024 0403 	bic.w	r4, r4, #3
     89a:	42a0      	cmp	r0, r4
     89c:	d0e3      	beq.n	866 <_malloc_r+0x62>
     89e:	1a21      	subs	r1, r4, r0
     8a0:	4638      	mov	r0, r7
     8a2:	f000 fac5 	bl	e30 <_sbrk_r>
     8a6:	3001      	adds	r0, #1
     8a8:	d1dd      	bne.n	866 <_malloc_r+0x62>
     8aa:	e7cf      	b.n	84c <_malloc_r+0x48>
     8ac:	20002000 	.word	0x20002000

000008b0 <__sfputc_r>:
     8b0:	6893      	ldr	r3, [r2, #8]
     8b2:	3b01      	subs	r3, #1
     8b4:	2b00      	cmp	r3, #0
     8b6:	b410      	push	{r4}
     8b8:	6093      	str	r3, [r2, #8]
     8ba:	da07      	bge.n	8cc <__sfputc_r+0x1c>
     8bc:	6994      	ldr	r4, [r2, #24]
     8be:	42a3      	cmp	r3, r4
     8c0:	db01      	blt.n	8c6 <__sfputc_r+0x16>
     8c2:	290a      	cmp	r1, #10
     8c4:	d102      	bne.n	8cc <__sfputc_r+0x1c>
     8c6:	bc10      	pop	{r4}
     8c8:	f000 bbe8 	b.w	109c <__swbuf_r>
     8cc:	6813      	ldr	r3, [r2, #0]
     8ce:	1c58      	adds	r0, r3, #1
     8d0:	6010      	str	r0, [r2, #0]
     8d2:	7019      	strb	r1, [r3, #0]
     8d4:	4608      	mov	r0, r1
     8d6:	bc10      	pop	{r4}
     8d8:	4770      	bx	lr

000008da <__sfputs_r>:
     8da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     8dc:	4606      	mov	r6, r0
     8de:	460f      	mov	r7, r1
     8e0:	4614      	mov	r4, r2
     8e2:	18d5      	adds	r5, r2, r3
     8e4:	42ac      	cmp	r4, r5
     8e6:	d101      	bne.n	8ec <__sfputs_r+0x12>
     8e8:	2000      	movs	r0, #0
     8ea:	e007      	b.n	8fc <__sfputs_r+0x22>
     8ec:	463a      	mov	r2, r7
     8ee:	f814 1b01 	ldrb.w	r1, [r4], #1
     8f2:	4630      	mov	r0, r6
     8f4:	f7ff ffdc 	bl	8b0 <__sfputc_r>
     8f8:	1c43      	adds	r3, r0, #1
     8fa:	d1f3      	bne.n	8e4 <__sfputs_r+0xa>
     8fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000008fe <__sprint_r>:
     8fe:	b538      	push	{r3, r4, r5, lr}
     900:	6893      	ldr	r3, [r2, #8]
     902:	4614      	mov	r4, r2
     904:	2500      	movs	r5, #0
     906:	b913      	cbnz	r3, 90e <__sprint_r+0x10>
     908:	6053      	str	r3, [r2, #4]
     90a:	4618      	mov	r0, r3
     90c:	bd38      	pop	{r3, r4, r5, pc}
     90e:	f000 fddd 	bl	14cc <__sfvwrite_r>
     912:	e9c4 5501 	strd	r5, r5, [r4, #4]
     916:	e7f9      	b.n	90c <__sprint_r+0xe>

00000918 <_vfiprintf_r>:
     918:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     91c:	460e      	mov	r6, r1
     91e:	b09d      	sub	sp, #116	; 0x74
     920:	4614      	mov	r4, r2
     922:	461d      	mov	r5, r3
     924:	4607      	mov	r7, r0
     926:	b118      	cbz	r0, 930 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x7>
     928:	6b83      	ldr	r3, [r0, #56]	; 0x38
     92a:	b90b      	cbnz	r3, 930 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x7>
     92c:	f000 fd70 	bl	1410 <__sinit>
     930:	89b3      	ldrh	r3, [r6, #12]
     932:	0718      	lsls	r0, r3, #28
     934:	d556      	bpl.n	9e4 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xbb>
     936:	6933      	ldr	r3, [r6, #16]
     938:	2b00      	cmp	r3, #0
     93a:	d053      	beq.n	9e4 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xbb>
     93c:	2300      	movs	r3, #0
     93e:	9309      	str	r3, [sp, #36]	; 0x24
     940:	2320      	movs	r3, #32
     942:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
     946:	f8df 91ac 	ldr.w	r9, [pc, #428]	; af4 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1cb>
     94a:	9503      	str	r5, [sp, #12]
     94c:	2330      	movs	r3, #48	; 0x30
     94e:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
     952:	f04f 0a01 	mov.w	sl, #1
     956:	4623      	mov	r3, r4
     958:	461d      	mov	r5, r3
     95a:	f813 2b01 	ldrb.w	r2, [r3], #1
     95e:	b10a      	cbz	r2, 964 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x3b>
     960:	2a25      	cmp	r2, #37	; 0x25
     962:	d1f9      	bne.n	958 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x2f>
     964:	ebb5 0b04 	subs.w	fp, r5, r4
     968:	d00b      	beq.n	982 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x59>
     96a:	465b      	mov	r3, fp
     96c:	4622      	mov	r2, r4
     96e:	4631      	mov	r1, r6
     970:	4638      	mov	r0, r7
     972:	f7ff ffb2 	bl	8da <__sfputs_r>
     976:	3001      	adds	r0, #1
     978:	f000 80ae 	beq.w	ad8 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1af>
     97c:	9b09      	ldr	r3, [sp, #36]	; 0x24
     97e:	445b      	add	r3, fp
     980:	9309      	str	r3, [sp, #36]	; 0x24
     982:	782b      	ldrb	r3, [r5, #0]
     984:	2b00      	cmp	r3, #0
     986:	f000 80a7 	beq.w	ad8 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1af>
     98a:	2300      	movs	r3, #0
     98c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     990:	e9cd 2305 	strd	r2, r3, [sp, #20]
     994:	3501      	adds	r5, #1
     996:	9304      	str	r3, [sp, #16]
     998:	9307      	str	r3, [sp, #28]
     99a:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
     99e:	931a      	str	r3, [sp, #104]	; 0x68
     9a0:	462c      	mov	r4, r5
     9a2:	2205      	movs	r2, #5
     9a4:	f814 1b01 	ldrb.w	r1, [r4], #1
     9a8:	4852      	ldr	r0, [pc, #328]	; (af4 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1cb>)
     9aa:	f7ff fba9 	bl	100 <memchr>
     9ae:	9b04      	ldr	r3, [sp, #16]
     9b0:	bb18      	cbnz	r0, 9fa <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xd1>
     9b2:	06d9      	lsls	r1, r3, #27
     9b4:	bf44      	itt	mi
     9b6:	2220      	movmi	r2, #32
     9b8:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
     9bc:	071a      	lsls	r2, r3, #28
     9be:	bf44      	itt	mi
     9c0:	222b      	movmi	r2, #43	; 0x2b
     9c2:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
     9c6:	782a      	ldrb	r2, [r5, #0]
     9c8:	2a2a      	cmp	r2, #42	; 0x2a
     9ca:	d01e      	beq.n	a0a <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xe1>
     9cc:	9a07      	ldr	r2, [sp, #28]
     9ce:	462c      	mov	r4, r5
     9d0:	2000      	movs	r0, #0
     9d2:	250a      	movs	r5, #10
     9d4:	4621      	mov	r1, r4
     9d6:	f811 3b01 	ldrb.w	r3, [r1], #1
     9da:	3b30      	subs	r3, #48	; 0x30
     9dc:	2b09      	cmp	r3, #9
     9de:	d956      	bls.n	a8e <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x165>
     9e0:	b9c8      	cbnz	r0, a16 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xed>
     9e2:	e01f      	b.n	a24 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xfb>
     9e4:	4631      	mov	r1, r6
     9e6:	4638      	mov	r0, r7
     9e8:	f000 fb9e 	bl	1128 <__swsetup_r>
     9ec:	2800      	cmp	r0, #0
     9ee:	d0a5      	beq.n	93c <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x13>
     9f0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     9f4:	b01d      	add	sp, #116	; 0x74
     9f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     9fa:	eba0 0009 	sub.w	r0, r0, r9
     9fe:	fa0a f000 	lsl.w	r0, sl, r0
     a02:	4318      	orrs	r0, r3
     a04:	9004      	str	r0, [sp, #16]
     a06:	4625      	mov	r5, r4
     a08:	e7ca      	b.n	9a0 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x77>
     a0a:	9a03      	ldr	r2, [sp, #12]
     a0c:	1d11      	adds	r1, r2, #4
     a0e:	6812      	ldr	r2, [r2, #0]
     a10:	9103      	str	r1, [sp, #12]
     a12:	2a00      	cmp	r2, #0
     a14:	db01      	blt.n	a1a <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xf1>
     a16:	9207      	str	r2, [sp, #28]
     a18:	e004      	b.n	a24 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xfb>
     a1a:	4252      	negs	r2, r2
     a1c:	f043 0302 	orr.w	r3, r3, #2
     a20:	9207      	str	r2, [sp, #28]
     a22:	9304      	str	r3, [sp, #16]
     a24:	7823      	ldrb	r3, [r4, #0]
     a26:	2b2e      	cmp	r3, #46	; 0x2e
     a28:	d10c      	bne.n	a44 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x11b>
     a2a:	7863      	ldrb	r3, [r4, #1]
     a2c:	2b2a      	cmp	r3, #42	; 0x2a
     a2e:	d133      	bne.n	a98 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x16f>
     a30:	9b03      	ldr	r3, [sp, #12]
     a32:	1d1a      	adds	r2, r3, #4
     a34:	681b      	ldr	r3, [r3, #0]
     a36:	9203      	str	r2, [sp, #12]
     a38:	2b00      	cmp	r3, #0
     a3a:	bfb8      	it	lt
     a3c:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
     a40:	3402      	adds	r4, #2
     a42:	9305      	str	r3, [sp, #20]
     a44:	4d2c      	ldr	r5, [pc, #176]	; (af8 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1cf>)
     a46:	7821      	ldrb	r1, [r4, #0]
     a48:	2203      	movs	r2, #3
     a4a:	4628      	mov	r0, r5
     a4c:	f7ff fb58 	bl	100 <memchr>
     a50:	b138      	cbz	r0, a62 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x139>
     a52:	2340      	movs	r3, #64	; 0x40
     a54:	1b40      	subs	r0, r0, r5
     a56:	fa03 f000 	lsl.w	r0, r3, r0
     a5a:	9b04      	ldr	r3, [sp, #16]
     a5c:	4303      	orrs	r3, r0
     a5e:	3401      	adds	r4, #1
     a60:	9304      	str	r3, [sp, #16]
     a62:	f814 1b01 	ldrb.w	r1, [r4], #1
     a66:	4825      	ldr	r0, [pc, #148]	; (afc <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1d3>)
     a68:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
     a6c:	2206      	movs	r2, #6
     a6e:	f7ff fb47 	bl	100 <memchr>
     a72:	2800      	cmp	r0, #0
     a74:	d035      	beq.n	ae2 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1b9>
     a76:	4b22      	ldr	r3, [pc, #136]	; (b00 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1d7>)
     a78:	bb13      	cbnz	r3, ac0 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x197>
     a7a:	9b03      	ldr	r3, [sp, #12]
     a7c:	3307      	adds	r3, #7
     a7e:	f023 0307 	bic.w	r3, r3, #7
     a82:	3308      	adds	r3, #8
     a84:	9303      	str	r3, [sp, #12]
     a86:	9b09      	ldr	r3, [sp, #36]	; 0x24
     a88:	4443      	add	r3, r8
     a8a:	9309      	str	r3, [sp, #36]	; 0x24
     a8c:	e763      	b.n	956 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x2d>
     a8e:	fb05 3202 	mla	r2, r5, r2, r3
     a92:	2001      	movs	r0, #1
     a94:	460c      	mov	r4, r1
     a96:	e79d      	b.n	9d4 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xab>
     a98:	2300      	movs	r3, #0
     a9a:	3401      	adds	r4, #1
     a9c:	9305      	str	r3, [sp, #20]
     a9e:	4619      	mov	r1, r3
     aa0:	250a      	movs	r5, #10
     aa2:	4620      	mov	r0, r4
     aa4:	f810 2b01 	ldrb.w	r2, [r0], #1
     aa8:	3a30      	subs	r2, #48	; 0x30
     aaa:	2a09      	cmp	r2, #9
     aac:	d903      	bls.n	ab6 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x18d>
     aae:	2b00      	cmp	r3, #0
     ab0:	d0c8      	beq.n	a44 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x11b>
     ab2:	9105      	str	r1, [sp, #20]
     ab4:	e7c6      	b.n	a44 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x11b>
     ab6:	fb05 2101 	mla	r1, r5, r1, r2
     aba:	2301      	movs	r3, #1
     abc:	4604      	mov	r4, r0
     abe:	e7f0      	b.n	aa2 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x179>
     ac0:	ab03      	add	r3, sp, #12
     ac2:	9300      	str	r3, [sp, #0]
     ac4:	4632      	mov	r2, r6
     ac6:	4b0f      	ldr	r3, [pc, #60]	; (b04 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1db>)
     ac8:	a904      	add	r1, sp, #16
     aca:	4638      	mov	r0, r7
     acc:	f3af 8000 	nop.w
     ad0:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
     ad4:	4680      	mov	r8, r0
     ad6:	d1d6      	bne.n	a86 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x15d>
     ad8:	89b3      	ldrh	r3, [r6, #12]
     ada:	065b      	lsls	r3, r3, #25
     adc:	d488      	bmi.n	9f0 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xc7>
     ade:	9809      	ldr	r0, [sp, #36]	; 0x24
     ae0:	e788      	b.n	9f4 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0xcb>
     ae2:	ab03      	add	r3, sp, #12
     ae4:	9300      	str	r3, [sp, #0]
     ae6:	4632      	mov	r2, r6
     ae8:	4b06      	ldr	r3, [pc, #24]	; (b04 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1db>)
     aea:	a904      	add	r1, sp, #16
     aec:	4638      	mov	r0, r7
     aee:	f000 f88a 	bl	c06 <_printf_i>
     af2:	e7ed      	b.n	ad0 <CONFIG_COAP_INIT_ACK_TIMEOUT_MS+0x1a7>
     af4:	00019206 	.word	0x00019206
     af8:	0001920c 	.word	0x0001920c
     afc:	00019210 	.word	0x00019210
     b00:	00000000 	.word	0x00000000
     b04:	000008db 	.word	0x000008db

00000b08 <vfiprintf>:
     b08:	4613      	mov	r3, r2
     b0a:	460a      	mov	r2, r1
     b0c:	4601      	mov	r1, r0
     b0e:	4802      	ldr	r0, [pc, #8]	; (b18 <vfiprintf+0x10>)
     b10:	6800      	ldr	r0, [r0, #0]
     b12:	f7ff bf01 	b.w	918 <_vfiprintf_r>
     b16:	bf00      	nop
     b18:	200109c8 	.word	0x200109c8

00000b1c <_printf_common>:
     b1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     b20:	4691      	mov	r9, r2
     b22:	461f      	mov	r7, r3
     b24:	688a      	ldr	r2, [r1, #8]
     b26:	690b      	ldr	r3, [r1, #16]
     b28:	f8dd 8020 	ldr.w	r8, [sp, #32]
     b2c:	4293      	cmp	r3, r2
     b2e:	bfb8      	it	lt
     b30:	4613      	movlt	r3, r2
     b32:	f8c9 3000 	str.w	r3, [r9]
     b36:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
     b3a:	4606      	mov	r6, r0
     b3c:	460c      	mov	r4, r1
     b3e:	b112      	cbz	r2, b46 <_printf_common+0x2a>
     b40:	3301      	adds	r3, #1
     b42:	f8c9 3000 	str.w	r3, [r9]
     b46:	6823      	ldr	r3, [r4, #0]
     b48:	0699      	lsls	r1, r3, #26
     b4a:	bf42      	ittt	mi
     b4c:	f8d9 3000 	ldrmi.w	r3, [r9]
     b50:	3302      	addmi	r3, #2
     b52:	f8c9 3000 	strmi.w	r3, [r9]
     b56:	6825      	ldr	r5, [r4, #0]
     b58:	f015 0506 	ands.w	r5, r5, #6
     b5c:	d107      	bne.n	b6e <_printf_common+0x52>
     b5e:	f104 0a19 	add.w	sl, r4, #25
     b62:	68e3      	ldr	r3, [r4, #12]
     b64:	f8d9 2000 	ldr.w	r2, [r9]
     b68:	1a9b      	subs	r3, r3, r2
     b6a:	42ab      	cmp	r3, r5
     b6c:	dc28      	bgt.n	bc0 <CONFIG_NET_SOCKETS_CONNECT_TIMEOUT+0x8>
     b6e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
     b72:	6822      	ldr	r2, [r4, #0]
     b74:	3300      	adds	r3, #0
     b76:	bf18      	it	ne
     b78:	2301      	movne	r3, #1
     b7a:	0692      	lsls	r2, r2, #26
     b7c:	d42d      	bmi.n	bda <CONFIG_NET_SOCKETS_CONNECT_TIMEOUT+0x22>
     b7e:	f104 0243 	add.w	r2, r4, #67	; 0x43
     b82:	4639      	mov	r1, r7
     b84:	4630      	mov	r0, r6
     b86:	47c0      	blx	r8
     b88:	3001      	adds	r0, #1
     b8a:	d020      	beq.n	bce <CONFIG_NET_SOCKETS_CONNECT_TIMEOUT+0x16>
     b8c:	6823      	ldr	r3, [r4, #0]
     b8e:	68e5      	ldr	r5, [r4, #12]
     b90:	f8d9 2000 	ldr.w	r2, [r9]
     b94:	f003 0306 	and.w	r3, r3, #6
     b98:	2b04      	cmp	r3, #4
     b9a:	bf08      	it	eq
     b9c:	1aad      	subeq	r5, r5, r2
     b9e:	68a3      	ldr	r3, [r4, #8]
     ba0:	6922      	ldr	r2, [r4, #16]
     ba2:	bf0c      	ite	eq
     ba4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
     ba8:	2500      	movne	r5, #0
     baa:	4293      	cmp	r3, r2
     bac:	bfc4      	itt	gt
     bae:	1a9b      	subgt	r3, r3, r2
     bb0:	18ed      	addgt	r5, r5, r3
     bb2:	f04f 0900 	mov.w	r9, #0
     bb6:	341a      	adds	r4, #26
     bb8:	454d      	cmp	r5, r9
     bba:	d11a      	bne.n	bf2 <CONFIG_NET_SOCKETS_CONNECT_TIMEOUT+0x3a>
     bbc:	2000      	movs	r0, #0
     bbe:	e008      	b.n	bd2 <CONFIG_NET_SOCKETS_CONNECT_TIMEOUT+0x1a>
     bc0:	2301      	movs	r3, #1
     bc2:	4652      	mov	r2, sl
     bc4:	4639      	mov	r1, r7
     bc6:	4630      	mov	r0, r6
     bc8:	47c0      	blx	r8
     bca:	3001      	adds	r0, #1
     bcc:	d103      	bne.n	bd6 <CONFIG_NET_SOCKETS_CONNECT_TIMEOUT+0x1e>
     bce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     bd2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     bd6:	3501      	adds	r5, #1
     bd8:	e7c3      	b.n	b62 <_printf_common+0x46>
     bda:	18e1      	adds	r1, r4, r3
     bdc:	1c5a      	adds	r2, r3, #1
     bde:	2030      	movs	r0, #48	; 0x30
     be0:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
     be4:	4422      	add	r2, r4
     be6:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
     bea:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
     bee:	3302      	adds	r3, #2
     bf0:	e7c5      	b.n	b7e <_printf_common+0x62>
     bf2:	2301      	movs	r3, #1
     bf4:	4622      	mov	r2, r4
     bf6:	4639      	mov	r1, r7
     bf8:	4630      	mov	r0, r6
     bfa:	47c0      	blx	r8
     bfc:	3001      	adds	r0, #1
     bfe:	d0e6      	beq.n	bce <CONFIG_NET_SOCKETS_CONNECT_TIMEOUT+0x16>
     c00:	f109 0901 	add.w	r9, r9, #1
     c04:	e7d8      	b.n	bb8 <CONFIG_NET_SOCKETS_CONNECT_TIMEOUT>

00000c06 <_printf_i>:
     c06:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     c0a:	4606      	mov	r6, r0
     c0c:	460c      	mov	r4, r1
     c0e:	f101 0043 	add.w	r0, r1, #67	; 0x43
     c12:	7e09      	ldrb	r1, [r1, #24]
     c14:	b085      	sub	sp, #20
     c16:	296e      	cmp	r1, #110	; 0x6e
     c18:	4698      	mov	r8, r3
     c1a:	4617      	mov	r7, r2
     c1c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     c1e:	f000 80ba 	beq.w	d96 <_printf_i+0x190>
     c22:	d824      	bhi.n	c6e <_printf_i+0x68>
     c24:	2963      	cmp	r1, #99	; 0x63
     c26:	d039      	beq.n	c9c <_printf_i+0x96>
     c28:	d80a      	bhi.n	c40 <_printf_i+0x3a>
     c2a:	2900      	cmp	r1, #0
     c2c:	f000 80c3 	beq.w	db6 <_printf_i+0x1b0>
     c30:	2958      	cmp	r1, #88	; 0x58
     c32:	f000 8091 	beq.w	d58 <_printf_i+0x152>
     c36:	f104 0542 	add.w	r5, r4, #66	; 0x42
     c3a:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
     c3e:	e035      	b.n	cac <_printf_i+0xa6>
     c40:	2964      	cmp	r1, #100	; 0x64
     c42:	d001      	beq.n	c48 <_printf_i+0x42>
     c44:	2969      	cmp	r1, #105	; 0x69
     c46:	d1f6      	bne.n	c36 <_printf_i+0x30>
     c48:	6825      	ldr	r5, [r4, #0]
     c4a:	681a      	ldr	r2, [r3, #0]
     c4c:	f015 0f80 	tst.w	r5, #128	; 0x80
     c50:	f102 0104 	add.w	r1, r2, #4
     c54:	d02c      	beq.n	cb0 <_printf_i+0xaa>
     c56:	6812      	ldr	r2, [r2, #0]
     c58:	6019      	str	r1, [r3, #0]
     c5a:	2a00      	cmp	r2, #0
     c5c:	da03      	bge.n	c66 <_printf_i+0x60>
     c5e:	232d      	movs	r3, #45	; 0x2d
     c60:	4252      	negs	r2, r2
     c62:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
     c66:	f8df c1c0 	ldr.w	ip, [pc, #448]	; e28 <_printf_i+0x222>
     c6a:	230a      	movs	r3, #10
     c6c:	e03f      	b.n	cee <_printf_i+0xe8>
     c6e:	2973      	cmp	r1, #115	; 0x73
     c70:	f000 80a5 	beq.w	dbe <_printf_i+0x1b8>
     c74:	d808      	bhi.n	c88 <_printf_i+0x82>
     c76:	296f      	cmp	r1, #111	; 0x6f
     c78:	d021      	beq.n	cbe <_printf_i+0xb8>
     c7a:	2970      	cmp	r1, #112	; 0x70
     c7c:	d1db      	bne.n	c36 <_printf_i+0x30>
     c7e:	6822      	ldr	r2, [r4, #0]
     c80:	f042 0220 	orr.w	r2, r2, #32
     c84:	6022      	str	r2, [r4, #0]
     c86:	e003      	b.n	c90 <_printf_i+0x8a>
     c88:	2975      	cmp	r1, #117	; 0x75
     c8a:	d018      	beq.n	cbe <_printf_i+0xb8>
     c8c:	2978      	cmp	r1, #120	; 0x78
     c8e:	d1d2      	bne.n	c36 <_printf_i+0x30>
     c90:	2278      	movs	r2, #120	; 0x78
     c92:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
     c96:	f8df c194 	ldr.w	ip, [pc, #404]	; e2c <_printf_i+0x226>
     c9a:	e061      	b.n	d60 <_printf_i+0x15a>
     c9c:	681a      	ldr	r2, [r3, #0]
     c9e:	1d11      	adds	r1, r2, #4
     ca0:	6019      	str	r1, [r3, #0]
     ca2:	6813      	ldr	r3, [r2, #0]
     ca4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
     ca8:	f104 0542 	add.w	r5, r4, #66	; 0x42
     cac:	2301      	movs	r3, #1
     cae:	e093      	b.n	dd8 <_printf_i+0x1d2>
     cb0:	6812      	ldr	r2, [r2, #0]
     cb2:	6019      	str	r1, [r3, #0]
     cb4:	f015 0f40 	tst.w	r5, #64	; 0x40
     cb8:	bf18      	it	ne
     cba:	b212      	sxthne	r2, r2
     cbc:	e7cd      	b.n	c5a <_printf_i+0x54>
     cbe:	f8d4 c000 	ldr.w	ip, [r4]
     cc2:	681a      	ldr	r2, [r3, #0]
     cc4:	f01c 0f80 	tst.w	ip, #128	; 0x80
     cc8:	f102 0504 	add.w	r5, r2, #4
     ccc:	601d      	str	r5, [r3, #0]
     cce:	d001      	beq.n	cd4 <_printf_i+0xce>
     cd0:	6812      	ldr	r2, [r2, #0]
     cd2:	e003      	b.n	cdc <_printf_i+0xd6>
     cd4:	f01c 0f40 	tst.w	ip, #64	; 0x40
     cd8:	d0fa      	beq.n	cd0 <_printf_i+0xca>
     cda:	8812      	ldrh	r2, [r2, #0]
     cdc:	f8df c148 	ldr.w	ip, [pc, #328]	; e28 <_printf_i+0x222>
     ce0:	296f      	cmp	r1, #111	; 0x6f
     ce2:	bf0c      	ite	eq
     ce4:	2308      	moveq	r3, #8
     ce6:	230a      	movne	r3, #10
     ce8:	2100      	movs	r1, #0
     cea:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
     cee:	6865      	ldr	r5, [r4, #4]
     cf0:	60a5      	str	r5, [r4, #8]
     cf2:	2d00      	cmp	r5, #0
     cf4:	bfa2      	ittt	ge
     cf6:	6821      	ldrge	r1, [r4, #0]
     cf8:	f021 0104 	bicge.w	r1, r1, #4
     cfc:	6021      	strge	r1, [r4, #0]
     cfe:	b90a      	cbnz	r2, d04 <_printf_i+0xfe>
     d00:	2d00      	cmp	r5, #0
     d02:	d046      	beq.n	d92 <_printf_i+0x18c>
     d04:	4605      	mov	r5, r0
     d06:	fbb2 f1f3 	udiv	r1, r2, r3
     d0a:	fb03 2e11 	mls	lr, r3, r1, r2
     d0e:	4293      	cmp	r3, r2
     d10:	f81c e00e 	ldrb.w	lr, [ip, lr]
     d14:	f805 ed01 	strb.w	lr, [r5, #-1]!
     d18:	d939      	bls.n	d8e <_printf_i+0x188>
     d1a:	2b08      	cmp	r3, #8
     d1c:	d10b      	bne.n	d36 <_printf_i+0x130>
     d1e:	6823      	ldr	r3, [r4, #0]
     d20:	07da      	lsls	r2, r3, #31
     d22:	d508      	bpl.n	d36 <_printf_i+0x130>
     d24:	6923      	ldr	r3, [r4, #16]
     d26:	6862      	ldr	r2, [r4, #4]
     d28:	429a      	cmp	r2, r3
     d2a:	bfde      	ittt	le
     d2c:	2330      	movle	r3, #48	; 0x30
     d2e:	f805 3c01 	strble.w	r3, [r5, #-1]
     d32:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
     d36:	1b40      	subs	r0, r0, r5
     d38:	6120      	str	r0, [r4, #16]
     d3a:	f8cd 8000 	str.w	r8, [sp]
     d3e:	463b      	mov	r3, r7
     d40:	aa03      	add	r2, sp, #12
     d42:	4621      	mov	r1, r4
     d44:	4630      	mov	r0, r6
     d46:	f7ff fee9 	bl	b1c <_printf_common>
     d4a:	3001      	adds	r0, #1
     d4c:	d149      	bne.n	de2 <_printf_i+0x1dc>
     d4e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     d52:	b005      	add	sp, #20
     d54:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     d58:	f8df c0cc 	ldr.w	ip, [pc, #204]	; e28 <_printf_i+0x222>
     d5c:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
     d60:	681d      	ldr	r5, [r3, #0]
     d62:	6821      	ldr	r1, [r4, #0]
     d64:	f855 2b04 	ldr.w	r2, [r5], #4
     d68:	601d      	str	r5, [r3, #0]
     d6a:	060d      	lsls	r5, r1, #24
     d6c:	d50b      	bpl.n	d86 <_printf_i+0x180>
     d6e:	07cd      	lsls	r5, r1, #31
     d70:	bf44      	itt	mi
     d72:	f041 0120 	orrmi.w	r1, r1, #32
     d76:	6021      	strmi	r1, [r4, #0]
     d78:	b91a      	cbnz	r2, d82 <_printf_i+0x17c>
     d7a:	6823      	ldr	r3, [r4, #0]
     d7c:	f023 0320 	bic.w	r3, r3, #32
     d80:	6023      	str	r3, [r4, #0]
     d82:	2310      	movs	r3, #16
     d84:	e7b0      	b.n	ce8 <_printf_i+0xe2>
     d86:	064b      	lsls	r3, r1, #25
     d88:	bf48      	it	mi
     d8a:	b292      	uxthmi	r2, r2
     d8c:	e7ef      	b.n	d6e <_printf_i+0x168>
     d8e:	460a      	mov	r2, r1
     d90:	e7b9      	b.n	d06 <_printf_i+0x100>
     d92:	4605      	mov	r5, r0
     d94:	e7c1      	b.n	d1a <_printf_i+0x114>
     d96:	681a      	ldr	r2, [r3, #0]
     d98:	f8d4 c000 	ldr.w	ip, [r4]
     d9c:	6961      	ldr	r1, [r4, #20]
     d9e:	1d15      	adds	r5, r2, #4
     da0:	601d      	str	r5, [r3, #0]
     da2:	f01c 0f80 	tst.w	ip, #128	; 0x80
     da6:	6813      	ldr	r3, [r2, #0]
     da8:	d001      	beq.n	dae <_printf_i+0x1a8>
     daa:	6019      	str	r1, [r3, #0]
     dac:	e003      	b.n	db6 <_printf_i+0x1b0>
     dae:	f01c 0f40 	tst.w	ip, #64	; 0x40
     db2:	d0fa      	beq.n	daa <_printf_i+0x1a4>
     db4:	8019      	strh	r1, [r3, #0]
     db6:	2300      	movs	r3, #0
     db8:	6123      	str	r3, [r4, #16]
     dba:	4605      	mov	r5, r0
     dbc:	e7bd      	b.n	d3a <_printf_i+0x134>
     dbe:	681a      	ldr	r2, [r3, #0]
     dc0:	1d11      	adds	r1, r2, #4
     dc2:	6019      	str	r1, [r3, #0]
     dc4:	6815      	ldr	r5, [r2, #0]
     dc6:	6862      	ldr	r2, [r4, #4]
     dc8:	2100      	movs	r1, #0
     dca:	4628      	mov	r0, r5
     dcc:	f7ff f998 	bl	100 <memchr>
     dd0:	b108      	cbz	r0, dd6 <_printf_i+0x1d0>
     dd2:	1b40      	subs	r0, r0, r5
     dd4:	6060      	str	r0, [r4, #4]
     dd6:	6863      	ldr	r3, [r4, #4]
     dd8:	6123      	str	r3, [r4, #16]
     dda:	2300      	movs	r3, #0
     ddc:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
     de0:	e7ab      	b.n	d3a <_printf_i+0x134>
     de2:	6923      	ldr	r3, [r4, #16]
     de4:	462a      	mov	r2, r5
     de6:	4639      	mov	r1, r7
     de8:	4630      	mov	r0, r6
     dea:	47c0      	blx	r8
     dec:	3001      	adds	r0, #1
     dee:	d0ae      	beq.n	d4e <_printf_i+0x148>
     df0:	6823      	ldr	r3, [r4, #0]
     df2:	079b      	lsls	r3, r3, #30
     df4:	d413      	bmi.n	e1e <_printf_i+0x218>
     df6:	68e0      	ldr	r0, [r4, #12]
     df8:	9b03      	ldr	r3, [sp, #12]
     dfa:	4298      	cmp	r0, r3
     dfc:	bfb8      	it	lt
     dfe:	4618      	movlt	r0, r3
     e00:	e7a7      	b.n	d52 <_printf_i+0x14c>
     e02:	2301      	movs	r3, #1
     e04:	464a      	mov	r2, r9
     e06:	4639      	mov	r1, r7
     e08:	4630      	mov	r0, r6
     e0a:	47c0      	blx	r8
     e0c:	3001      	adds	r0, #1
     e0e:	d09e      	beq.n	d4e <_printf_i+0x148>
     e10:	3501      	adds	r5, #1
     e12:	68e3      	ldr	r3, [r4, #12]
     e14:	9a03      	ldr	r2, [sp, #12]
     e16:	1a9b      	subs	r3, r3, r2
     e18:	42ab      	cmp	r3, r5
     e1a:	dcf2      	bgt.n	e02 <_printf_i+0x1fc>
     e1c:	e7eb      	b.n	df6 <_printf_i+0x1f0>
     e1e:	2500      	movs	r5, #0
     e20:	f104 0919 	add.w	r9, r4, #25
     e24:	e7f5      	b.n	e12 <_printf_i+0x20c>
     e26:	bf00      	nop
     e28:	00019217 	.word	0x00019217
     e2c:	00019228 	.word	0x00019228

00000e30 <_sbrk_r>:
     e30:	b538      	push	{r3, r4, r5, lr}
     e32:	4c06      	ldr	r4, [pc, #24]	; (e4c <_sbrk_r+0x1c>)
     e34:	2300      	movs	r3, #0
     e36:	4605      	mov	r5, r0
     e38:	4608      	mov	r0, r1
     e3a:	6023      	str	r3, [r4, #0]
     e3c:	f009 fa2e 	bl	a29c <_sbrk>
     e40:	1c43      	adds	r3, r0, #1
     e42:	d102      	bne.n	e4a <_sbrk_r+0x1a>
     e44:	6823      	ldr	r3, [r4, #0]
     e46:	b103      	cbz	r3, e4a <_sbrk_r+0x1a>
     e48:	602b      	str	r3, [r5, #0]
     e4a:	bd38      	pop	{r3, r4, r5, pc}
     e4c:	20006880 	.word	0x20006880

00000e50 <_sniprintf_r>:
     e50:	b408      	push	{r3}
     e52:	b530      	push	{r4, r5, lr}
     e54:	1e14      	subs	r4, r2, #0
     e56:	b09a      	sub	sp, #104	; 0x68
     e58:	4605      	mov	r5, r0
     e5a:	da08      	bge.n	e6e <_sniprintf_r+0x1e>
     e5c:	238b      	movs	r3, #139	; 0x8b
     e5e:	6003      	str	r3, [r0, #0]
     e60:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     e64:	b01a      	add	sp, #104	; 0x68
     e66:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
     e6a:	b001      	add	sp, #4
     e6c:	4770      	bx	lr
     e6e:	f44f 7302 	mov.w	r3, #520	; 0x208
     e72:	f8ad 3010 	strh.w	r3, [sp, #16]
     e76:	bf14      	ite	ne
     e78:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
     e7c:	4623      	moveq	r3, r4
     e7e:	9303      	str	r3, [sp, #12]
     e80:	9306      	str	r3, [sp, #24]
     e82:	f64f 73ff 	movw	r3, #65535	; 0xffff
     e86:	9101      	str	r1, [sp, #4]
     e88:	9105      	str	r1, [sp, #20]
     e8a:	f8ad 3012 	strh.w	r3, [sp, #18]
     e8e:	9a1d      	ldr	r2, [sp, #116]	; 0x74
     e90:	ab1e      	add	r3, sp, #120	; 0x78
     e92:	a901      	add	r1, sp, #4
     e94:	9300      	str	r3, [sp, #0]
     e96:	f000 fdf6 	bl	1a86 <_svfiprintf_r>
     e9a:	1c43      	adds	r3, r0, #1
     e9c:	bfbc      	itt	lt
     e9e:	238b      	movlt	r3, #139	; 0x8b
     ea0:	602b      	strlt	r3, [r5, #0]
     ea2:	2c00      	cmp	r4, #0
     ea4:	d0de      	beq.n	e64 <_sniprintf_r+0x14>
     ea6:	9b01      	ldr	r3, [sp, #4]
     ea8:	2200      	movs	r2, #0
     eaa:	701a      	strb	r2, [r3, #0]
     eac:	e7da      	b.n	e64 <_sniprintf_r+0x14>

00000eae <sniprintf>:
     eae:	b40c      	push	{r2, r3}
     eb0:	b530      	push	{r4, r5, lr}
     eb2:	4b17      	ldr	r3, [pc, #92]	; (f10 <sniprintf+0x62>)
     eb4:	1e0c      	subs	r4, r1, #0
     eb6:	b09b      	sub	sp, #108	; 0x6c
     eb8:	681d      	ldr	r5, [r3, #0]
     eba:	da08      	bge.n	ece <sniprintf+0x20>
     ebc:	238b      	movs	r3, #139	; 0x8b
     ebe:	602b      	str	r3, [r5, #0]
     ec0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     ec4:	b01b      	add	sp, #108	; 0x6c
     ec6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
     eca:	b002      	add	sp, #8
     ecc:	4770      	bx	lr
     ece:	f44f 7302 	mov.w	r3, #520	; 0x208
     ed2:	f8ad 3010 	strh.w	r3, [sp, #16]
     ed6:	bf14      	ite	ne
     ed8:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
     edc:	4623      	moveq	r3, r4
     ede:	9303      	str	r3, [sp, #12]
     ee0:	9306      	str	r3, [sp, #24]
     ee2:	f64f 73ff 	movw	r3, #65535	; 0xffff
     ee6:	9001      	str	r0, [sp, #4]
     ee8:	9005      	str	r0, [sp, #20]
     eea:	f8ad 3012 	strh.w	r3, [sp, #18]
     eee:	9a1e      	ldr	r2, [sp, #120]	; 0x78
     ef0:	ab1f      	add	r3, sp, #124	; 0x7c
     ef2:	a901      	add	r1, sp, #4
     ef4:	4628      	mov	r0, r5
     ef6:	9300      	str	r3, [sp, #0]
     ef8:	f000 fdc5 	bl	1a86 <_svfiprintf_r>
     efc:	1c43      	adds	r3, r0, #1
     efe:	bfbc      	itt	lt
     f00:	238b      	movlt	r3, #139	; 0x8b
     f02:	602b      	strlt	r3, [r5, #0]
     f04:	2c00      	cmp	r4, #0
     f06:	d0dd      	beq.n	ec4 <sniprintf+0x16>
     f08:	9b01      	ldr	r3, [sp, #4]
     f0a:	2200      	movs	r2, #0
     f0c:	701a      	strb	r2, [r3, #0]
     f0e:	e7d9      	b.n	ec4 <sniprintf+0x16>
     f10:	200109c8 	.word	0x200109c8

00000f14 <_strtol_l.isra.0>:
     f14:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     f18:	4f39      	ldr	r7, [pc, #228]	; (1000 <CONFIG_HEAP_MEM_POOL_SIZE>)
     f1a:	4686      	mov	lr, r0
     f1c:	4608      	mov	r0, r1
     f1e:	4605      	mov	r5, r0
     f20:	f815 4b01 	ldrb.w	r4, [r5], #1
     f24:	5de6      	ldrb	r6, [r4, r7]
     f26:	f016 0608 	ands.w	r6, r6, #8
     f2a:	d134      	bne.n	f96 <_strtol_l.isra.0+0x82>
     f2c:	2c2d      	cmp	r4, #45	; 0x2d
     f2e:	d134      	bne.n	f9a <_strtol_l.isra.0+0x86>
     f30:	782c      	ldrb	r4, [r5, #0]
     f32:	f04f 0801 	mov.w	r8, #1
     f36:	1c85      	adds	r5, r0, #2
     f38:	2b00      	cmp	r3, #0
     f3a:	d05c      	beq.n	ff6 <_strtol_l.isra.0+0xe2>
     f3c:	2b10      	cmp	r3, #16
     f3e:	d109      	bne.n	f54 <_strtol_l.isra.0+0x40>
     f40:	2c30      	cmp	r4, #48	; 0x30
     f42:	d107      	bne.n	f54 <_strtol_l.isra.0+0x40>
     f44:	7828      	ldrb	r0, [r5, #0]
     f46:	f000 00df 	and.w	r0, r0, #223	; 0xdf
     f4a:	2858      	cmp	r0, #88	; 0x58
     f4c:	d14e      	bne.n	fec <_strtol_l.isra.0+0xd8>
     f4e:	786c      	ldrb	r4, [r5, #1]
     f50:	2310      	movs	r3, #16
     f52:	3502      	adds	r5, #2
     f54:	f1b8 0f00 	cmp.w	r8, #0
     f58:	bf14      	ite	ne
     f5a:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
     f5e:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
     f62:	2700      	movs	r7, #0
     f64:	fbbc f9f3 	udiv	r9, ip, r3
     f68:	4638      	mov	r0, r7
     f6a:	fb03 ca19 	mls	sl, r3, r9, ip
     f6e:	f1a4 0630 	sub.w	r6, r4, #48	; 0x30
     f72:	2e09      	cmp	r6, #9
     f74:	d818      	bhi.n	fa8 <_strtol_l.isra.0+0x94>
     f76:	4634      	mov	r4, r6
     f78:	42a3      	cmp	r3, r4
     f7a:	dd24      	ble.n	fc6 <_strtol_l.isra.0+0xb2>
     f7c:	1c7e      	adds	r6, r7, #1
     f7e:	d007      	beq.n	f90 <_strtol_l.isra.0+0x7c>
     f80:	4581      	cmp	r9, r0
     f82:	d31d      	bcc.n	fc0 <_strtol_l.isra.0+0xac>
     f84:	d101      	bne.n	f8a <_strtol_l.isra.0+0x76>
     f86:	45a2      	cmp	sl, r4
     f88:	db1a      	blt.n	fc0 <_strtol_l.isra.0+0xac>
     f8a:	fb00 4003 	mla	r0, r0, r3, r4
     f8e:	2701      	movs	r7, #1
     f90:	f815 4b01 	ldrb.w	r4, [r5], #1
     f94:	e7eb      	b.n	f6e <_strtol_l.isra.0+0x5a>
     f96:	4628      	mov	r0, r5
     f98:	e7c1      	b.n	f1e <_strtol_l.isra.0+0xa>
     f9a:	2c2b      	cmp	r4, #43	; 0x2b
     f9c:	bf08      	it	eq
     f9e:	782c      	ldrbeq	r4, [r5, #0]
     fa0:	46b0      	mov	r8, r6
     fa2:	bf08      	it	eq
     fa4:	1c85      	addeq	r5, r0, #2
     fa6:	e7c7      	b.n	f38 <_strtol_l.isra.0+0x24>
     fa8:	f1a4 0641 	sub.w	r6, r4, #65	; 0x41
     fac:	2e19      	cmp	r6, #25
     fae:	d801      	bhi.n	fb4 <_strtol_l.isra.0+0xa0>
     fb0:	3c37      	subs	r4, #55	; 0x37
     fb2:	e7e1      	b.n	f78 <_strtol_l.isra.0+0x64>
     fb4:	f1a4 0661 	sub.w	r6, r4, #97	; 0x61
     fb8:	2e19      	cmp	r6, #25
     fba:	d804      	bhi.n	fc6 <_strtol_l.isra.0+0xb2>
     fbc:	3c57      	subs	r4, #87	; 0x57
     fbe:	e7db      	b.n	f78 <_strtol_l.isra.0+0x64>
     fc0:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
     fc4:	e7e4      	b.n	f90 <_strtol_l.isra.0+0x7c>
     fc6:	1c7b      	adds	r3, r7, #1
     fc8:	d106      	bne.n	fd8 <_strtol_l.isra.0+0xc4>
     fca:	2322      	movs	r3, #34	; 0x22
     fcc:	f8ce 3000 	str.w	r3, [lr]
     fd0:	4660      	mov	r0, ip
     fd2:	b942      	cbnz	r2, fe6 <_strtol_l.isra.0+0xd2>
     fd4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     fd8:	f1b8 0f00 	cmp.w	r8, #0
     fdc:	d000      	beq.n	fe0 <_strtol_l.isra.0+0xcc>
     fde:	4240      	negs	r0, r0
     fe0:	2a00      	cmp	r2, #0
     fe2:	d0f7      	beq.n	fd4 <_strtol_l.isra.0+0xc0>
     fe4:	b107      	cbz	r7, fe8 <_strtol_l.isra.0+0xd4>
     fe6:	1e69      	subs	r1, r5, #1
     fe8:	6011      	str	r1, [r2, #0]
     fea:	e7f3      	b.n	fd4 <_strtol_l.isra.0+0xc0>
     fec:	2430      	movs	r4, #48	; 0x30
     fee:	2b00      	cmp	r3, #0
     ff0:	d1b0      	bne.n	f54 <_strtol_l.isra.0+0x40>
     ff2:	2308      	movs	r3, #8
     ff4:	e7ae      	b.n	f54 <_strtol_l.isra.0+0x40>
     ff6:	2c30      	cmp	r4, #48	; 0x30
     ff8:	d0a4      	beq.n	f44 <_strtol_l.isra.0+0x30>
     ffa:	230a      	movs	r3, #10
     ffc:	e7aa      	b.n	f54 <_strtol_l.isra.0+0x40>
     ffe:	bf00      	nop
    1000:	0001649f 	.word	0x0001649f

00001004 <_strtol_r>:
    1004:	e786      	b.n	f14 <_strtol_l.isra.0>

00001006 <strtol_l>:
    1006:	4613      	mov	r3, r2
    1008:	460a      	mov	r2, r1
    100a:	4601      	mov	r1, r0
    100c:	4801      	ldr	r0, [pc, #4]	; (1014 <strtol_l+0xe>)
    100e:	6800      	ldr	r0, [r0, #0]
    1010:	e780      	b.n	f14 <_strtol_l.isra.0>
    1012:	bf00      	nop
    1014:	200109c8 	.word	0x200109c8

00001018 <strtol>:
    1018:	4613      	mov	r3, r2
    101a:	460a      	mov	r2, r1
    101c:	4601      	mov	r1, r0
    101e:	4801      	ldr	r0, [pc, #4]	; (1024 <strtol+0xc>)
    1020:	6800      	ldr	r0, [r0, #0]
    1022:	e777      	b.n	f14 <_strtol_l.isra.0>
    1024:	200109c8 	.word	0x200109c8

00001028 <_vsniprintf_r>:
    1028:	b530      	push	{r4, r5, lr}
    102a:	1e14      	subs	r4, r2, #0
    102c:	4605      	mov	r5, r0
    102e:	b09b      	sub	sp, #108	; 0x6c
    1030:	4618      	mov	r0, r3
    1032:	da05      	bge.n	1040 <_vsniprintf_r+0x18>
    1034:	238b      	movs	r3, #139	; 0x8b
    1036:	602b      	str	r3, [r5, #0]
    1038:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    103c:	b01b      	add	sp, #108	; 0x6c
    103e:	bd30      	pop	{r4, r5, pc}
    1040:	f44f 7302 	mov.w	r3, #520	; 0x208
    1044:	f8ad 3010 	strh.w	r3, [sp, #16]
    1048:	bf14      	ite	ne
    104a:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
    104e:	4623      	moveq	r3, r4
    1050:	9303      	str	r3, [sp, #12]
    1052:	9306      	str	r3, [sp, #24]
    1054:	f64f 73ff 	movw	r3, #65535	; 0xffff
    1058:	9101      	str	r1, [sp, #4]
    105a:	9105      	str	r1, [sp, #20]
    105c:	f8ad 3012 	strh.w	r3, [sp, #18]
    1060:	4602      	mov	r2, r0
    1062:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1064:	a901      	add	r1, sp, #4
    1066:	4628      	mov	r0, r5
    1068:	f000 fd0d 	bl	1a86 <_svfiprintf_r>
    106c:	1c43      	adds	r3, r0, #1
    106e:	bfbc      	itt	lt
    1070:	238b      	movlt	r3, #139	; 0x8b
    1072:	602b      	strlt	r3, [r5, #0]
    1074:	2c00      	cmp	r4, #0
    1076:	d0e1      	beq.n	103c <_vsniprintf_r+0x14>
    1078:	9b01      	ldr	r3, [sp, #4]
    107a:	2200      	movs	r2, #0
    107c:	701a      	strb	r2, [r3, #0]
    107e:	e7dd      	b.n	103c <_vsniprintf_r+0x14>

00001080 <vsniprintf>:
    1080:	b507      	push	{r0, r1, r2, lr}
    1082:	9300      	str	r3, [sp, #0]
    1084:	4613      	mov	r3, r2
    1086:	460a      	mov	r2, r1
    1088:	4601      	mov	r1, r0
    108a:	4803      	ldr	r0, [pc, #12]	; (1098 <vsniprintf+0x18>)
    108c:	6800      	ldr	r0, [r0, #0]
    108e:	f7ff ffcb 	bl	1028 <_vsniprintf_r>
    1092:	b003      	add	sp, #12
    1094:	f85d fb04 	ldr.w	pc, [sp], #4
    1098:	200109c8 	.word	0x200109c8

0000109c <__swbuf_r>:
    109c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    109e:	460d      	mov	r5, r1
    10a0:	4614      	mov	r4, r2
    10a2:	4606      	mov	r6, r0
    10a4:	b118      	cbz	r0, 10ae <__swbuf_r+0x12>
    10a6:	6b83      	ldr	r3, [r0, #56]	; 0x38
    10a8:	b90b      	cbnz	r3, 10ae <__swbuf_r+0x12>
    10aa:	f000 f9b1 	bl	1410 <__sinit>
    10ae:	69a3      	ldr	r3, [r4, #24]
    10b0:	60a3      	str	r3, [r4, #8]
    10b2:	89a3      	ldrh	r3, [r4, #12]
    10b4:	071a      	lsls	r2, r3, #28
    10b6:	d525      	bpl.n	1104 <__swbuf_r+0x68>
    10b8:	6923      	ldr	r3, [r4, #16]
    10ba:	b31b      	cbz	r3, 1104 <__swbuf_r+0x68>
    10bc:	6923      	ldr	r3, [r4, #16]
    10be:	6820      	ldr	r0, [r4, #0]
    10c0:	1ac0      	subs	r0, r0, r3
    10c2:	6963      	ldr	r3, [r4, #20]
    10c4:	b2ed      	uxtb	r5, r5
    10c6:	4283      	cmp	r3, r0
    10c8:	462f      	mov	r7, r5
    10ca:	dc04      	bgt.n	10d6 <__swbuf_r+0x3a>
    10cc:	4621      	mov	r1, r4
    10ce:	4630      	mov	r0, r6
    10d0:	f000 f934 	bl	133c <_fflush_r>
    10d4:	b9e0      	cbnz	r0, 1110 <__swbuf_r+0x74>
    10d6:	68a3      	ldr	r3, [r4, #8]
    10d8:	3b01      	subs	r3, #1
    10da:	60a3      	str	r3, [r4, #8]
    10dc:	6823      	ldr	r3, [r4, #0]
    10de:	1c5a      	adds	r2, r3, #1
    10e0:	6022      	str	r2, [r4, #0]
    10e2:	701d      	strb	r5, [r3, #0]
    10e4:	6963      	ldr	r3, [r4, #20]
    10e6:	3001      	adds	r0, #1
    10e8:	4283      	cmp	r3, r0
    10ea:	d004      	beq.n	10f6 <__swbuf_r+0x5a>
    10ec:	89a3      	ldrh	r3, [r4, #12]
    10ee:	07db      	lsls	r3, r3, #31
    10f0:	d506      	bpl.n	1100 <__swbuf_r+0x64>
    10f2:	2d0a      	cmp	r5, #10
    10f4:	d104      	bne.n	1100 <__swbuf_r+0x64>
    10f6:	4621      	mov	r1, r4
    10f8:	4630      	mov	r0, r6
    10fa:	f000 f91f 	bl	133c <_fflush_r>
    10fe:	b938      	cbnz	r0, 1110 <__swbuf_r+0x74>
    1100:	4638      	mov	r0, r7
    1102:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1104:	4621      	mov	r1, r4
    1106:	4630      	mov	r0, r6
    1108:	f000 f80e 	bl	1128 <__swsetup_r>
    110c:	2800      	cmp	r0, #0
    110e:	d0d5      	beq.n	10bc <__swbuf_r+0x20>
    1110:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    1114:	e7f4      	b.n	1100 <__swbuf_r+0x64>

00001116 <__swbuf>:
    1116:	4b03      	ldr	r3, [pc, #12]	; (1124 <__swbuf+0xe>)
    1118:	460a      	mov	r2, r1
    111a:	4601      	mov	r1, r0
    111c:	6818      	ldr	r0, [r3, #0]
    111e:	f7ff bfbd 	b.w	109c <__swbuf_r>
    1122:	bf00      	nop
    1124:	200109c8 	.word	0x200109c8

00001128 <__swsetup_r>:
    1128:	b538      	push	{r3, r4, r5, lr}
    112a:	4b2a      	ldr	r3, [pc, #168]	; (11d4 <__swsetup_r+0xac>)
    112c:	4605      	mov	r5, r0
    112e:	6818      	ldr	r0, [r3, #0]
    1130:	460c      	mov	r4, r1
    1132:	b118      	cbz	r0, 113c <__swsetup_r+0x14>
    1134:	6b83      	ldr	r3, [r0, #56]	; 0x38
    1136:	b90b      	cbnz	r3, 113c <__swsetup_r+0x14>
    1138:	f000 f96a 	bl	1410 <__sinit>
    113c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    1140:	b29a      	uxth	r2, r3
    1142:	0711      	lsls	r1, r2, #28
    1144:	d422      	bmi.n	118c <__swsetup_r+0x64>
    1146:	06d0      	lsls	r0, r2, #27
    1148:	d407      	bmi.n	115a <__swsetup_r+0x32>
    114a:	2209      	movs	r2, #9
    114c:	602a      	str	r2, [r5, #0]
    114e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1152:	81a3      	strh	r3, [r4, #12]
    1154:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1158:	e034      	b.n	11c4 <__swsetup_r+0x9c>
    115a:	0751      	lsls	r1, r2, #29
    115c:	d512      	bpl.n	1184 <__swsetup_r+0x5c>
    115e:	6b21      	ldr	r1, [r4, #48]	; 0x30
    1160:	b141      	cbz	r1, 1174 <__swsetup_r+0x4c>
    1162:	f104 0340 	add.w	r3, r4, #64	; 0x40
    1166:	4299      	cmp	r1, r3
    1168:	d002      	beq.n	1170 <__swsetup_r+0x48>
    116a:	4628      	mov	r0, r5
    116c:	f000 fb6a 	bl	1844 <_free_r>
    1170:	2300      	movs	r3, #0
    1172:	6323      	str	r3, [r4, #48]	; 0x30
    1174:	89a3      	ldrh	r3, [r4, #12]
    1176:	f023 0324 	bic.w	r3, r3, #36	; 0x24
    117a:	81a3      	strh	r3, [r4, #12]
    117c:	2300      	movs	r3, #0
    117e:	6063      	str	r3, [r4, #4]
    1180:	6923      	ldr	r3, [r4, #16]
    1182:	6023      	str	r3, [r4, #0]
    1184:	89a3      	ldrh	r3, [r4, #12]
    1186:	f043 0308 	orr.w	r3, r3, #8
    118a:	81a3      	strh	r3, [r4, #12]
    118c:	6923      	ldr	r3, [r4, #16]
    118e:	b94b      	cbnz	r3, 11a4 <__swsetup_r+0x7c>
    1190:	89a3      	ldrh	r3, [r4, #12]
    1192:	f403 7320 	and.w	r3, r3, #640	; 0x280
    1196:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    119a:	d003      	beq.n	11a4 <__swsetup_r+0x7c>
    119c:	4621      	mov	r1, r4
    119e:	4628      	mov	r0, r5
    11a0:	f000 fb0f 	bl	17c2 <__smakebuf_r>
    11a4:	89a2      	ldrh	r2, [r4, #12]
    11a6:	f012 0301 	ands.w	r3, r2, #1
    11aa:	d00c      	beq.n	11c6 <__swsetup_r+0x9e>
    11ac:	2300      	movs	r3, #0
    11ae:	60a3      	str	r3, [r4, #8]
    11b0:	6963      	ldr	r3, [r4, #20]
    11b2:	425b      	negs	r3, r3
    11b4:	61a3      	str	r3, [r4, #24]
    11b6:	6923      	ldr	r3, [r4, #16]
    11b8:	b953      	cbnz	r3, 11d0 <__swsetup_r+0xa8>
    11ba:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    11be:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    11c2:	d1c4      	bne.n	114e <__swsetup_r+0x26>
    11c4:	bd38      	pop	{r3, r4, r5, pc}
    11c6:	0792      	lsls	r2, r2, #30
    11c8:	bf58      	it	pl
    11ca:	6963      	ldrpl	r3, [r4, #20]
    11cc:	60a3      	str	r3, [r4, #8]
    11ce:	e7f2      	b.n	11b6 <__swsetup_r+0x8e>
    11d0:	2000      	movs	r0, #0
    11d2:	e7f7      	b.n	11c4 <__swsetup_r+0x9c>
    11d4:	200109c8 	.word	0x200109c8

000011d8 <__chk_fail>:
    11d8:	b500      	push	{lr}
    11da:	4b10      	ldr	r3, [pc, #64]	; (121c <__chk_fail+0x44>)
    11dc:	b08d      	sub	sp, #52	; 0x34
    11de:	466a      	mov	r2, sp
    11e0:	f103 0628 	add.w	r6, r3, #40	; 0x28
    11e4:	4615      	mov	r5, r2
    11e6:	6818      	ldr	r0, [r3, #0]
    11e8:	6859      	ldr	r1, [r3, #4]
    11ea:	4614      	mov	r4, r2
    11ec:	c403      	stmia	r4!, {r0, r1}
    11ee:	3308      	adds	r3, #8
    11f0:	42b3      	cmp	r3, r6
    11f2:	4622      	mov	r2, r4
    11f4:	d1f7      	bne.n	11e6 <__chk_fail+0xe>
    11f6:	6818      	ldr	r0, [r3, #0]
    11f8:	889b      	ldrh	r3, [r3, #4]
    11fa:	80a3      	strh	r3, [r4, #4]
    11fc:	6020      	str	r0, [r4, #0]
    11fe:	4628      	mov	r0, r5
    1200:	f001 f812 	bl	2228 <strlen>
    1204:	4629      	mov	r1, r5
    1206:	4602      	mov	r2, r0
    1208:	2002      	movs	r0, #2
    120a:	f011 ff20 	bl	1304e <_write>
    120e:	2006      	movs	r0, #6
    1210:	f000 fdaf 	bl	1d72 <raise>
    1214:	207f      	movs	r0, #127	; 0x7f
    1216:	f009 f839 	bl	a28c <_exit>
    121a:	bf00      	nop
    121c:	00019239 	.word	0x00019239

00001220 <__sflush_r>:
    1220:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
    1224:	b293      	uxth	r3, r2
    1226:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    122a:	4605      	mov	r5, r0
    122c:	0718      	lsls	r0, r3, #28
    122e:	460c      	mov	r4, r1
    1230:	d45f      	bmi.n	12f2 <__sflush_r+0xd2>
    1232:	684b      	ldr	r3, [r1, #4]
    1234:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    1238:	2b00      	cmp	r3, #0
    123a:	818a      	strh	r2, [r1, #12]
    123c:	dc05      	bgt.n	124a <__sflush_r+0x2a>
    123e:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
    1240:	2b00      	cmp	r3, #0
    1242:	dc02      	bgt.n	124a <__sflush_r+0x2a>
    1244:	2000      	movs	r0, #0
    1246:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    124a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    124c:	2e00      	cmp	r6, #0
    124e:	d0f9      	beq.n	1244 <__sflush_r+0x24>
    1250:	2300      	movs	r3, #0
    1252:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    1256:	682f      	ldr	r7, [r5, #0]
    1258:	602b      	str	r3, [r5, #0]
    125a:	d036      	beq.n	12ca <__sflush_r+0xaa>
    125c:	6d20      	ldr	r0, [r4, #80]	; 0x50
    125e:	89a3      	ldrh	r3, [r4, #12]
    1260:	075a      	lsls	r2, r3, #29
    1262:	d505      	bpl.n	1270 <__sflush_r+0x50>
    1264:	6863      	ldr	r3, [r4, #4]
    1266:	1ac0      	subs	r0, r0, r3
    1268:	6b23      	ldr	r3, [r4, #48]	; 0x30
    126a:	b10b      	cbz	r3, 1270 <__sflush_r+0x50>
    126c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    126e:	1ac0      	subs	r0, r0, r3
    1270:	2300      	movs	r3, #0
    1272:	4602      	mov	r2, r0
    1274:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    1276:	69e1      	ldr	r1, [r4, #28]
    1278:	4628      	mov	r0, r5
    127a:	47b0      	blx	r6
    127c:	1c43      	adds	r3, r0, #1
    127e:	89a3      	ldrh	r3, [r4, #12]
    1280:	d106      	bne.n	1290 <__sflush_r+0x70>
    1282:	6829      	ldr	r1, [r5, #0]
    1284:	291d      	cmp	r1, #29
    1286:	d830      	bhi.n	12ea <__sflush_r+0xca>
    1288:	4a2b      	ldr	r2, [pc, #172]	; (1338 <__sflush_r+0x118>)
    128a:	40ca      	lsrs	r2, r1
    128c:	07d6      	lsls	r6, r2, #31
    128e:	d52c      	bpl.n	12ea <__sflush_r+0xca>
    1290:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    1294:	b21b      	sxth	r3, r3
    1296:	2200      	movs	r2, #0
    1298:	6062      	str	r2, [r4, #4]
    129a:	04d9      	lsls	r1, r3, #19
    129c:	6922      	ldr	r2, [r4, #16]
    129e:	81a3      	strh	r3, [r4, #12]
    12a0:	6022      	str	r2, [r4, #0]
    12a2:	d504      	bpl.n	12ae <__sflush_r+0x8e>
    12a4:	1c42      	adds	r2, r0, #1
    12a6:	d101      	bne.n	12ac <__sflush_r+0x8c>
    12a8:	682b      	ldr	r3, [r5, #0]
    12aa:	b903      	cbnz	r3, 12ae <__sflush_r+0x8e>
    12ac:	6520      	str	r0, [r4, #80]	; 0x50
    12ae:	6b21      	ldr	r1, [r4, #48]	; 0x30
    12b0:	602f      	str	r7, [r5, #0]
    12b2:	2900      	cmp	r1, #0
    12b4:	d0c6      	beq.n	1244 <__sflush_r+0x24>
    12b6:	f104 0340 	add.w	r3, r4, #64	; 0x40
    12ba:	4299      	cmp	r1, r3
    12bc:	d002      	beq.n	12c4 <__sflush_r+0xa4>
    12be:	4628      	mov	r0, r5
    12c0:	f000 fac0 	bl	1844 <_free_r>
    12c4:	2000      	movs	r0, #0
    12c6:	6320      	str	r0, [r4, #48]	; 0x30
    12c8:	e7bd      	b.n	1246 <__sflush_r+0x26>
    12ca:	69e1      	ldr	r1, [r4, #28]
    12cc:	2301      	movs	r3, #1
    12ce:	4628      	mov	r0, r5
    12d0:	47b0      	blx	r6
    12d2:	1c41      	adds	r1, r0, #1
    12d4:	d1c3      	bne.n	125e <__sflush_r+0x3e>
    12d6:	682b      	ldr	r3, [r5, #0]
    12d8:	2b00      	cmp	r3, #0
    12da:	d0c0      	beq.n	125e <__sflush_r+0x3e>
    12dc:	2b1d      	cmp	r3, #29
    12de:	d001      	beq.n	12e4 <__sflush_r+0xc4>
    12e0:	2b16      	cmp	r3, #22
    12e2:	d101      	bne.n	12e8 <__sflush_r+0xc8>
    12e4:	602f      	str	r7, [r5, #0]
    12e6:	e7ad      	b.n	1244 <__sflush_r+0x24>
    12e8:	89a3      	ldrh	r3, [r4, #12]
    12ea:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    12ee:	81a3      	strh	r3, [r4, #12]
    12f0:	e7a9      	b.n	1246 <__sflush_r+0x26>
    12f2:	690f      	ldr	r7, [r1, #16]
    12f4:	2f00      	cmp	r7, #0
    12f6:	d0a5      	beq.n	1244 <__sflush_r+0x24>
    12f8:	079b      	lsls	r3, r3, #30
    12fa:	680e      	ldr	r6, [r1, #0]
    12fc:	bf08      	it	eq
    12fe:	694b      	ldreq	r3, [r1, #20]
    1300:	600f      	str	r7, [r1, #0]
    1302:	bf18      	it	ne
    1304:	2300      	movne	r3, #0
    1306:	eba6 0807 	sub.w	r8, r6, r7
    130a:	608b      	str	r3, [r1, #8]
    130c:	f1b8 0f00 	cmp.w	r8, #0
    1310:	dd98      	ble.n	1244 <__sflush_r+0x24>
    1312:	4643      	mov	r3, r8
    1314:	463a      	mov	r2, r7
    1316:	69e1      	ldr	r1, [r4, #28]
    1318:	6a66      	ldr	r6, [r4, #36]	; 0x24
    131a:	4628      	mov	r0, r5
    131c:	47b0      	blx	r6
    131e:	2800      	cmp	r0, #0
    1320:	dc06      	bgt.n	1330 <__sflush_r+0x110>
    1322:	89a3      	ldrh	r3, [r4, #12]
    1324:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1328:	81a3      	strh	r3, [r4, #12]
    132a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    132e:	e78a      	b.n	1246 <__sflush_r+0x26>
    1330:	4407      	add	r7, r0
    1332:	eba8 0800 	sub.w	r8, r8, r0
    1336:	e7e9      	b.n	130c <__sflush_r+0xec>
    1338:	20400001 	.word	0x20400001

0000133c <_fflush_r>:
    133c:	b538      	push	{r3, r4, r5, lr}
    133e:	460d      	mov	r5, r1
    1340:	4604      	mov	r4, r0
    1342:	b118      	cbz	r0, 134c <_fflush_r+0x10>
    1344:	6b83      	ldr	r3, [r0, #56]	; 0x38
    1346:	b90b      	cbnz	r3, 134c <_fflush_r+0x10>
    1348:	f000 f862 	bl	1410 <__sinit>
    134c:	f9b5 000c 	ldrsh.w	r0, [r5, #12]
    1350:	b128      	cbz	r0, 135e <_fflush_r+0x22>
    1352:	4629      	mov	r1, r5
    1354:	4620      	mov	r0, r4
    1356:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    135a:	f7ff bf61 	b.w	1220 <__sflush_r>
    135e:	bd38      	pop	{r3, r4, r5, pc}

00001360 <fflush>:
    1360:	4601      	mov	r1, r0
    1362:	b920      	cbnz	r0, 136e <fflush+0xe>
    1364:	4b04      	ldr	r3, [pc, #16]	; (1378 <fflush+0x18>)
    1366:	4905      	ldr	r1, [pc, #20]	; (137c <fflush+0x1c>)
    1368:	6818      	ldr	r0, [r3, #0]
    136a:	f000 bfaf 	b.w	22cc <_fwalk_reent>
    136e:	4b04      	ldr	r3, [pc, #16]	; (1380 <fflush+0x20>)
    1370:	6818      	ldr	r0, [r3, #0]
    1372:	f7ff bfe3 	b.w	133c <_fflush_r>
    1376:	bf00      	nop
    1378:	00016484 	.word	0x00016484
    137c:	0000133d 	.word	0x0000133d
    1380:	200109c8 	.word	0x200109c8

00001384 <std>:
    1384:	2300      	movs	r3, #0
    1386:	b510      	push	{r4, lr}
    1388:	4604      	mov	r4, r0
    138a:	e9c0 3300 	strd	r3, r3, [r0]
    138e:	6083      	str	r3, [r0, #8]
    1390:	8181      	strh	r1, [r0, #12]
    1392:	6603      	str	r3, [r0, #96]	; 0x60
    1394:	81c2      	strh	r2, [r0, #14]
    1396:	e9c0 3304 	strd	r3, r3, [r0, #16]
    139a:	6183      	str	r3, [r0, #24]
    139c:	4619      	mov	r1, r3
    139e:	2208      	movs	r2, #8
    13a0:	3058      	adds	r0, #88	; 0x58
    13a2:	f000 ff22 	bl	21ea <memset>
    13a6:	4b05      	ldr	r3, [pc, #20]	; (13bc <std+0x38>)
    13a8:	6223      	str	r3, [r4, #32]
    13aa:	4b05      	ldr	r3, [pc, #20]	; (13c0 <std+0x3c>)
    13ac:	6263      	str	r3, [r4, #36]	; 0x24
    13ae:	4b05      	ldr	r3, [pc, #20]	; (13c4 <std+0x40>)
    13b0:	62a3      	str	r3, [r4, #40]	; 0x28
    13b2:	4b05      	ldr	r3, [pc, #20]	; (13c8 <std+0x44>)
    13b4:	61e4      	str	r4, [r4, #28]
    13b6:	62e3      	str	r3, [r4, #44]	; 0x2c
    13b8:	bd10      	pop	{r4, pc}
    13ba:	bf00      	nop
    13bc:	00002359 	.word	0x00002359
    13c0:	0000237f 	.word	0x0000237f
    13c4:	000023b7 	.word	0x000023b7
    13c8:	000023db 	.word	0x000023db

000013cc <_cleanup_r>:
    13cc:	4901      	ldr	r1, [pc, #4]	; (13d4 <_cleanup_r+0x8>)
    13ce:	f000 bf7d 	b.w	22cc <_fwalk_reent>
    13d2:	bf00      	nop
    13d4:	0000133d 	.word	0x0000133d

000013d8 <__sfmoreglue>:
    13d8:	b570      	push	{r4, r5, r6, lr}
    13da:	1e4a      	subs	r2, r1, #1
    13dc:	2564      	movs	r5, #100	; 0x64
    13de:	4355      	muls	r5, r2
    13e0:	460e      	mov	r6, r1
    13e2:	f105 0170 	add.w	r1, r5, #112	; 0x70
    13e6:	f7ff fa0d 	bl	804 <_malloc_r>
    13ea:	4604      	mov	r4, r0
    13ec:	b140      	cbz	r0, 1400 <__sfmoreglue+0x28>
    13ee:	2100      	movs	r1, #0
    13f0:	e9c0 1600 	strd	r1, r6, [r0]
    13f4:	300c      	adds	r0, #12
    13f6:	60a0      	str	r0, [r4, #8]
    13f8:	f105 0264 	add.w	r2, r5, #100	; 0x64
    13fc:	f000 fef5 	bl	21ea <memset>
    1400:	4620      	mov	r0, r4
    1402:	bd70      	pop	{r4, r5, r6, pc}

00001404 <_cleanup>:
    1404:	4b01      	ldr	r3, [pc, #4]	; (140c <_cleanup+0x8>)
    1406:	6818      	ldr	r0, [r3, #0]
    1408:	f7ff bfe0 	b.w	13cc <_cleanup_r>
    140c:	00016484 	.word	0x00016484

00001410 <__sinit>:
    1410:	6b82      	ldr	r2, [r0, #56]	; 0x38
    1412:	b510      	push	{r4, lr}
    1414:	4604      	mov	r4, r0
    1416:	b9d2      	cbnz	r2, 144e <__sinit+0x3e>
    1418:	4b0d      	ldr	r3, [pc, #52]	; (1450 <__sinit+0x40>)
    141a:	63c3      	str	r3, [r0, #60]	; 0x3c
    141c:	2303      	movs	r3, #3
    141e:	f8c0 3150 	str.w	r3, [r0, #336]	; 0x150
    1422:	f500 73ac 	add.w	r3, r0, #344	; 0x158
    1426:	f8c0 3154 	str.w	r3, [r0, #340]	; 0x154
    142a:	f8c0 214c 	str.w	r2, [r0, #332]	; 0x14c
    142e:	2104      	movs	r1, #4
    1430:	6840      	ldr	r0, [r0, #4]
    1432:	f7ff ffa7 	bl	1384 <std>
    1436:	2201      	movs	r2, #1
    1438:	2109      	movs	r1, #9
    143a:	68a0      	ldr	r0, [r4, #8]
    143c:	f7ff ffa2 	bl	1384 <std>
    1440:	2202      	movs	r2, #2
    1442:	2112      	movs	r1, #18
    1444:	68e0      	ldr	r0, [r4, #12]
    1446:	f7ff ff9d 	bl	1384 <std>
    144a:	2301      	movs	r3, #1
    144c:	63a3      	str	r3, [r4, #56]	; 0x38
    144e:	bd10      	pop	{r4, pc}
    1450:	000013cd 	.word	0x000013cd

00001454 <__sfp>:
    1454:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1456:	4b1b      	ldr	r3, [pc, #108]	; (14c4 <__sfp+0x70>)
    1458:	681e      	ldr	r6, [r3, #0]
    145a:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    145c:	4607      	mov	r7, r0
    145e:	b913      	cbnz	r3, 1466 <__sfp+0x12>
    1460:	4630      	mov	r0, r6
    1462:	f7ff ffd5 	bl	1410 <__sinit>
    1466:	f506 76a6 	add.w	r6, r6, #332	; 0x14c
    146a:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
    146e:	3b01      	subs	r3, #1
    1470:	d503      	bpl.n	147a <__sfp+0x26>
    1472:	6833      	ldr	r3, [r6, #0]
    1474:	b1db      	cbz	r3, 14ae <__sfp+0x5a>
    1476:	6836      	ldr	r6, [r6, #0]
    1478:	e7f7      	b.n	146a <__sfp+0x16>
    147a:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
    147e:	b9a5      	cbnz	r5, 14aa <__sfp+0x56>
    1480:	4b11      	ldr	r3, [pc, #68]	; (14c8 <__sfp+0x74>)
    1482:	6625      	str	r5, [r4, #96]	; 0x60
    1484:	e9c4 5500 	strd	r5, r5, [r4]
    1488:	60a5      	str	r5, [r4, #8]
    148a:	e9c4 3503 	strd	r3, r5, [r4, #12]
    148e:	e9c4 5505 	strd	r5, r5, [r4, #20]
    1492:	2208      	movs	r2, #8
    1494:	4629      	mov	r1, r5
    1496:	f104 0058 	add.w	r0, r4, #88	; 0x58
    149a:	f000 fea6 	bl	21ea <memset>
    149e:	e9c4 550c 	strd	r5, r5, [r4, #48]	; 0x30
    14a2:	e9c4 5511 	strd	r5, r5, [r4, #68]	; 0x44
    14a6:	4620      	mov	r0, r4
    14a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    14aa:	3464      	adds	r4, #100	; 0x64
    14ac:	e7df      	b.n	146e <__sfp+0x1a>
    14ae:	2104      	movs	r1, #4
    14b0:	4638      	mov	r0, r7
    14b2:	f7ff ff91 	bl	13d8 <__sfmoreglue>
    14b6:	4604      	mov	r4, r0
    14b8:	6030      	str	r0, [r6, #0]
    14ba:	2800      	cmp	r0, #0
    14bc:	d1db      	bne.n	1476 <__sfp+0x22>
    14be:	230c      	movs	r3, #12
    14c0:	603b      	str	r3, [r7, #0]
    14c2:	e7f0      	b.n	14a6 <__sfp+0x52>
    14c4:	00016484 	.word	0x00016484
    14c8:	ffff0001 	.word	0xffff0001

000014cc <__sfvwrite_r>:
    14cc:	6893      	ldr	r3, [r2, #8]
    14ce:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    14d2:	4607      	mov	r7, r0
    14d4:	460c      	mov	r4, r1
    14d6:	4690      	mov	r8, r2
    14d8:	b91b      	cbnz	r3, 14e2 <__sfvwrite_r+0x16>
    14da:	2000      	movs	r0, #0
    14dc:	b003      	add	sp, #12
    14de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    14e2:	898b      	ldrh	r3, [r1, #12]
    14e4:	0718      	lsls	r0, r3, #28
    14e6:	d550      	bpl.n	158a <__sfvwrite_r+0xbe>
    14e8:	690b      	ldr	r3, [r1, #16]
    14ea:	2b00      	cmp	r3, #0
    14ec:	d04d      	beq.n	158a <__sfvwrite_r+0xbe>
    14ee:	89a3      	ldrh	r3, [r4, #12]
    14f0:	f8d8 6000 	ldr.w	r6, [r8]
    14f4:	f013 0902 	ands.w	r9, r3, #2
    14f8:	d16c      	bne.n	15d4 <__sfvwrite_r+0x108>
    14fa:	f013 0301 	ands.w	r3, r3, #1
    14fe:	f000 809c 	beq.w	163a <__sfvwrite_r+0x16e>
    1502:	4648      	mov	r0, r9
    1504:	46ca      	mov	sl, r9
    1506:	46cb      	mov	fp, r9
    1508:	f1bb 0f00 	cmp.w	fp, #0
    150c:	f000 8106 	beq.w	171c <__sfvwrite_r+0x250>
    1510:	b950      	cbnz	r0, 1528 <__sfvwrite_r+0x5c>
    1512:	465a      	mov	r2, fp
    1514:	210a      	movs	r1, #10
    1516:	4650      	mov	r0, sl
    1518:	f7fe fdf2 	bl	100 <memchr>
    151c:	2800      	cmp	r0, #0
    151e:	f000 8102 	beq.w	1726 <__sfvwrite_r+0x25a>
    1522:	3001      	adds	r0, #1
    1524:	eba0 090a 	sub.w	r9, r0, sl
    1528:	6820      	ldr	r0, [r4, #0]
    152a:	6921      	ldr	r1, [r4, #16]
    152c:	6962      	ldr	r2, [r4, #20]
    152e:	45d9      	cmp	r9, fp
    1530:	464b      	mov	r3, r9
    1532:	bf28      	it	cs
    1534:	465b      	movcs	r3, fp
    1536:	4288      	cmp	r0, r1
    1538:	f240 80f8 	bls.w	172c <__sfvwrite_r+0x260>
    153c:	68a5      	ldr	r5, [r4, #8]
    153e:	4415      	add	r5, r2
    1540:	42ab      	cmp	r3, r5
    1542:	f340 80f3 	ble.w	172c <__sfvwrite_r+0x260>
    1546:	4651      	mov	r1, sl
    1548:	462a      	mov	r2, r5
    154a:	f000 fe34 	bl	21b6 <memmove>
    154e:	6823      	ldr	r3, [r4, #0]
    1550:	442b      	add	r3, r5
    1552:	6023      	str	r3, [r4, #0]
    1554:	4621      	mov	r1, r4
    1556:	4638      	mov	r0, r7
    1558:	f7ff fef0 	bl	133c <_fflush_r>
    155c:	2800      	cmp	r0, #0
    155e:	d167      	bne.n	1630 <__sfvwrite_r+0x164>
    1560:	ebb9 0905 	subs.w	r9, r9, r5
    1564:	f040 80fc 	bne.w	1760 <__sfvwrite_r+0x294>
    1568:	4621      	mov	r1, r4
    156a:	4638      	mov	r0, r7
    156c:	f7ff fee6 	bl	133c <_fflush_r>
    1570:	2800      	cmp	r0, #0
    1572:	d15d      	bne.n	1630 <__sfvwrite_r+0x164>
    1574:	f8d8 3008 	ldr.w	r3, [r8, #8]
    1578:	44aa      	add	sl, r5
    157a:	ebab 0b05 	sub.w	fp, fp, r5
    157e:	1b5d      	subs	r5, r3, r5
    1580:	f8c8 5008 	str.w	r5, [r8, #8]
    1584:	2d00      	cmp	r5, #0
    1586:	d1bf      	bne.n	1508 <__sfvwrite_r+0x3c>
    1588:	e7a7      	b.n	14da <__sfvwrite_r+0xe>
    158a:	4621      	mov	r1, r4
    158c:	4638      	mov	r0, r7
    158e:	f7ff fdcb 	bl	1128 <__swsetup_r>
    1592:	2800      	cmp	r0, #0
    1594:	d0ab      	beq.n	14ee <__sfvwrite_r+0x22>
    1596:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    159a:	e79f      	b.n	14dc <__sfvwrite_r+0x10>
    159c:	e9d6 a900 	ldrd	sl, r9, [r6]
    15a0:	3608      	adds	r6, #8
    15a2:	f1b9 0f00 	cmp.w	r9, #0
    15a6:	d0f9      	beq.n	159c <__sfvwrite_r+0xd0>
    15a8:	45d9      	cmp	r9, fp
    15aa:	464b      	mov	r3, r9
    15ac:	4652      	mov	r2, sl
    15ae:	bf28      	it	cs
    15b0:	465b      	movcs	r3, fp
    15b2:	69e1      	ldr	r1, [r4, #28]
    15b4:	6a65      	ldr	r5, [r4, #36]	; 0x24
    15b6:	4638      	mov	r0, r7
    15b8:	47a8      	blx	r5
    15ba:	2800      	cmp	r0, #0
    15bc:	dd38      	ble.n	1630 <__sfvwrite_r+0x164>
    15be:	f8d8 3008 	ldr.w	r3, [r8, #8]
    15c2:	4482      	add	sl, r0
    15c4:	eba9 0900 	sub.w	r9, r9, r0
    15c8:	1a18      	subs	r0, r3, r0
    15ca:	f8c8 0008 	str.w	r0, [r8, #8]
    15ce:	2800      	cmp	r0, #0
    15d0:	d1e7      	bne.n	15a2 <__sfvwrite_r+0xd6>
    15d2:	e782      	b.n	14da <__sfvwrite_r+0xe>
    15d4:	f04f 0a00 	mov.w	sl, #0
    15d8:	46d1      	mov	r9, sl
    15da:	f8df b18c 	ldr.w	fp, [pc, #396]	; 1768 <__sfvwrite_r+0x29c>
    15de:	e7e0      	b.n	15a2 <__sfvwrite_r+0xd6>
    15e0:	e9d6 9a00 	ldrd	r9, sl, [r6]
    15e4:	3608      	adds	r6, #8
    15e6:	f1ba 0f00 	cmp.w	sl, #0
    15ea:	d0f9      	beq.n	15e0 <__sfvwrite_r+0x114>
    15ec:	89a2      	ldrh	r2, [r4, #12]
    15ee:	68a3      	ldr	r3, [r4, #8]
    15f0:	6820      	ldr	r0, [r4, #0]
    15f2:	0591      	lsls	r1, r2, #22
    15f4:	d564      	bpl.n	16c0 <__sfvwrite_r+0x1f4>
    15f6:	4553      	cmp	r3, sl
    15f8:	d836      	bhi.n	1668 <__sfvwrite_r+0x19c>
    15fa:	f412 6f90 	tst.w	r2, #1152	; 0x480
    15fe:	d033      	beq.n	1668 <__sfvwrite_r+0x19c>
    1600:	6921      	ldr	r1, [r4, #16]
    1602:	6965      	ldr	r5, [r4, #20]
    1604:	eba0 0b01 	sub.w	fp, r0, r1
    1608:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    160c:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
    1610:	f10b 0301 	add.w	r3, fp, #1
    1614:	4453      	add	r3, sl
    1616:	106d      	asrs	r5, r5, #1
    1618:	429d      	cmp	r5, r3
    161a:	bf38      	it	cc
    161c:	461d      	movcc	r5, r3
    161e:	0553      	lsls	r3, r2, #21
    1620:	d53e      	bpl.n	16a0 <__sfvwrite_r+0x1d4>
    1622:	4629      	mov	r1, r5
    1624:	4638      	mov	r0, r7
    1626:	f7ff f8ed 	bl	804 <_malloc_r>
    162a:	b948      	cbnz	r0, 1640 <__sfvwrite_r+0x174>
    162c:	230c      	movs	r3, #12
    162e:	603b      	str	r3, [r7, #0]
    1630:	89a3      	ldrh	r3, [r4, #12]
    1632:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1636:	81a3      	strh	r3, [r4, #12]
    1638:	e7ad      	b.n	1596 <__sfvwrite_r+0xca>
    163a:	4699      	mov	r9, r3
    163c:	469a      	mov	sl, r3
    163e:	e7d2      	b.n	15e6 <__sfvwrite_r+0x11a>
    1640:	465a      	mov	r2, fp
    1642:	6921      	ldr	r1, [r4, #16]
    1644:	9001      	str	r0, [sp, #4]
    1646:	f000 fd95 	bl	2174 <memcpy>
    164a:	89a2      	ldrh	r2, [r4, #12]
    164c:	9b01      	ldr	r3, [sp, #4]
    164e:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    1652:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    1656:	81a2      	strh	r2, [r4, #12]
    1658:	6123      	str	r3, [r4, #16]
    165a:	6165      	str	r5, [r4, #20]
    165c:	445b      	add	r3, fp
    165e:	eba5 050b 	sub.w	r5, r5, fp
    1662:	6023      	str	r3, [r4, #0]
    1664:	60a5      	str	r5, [r4, #8]
    1666:	4653      	mov	r3, sl
    1668:	4553      	cmp	r3, sl
    166a:	bf28      	it	cs
    166c:	4653      	movcs	r3, sl
    166e:	461a      	mov	r2, r3
    1670:	4649      	mov	r1, r9
    1672:	6820      	ldr	r0, [r4, #0]
    1674:	9301      	str	r3, [sp, #4]
    1676:	f000 fd9e 	bl	21b6 <memmove>
    167a:	68a2      	ldr	r2, [r4, #8]
    167c:	9b01      	ldr	r3, [sp, #4]
    167e:	1ad2      	subs	r2, r2, r3
    1680:	60a2      	str	r2, [r4, #8]
    1682:	6822      	ldr	r2, [r4, #0]
    1684:	4413      	add	r3, r2
    1686:	4655      	mov	r5, sl
    1688:	6023      	str	r3, [r4, #0]
    168a:	f8d8 3008 	ldr.w	r3, [r8, #8]
    168e:	44a9      	add	r9, r5
    1690:	ebaa 0a05 	sub.w	sl, sl, r5
    1694:	1b5d      	subs	r5, r3, r5
    1696:	f8c8 5008 	str.w	r5, [r8, #8]
    169a:	2d00      	cmp	r5, #0
    169c:	d1a3      	bne.n	15e6 <__sfvwrite_r+0x11a>
    169e:	e71c      	b.n	14da <__sfvwrite_r+0xe>
    16a0:	462a      	mov	r2, r5
    16a2:	4638      	mov	r0, r7
    16a4:	f000 fe32 	bl	230c <_realloc_r>
    16a8:	4603      	mov	r3, r0
    16aa:	2800      	cmp	r0, #0
    16ac:	d1d4      	bne.n	1658 <__sfvwrite_r+0x18c>
    16ae:	6921      	ldr	r1, [r4, #16]
    16b0:	4638      	mov	r0, r7
    16b2:	f000 f8c7 	bl	1844 <_free_r>
    16b6:	89a3      	ldrh	r3, [r4, #12]
    16b8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    16bc:	81a3      	strh	r3, [r4, #12]
    16be:	e7b5      	b.n	162c <__sfvwrite_r+0x160>
    16c0:	6922      	ldr	r2, [r4, #16]
    16c2:	4282      	cmp	r2, r0
    16c4:	d302      	bcc.n	16cc <__sfvwrite_r+0x200>
    16c6:	6962      	ldr	r2, [r4, #20]
    16c8:	4552      	cmp	r2, sl
    16ca:	d916      	bls.n	16fa <__sfvwrite_r+0x22e>
    16cc:	4553      	cmp	r3, sl
    16ce:	bf28      	it	cs
    16d0:	4653      	movcs	r3, sl
    16d2:	461a      	mov	r2, r3
    16d4:	4649      	mov	r1, r9
    16d6:	461d      	mov	r5, r3
    16d8:	f000 fd6d 	bl	21b6 <memmove>
    16dc:	68a3      	ldr	r3, [r4, #8]
    16de:	6822      	ldr	r2, [r4, #0]
    16e0:	1b5b      	subs	r3, r3, r5
    16e2:	442a      	add	r2, r5
    16e4:	60a3      	str	r3, [r4, #8]
    16e6:	6022      	str	r2, [r4, #0]
    16e8:	2b00      	cmp	r3, #0
    16ea:	d1ce      	bne.n	168a <__sfvwrite_r+0x1be>
    16ec:	4621      	mov	r1, r4
    16ee:	4638      	mov	r0, r7
    16f0:	f7ff fe24 	bl	133c <_fflush_r>
    16f4:	2800      	cmp	r0, #0
    16f6:	d0c8      	beq.n	168a <__sfvwrite_r+0x1be>
    16f8:	e79a      	b.n	1630 <__sfvwrite_r+0x164>
    16fa:	4b1a      	ldr	r3, [pc, #104]	; (1764 <__sfvwrite_r+0x298>)
    16fc:	6a65      	ldr	r5, [r4, #36]	; 0x24
    16fe:	69e1      	ldr	r1, [r4, #28]
    1700:	459a      	cmp	sl, r3
    1702:	bf94      	ite	ls
    1704:	4653      	movls	r3, sl
    1706:	f06f 4300 	mvnhi.w	r3, #2147483648	; 0x80000000
    170a:	4638      	mov	r0, r7
    170c:	fb93 f3f2 	sdiv	r3, r3, r2
    1710:	4353      	muls	r3, r2
    1712:	464a      	mov	r2, r9
    1714:	47a8      	blx	r5
    1716:	1e05      	subs	r5, r0, #0
    1718:	dcb7      	bgt.n	168a <__sfvwrite_r+0x1be>
    171a:	e789      	b.n	1630 <__sfvwrite_r+0x164>
    171c:	e9d6 ab00 	ldrd	sl, fp, [r6]
    1720:	2000      	movs	r0, #0
    1722:	3608      	adds	r6, #8
    1724:	e6f0      	b.n	1508 <__sfvwrite_r+0x3c>
    1726:	f10b 0901 	add.w	r9, fp, #1
    172a:	e6fd      	b.n	1528 <__sfvwrite_r+0x5c>
    172c:	429a      	cmp	r2, r3
    172e:	dc09      	bgt.n	1744 <__sfvwrite_r+0x278>
    1730:	6a65      	ldr	r5, [r4, #36]	; 0x24
    1732:	69e1      	ldr	r1, [r4, #28]
    1734:	4613      	mov	r3, r2
    1736:	4638      	mov	r0, r7
    1738:	4652      	mov	r2, sl
    173a:	47a8      	blx	r5
    173c:	1e05      	subs	r5, r0, #0
    173e:	f73f af0f 	bgt.w	1560 <__sfvwrite_r+0x94>
    1742:	e775      	b.n	1630 <__sfvwrite_r+0x164>
    1744:	461a      	mov	r2, r3
    1746:	4651      	mov	r1, sl
    1748:	9301      	str	r3, [sp, #4]
    174a:	f000 fd34 	bl	21b6 <memmove>
    174e:	9b01      	ldr	r3, [sp, #4]
    1750:	68a2      	ldr	r2, [r4, #8]
    1752:	1ad2      	subs	r2, r2, r3
    1754:	60a2      	str	r2, [r4, #8]
    1756:	6822      	ldr	r2, [r4, #0]
    1758:	441a      	add	r2, r3
    175a:	6022      	str	r2, [r4, #0]
    175c:	461d      	mov	r5, r3
    175e:	e6ff      	b.n	1560 <__sfvwrite_r+0x94>
    1760:	2001      	movs	r0, #1
    1762:	e707      	b.n	1574 <__sfvwrite_r+0xa8>
    1764:	7ffffffe 	.word	0x7ffffffe
    1768:	7ffffc00 	.word	0x7ffffc00

0000176c <__swhatbuf_r>:
    176c:	b570      	push	{r4, r5, r6, lr}
    176e:	460e      	mov	r6, r1
    1770:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    1774:	2900      	cmp	r1, #0
    1776:	b096      	sub	sp, #88	; 0x58
    1778:	4614      	mov	r4, r2
    177a:	461d      	mov	r5, r3
    177c:	da09      	bge.n	1792 <__swhatbuf_r+0x26>
    177e:	89b3      	ldrh	r3, [r6, #12]
    1780:	2200      	movs	r2, #0
    1782:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    1786:	602a      	str	r2, [r5, #0]
    1788:	d116      	bne.n	17b8 <__swhatbuf_r+0x4c>
    178a:	f44f 6380 	mov.w	r3, #1024	; 0x400
    178e:	6023      	str	r3, [r4, #0]
    1790:	e015      	b.n	17be <__swhatbuf_r+0x52>
    1792:	466a      	mov	r2, sp
    1794:	f000 fb40 	bl	1e18 <_fstat_r>
    1798:	2800      	cmp	r0, #0
    179a:	dbf0      	blt.n	177e <__swhatbuf_r+0x12>
    179c:	9a01      	ldr	r2, [sp, #4]
    179e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    17a2:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
    17a6:	425a      	negs	r2, r3
    17a8:	415a      	adcs	r2, r3
    17aa:	f44f 6380 	mov.w	r3, #1024	; 0x400
    17ae:	602a      	str	r2, [r5, #0]
    17b0:	f44f 6000 	mov.w	r0, #2048	; 0x800
    17b4:	6023      	str	r3, [r4, #0]
    17b6:	e002      	b.n	17be <__swhatbuf_r+0x52>
    17b8:	2340      	movs	r3, #64	; 0x40
    17ba:	6023      	str	r3, [r4, #0]
    17bc:	4610      	mov	r0, r2
    17be:	b016      	add	sp, #88	; 0x58
    17c0:	bd70      	pop	{r4, r5, r6, pc}

000017c2 <__smakebuf_r>:
    17c2:	898b      	ldrh	r3, [r1, #12]
    17c4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    17c6:	079d      	lsls	r5, r3, #30
    17c8:	4606      	mov	r6, r0
    17ca:	460c      	mov	r4, r1
    17cc:	d507      	bpl.n	17de <__smakebuf_r+0x1c>
    17ce:	f104 0343 	add.w	r3, r4, #67	; 0x43
    17d2:	6023      	str	r3, [r4, #0]
    17d4:	6123      	str	r3, [r4, #16]
    17d6:	2301      	movs	r3, #1
    17d8:	6163      	str	r3, [r4, #20]
    17da:	b002      	add	sp, #8
    17dc:	bd70      	pop	{r4, r5, r6, pc}
    17de:	ab01      	add	r3, sp, #4
    17e0:	466a      	mov	r2, sp
    17e2:	f7ff ffc3 	bl	176c <__swhatbuf_r>
    17e6:	9900      	ldr	r1, [sp, #0]
    17e8:	4605      	mov	r5, r0
    17ea:	4630      	mov	r0, r6
    17ec:	f7ff f80a 	bl	804 <_malloc_r>
    17f0:	b948      	cbnz	r0, 1806 <__smakebuf_r+0x44>
    17f2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    17f6:	059a      	lsls	r2, r3, #22
    17f8:	d4ef      	bmi.n	17da <__smakebuf_r+0x18>
    17fa:	f023 0303 	bic.w	r3, r3, #3
    17fe:	f043 0302 	orr.w	r3, r3, #2
    1802:	81a3      	strh	r3, [r4, #12]
    1804:	e7e3      	b.n	17ce <__smakebuf_r+0xc>
    1806:	4b0e      	ldr	r3, [pc, #56]	; (1840 <__smakebuf_r+0x7e>)
    1808:	63f3      	str	r3, [r6, #60]	; 0x3c
    180a:	89a3      	ldrh	r3, [r4, #12]
    180c:	6020      	str	r0, [r4, #0]
    180e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1812:	81a3      	strh	r3, [r4, #12]
    1814:	9b00      	ldr	r3, [sp, #0]
    1816:	6163      	str	r3, [r4, #20]
    1818:	9b01      	ldr	r3, [sp, #4]
    181a:	6120      	str	r0, [r4, #16]
    181c:	b15b      	cbz	r3, 1836 <__smakebuf_r+0x74>
    181e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    1822:	4630      	mov	r0, r6
    1824:	f000 fb0a 	bl	1e3c <_isatty_r>
    1828:	b128      	cbz	r0, 1836 <__smakebuf_r+0x74>
    182a:	89a3      	ldrh	r3, [r4, #12]
    182c:	f023 0303 	bic.w	r3, r3, #3
    1830:	f043 0301 	orr.w	r3, r3, #1
    1834:	81a3      	strh	r3, [r4, #12]
    1836:	89a3      	ldrh	r3, [r4, #12]
    1838:	431d      	orrs	r5, r3
    183a:	81a5      	strh	r5, [r4, #12]
    183c:	e7cd      	b.n	17da <__smakebuf_r+0x18>
    183e:	bf00      	nop
    1840:	000013cd 	.word	0x000013cd

00001844 <_free_r>:
    1844:	b538      	push	{r3, r4, r5, lr}
    1846:	4605      	mov	r5, r0
    1848:	2900      	cmp	r1, #0
    184a:	d045      	beq.n	18d8 <_free_r+0x94>
    184c:	f851 3c04 	ldr.w	r3, [r1, #-4]
    1850:	1f0c      	subs	r4, r1, #4
    1852:	2b00      	cmp	r3, #0
    1854:	bfb8      	it	lt
    1856:	18e4      	addlt	r4, r4, r3
    1858:	f000 fd56 	bl	2308 <__malloc_lock>
    185c:	4a1f      	ldr	r2, [pc, #124]	; (18dc <_free_r+0x98>)
    185e:	6813      	ldr	r3, [r2, #0]
    1860:	4610      	mov	r0, r2
    1862:	b933      	cbnz	r3, 1872 <_free_r+0x2e>
    1864:	6063      	str	r3, [r4, #4]
    1866:	6014      	str	r4, [r2, #0]
    1868:	4628      	mov	r0, r5
    186a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    186e:	f000 bd4c 	b.w	230a <__malloc_unlock>
    1872:	42a3      	cmp	r3, r4
    1874:	d90c      	bls.n	1890 <_free_r+0x4c>
    1876:	6821      	ldr	r1, [r4, #0]
    1878:	1862      	adds	r2, r4, r1
    187a:	4293      	cmp	r3, r2
    187c:	bf04      	itt	eq
    187e:	681a      	ldreq	r2, [r3, #0]
    1880:	685b      	ldreq	r3, [r3, #4]
    1882:	6063      	str	r3, [r4, #4]
    1884:	bf04      	itt	eq
    1886:	1852      	addeq	r2, r2, r1
    1888:	6022      	streq	r2, [r4, #0]
    188a:	6004      	str	r4, [r0, #0]
    188c:	e7ec      	b.n	1868 <_free_r+0x24>
    188e:	4613      	mov	r3, r2
    1890:	685a      	ldr	r2, [r3, #4]
    1892:	b10a      	cbz	r2, 1898 <_free_r+0x54>
    1894:	42a2      	cmp	r2, r4
    1896:	d9fa      	bls.n	188e <_free_r+0x4a>
    1898:	6819      	ldr	r1, [r3, #0]
    189a:	1858      	adds	r0, r3, r1
    189c:	42a0      	cmp	r0, r4
    189e:	d10b      	bne.n	18b8 <_free_r+0x74>
    18a0:	6820      	ldr	r0, [r4, #0]
    18a2:	4401      	add	r1, r0
    18a4:	1858      	adds	r0, r3, r1
    18a6:	4282      	cmp	r2, r0
    18a8:	6019      	str	r1, [r3, #0]
    18aa:	d1dd      	bne.n	1868 <_free_r+0x24>
    18ac:	6810      	ldr	r0, [r2, #0]
    18ae:	6852      	ldr	r2, [r2, #4]
    18b0:	605a      	str	r2, [r3, #4]
    18b2:	4401      	add	r1, r0
    18b4:	6019      	str	r1, [r3, #0]
    18b6:	e7d7      	b.n	1868 <_free_r+0x24>
    18b8:	d902      	bls.n	18c0 <_free_r+0x7c>
    18ba:	230c      	movs	r3, #12
    18bc:	602b      	str	r3, [r5, #0]
    18be:	e7d3      	b.n	1868 <_free_r+0x24>
    18c0:	6820      	ldr	r0, [r4, #0]
    18c2:	1821      	adds	r1, r4, r0
    18c4:	428a      	cmp	r2, r1
    18c6:	bf04      	itt	eq
    18c8:	6811      	ldreq	r1, [r2, #0]
    18ca:	6852      	ldreq	r2, [r2, #4]
    18cc:	6062      	str	r2, [r4, #4]
    18ce:	bf04      	itt	eq
    18d0:	1809      	addeq	r1, r1, r0
    18d2:	6021      	streq	r1, [r4, #0]
    18d4:	605c      	str	r4, [r3, #4]
    18d6:	e7c7      	b.n	1868 <_free_r+0x24>
    18d8:	bd38      	pop	{r3, r4, r5, pc}
    18da:	bf00      	nop
    18dc:	20002000 	.word	0x20002000

000018e0 <__ssputs_r>:
    18e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    18e4:	688e      	ldr	r6, [r1, #8]
    18e6:	429e      	cmp	r6, r3
    18e8:	4682      	mov	sl, r0
    18ea:	460c      	mov	r4, r1
    18ec:	4691      	mov	r9, r2
    18ee:	4698      	mov	r8, r3
    18f0:	d838      	bhi.n	1964 <__ssputs_r+0x84>
    18f2:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
    18f6:	f41c 6f90 	tst.w	ip, #1152	; 0x480
    18fa:	d031      	beq.n	1960 <__ssputs_r+0x80>
    18fc:	6962      	ldr	r2, [r4, #20]
    18fe:	6825      	ldr	r5, [r4, #0]
    1900:	6909      	ldr	r1, [r1, #16]
    1902:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    1906:	1a6f      	subs	r7, r5, r1
    1908:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
    190c:	3301      	adds	r3, #1
    190e:	1055      	asrs	r5, r2, #1
    1910:	443b      	add	r3, r7
    1912:	429d      	cmp	r5, r3
    1914:	bf38      	it	cc
    1916:	461d      	movcc	r5, r3
    1918:	f41c 6f80 	tst.w	ip, #1024	; 0x400
    191c:	d030      	beq.n	1980 <__ssputs_r+0xa0>
    191e:	4629      	mov	r1, r5
    1920:	f7fe ff70 	bl	804 <_malloc_r>
    1924:	4606      	mov	r6, r0
    1926:	b950      	cbnz	r0, 193e <__ssputs_r+0x5e>
    1928:	230c      	movs	r3, #12
    192a:	f8ca 3000 	str.w	r3, [sl]
    192e:	89a3      	ldrh	r3, [r4, #12]
    1930:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1934:	81a3      	strh	r3, [r4, #12]
    1936:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    193a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    193e:	463a      	mov	r2, r7
    1940:	6921      	ldr	r1, [r4, #16]
    1942:	f000 fc17 	bl	2174 <memcpy>
    1946:	89a3      	ldrh	r3, [r4, #12]
    1948:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
    194c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1950:	81a3      	strh	r3, [r4, #12]
    1952:	6126      	str	r6, [r4, #16]
    1954:	6165      	str	r5, [r4, #20]
    1956:	443e      	add	r6, r7
    1958:	1bed      	subs	r5, r5, r7
    195a:	6026      	str	r6, [r4, #0]
    195c:	60a5      	str	r5, [r4, #8]
    195e:	4646      	mov	r6, r8
    1960:	4546      	cmp	r6, r8
    1962:	d900      	bls.n	1966 <__ssputs_r+0x86>
    1964:	4646      	mov	r6, r8
    1966:	4632      	mov	r2, r6
    1968:	4649      	mov	r1, r9
    196a:	6820      	ldr	r0, [r4, #0]
    196c:	f000 fc23 	bl	21b6 <memmove>
    1970:	68a3      	ldr	r3, [r4, #8]
    1972:	1b9b      	subs	r3, r3, r6
    1974:	60a3      	str	r3, [r4, #8]
    1976:	6823      	ldr	r3, [r4, #0]
    1978:	441e      	add	r6, r3
    197a:	6026      	str	r6, [r4, #0]
    197c:	2000      	movs	r0, #0
    197e:	e7dc      	b.n	193a <__ssputs_r+0x5a>
    1980:	462a      	mov	r2, r5
    1982:	f000 fcc3 	bl	230c <_realloc_r>
    1986:	4606      	mov	r6, r0
    1988:	2800      	cmp	r0, #0
    198a:	d1e2      	bne.n	1952 <__ssputs_r+0x72>
    198c:	6921      	ldr	r1, [r4, #16]
    198e:	4650      	mov	r0, sl
    1990:	f7ff ff58 	bl	1844 <_free_r>
    1994:	e7c8      	b.n	1928 <__ssputs_r+0x48>

00001996 <__ssprint_r>:
    1996:	6893      	ldr	r3, [r2, #8]
    1998:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    199c:	4681      	mov	r9, r0
    199e:	460c      	mov	r4, r1
    19a0:	4616      	mov	r6, r2
    19a2:	2b00      	cmp	r3, #0
    19a4:	d05e      	beq.n	1a64 <__ssprint_r+0xce>
    19a6:	f04f 0b00 	mov.w	fp, #0
    19aa:	f8d2 a000 	ldr.w	sl, [r2]
    19ae:	465f      	mov	r7, fp
    19b0:	b357      	cbz	r7, 1a08 <__ssprint_r+0x72>
    19b2:	68a3      	ldr	r3, [r4, #8]
    19b4:	429f      	cmp	r7, r3
    19b6:	d340      	bcc.n	1a3a <__ssprint_r+0xa4>
    19b8:	89a2      	ldrh	r2, [r4, #12]
    19ba:	f412 6f90 	tst.w	r2, #1152	; 0x480
    19be:	d03c      	beq.n	1a3a <__ssprint_r+0xa4>
    19c0:	6825      	ldr	r5, [r4, #0]
    19c2:	6921      	ldr	r1, [r4, #16]
    19c4:	eba5 0801 	sub.w	r8, r5, r1
    19c8:	6965      	ldr	r5, [r4, #20]
    19ca:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    19ce:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
    19d2:	f108 0301 	add.w	r3, r8, #1
    19d6:	443b      	add	r3, r7
    19d8:	106d      	asrs	r5, r5, #1
    19da:	429d      	cmp	r5, r3
    19dc:	bf38      	it	cc
    19de:	461d      	movcc	r5, r3
    19e0:	0553      	lsls	r3, r2, #21
    19e2:	d544      	bpl.n	1a6e <__ssprint_r+0xd8>
    19e4:	4629      	mov	r1, r5
    19e6:	4648      	mov	r0, r9
    19e8:	f7fe ff0c 	bl	804 <_malloc_r>
    19ec:	b988      	cbnz	r0, 1a12 <__ssprint_r+0x7c>
    19ee:	230c      	movs	r3, #12
    19f0:	f8c9 3000 	str.w	r3, [r9]
    19f4:	89a3      	ldrh	r3, [r4, #12]
    19f6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    19fa:	81a3      	strh	r3, [r4, #12]
    19fc:	2300      	movs	r3, #0
    19fe:	e9c6 3301 	strd	r3, r3, [r6, #4]
    1a02:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1a06:	e02f      	b.n	1a68 <__ssprint_r+0xd2>
    1a08:	e9da b700 	ldrd	fp, r7, [sl]
    1a0c:	f10a 0a08 	add.w	sl, sl, #8
    1a10:	e7ce      	b.n	19b0 <__ssprint_r+0x1a>
    1a12:	4642      	mov	r2, r8
    1a14:	6921      	ldr	r1, [r4, #16]
    1a16:	9001      	str	r0, [sp, #4]
    1a18:	f000 fbac 	bl	2174 <memcpy>
    1a1c:	89a2      	ldrh	r2, [r4, #12]
    1a1e:	9b01      	ldr	r3, [sp, #4]
    1a20:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    1a24:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    1a28:	81a2      	strh	r2, [r4, #12]
    1a2a:	6123      	str	r3, [r4, #16]
    1a2c:	6165      	str	r5, [r4, #20]
    1a2e:	4443      	add	r3, r8
    1a30:	eba5 0508 	sub.w	r5, r5, r8
    1a34:	6023      	str	r3, [r4, #0]
    1a36:	60a5      	str	r5, [r4, #8]
    1a38:	463b      	mov	r3, r7
    1a3a:	42bb      	cmp	r3, r7
    1a3c:	bf28      	it	cs
    1a3e:	463b      	movcs	r3, r7
    1a40:	461a      	mov	r2, r3
    1a42:	4659      	mov	r1, fp
    1a44:	6820      	ldr	r0, [r4, #0]
    1a46:	9301      	str	r3, [sp, #4]
    1a48:	f000 fbb5 	bl	21b6 <memmove>
    1a4c:	68a2      	ldr	r2, [r4, #8]
    1a4e:	9b01      	ldr	r3, [sp, #4]
    1a50:	1ad2      	subs	r2, r2, r3
    1a52:	60a2      	str	r2, [r4, #8]
    1a54:	6822      	ldr	r2, [r4, #0]
    1a56:	4413      	add	r3, r2
    1a58:	6023      	str	r3, [r4, #0]
    1a5a:	68b3      	ldr	r3, [r6, #8]
    1a5c:	1bdf      	subs	r7, r3, r7
    1a5e:	60b7      	str	r7, [r6, #8]
    1a60:	2f00      	cmp	r7, #0
    1a62:	d1d1      	bne.n	1a08 <__ssprint_r+0x72>
    1a64:	2000      	movs	r0, #0
    1a66:	6070      	str	r0, [r6, #4]
    1a68:	b003      	add	sp, #12
    1a6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1a6e:	462a      	mov	r2, r5
    1a70:	4648      	mov	r0, r9
    1a72:	f000 fc4b 	bl	230c <_realloc_r>
    1a76:	4603      	mov	r3, r0
    1a78:	2800      	cmp	r0, #0
    1a7a:	d1d6      	bne.n	1a2a <__ssprint_r+0x94>
    1a7c:	6921      	ldr	r1, [r4, #16]
    1a7e:	4648      	mov	r0, r9
    1a80:	f7ff fee0 	bl	1844 <_free_r>
    1a84:	e7b3      	b.n	19ee <__ssprint_r+0x58>

00001a86 <_svfiprintf_r>:
    1a86:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1a8a:	461e      	mov	r6, r3
    1a8c:	898b      	ldrh	r3, [r1, #12]
    1a8e:	061b      	lsls	r3, r3, #24
    1a90:	b09d      	sub	sp, #116	; 0x74
    1a92:	4607      	mov	r7, r0
    1a94:	460d      	mov	r5, r1
    1a96:	4614      	mov	r4, r2
    1a98:	d50e      	bpl.n	1ab8 <_svfiprintf_r+0x32>
    1a9a:	690b      	ldr	r3, [r1, #16]
    1a9c:	b963      	cbnz	r3, 1ab8 <_svfiprintf_r+0x32>
    1a9e:	2140      	movs	r1, #64	; 0x40
    1aa0:	f7fe feb0 	bl	804 <_malloc_r>
    1aa4:	6028      	str	r0, [r5, #0]
    1aa6:	6128      	str	r0, [r5, #16]
    1aa8:	b920      	cbnz	r0, 1ab4 <_svfiprintf_r+0x2e>
    1aaa:	230c      	movs	r3, #12
    1aac:	603b      	str	r3, [r7, #0]
    1aae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1ab2:	e0c9      	b.n	1c48 <_svfiprintf_r+0x1c2>
    1ab4:	2340      	movs	r3, #64	; 0x40
    1ab6:	616b      	str	r3, [r5, #20]
    1ab8:	2300      	movs	r3, #0
    1aba:	9309      	str	r3, [sp, #36]	; 0x24
    1abc:	2320      	movs	r3, #32
    1abe:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    1ac2:	f8df 919c 	ldr.w	r9, [pc, #412]	; 1c60 <_svfiprintf_r+0x1da>
    1ac6:	9603      	str	r6, [sp, #12]
    1ac8:	2330      	movs	r3, #48	; 0x30
    1aca:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    1ace:	f04f 0a01 	mov.w	sl, #1
    1ad2:	4623      	mov	r3, r4
    1ad4:	461e      	mov	r6, r3
    1ad6:	f813 2b01 	ldrb.w	r2, [r3], #1
    1ada:	b10a      	cbz	r2, 1ae0 <_svfiprintf_r+0x5a>
    1adc:	2a25      	cmp	r2, #37	; 0x25
    1ade:	d1f9      	bne.n	1ad4 <_svfiprintf_r+0x4e>
    1ae0:	ebb6 0b04 	subs.w	fp, r6, r4
    1ae4:	d00b      	beq.n	1afe <_svfiprintf_r+0x78>
    1ae6:	465b      	mov	r3, fp
    1ae8:	4622      	mov	r2, r4
    1aea:	4629      	mov	r1, r5
    1aec:	4638      	mov	r0, r7
    1aee:	f7ff fef7 	bl	18e0 <__ssputs_r>
    1af2:	3001      	adds	r0, #1
    1af4:	f000 80a3 	beq.w	1c3e <_svfiprintf_r+0x1b8>
    1af8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1afa:	445b      	add	r3, fp
    1afc:	9309      	str	r3, [sp, #36]	; 0x24
    1afe:	7833      	ldrb	r3, [r6, #0]
    1b00:	2b00      	cmp	r3, #0
    1b02:	f000 809c 	beq.w	1c3e <_svfiprintf_r+0x1b8>
    1b06:	2300      	movs	r3, #0
    1b08:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    1b0c:	e9cd 2305 	strd	r2, r3, [sp, #20]
    1b10:	3601      	adds	r6, #1
    1b12:	9304      	str	r3, [sp, #16]
    1b14:	9307      	str	r3, [sp, #28]
    1b16:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    1b1a:	931a      	str	r3, [sp, #104]	; 0x68
    1b1c:	4634      	mov	r4, r6
    1b1e:	2205      	movs	r2, #5
    1b20:	f814 1b01 	ldrb.w	r1, [r4], #1
    1b24:	484e      	ldr	r0, [pc, #312]	; (1c60 <_svfiprintf_r+0x1da>)
    1b26:	f7fe faeb 	bl	100 <memchr>
    1b2a:	9b04      	ldr	r3, [sp, #16]
    1b2c:	b9c0      	cbnz	r0, 1b60 <_svfiprintf_r+0xda>
    1b2e:	06d9      	lsls	r1, r3, #27
    1b30:	bf44      	itt	mi
    1b32:	2220      	movmi	r2, #32
    1b34:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    1b38:	071a      	lsls	r2, r3, #28
    1b3a:	bf44      	itt	mi
    1b3c:	222b      	movmi	r2, #43	; 0x2b
    1b3e:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    1b42:	7832      	ldrb	r2, [r6, #0]
    1b44:	2a2a      	cmp	r2, #42	; 0x2a
    1b46:	d013      	beq.n	1b70 <_svfiprintf_r+0xea>
    1b48:	9a07      	ldr	r2, [sp, #28]
    1b4a:	4634      	mov	r4, r6
    1b4c:	2000      	movs	r0, #0
    1b4e:	260a      	movs	r6, #10
    1b50:	4621      	mov	r1, r4
    1b52:	f811 3b01 	ldrb.w	r3, [r1], #1
    1b56:	3b30      	subs	r3, #48	; 0x30
    1b58:	2b09      	cmp	r3, #9
    1b5a:	d94b      	bls.n	1bf4 <_svfiprintf_r+0x16e>
    1b5c:	b970      	cbnz	r0, 1b7c <_svfiprintf_r+0xf6>
    1b5e:	e014      	b.n	1b8a <_svfiprintf_r+0x104>
    1b60:	eba0 0009 	sub.w	r0, r0, r9
    1b64:	fa0a f000 	lsl.w	r0, sl, r0
    1b68:	4318      	orrs	r0, r3
    1b6a:	9004      	str	r0, [sp, #16]
    1b6c:	4626      	mov	r6, r4
    1b6e:	e7d5      	b.n	1b1c <_svfiprintf_r+0x96>
    1b70:	9a03      	ldr	r2, [sp, #12]
    1b72:	1d11      	adds	r1, r2, #4
    1b74:	6812      	ldr	r2, [r2, #0]
    1b76:	9103      	str	r1, [sp, #12]
    1b78:	2a00      	cmp	r2, #0
    1b7a:	db01      	blt.n	1b80 <_svfiprintf_r+0xfa>
    1b7c:	9207      	str	r2, [sp, #28]
    1b7e:	e004      	b.n	1b8a <_svfiprintf_r+0x104>
    1b80:	4252      	negs	r2, r2
    1b82:	f043 0302 	orr.w	r3, r3, #2
    1b86:	9207      	str	r2, [sp, #28]
    1b88:	9304      	str	r3, [sp, #16]
    1b8a:	7823      	ldrb	r3, [r4, #0]
    1b8c:	2b2e      	cmp	r3, #46	; 0x2e
    1b8e:	d10c      	bne.n	1baa <_svfiprintf_r+0x124>
    1b90:	7863      	ldrb	r3, [r4, #1]
    1b92:	2b2a      	cmp	r3, #42	; 0x2a
    1b94:	d133      	bne.n	1bfe <_svfiprintf_r+0x178>
    1b96:	9b03      	ldr	r3, [sp, #12]
    1b98:	1d1a      	adds	r2, r3, #4
    1b9a:	681b      	ldr	r3, [r3, #0]
    1b9c:	9203      	str	r2, [sp, #12]
    1b9e:	2b00      	cmp	r3, #0
    1ba0:	bfb8      	it	lt
    1ba2:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
    1ba6:	3402      	adds	r4, #2
    1ba8:	9305      	str	r3, [sp, #20]
    1baa:	4e2e      	ldr	r6, [pc, #184]	; (1c64 <_svfiprintf_r+0x1de>)
    1bac:	7821      	ldrb	r1, [r4, #0]
    1bae:	2203      	movs	r2, #3
    1bb0:	4630      	mov	r0, r6
    1bb2:	f7fe faa5 	bl	100 <memchr>
    1bb6:	b138      	cbz	r0, 1bc8 <_svfiprintf_r+0x142>
    1bb8:	2340      	movs	r3, #64	; 0x40
    1bba:	1b80      	subs	r0, r0, r6
    1bbc:	fa03 f000 	lsl.w	r0, r3, r0
    1bc0:	9b04      	ldr	r3, [sp, #16]
    1bc2:	4303      	orrs	r3, r0
    1bc4:	3401      	adds	r4, #1
    1bc6:	9304      	str	r3, [sp, #16]
    1bc8:	f814 1b01 	ldrb.w	r1, [r4], #1
    1bcc:	4826      	ldr	r0, [pc, #152]	; (1c68 <_svfiprintf_r+0x1e2>)
    1bce:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    1bd2:	2206      	movs	r2, #6
    1bd4:	f7fe fa94 	bl	100 <memchr>
    1bd8:	2800      	cmp	r0, #0
    1bda:	d038      	beq.n	1c4e <_svfiprintf_r+0x1c8>
    1bdc:	4b23      	ldr	r3, [pc, #140]	; (1c6c <_svfiprintf_r+0x1e6>)
    1bde:	bb13      	cbnz	r3, 1c26 <_svfiprintf_r+0x1a0>
    1be0:	9b03      	ldr	r3, [sp, #12]
    1be2:	3307      	adds	r3, #7
    1be4:	f023 0307 	bic.w	r3, r3, #7
    1be8:	3308      	adds	r3, #8
    1bea:	9303      	str	r3, [sp, #12]
    1bec:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1bee:	4443      	add	r3, r8
    1bf0:	9309      	str	r3, [sp, #36]	; 0x24
    1bf2:	e76e      	b.n	1ad2 <_svfiprintf_r+0x4c>
    1bf4:	fb06 3202 	mla	r2, r6, r2, r3
    1bf8:	2001      	movs	r0, #1
    1bfa:	460c      	mov	r4, r1
    1bfc:	e7a8      	b.n	1b50 <_svfiprintf_r+0xca>
    1bfe:	2300      	movs	r3, #0
    1c00:	3401      	adds	r4, #1
    1c02:	9305      	str	r3, [sp, #20]
    1c04:	4619      	mov	r1, r3
    1c06:	260a      	movs	r6, #10
    1c08:	4620      	mov	r0, r4
    1c0a:	f810 2b01 	ldrb.w	r2, [r0], #1
    1c0e:	3a30      	subs	r2, #48	; 0x30
    1c10:	2a09      	cmp	r2, #9
    1c12:	d903      	bls.n	1c1c <_svfiprintf_r+0x196>
    1c14:	2b00      	cmp	r3, #0
    1c16:	d0c8      	beq.n	1baa <_svfiprintf_r+0x124>
    1c18:	9105      	str	r1, [sp, #20]
    1c1a:	e7c6      	b.n	1baa <_svfiprintf_r+0x124>
    1c1c:	fb06 2101 	mla	r1, r6, r1, r2
    1c20:	2301      	movs	r3, #1
    1c22:	4604      	mov	r4, r0
    1c24:	e7f0      	b.n	1c08 <_svfiprintf_r+0x182>
    1c26:	ab03      	add	r3, sp, #12
    1c28:	9300      	str	r3, [sp, #0]
    1c2a:	462a      	mov	r2, r5
    1c2c:	4b10      	ldr	r3, [pc, #64]	; (1c70 <_svfiprintf_r+0x1ea>)
    1c2e:	a904      	add	r1, sp, #16
    1c30:	4638      	mov	r0, r7
    1c32:	f3af 8000 	nop.w
    1c36:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    1c3a:	4680      	mov	r8, r0
    1c3c:	d1d6      	bne.n	1bec <_svfiprintf_r+0x166>
    1c3e:	89ab      	ldrh	r3, [r5, #12]
    1c40:	065b      	lsls	r3, r3, #25
    1c42:	f53f af34 	bmi.w	1aae <_svfiprintf_r+0x28>
    1c46:	9809      	ldr	r0, [sp, #36]	; 0x24
    1c48:	b01d      	add	sp, #116	; 0x74
    1c4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1c4e:	ab03      	add	r3, sp, #12
    1c50:	9300      	str	r3, [sp, #0]
    1c52:	462a      	mov	r2, r5
    1c54:	4b06      	ldr	r3, [pc, #24]	; (1c70 <_svfiprintf_r+0x1ea>)
    1c56:	a904      	add	r1, sp, #16
    1c58:	4638      	mov	r0, r7
    1c5a:	f7fe ffd4 	bl	c06 <_printf_i>
    1c5e:	e7ea      	b.n	1c36 <_svfiprintf_r+0x1b0>
    1c60:	00019206 	.word	0x00019206
    1c64:	0001920c 	.word	0x0001920c
    1c68:	00019210 	.word	0x00019210
    1c6c:	00000000 	.word	0x00000000
    1c70:	000018e1 	.word	0x000018e1

00001c74 <_init_signal_r>:
    1c74:	b538      	push	{r3, r4, r5, lr}
    1c76:	f8d0 4148 	ldr.w	r4, [r0, #328]	; 0x148
    1c7a:	4605      	mov	r5, r0
    1c7c:	b95c      	cbnz	r4, 1c96 <_init_signal_r+0x22>
    1c7e:	2180      	movs	r1, #128	; 0x80
    1c80:	f7fe fdc0 	bl	804 <_malloc_r>
    1c84:	f8c5 0148 	str.w	r0, [r5, #328]	; 0x148
    1c88:	b138      	cbz	r0, 1c9a <_init_signal_r+0x26>
    1c8a:	1f03      	subs	r3, r0, #4
    1c8c:	307c      	adds	r0, #124	; 0x7c
    1c8e:	f843 4f04 	str.w	r4, [r3, #4]!
    1c92:	4283      	cmp	r3, r0
    1c94:	d1fb      	bne.n	1c8e <_init_signal_r+0x1a>
    1c96:	2000      	movs	r0, #0
    1c98:	bd38      	pop	{r3, r4, r5, pc}
    1c9a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1c9e:	e7fb      	b.n	1c98 <_init_signal_r+0x24>

00001ca0 <_signal_r>:
    1ca0:	291f      	cmp	r1, #31
    1ca2:	b570      	push	{r4, r5, r6, lr}
    1ca4:	4604      	mov	r4, r0
    1ca6:	460d      	mov	r5, r1
    1ca8:	4616      	mov	r6, r2
    1caa:	d904      	bls.n	1cb6 <_signal_r+0x16>
    1cac:	2316      	movs	r3, #22
    1cae:	6003      	str	r3, [r0, #0]
    1cb0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1cb4:	e008      	b.n	1cc8 <_signal_r+0x28>
    1cb6:	f8d0 3148 	ldr.w	r3, [r0, #328]	; 0x148
    1cba:	b133      	cbz	r3, 1cca <_signal_r+0x2a>
    1cbc:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    1cc0:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    1cc4:	f843 6025 	str.w	r6, [r3, r5, lsl #2]
    1cc8:	bd70      	pop	{r4, r5, r6, pc}
    1cca:	f7ff ffd3 	bl	1c74 <_init_signal_r>
    1cce:	2800      	cmp	r0, #0
    1cd0:	d0f4      	beq.n	1cbc <_signal_r+0x1c>
    1cd2:	e7ed      	b.n	1cb0 <_signal_r+0x10>

00001cd4 <_raise_r>:
    1cd4:	291f      	cmp	r1, #31
    1cd6:	b538      	push	{r3, r4, r5, lr}
    1cd8:	4604      	mov	r4, r0
    1cda:	460d      	mov	r5, r1
    1cdc:	d904      	bls.n	1ce8 <_raise_r+0x14>
    1cde:	2316      	movs	r3, #22
    1ce0:	6003      	str	r3, [r0, #0]
    1ce2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1ce6:	bd38      	pop	{r3, r4, r5, pc}
    1ce8:	f8d0 2148 	ldr.w	r2, [r0, #328]	; 0x148
    1cec:	b112      	cbz	r2, 1cf4 <_raise_r+0x20>
    1cee:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
    1cf2:	b94b      	cbnz	r3, 1d08 <_raise_r+0x34>
    1cf4:	4620      	mov	r0, r4
    1cf6:	f000 f86b 	bl	1dd0 <_getpid_r>
    1cfa:	462a      	mov	r2, r5
    1cfc:	4601      	mov	r1, r0
    1cfe:	4620      	mov	r0, r4
    1d00:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    1d04:	f000 b852 	b.w	1dac <_kill_r>
    1d08:	2b01      	cmp	r3, #1
    1d0a:	d00a      	beq.n	1d22 <_raise_r+0x4e>
    1d0c:	1c59      	adds	r1, r3, #1
    1d0e:	d103      	bne.n	1d18 <_raise_r+0x44>
    1d10:	2316      	movs	r3, #22
    1d12:	6003      	str	r3, [r0, #0]
    1d14:	2001      	movs	r0, #1
    1d16:	e7e6      	b.n	1ce6 <_raise_r+0x12>
    1d18:	2400      	movs	r4, #0
    1d1a:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
    1d1e:	4628      	mov	r0, r5
    1d20:	4798      	blx	r3
    1d22:	2000      	movs	r0, #0
    1d24:	e7df      	b.n	1ce6 <_raise_r+0x12>

00001d26 <__sigtramp_r>:
    1d26:	291f      	cmp	r1, #31
    1d28:	b538      	push	{r3, r4, r5, lr}
    1d2a:	4604      	mov	r4, r0
    1d2c:	460d      	mov	r5, r1
    1d2e:	d902      	bls.n	1d36 <__sigtramp_r+0x10>
    1d30:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1d34:	bd38      	pop	{r3, r4, r5, pc}
    1d36:	f8d0 3148 	ldr.w	r3, [r0, #328]	; 0x148
    1d3a:	b133      	cbz	r3, 1d4a <__sigtramp_r+0x24>
    1d3c:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
    1d40:	f852 3025 	ldr.w	r3, [r2, r5, lsl #2]
    1d44:	b933      	cbnz	r3, 1d54 <__sigtramp_r+0x2e>
    1d46:	2001      	movs	r0, #1
    1d48:	e7f4      	b.n	1d34 <__sigtramp_r+0xe>
    1d4a:	f7ff ff93 	bl	1c74 <_init_signal_r>
    1d4e:	2800      	cmp	r0, #0
    1d50:	d0f4      	beq.n	1d3c <__sigtramp_r+0x16>
    1d52:	e7ed      	b.n	1d30 <__sigtramp_r+0xa>
    1d54:	1c59      	adds	r1, r3, #1
    1d56:	d008      	beq.n	1d6a <__sigtramp_r+0x44>
    1d58:	2b01      	cmp	r3, #1
    1d5a:	d008      	beq.n	1d6e <__sigtramp_r+0x48>
    1d5c:	2400      	movs	r4, #0
    1d5e:	4628      	mov	r0, r5
    1d60:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
    1d64:	4798      	blx	r3
    1d66:	4620      	mov	r0, r4
    1d68:	e7e4      	b.n	1d34 <__sigtramp_r+0xe>
    1d6a:	2002      	movs	r0, #2
    1d6c:	e7e2      	b.n	1d34 <__sigtramp_r+0xe>
    1d6e:	2003      	movs	r0, #3
    1d70:	e7e0      	b.n	1d34 <__sigtramp_r+0xe>

00001d72 <raise>:
    1d72:	4b02      	ldr	r3, [pc, #8]	; (1d7c <raise+0xa>)
    1d74:	4601      	mov	r1, r0
    1d76:	6818      	ldr	r0, [r3, #0]
    1d78:	f7ff bfac 	b.w	1cd4 <_raise_r>
    1d7c:	200109c8 	.word	0x200109c8

00001d80 <signal>:
    1d80:	4b02      	ldr	r3, [pc, #8]	; (1d8c <signal+0xc>)
    1d82:	460a      	mov	r2, r1
    1d84:	4601      	mov	r1, r0
    1d86:	6818      	ldr	r0, [r3, #0]
    1d88:	f7ff bf8a 	b.w	1ca0 <_signal_r>
    1d8c:	200109c8 	.word	0x200109c8

00001d90 <_init_signal>:
    1d90:	4b01      	ldr	r3, [pc, #4]	; (1d98 <_init_signal+0x8>)
    1d92:	6818      	ldr	r0, [r3, #0]
    1d94:	f7ff bf6e 	b.w	1c74 <_init_signal_r>
    1d98:	200109c8 	.word	0x200109c8

00001d9c <__sigtramp>:
    1d9c:	4b02      	ldr	r3, [pc, #8]	; (1da8 <__sigtramp+0xc>)
    1d9e:	4601      	mov	r1, r0
    1da0:	6818      	ldr	r0, [r3, #0]
    1da2:	f7ff bfc0 	b.w	1d26 <__sigtramp_r>
    1da6:	bf00      	nop
    1da8:	200109c8 	.word	0x200109c8

00001dac <_kill_r>:
    1dac:	b538      	push	{r3, r4, r5, lr}
    1dae:	4c07      	ldr	r4, [pc, #28]	; (1dcc <_kill_r+0x20>)
    1db0:	2300      	movs	r3, #0
    1db2:	4605      	mov	r5, r0
    1db4:	4608      	mov	r0, r1
    1db6:	4611      	mov	r1, r2
    1db8:	6023      	str	r3, [r4, #0]
    1dba:	f011 f953 	bl	13064 <_kill>
    1dbe:	1c43      	adds	r3, r0, #1
    1dc0:	d102      	bne.n	1dc8 <_kill_r+0x1c>
    1dc2:	6823      	ldr	r3, [r4, #0]
    1dc4:	b103      	cbz	r3, 1dc8 <_kill_r+0x1c>
    1dc6:	602b      	str	r3, [r5, #0]
    1dc8:	bd38      	pop	{r3, r4, r5, pc}
    1dca:	bf00      	nop
    1dcc:	20006880 	.word	0x20006880

00001dd0 <_getpid_r>:
    1dd0:	f011 b94a 	b.w	13068 <_getpid>

00001dd4 <_write_r>:
    1dd4:	b538      	push	{r3, r4, r5, lr}
    1dd6:	4c07      	ldr	r4, [pc, #28]	; (1df4 <_write_r+0x20>)
    1dd8:	4605      	mov	r5, r0
    1dda:	4608      	mov	r0, r1
    1ddc:	4611      	mov	r1, r2
    1dde:	2200      	movs	r2, #0
    1de0:	6022      	str	r2, [r4, #0]
    1de2:	461a      	mov	r2, r3
    1de4:	f011 f933 	bl	1304e <_write>
    1de8:	1c43      	adds	r3, r0, #1
    1dea:	d102      	bne.n	1df2 <_write_r+0x1e>
    1dec:	6823      	ldr	r3, [r4, #0]
    1dee:	b103      	cbz	r3, 1df2 <_write_r+0x1e>
    1df0:	602b      	str	r3, [r5, #0]
    1df2:	bd38      	pop	{r3, r4, r5, pc}
    1df4:	20006880 	.word	0x20006880

00001df8 <_close_r>:
    1df8:	b538      	push	{r3, r4, r5, lr}
    1dfa:	4c06      	ldr	r4, [pc, #24]	; (1e14 <_close_r+0x1c>)
    1dfc:	2300      	movs	r3, #0
    1dfe:	4605      	mov	r5, r0
    1e00:	4608      	mov	r0, r1
    1e02:	6023      	str	r3, [r4, #0]
    1e04:	f011 f927 	bl	13056 <_close>
    1e08:	1c43      	adds	r3, r0, #1
    1e0a:	d102      	bne.n	1e12 <_close_r+0x1a>
    1e0c:	6823      	ldr	r3, [r4, #0]
    1e0e:	b103      	cbz	r3, 1e12 <_close_r+0x1a>
    1e10:	602b      	str	r3, [r5, #0]
    1e12:	bd38      	pop	{r3, r4, r5, pc}
    1e14:	20006880 	.word	0x20006880

00001e18 <_fstat_r>:
    1e18:	b538      	push	{r3, r4, r5, lr}
    1e1a:	4c07      	ldr	r4, [pc, #28]	; (1e38 <_fstat_r+0x20>)
    1e1c:	2300      	movs	r3, #0
    1e1e:	4605      	mov	r5, r0
    1e20:	4608      	mov	r0, r1
    1e22:	4611      	mov	r1, r2
    1e24:	6023      	str	r3, [r4, #0]
    1e26:	f011 f921 	bl	1306c <_fstat>
    1e2a:	1c43      	adds	r3, r0, #1
    1e2c:	d102      	bne.n	1e34 <_fstat_r+0x1c>
    1e2e:	6823      	ldr	r3, [r4, #0]
    1e30:	b103      	cbz	r3, 1e34 <_fstat_r+0x1c>
    1e32:	602b      	str	r3, [r5, #0]
    1e34:	bd38      	pop	{r3, r4, r5, pc}
    1e36:	bf00      	nop
    1e38:	20006880 	.word	0x20006880

00001e3c <_isatty_r>:
    1e3c:	b538      	push	{r3, r4, r5, lr}
    1e3e:	4c06      	ldr	r4, [pc, #24]	; (1e58 <_isatty_r+0x1c>)
    1e40:	2300      	movs	r3, #0
    1e42:	4605      	mov	r5, r0
    1e44:	4608      	mov	r0, r1
    1e46:	6023      	str	r3, [r4, #0]
    1e48:	f011 f90a 	bl	13060 <_isatty>
    1e4c:	1c43      	adds	r3, r0, #1
    1e4e:	d102      	bne.n	1e56 <_isatty_r+0x1a>
    1e50:	6823      	ldr	r3, [r4, #0]
    1e52:	b103      	cbz	r3, 1e56 <_isatty_r+0x1a>
    1e54:	602b      	str	r3, [r5, #0]
    1e56:	bd38      	pop	{r3, r4, r5, pc}
    1e58:	20006880 	.word	0x20006880

00001e5c <_lseek_r>:
    1e5c:	b538      	push	{r3, r4, r5, lr}
    1e5e:	4c07      	ldr	r4, [pc, #28]	; (1e7c <_lseek_r+0x20>)
    1e60:	4605      	mov	r5, r0
    1e62:	4608      	mov	r0, r1
    1e64:	4611      	mov	r1, r2
    1e66:	2200      	movs	r2, #0
    1e68:	6022      	str	r2, [r4, #0]
    1e6a:	461a      	mov	r2, r3
    1e6c:	f011 f8f6 	bl	1305c <_lseek>
    1e70:	1c43      	adds	r3, r0, #1
    1e72:	d102      	bne.n	1e7a <_lseek_r+0x1e>
    1e74:	6823      	ldr	r3, [r4, #0]
    1e76:	b103      	cbz	r3, 1e7a <_lseek_r+0x1e>
    1e78:	602b      	str	r3, [r5, #0]
    1e7a:	bd38      	pop	{r3, r4, r5, pc}
    1e7c:	20006880 	.word	0x20006880

00001e80 <_read_r>:
    1e80:	b538      	push	{r3, r4, r5, lr}
    1e82:	4c07      	ldr	r4, [pc, #28]	; (1ea0 <_read_r+0x20>)
    1e84:	4605      	mov	r5, r0
    1e86:	4608      	mov	r0, r1
    1e88:	4611      	mov	r1, r2
    1e8a:	2200      	movs	r2, #0
    1e8c:	6022      	str	r2, [r4, #0]
    1e8e:	461a      	mov	r2, r3
    1e90:	f011 f8d9 	bl	13046 <_read>
    1e94:	1c43      	adds	r3, r0, #1
    1e96:	d102      	bne.n	1e9e <_read_r+0x1e>
    1e98:	6823      	ldr	r3, [r4, #0]
    1e9a:	b103      	cbz	r3, 1e9e <_read_r+0x1e>
    1e9c:	602b      	str	r3, [r5, #0]
    1e9e:	bd38      	pop	{r3, r4, r5, pc}
    1ea0:	20006880 	.word	0x20006880

00001ea4 <__udivmoddi4>:
    1ea4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ea8:	9f09      	ldr	r7, [sp, #36]	; 0x24
    1eaa:	4615      	mov	r5, r2
    1eac:	4604      	mov	r4, r0
    1eae:	468e      	mov	lr, r1
    1eb0:	461e      	mov	r6, r3
    1eb2:	2b00      	cmp	r3, #0
    1eb4:	f040 80cc 	bne.w	2050 <_ramfunc_ram_size+0x50>
    1eb8:	428a      	cmp	r2, r1
    1eba:	fab2 fc82 	clz	ip, r2
    1ebe:	d94c      	bls.n	1f5a <__udivmoddi4+0xb6>
    1ec0:	f1bc 0f00 	cmp.w	ip, #0
    1ec4:	d00b      	beq.n	1ede <__udivmoddi4+0x3a>
    1ec6:	f1cc 0820 	rsb	r8, ip, #32
    1eca:	fa01 fe0c 	lsl.w	lr, r1, ip
    1ece:	fa20 f808 	lsr.w	r8, r0, r8
    1ed2:	fa02 f50c 	lsl.w	r5, r2, ip
    1ed6:	ea48 0e0e 	orr.w	lr, r8, lr
    1eda:	fa00 f40c 	lsl.w	r4, r0, ip
    1ede:	ea4f 4915 	mov.w	r9, r5, lsr #16
    1ee2:	fa1f f885 	uxth.w	r8, r5
    1ee6:	fbbe faf9 	udiv	sl, lr, r9
    1eea:	0c21      	lsrs	r1, r4, #16
    1eec:	fb09 e31a 	mls	r3, r9, sl, lr
    1ef0:	fb0a fb08 	mul.w	fp, sl, r8
    1ef4:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
    1ef8:	459b      	cmp	fp, r3
    1efa:	d92a      	bls.n	1f52 <__udivmoddi4+0xae>
    1efc:	18eb      	adds	r3, r5, r3
    1efe:	f10a 30ff 	add.w	r0, sl, #4294967295	; 0xffffffff
    1f02:	d204      	bcs.n	1f0e <__udivmoddi4+0x6a>
    1f04:	459b      	cmp	fp, r3
    1f06:	d902      	bls.n	1f0e <__udivmoddi4+0x6a>
    1f08:	f1aa 0002 	sub.w	r0, sl, #2
    1f0c:	442b      	add	r3, r5
    1f0e:	eba3 030b 	sub.w	r3, r3, fp
    1f12:	b2a4      	uxth	r4, r4
    1f14:	fbb3 f2f9 	udiv	r2, r3, r9
    1f18:	fb09 3312 	mls	r3, r9, r2, r3
    1f1c:	fb02 f808 	mul.w	r8, r2, r8
    1f20:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    1f24:	45a0      	cmp	r8, r4
    1f26:	d916      	bls.n	1f56 <__udivmoddi4+0xb2>
    1f28:	192c      	adds	r4, r5, r4
    1f2a:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
    1f2e:	d203      	bcs.n	1f38 <__udivmoddi4+0x94>
    1f30:	45a0      	cmp	r8, r4
    1f32:	d901      	bls.n	1f38 <__udivmoddi4+0x94>
    1f34:	1e93      	subs	r3, r2, #2
    1f36:	442c      	add	r4, r5
    1f38:	eba4 0408 	sub.w	r4, r4, r8
    1f3c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    1f40:	b127      	cbz	r7, 1f4c <__udivmoddi4+0xa8>
    1f42:	fa24 f40c 	lsr.w	r4, r4, ip
    1f46:	2300      	movs	r3, #0
    1f48:	603c      	str	r4, [r7, #0]
    1f4a:	607b      	str	r3, [r7, #4]
    1f4c:	4631      	mov	r1, r6
    1f4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1f52:	4650      	mov	r0, sl
    1f54:	e7db      	b.n	1f0e <__udivmoddi4+0x6a>
    1f56:	4613      	mov	r3, r2
    1f58:	e7ee      	b.n	1f38 <__udivmoddi4+0x94>
    1f5a:	b902      	cbnz	r2, 1f5e <__udivmoddi4+0xba>
    1f5c:	deff      	udf	#255	; 0xff
    1f5e:	f1bc 0f00 	cmp.w	ip, #0
    1f62:	d12e      	bne.n	1fc2 <__udivmoddi4+0x11e>
    1f64:	1a8b      	subs	r3, r1, r2
    1f66:	2601      	movs	r6, #1
    1f68:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    1f6c:	b2aa      	uxth	r2, r5
    1f6e:	fbb3 f8fe 	udiv	r8, r3, lr
    1f72:	0c21      	lsrs	r1, r4, #16
    1f74:	fb0e 3318 	mls	r3, lr, r8, r3
    1f78:	fb08 f902 	mul.w	r9, r8, r2
    1f7c:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
    1f80:	4599      	cmp	r9, r3
    1f82:	d961      	bls.n	2048 <_ramfunc_ram_size+0x48>
    1f84:	18eb      	adds	r3, r5, r3
    1f86:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
    1f8a:	d204      	bcs.n	1f96 <__udivmoddi4+0xf2>
    1f8c:	4599      	cmp	r9, r3
    1f8e:	d902      	bls.n	1f96 <__udivmoddi4+0xf2>
    1f90:	f1a8 0002 	sub.w	r0, r8, #2
    1f94:	442b      	add	r3, r5
    1f96:	eba3 0309 	sub.w	r3, r3, r9
    1f9a:	b2a4      	uxth	r4, r4
    1f9c:	fbb3 f1fe 	udiv	r1, r3, lr
    1fa0:	fb0e 3311 	mls	r3, lr, r1, r3
    1fa4:	434a      	muls	r2, r1
    1fa6:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    1faa:	42a2      	cmp	r2, r4
    1fac:	d94e      	bls.n	204c <_ramfunc_ram_size+0x4c>
    1fae:	192c      	adds	r4, r5, r4
    1fb0:	f101 33ff 	add.w	r3, r1, #4294967295	; 0xffffffff
    1fb4:	d203      	bcs.n	1fbe <__udivmoddi4+0x11a>
    1fb6:	42a2      	cmp	r2, r4
    1fb8:	d901      	bls.n	1fbe <__udivmoddi4+0x11a>
    1fba:	1e8b      	subs	r3, r1, #2
    1fbc:	442c      	add	r4, r5
    1fbe:	1aa4      	subs	r4, r4, r2
    1fc0:	e7bc      	b.n	1f3c <__udivmoddi4+0x98>
    1fc2:	f1cc 0e20 	rsb	lr, ip, #32
    1fc6:	fa02 f50c 	lsl.w	r5, r2, ip
    1fca:	fa21 f90e 	lsr.w	r9, r1, lr
    1fce:	fa01 f30c 	lsl.w	r3, r1, ip
    1fd2:	fa20 fe0e 	lsr.w	lr, r0, lr
    1fd6:	ea4e 0303 	orr.w	r3, lr, r3
    1fda:	ea4f 4815 	mov.w	r8, r5, lsr #16
    1fde:	fa00 f40c 	lsl.w	r4, r0, ip
    1fe2:	fbb9 f1f8 	udiv	r1, r9, r8
    1fe6:	fa1f fe85 	uxth.w	lr, r5
    1fea:	fb08 9211 	mls	r2, r8, r1, r9
    1fee:	0c18      	lsrs	r0, r3, #16
    1ff0:	fb01 f60e 	mul.w	r6, r1, lr
    1ff4:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
    1ff8:	4296      	cmp	r6, r2
    1ffa:	d921      	bls.n	2040 <_ramfunc_ram_size+0x40>
    1ffc:	18aa      	adds	r2, r5, r2
    1ffe:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
    2002:	d203      	bcs.n	200c <_ramfunc_ram_size+0xc>
    2004:	4296      	cmp	r6, r2
    2006:	d901      	bls.n	200c <_ramfunc_ram_size+0xc>
    2008:	1e88      	subs	r0, r1, #2
    200a:	442a      	add	r2, r5
    200c:	1b92      	subs	r2, r2, r6
    200e:	b29b      	uxth	r3, r3
    2010:	fbb2 f9f8 	udiv	r9, r2, r8
    2014:	fb08 2219 	mls	r2, r8, r9, r2
    2018:	fb09 fe0e 	mul.w	lr, r9, lr
    201c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    2020:	459e      	cmp	lr, r3
    2022:	d90f      	bls.n	2044 <_ramfunc_ram_size+0x44>
    2024:	18eb      	adds	r3, r5, r3
    2026:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
    202a:	d204      	bcs.n	2036 <_ramfunc_ram_size+0x36>
    202c:	459e      	cmp	lr, r3
    202e:	d902      	bls.n	2036 <_ramfunc_ram_size+0x36>
    2030:	f1a9 0602 	sub.w	r6, r9, #2
    2034:	442b      	add	r3, r5
    2036:	eba3 030e 	sub.w	r3, r3, lr
    203a:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
    203e:	e793      	b.n	1f68 <__udivmoddi4+0xc4>
    2040:	4608      	mov	r0, r1
    2042:	e7e3      	b.n	200c <_ramfunc_ram_size+0xc>
    2044:	464e      	mov	r6, r9
    2046:	e7f6      	b.n	2036 <_ramfunc_ram_size+0x36>
    2048:	4640      	mov	r0, r8
    204a:	e7a4      	b.n	1f96 <__udivmoddi4+0xf2>
    204c:	460b      	mov	r3, r1
    204e:	e7b6      	b.n	1fbe <__udivmoddi4+0x11a>
    2050:	428b      	cmp	r3, r1
    2052:	d905      	bls.n	2060 <_ramfunc_ram_size+0x60>
    2054:	b10f      	cbz	r7, 205a <_ramfunc_ram_size+0x5a>
    2056:	e9c7 0100 	strd	r0, r1, [r7]
    205a:	2600      	movs	r6, #0
    205c:	4630      	mov	r0, r6
    205e:	e775      	b.n	1f4c <__udivmoddi4+0xa8>
    2060:	fab3 fc83 	clz	ip, r3
    2064:	f1bc 0f00 	cmp.w	ip, #0
    2068:	d10f      	bne.n	208a <_ramfunc_ram_size+0x8a>
    206a:	428b      	cmp	r3, r1
    206c:	d301      	bcc.n	2072 <_ramfunc_ram_size+0x72>
    206e:	4282      	cmp	r2, r0
    2070:	d809      	bhi.n	2086 <_ramfunc_ram_size+0x86>
    2072:	1a84      	subs	r4, r0, r2
    2074:	eb61 0e03 	sbc.w	lr, r1, r3
    2078:	2001      	movs	r0, #1
    207a:	2f00      	cmp	r7, #0
    207c:	d06a      	beq.n	2154 <_ramfunc_ram_size+0x154>
    207e:	e9c7 4e00 	strd	r4, lr, [r7]
    2082:	2600      	movs	r6, #0
    2084:	e762      	b.n	1f4c <__udivmoddi4+0xa8>
    2086:	4660      	mov	r0, ip
    2088:	e7f7      	b.n	207a <_ramfunc_ram_size+0x7a>
    208a:	f1cc 0e20 	rsb	lr, ip, #32
    208e:	fa03 f30c 	lsl.w	r3, r3, ip
    2092:	fa22 f50e 	lsr.w	r5, r2, lr
    2096:	fa21 f40e 	lsr.w	r4, r1, lr
    209a:	431d      	orrs	r5, r3
    209c:	fa01 f30c 	lsl.w	r3, r1, ip
    20a0:	fa20 f10e 	lsr.w	r1, r0, lr
    20a4:	430b      	orrs	r3, r1
    20a6:	ea4f 4a15 	mov.w	sl, r5, lsr #16
    20aa:	fa00 f60c 	lsl.w	r6, r0, ip
    20ae:	fbb4 f9fa 	udiv	r9, r4, sl
    20b2:	fa1f f885 	uxth.w	r8, r5
    20b6:	fb0a 4019 	mls	r0, sl, r9, r4
    20ba:	0c1c      	lsrs	r4, r3, #16
    20bc:	fb09 f108 	mul.w	r1, r9, r8
    20c0:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
    20c4:	42a1      	cmp	r1, r4
    20c6:	fa02 f20c 	lsl.w	r2, r2, ip
    20ca:	d93f      	bls.n	214c <_ramfunc_ram_size+0x14c>
    20cc:	192c      	adds	r4, r5, r4
    20ce:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    20d2:	d204      	bcs.n	20de <_ramfunc_ram_size+0xde>
    20d4:	42a1      	cmp	r1, r4
    20d6:	d902      	bls.n	20de <_ramfunc_ram_size+0xde>
    20d8:	f1a9 0002 	sub.w	r0, r9, #2
    20dc:	442c      	add	r4, r5
    20de:	1a64      	subs	r4, r4, r1
    20e0:	b29b      	uxth	r3, r3
    20e2:	fbb4 f9fa 	udiv	r9, r4, sl
    20e6:	fb0a 4419 	mls	r4, sl, r9, r4
    20ea:	fb09 f808 	mul.w	r8, r9, r8
    20ee:	ea43 4104 	orr.w	r1, r3, r4, lsl #16
    20f2:	4588      	cmp	r8, r1
    20f4:	d92c      	bls.n	2150 <_ramfunc_ram_size+0x150>
    20f6:	1869      	adds	r1, r5, r1
    20f8:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
    20fc:	d204      	bcs.n	2108 <_ramfunc_ram_size+0x108>
    20fe:	4588      	cmp	r8, r1
    2100:	d902      	bls.n	2108 <_ramfunc_ram_size+0x108>
    2102:	f1a9 0302 	sub.w	r3, r9, #2
    2106:	4429      	add	r1, r5
    2108:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    210c:	eba1 0108 	sub.w	r1, r1, r8
    2110:	fba0 8902 	umull	r8, r9, r0, r2
    2114:	4549      	cmp	r1, r9
    2116:	46c2      	mov	sl, r8
    2118:	464c      	mov	r4, r9
    211a:	d302      	bcc.n	2122 <_ramfunc_ram_size+0x122>
    211c:	d106      	bne.n	212c <_ramfunc_ram_size+0x12c>
    211e:	4546      	cmp	r6, r8
    2120:	d204      	bcs.n	212c <_ramfunc_ram_size+0x12c>
    2122:	ebb8 0a02 	subs.w	sl, r8, r2
    2126:	eb69 0405 	sbc.w	r4, r9, r5
    212a:	3801      	subs	r0, #1
    212c:	b197      	cbz	r7, 2154 <_ramfunc_ram_size+0x154>
    212e:	ebb6 030a 	subs.w	r3, r6, sl
    2132:	eb61 0604 	sbc.w	r6, r1, r4
    2136:	fa06 fe0e 	lsl.w	lr, r6, lr
    213a:	fa23 f30c 	lsr.w	r3, r3, ip
    213e:	ea4e 0303 	orr.w	r3, lr, r3
    2142:	fa26 f60c 	lsr.w	r6, r6, ip
    2146:	e9c7 3600 	strd	r3, r6, [r7]
    214a:	e79a      	b.n	2082 <_ramfunc_ram_size+0x82>
    214c:	4648      	mov	r0, r9
    214e:	e7c6      	b.n	20de <_ramfunc_ram_size+0xde>
    2150:	464b      	mov	r3, r9
    2152:	e7d9      	b.n	2108 <_ramfunc_ram_size+0x108>
    2154:	463e      	mov	r6, r7
    2156:	e6f9      	b.n	1f4c <__udivmoddi4+0xa8>

00002158 <memcmp>:
    2158:	b530      	push	{r4, r5, lr}
    215a:	3901      	subs	r1, #1
    215c:	2400      	movs	r4, #0
    215e:	42a2      	cmp	r2, r4
    2160:	d101      	bne.n	2166 <memcmp+0xe>
    2162:	2000      	movs	r0, #0
    2164:	e005      	b.n	2172 <memcmp+0x1a>
    2166:	5d03      	ldrb	r3, [r0, r4]
    2168:	3401      	adds	r4, #1
    216a:	5d0d      	ldrb	r5, [r1, r4]
    216c:	42ab      	cmp	r3, r5
    216e:	d0f6      	beq.n	215e <memcmp+0x6>
    2170:	1b58      	subs	r0, r3, r5
    2172:	bd30      	pop	{r4, r5, pc}

00002174 <memcpy>:
    2174:	440a      	add	r2, r1
    2176:	4291      	cmp	r1, r2
    2178:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    217c:	d100      	bne.n	2180 <memcpy+0xc>
    217e:	4770      	bx	lr
    2180:	b510      	push	{r4, lr}
    2182:	f811 4b01 	ldrb.w	r4, [r1], #1
    2186:	f803 4f01 	strb.w	r4, [r3, #1]!
    218a:	4291      	cmp	r1, r2
    218c:	d1f9      	bne.n	2182 <memcpy+0xe>
    218e:	bd10      	pop	{r4, pc}

00002190 <__memcpy_chk>:
    2190:	429a      	cmp	r2, r3
    2192:	b508      	push	{r3, lr}
    2194:	d901      	bls.n	219a <__memcpy_chk+0xa>
    2196:	f7ff f81f 	bl	11d8 <__chk_fail>
    219a:	4281      	cmp	r1, r0
    219c:	d804      	bhi.n	21a8 <__memcpy_chk+0x18>
    219e:	188b      	adds	r3, r1, r2
    21a0:	4298      	cmp	r0, r3
    21a2:	d3f8      	bcc.n	2196 <__memcpy_chk+0x6>
    21a4:	4281      	cmp	r1, r0
    21a6:	d102      	bne.n	21ae <__memcpy_chk+0x1e>
    21a8:	1883      	adds	r3, r0, r2
    21aa:	4299      	cmp	r1, r3
    21ac:	d3f3      	bcc.n	2196 <__memcpy_chk+0x6>
    21ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    21b2:	f7ff bfdf 	b.w	2174 <memcpy>

000021b6 <memmove>:
    21b6:	4288      	cmp	r0, r1
    21b8:	b510      	push	{r4, lr}
    21ba:	eb01 0302 	add.w	r3, r1, r2
    21be:	d902      	bls.n	21c6 <memmove+0x10>
    21c0:	4283      	cmp	r3, r0
    21c2:	461c      	mov	r4, r3
    21c4:	d807      	bhi.n	21d6 <memmove+0x20>
    21c6:	1e42      	subs	r2, r0, #1
    21c8:	4299      	cmp	r1, r3
    21ca:	d008      	beq.n	21de <memmove+0x28>
    21cc:	f811 4b01 	ldrb.w	r4, [r1], #1
    21d0:	f802 4f01 	strb.w	r4, [r2, #1]!
    21d4:	e7f8      	b.n	21c8 <memmove+0x12>
    21d6:	1883      	adds	r3, r0, r2
    21d8:	1a9a      	subs	r2, r3, r2
    21da:	429a      	cmp	r2, r3
    21dc:	d100      	bne.n	21e0 <memmove+0x2a>
    21de:	bd10      	pop	{r4, pc}
    21e0:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
    21e4:	f803 1d01 	strb.w	r1, [r3, #-1]!
    21e8:	e7f7      	b.n	21da <memmove+0x24>

000021ea <memset>:
    21ea:	4402      	add	r2, r0
    21ec:	4603      	mov	r3, r0
    21ee:	4293      	cmp	r3, r2
    21f0:	d100      	bne.n	21f4 <memset+0xa>
    21f2:	4770      	bx	lr
    21f4:	f803 1b01 	strb.w	r1, [r3], #1
    21f8:	e7f9      	b.n	21ee <memset+0x4>

000021fa <strchr>:
    21fa:	b2c9      	uxtb	r1, r1
    21fc:	4603      	mov	r3, r0
    21fe:	f810 2b01 	ldrb.w	r2, [r0], #1
    2202:	b11a      	cbz	r2, 220c <strchr+0x12>
    2204:	428a      	cmp	r2, r1
    2206:	d1f9      	bne.n	21fc <strchr+0x2>
    2208:	4618      	mov	r0, r3
    220a:	4770      	bx	lr
    220c:	2900      	cmp	r1, #0
    220e:	bf18      	it	ne
    2210:	2300      	movne	r3, #0
    2212:	e7f9      	b.n	2208 <strchr+0xe>

00002214 <strcmp>:
    2214:	f810 2b01 	ldrb.w	r2, [r0], #1
    2218:	f811 3b01 	ldrb.w	r3, [r1], #1
    221c:	2a01      	cmp	r2, #1
    221e:	bf28      	it	cs
    2220:	429a      	cmpcs	r2, r3
    2222:	d0f7      	beq.n	2214 <strcmp>
    2224:	1ad0      	subs	r0, r2, r3
    2226:	4770      	bx	lr

00002228 <strlen>:
    2228:	4603      	mov	r3, r0
    222a:	f813 2b01 	ldrb.w	r2, [r3], #1
    222e:	2a00      	cmp	r2, #0
    2230:	d1fb      	bne.n	222a <strlen+0x2>
    2232:	1a18      	subs	r0, r3, r0
    2234:	3801      	subs	r0, #1
    2236:	4770      	bx	lr

00002238 <strncpy>:
    2238:	b510      	push	{r4, lr}
    223a:	3901      	subs	r1, #1
    223c:	4603      	mov	r3, r0
    223e:	b132      	cbz	r2, 224e <strncpy+0x16>
    2240:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    2244:	f803 4b01 	strb.w	r4, [r3], #1
    2248:	3a01      	subs	r2, #1
    224a:	2c00      	cmp	r4, #0
    224c:	d1f7      	bne.n	223e <strncpy+0x6>
    224e:	441a      	add	r2, r3
    2250:	2100      	movs	r1, #0
    2252:	4293      	cmp	r3, r2
    2254:	d100      	bne.n	2258 <strncpy+0x20>
    2256:	bd10      	pop	{r4, pc}
    2258:	f803 1b01 	strb.w	r1, [r3], #1
    225c:	e7f9      	b.n	2252 <strncpy+0x1a>

0000225e <strrchr>:
    225e:	b538      	push	{r3, r4, r5, lr}
    2260:	4603      	mov	r3, r0
    2262:	460d      	mov	r5, r1
    2264:	b969      	cbnz	r1, 2282 <strrchr+0x24>
    2266:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    226a:	f7ff bfc6 	b.w	21fa <strchr>
    226e:	1c43      	adds	r3, r0, #1
    2270:	4604      	mov	r4, r0
    2272:	4629      	mov	r1, r5
    2274:	4618      	mov	r0, r3
    2276:	f7ff ffc0 	bl	21fa <strchr>
    227a:	2800      	cmp	r0, #0
    227c:	d1f7      	bne.n	226e <strrchr+0x10>
    227e:	4620      	mov	r0, r4
    2280:	bd38      	pop	{r3, r4, r5, pc}
    2282:	2400      	movs	r4, #0
    2284:	e7f5      	b.n	2272 <strrchr+0x14>

00002286 <abort>:
    2286:	b508      	push	{r3, lr}
    2288:	2006      	movs	r0, #6
    228a:	f7ff fd72 	bl	1d72 <raise>
    228e:	2001      	movs	r0, #1
    2290:	f007 fffc 	bl	a28c <_exit>

00002294 <_fwalk>:
    2294:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2298:	4688      	mov	r8, r1
    229a:	f500 74a6 	add.w	r4, r0, #332	; 0x14c
    229e:	2600      	movs	r6, #0
    22a0:	b914      	cbnz	r4, 22a8 <_fwalk+0x14>
    22a2:	4630      	mov	r0, r6
    22a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    22a8:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
    22ac:	3f01      	subs	r7, #1
    22ae:	d501      	bpl.n	22b4 <_fwalk+0x20>
    22b0:	6824      	ldr	r4, [r4, #0]
    22b2:	e7f5      	b.n	22a0 <_fwalk+0xc>
    22b4:	89ab      	ldrh	r3, [r5, #12]
    22b6:	2b01      	cmp	r3, #1
    22b8:	d906      	bls.n	22c8 <_fwalk+0x34>
    22ba:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    22be:	3301      	adds	r3, #1
    22c0:	d002      	beq.n	22c8 <_fwalk+0x34>
    22c2:	4628      	mov	r0, r5
    22c4:	47c0      	blx	r8
    22c6:	4306      	orrs	r6, r0
    22c8:	3564      	adds	r5, #100	; 0x64
    22ca:	e7ef      	b.n	22ac <_fwalk+0x18>

000022cc <_fwalk_reent>:
    22cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    22d0:	4680      	mov	r8, r0
    22d2:	4689      	mov	r9, r1
    22d4:	f500 74a6 	add.w	r4, r0, #332	; 0x14c
    22d8:	2600      	movs	r6, #0
    22da:	b914      	cbnz	r4, 22e2 <_fwalk_reent+0x16>
    22dc:	4630      	mov	r0, r6
    22de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    22e2:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
    22e6:	3f01      	subs	r7, #1
    22e8:	d501      	bpl.n	22ee <_fwalk_reent+0x22>
    22ea:	6824      	ldr	r4, [r4, #0]
    22ec:	e7f5      	b.n	22da <_fwalk_reent+0xe>
    22ee:	89ab      	ldrh	r3, [r5, #12]
    22f0:	2b01      	cmp	r3, #1
    22f2:	d907      	bls.n	2304 <_fwalk_reent+0x38>
    22f4:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    22f8:	3301      	adds	r3, #1
    22fa:	d003      	beq.n	2304 <_fwalk_reent+0x38>
    22fc:	4629      	mov	r1, r5
    22fe:	4640      	mov	r0, r8
    2300:	47c8      	blx	r9
    2302:	4306      	orrs	r6, r0
    2304:	3564      	adds	r5, #100	; 0x64
    2306:	e7ee      	b.n	22e6 <_fwalk_reent+0x1a>

00002308 <__malloc_lock>:
    2308:	4770      	bx	lr

0000230a <__malloc_unlock>:
    230a:	4770      	bx	lr

0000230c <_realloc_r>:
    230c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    230e:	4607      	mov	r7, r0
    2310:	4614      	mov	r4, r2
    2312:	460e      	mov	r6, r1
    2314:	b921      	cbnz	r1, 2320 <_realloc_r+0x14>
    2316:	4611      	mov	r1, r2
    2318:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    231c:	f7fe ba72 	b.w	804 <_malloc_r>
    2320:	b922      	cbnz	r2, 232c <_realloc_r+0x20>
    2322:	f7ff fa8f 	bl	1844 <_free_r>
    2326:	4625      	mov	r5, r4
    2328:	4628      	mov	r0, r5
    232a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    232c:	f000 f859 	bl	23e2 <_malloc_usable_size_r>
    2330:	42a0      	cmp	r0, r4
    2332:	d20f      	bcs.n	2354 <_realloc_r+0x48>
    2334:	4621      	mov	r1, r4
    2336:	4638      	mov	r0, r7
    2338:	f7fe fa64 	bl	804 <_malloc_r>
    233c:	4605      	mov	r5, r0
    233e:	2800      	cmp	r0, #0
    2340:	d0f2      	beq.n	2328 <_realloc_r+0x1c>
    2342:	4631      	mov	r1, r6
    2344:	4622      	mov	r2, r4
    2346:	f7ff ff15 	bl	2174 <memcpy>
    234a:	4631      	mov	r1, r6
    234c:	4638      	mov	r0, r7
    234e:	f7ff fa79 	bl	1844 <_free_r>
    2352:	e7e9      	b.n	2328 <_realloc_r+0x1c>
    2354:	4635      	mov	r5, r6
    2356:	e7e7      	b.n	2328 <_realloc_r+0x1c>

00002358 <__sread>:
    2358:	b510      	push	{r4, lr}
    235a:	460c      	mov	r4, r1
    235c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    2360:	f7ff fd8e 	bl	1e80 <_read_r>
    2364:	2800      	cmp	r0, #0
    2366:	bfab      	itete	ge
    2368:	6d23      	ldrge	r3, [r4, #80]	; 0x50
    236a:	89a3      	ldrhlt	r3, [r4, #12]
    236c:	181b      	addge	r3, r3, r0
    236e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    2372:	bfac      	ite	ge
    2374:	6523      	strge	r3, [r4, #80]	; 0x50
    2376:	81a3      	strhlt	r3, [r4, #12]
    2378:	bd10      	pop	{r4, pc}

0000237a <__seofread>:
    237a:	2000      	movs	r0, #0
    237c:	4770      	bx	lr

0000237e <__swrite>:
    237e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2382:	461f      	mov	r7, r3
    2384:	898b      	ldrh	r3, [r1, #12]
    2386:	05db      	lsls	r3, r3, #23
    2388:	4605      	mov	r5, r0
    238a:	460c      	mov	r4, r1
    238c:	4616      	mov	r6, r2
    238e:	d505      	bpl.n	239c <__swrite+0x1e>
    2390:	2302      	movs	r3, #2
    2392:	2200      	movs	r2, #0
    2394:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    2398:	f7ff fd60 	bl	1e5c <_lseek_r>
    239c:	89a3      	ldrh	r3, [r4, #12]
    239e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    23a2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    23a6:	81a3      	strh	r3, [r4, #12]
    23a8:	4632      	mov	r2, r6
    23aa:	463b      	mov	r3, r7
    23ac:	4628      	mov	r0, r5
    23ae:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    23b2:	f7ff bd0f 	b.w	1dd4 <_write_r>

000023b6 <__sseek>:
    23b6:	b510      	push	{r4, lr}
    23b8:	460c      	mov	r4, r1
    23ba:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    23be:	f7ff fd4d 	bl	1e5c <_lseek_r>
    23c2:	1c43      	adds	r3, r0, #1
    23c4:	89a3      	ldrh	r3, [r4, #12]
    23c6:	bf15      	itete	ne
    23c8:	6520      	strne	r0, [r4, #80]	; 0x50
    23ca:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    23ce:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    23d2:	81a3      	strheq	r3, [r4, #12]
    23d4:	bf18      	it	ne
    23d6:	81a3      	strhne	r3, [r4, #12]
    23d8:	bd10      	pop	{r4, pc}

000023da <__sclose>:
    23da:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    23de:	f7ff bd0b 	b.w	1df8 <_close_r>

000023e2 <_malloc_usable_size_r>:
    23e2:	f851 3c04 	ldr.w	r3, [r1, #-4]
    23e6:	1f18      	subs	r0, r3, #4
    23e8:	2b00      	cmp	r3, #0
    23ea:	bfbc      	itt	lt
    23ec:	580b      	ldrlt	r3, [r1, r0]
    23ee:	18c0      	addlt	r0, r0, r3
    23f0:	4770      	bx	lr
	...

000023f4 <test_debug_patch>:

static void test_rt_task(void) {
	// init_rt_task_servo_motor();
}

static void test_debug_patch(void) {
    23f4:	b508      	push	{r3, lr}
	DEBUG_LOG("test_debug_patch\n");
    23f6:	4803      	ldr	r0, [pc, #12]	; (2404 <test_debug_patch+0x10>)
    23f8:	f00d fda9 	bl	ff4e <debug_log>
#ifndef LINUX_TEST
	test_debugmon_patch();
#endif
	
}
    23fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	test_debugmon_patch();
    2400:	f000 bc50 	b.w	2ca4 <test_debugmon_patch>
    2404:	00016a95 	.word	0x00016a95

00002408 <shell_printf>:
static void shell_printf(char *fmt, ...) {
    2408:	b40f      	push	{r0, r1, r2, r3}
    240a:	b513      	push	{r0, r1, r4, lr}
	vsnprintf(log_buf, sizeof(log_buf) - 1, fmt, args);
    240c:	4c08      	ldr	r4, [pc, #32]	; (2430 <shell_printf+0x28>)
static void shell_printf(char *fmt, ...) {
    240e:	ab04      	add	r3, sp, #16
	vsnprintf(log_buf, sizeof(log_buf) - 1, fmt, args);
    2410:	21ff      	movs	r1, #255	; 0xff
static void shell_printf(char *fmt, ...) {
    2412:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
    2416:	9301      	str	r3, [sp, #4]
	vsnprintf(log_buf, sizeof(log_buf) - 1, fmt, args);
    2418:	4620      	mov	r0, r4
    241a:	f7fe fe31 	bl	1080 <vsniprintf>
	shell_echo_str(log_buf);
    241e:	4620      	mov	r0, r4
    2420:	f00d fca7 	bl	fd72 <shell_echo_str>
}
    2424:	b002      	add	sp, #8
    2426:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    242a:	b004      	add	sp, #16
    242c:	4770      	bx	lr
    242e:	bf00      	nop
    2430:	200056ad 	.word	0x200056ad

00002434 <cli_print_help>:
	{TEST_EBPF, run_eva_test, "Run eva test"},
	{TEST_SVR, start_patch_service, "Start patch service"},
	{TEST_FIXED_PATCH_POINT, run_fixed_patch_point_test, "Start testing fixed patch point"},
};

static void cli_print_help() {
    2434:	b570      	push	{r4, r5, r6, lr}
	int ncmd = sizeof(cmds) / sizeof(struct cli_cmd);
	shell_printf("IoTPatch Cli Usage: run [idx] | trigger [cve] | patch [cve] | vm [vid]\n");
    2436:	4808      	ldr	r0, [pc, #32]	; (2458 <cli_print_help+0x24>)
    2438:	4d08      	ldr	r5, [pc, #32]	; (245c <cli_print_help+0x28>)
	for (int i = 0; i < ncmd; i++) {
		shell_printf("run %d: %s\n", cmds[i].idx, cmds[i].help);
    243a:	4e09      	ldr	r6, [pc, #36]	; (2460 <cli_print_help+0x2c>)
	shell_printf("IoTPatch Cli Usage: run [idx] | trigger [cve] | patch [cve] | vm [vid]\n");
    243c:	f7ff ffe4 	bl	2408 <shell_printf>
	for (int i = 0; i < ncmd; i++) {
    2440:	2400      	movs	r4, #0
		shell_printf("run %d: %s\n", cmds[i].idx, cmds[i].help);
    2442:	68aa      	ldr	r2, [r5, #8]
    2444:	f855 1b0c 	ldr.w	r1, [r5], #12
    2448:	4630      	mov	r0, r6
	for (int i = 0; i < ncmd; i++) {
    244a:	3401      	adds	r4, #1
		shell_printf("run %d: %s\n", cmds[i].idx, cmds[i].help);
    244c:	f7ff ffdc 	bl	2408 <shell_printf>
	for (int i = 0; i < ncmd; i++) {
    2450:	2c06      	cmp	r4, #6
    2452:	d1f6      	bne.n	2442 <cli_print_help+0xe>
	}
}
    2454:	bd70      	pop	{r4, r5, r6, pc}
    2456:	bf00      	nop
    2458:	00016892 	.word	0x00016892
    245c:	000165a0 	.word	0x000165a0
    2460:	000168da 	.word	0x000168da

00002464 <print_control>:
	profile_dump(EV0);
	profile_dump(EV1);
	DEBUG_LOG("ret = %d\n", ret);
}

static void print_control(const char *s) {
    2464:	4601      	mov	r1, r0
	uint32_t control;
	__asm__ volatile ("mrs %0, CONTROL" : "=r"(control));
    2466:	f3ef 8214 	mrs	r2, CONTROL
	printk("%s - CONTROL: 0x%X\n", s, control);
    246a:	4801      	ldr	r0, [pc, #4]	; (2470 <print_control+0xc>)
    246c:	f00f bcc8 	b.w	11e00 <printk>
    2470:	000168f0 	.word	0x000168f0

00002474 <zephyr_cve_2020_10028>:
	api.enable_callback = (void*)escalate;
	port.driver_api = &api;
	gpio_enable_callback(&port, 0, 0);
}

static void zephyr_cve_2020_10028(void) {
    2474:	b508      	push	{r3, lr}
	print_control("kernel");
    2476:	4804      	ldr	r0, [pc, #16]	; (2488 <zephyr_cve_2020_10028+0x14>)
    2478:	f7ff fff4 	bl	2464 <print_control>
	k_thread_user_mode_enter(user, NULL, NULL, NULL);
    247c:	2300      	movs	r3, #0
    247e:	461a      	mov	r2, r3
    2480:	4619      	mov	r1, r3
    2482:	4802      	ldr	r0, [pc, #8]	; (248c <zephyr_cve_2020_10028+0x18>)
    2484:	f00d fa14 	bl	f8b0 <k_thread_user_mode_enter>
    2488:	00016af3 	.word	0x00016af3
    248c:	0000256d 	.word	0x0000256d

00002490 <escalate>:
	print_control("escalated");
    2490:	4801      	ldr	r0, [pc, #4]	; (2498 <escalate+0x8>)
    2492:	f7ff bfe7 	b.w	2464 <print_control>
    2496:	bf00      	nop
    2498:	000168e6 	.word	0x000168e6

0000249c <zephyr_cve_2020_10063>:
{
    249c:	b570      	push	{r4, r5, r6, lr}
	unsigned char testcase[] = {
    249e:	4a17      	ldr	r2, [pc, #92]	; (24fc <zephyr_cve_2020_10063+0x60>)
{
    24a0:	b088      	sub	sp, #32
	unsigned char testcase[] = {
    24a2:	6810      	ldr	r0, [r2, #0]
    24a4:	6851      	ldr	r1, [r2, #4]
    24a6:	ab02      	add	r3, sp, #8
    24a8:	c303      	stmia	r3!, {r0, r1}
	testcase[5] = testcase[6] = 1;
    24aa:	2401      	movs	r4, #1
	DEBUG_LOG("vul func addr: 0x%08x\n", coap_packet_parse);
    24ac:	4914      	ldr	r1, [pc, #80]	; (2500 <zephyr_cve_2020_10063+0x64>)
    24ae:	4815      	ldr	r0, [pc, #84]	; (2504 <zephyr_cve_2020_10063+0x68>)
	testcase[5] = testcase[6] = 1;
    24b0:	f88d 400e 	strb.w	r4, [sp, #14]
    24b4:	f88d 400d 	strb.w	r4, [sp, #13]
	DEBUG_LOG("vul func addr: 0x%08x\n", coap_packet_parse);
    24b8:	f00d fd49 	bl	ff4e <debug_log>
	int eid = profile_add_event("coap start");
    24bc:	4812      	ldr	r0, [pc, #72]	; (2508 <zephyr_cve_2020_10063+0x6c>)
    24be:	f001 f937 	bl	3730 <profile_add_event>
	profile_start(EV0);
    24c2:	2000      	movs	r0, #0
    24c4:	f001 f964 	bl	3790 <profile_start>
	profile_end(EV0);
    24c8:	2000      	movs	r0, #0
    24ca:	f001 f96b 	bl	37a4 <profile_end>
	ret = coap_packet_parse(&pkt, testcase, sizeof(testcase), NULL, 0);
    24ce:	2500      	movs	r5, #0
    24d0:	2208      	movs	r2, #8
    24d2:	eb0d 0102 	add.w	r1, sp, r2
    24d6:	462b      	mov	r3, r5
    24d8:	9500      	str	r5, [sp, #0]
    24da:	a804      	add	r0, sp, #16
    24dc:	f010 f9b1 	bl	12842 <coap_packet_parse>
    24e0:	4606      	mov	r6, r0
	profile_dump(EV0);
    24e2:	4628      	mov	r0, r5
    24e4:	f001 f97e 	bl	37e4 <profile_dump>
	profile_dump(EV1);
    24e8:	4620      	mov	r0, r4
    24ea:	f001 f97b 	bl	37e4 <profile_dump>
	DEBUG_LOG("ret = %d\n", ret);
    24ee:	4631      	mov	r1, r6
    24f0:	4806      	ldr	r0, [pc, #24]	; (250c <zephyr_cve_2020_10063+0x70>)
    24f2:	f00d fd2c 	bl	ff4e <debug_log>
}
    24f6:	b008      	add	sp, #32
    24f8:	bd70      	pop	{r4, r5, r6, pc}
    24fa:	bf00      	nop
    24fc:	00016488 	.word	0x00016488
    2500:	00012843 	.word	0x00012843
    2504:	00016afa 	.word	0x00016afa
    2508:	00016b11 	.word	0x00016b11
    250c:	00016b1c 	.word	0x00016b1c

00002510 <this_is_cve_trigger_func>:
static void this_is_cve_trigger_func(void) {
    2510:	b510      	push	{r4, lr}
	DEBUG_LOG("run test_func: 0x%08x\n", (uint32_t) test_dynamic_bug);
    2512:	4910      	ldr	r1, [pc, #64]	; (2554 <this_is_cve_trigger_func+0x44>)
    2514:	4810      	ldr	r0, [pc, #64]	; (2558 <this_is_cve_trigger_func+0x48>)
    2516:	f00d fd1a 	bl	ff4e <debug_log>
	int eid = profile_add_event("dummy cve start");
    251a:	4810      	ldr	r0, [pc, #64]	; (255c <this_is_cve_trigger_func+0x4c>)
    251c:	f001 f908 	bl	3730 <profile_add_event>
		profile_start(0);
    2520:	2000      	movs	r0, #0
    2522:	f001 f935 	bl	3790 <profile_start>
		int v = test_dynamic_bug(inputs[i]);
    2526:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
    252a:	f000 fbff 	bl	2d2c <test_dynamic_bug>
    252e:	4604      	mov	r4, r0
		profile_end(0);
    2530:	2000      	movs	r0, #0
    2532:	f001 f937 	bl	37a4 <profile_end>
		profile_dump(0);
    2536:	2000      	movs	r0, #0
    2538:	f001 f954 	bl	37e4 <profile_dump>
		DEBUG_LOG("[%04d] is bug fixed? %s\n", i, v == 0 ? "yes": "no");
    253c:	4a08      	ldr	r2, [pc, #32]	; (2560 <this_is_cve_trigger_func+0x50>)
    253e:	4b09      	ldr	r3, [pc, #36]	; (2564 <this_is_cve_trigger_func+0x54>)
    2540:	4809      	ldr	r0, [pc, #36]	; (2568 <this_is_cve_trigger_func+0x58>)
    2542:	2c00      	cmp	r4, #0
    2544:	bf18      	it	ne
    2546:	461a      	movne	r2, r3
    2548:	2101      	movs	r1, #1
}
    254a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		DEBUG_LOG("[%04d] is bug fixed? %s\n", i, v == 0 ? "yes": "no");
    254e:	f00d bcfe 	b.w	ff4e <debug_log>
    2552:	bf00      	nop
    2554:	00002d2d 	.word	0x00002d2d
    2558:	00016aae 	.word	0x00016aae
    255c:	00016ac5 	.word	0x00016ac5
    2560:	00016aa7 	.word	0x00016aa7
    2564:	00016aab 	.word	0x00016aab
    2568:	00016ad5 	.word	0x00016ad5

0000256c <user>:
static void user(void *p1, void *p2, void *p3) {
    256c:	b500      	push	{lr}
	print_control("user");
    256e:	4808      	ldr	r0, [pc, #32]	; (2590 <user+0x24>)
static void user(void *p1, void *p2, void *p3) {
    2570:	b08b      	sub	sp, #44	; 0x2c
	print_control("user");
    2572:	f7ff ff77 	bl	2464 <print_control>

	if (api->enable_callback == NULL) {
		return -ENOTSUP;
	}

	return api->enable_callback(port, access_op, pin);
    2576:	2200      	movs	r2, #0
	api.enable_callback = (void*)escalate;
    2578:	4b06      	ldr	r3, [pc, #24]	; (2594 <user+0x28>)
    257a:	9307      	str	r3, [sp, #28]
    257c:	4611      	mov	r1, r2
	port.driver_api = &api;
    257e:	ab03      	add	r3, sp, #12
    2580:	4668      	mov	r0, sp
    2582:	9301      	str	r3, [sp, #4]
    2584:	f7ff ff84 	bl	2490 <escalate>
}
    2588:	b00b      	add	sp, #44	; 0x2c
    258a:	f85d fb04 	ldr.w	pc, [sp], #4
    258e:	bf00      	nop
    2590:	00016aee 	.word	0x00016aee
    2594:	00002491 	.word	0x00002491

00002598 <run_test_by_id>:

void run_test_by_id(run_test_t cid) {
	int ncmd = sizeof(cmds) / sizeof(struct cli_cmd);
	if (cid > ncmd) {
    2598:	2806      	cmp	r0, #6
void run_test_by_id(run_test_t cid) {
    259a:	b510      	push	{r4, lr}
    259c:	4601      	mov	r1, r0
	if (cid > ncmd) {
    259e:	d906      	bls.n	25ae <run_test_by_id+0x16>
		shell_printf("Unsupport command: %d\n", cid);
    25a0:	480d      	ldr	r0, [pc, #52]	; (25d8 <run_test_by_id+0x40>)
    25a2:	f7ff ff31 	bl	2408 <shell_printf>
			cmd->func();
		} else {
			shell_printf("cmd:%d {%s} is not implement\n", cmd->idx, cmd->help);
		}
	}
}
    25a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		cli_print_help();
    25aa:	f7ff bf43 	b.w	2434 <cli_print_help>
		if (cmd->func != NULL) {
    25ae:	4a0b      	ldr	r2, [pc, #44]	; (25dc <run_test_by_id+0x44>)
    25b0:	230c      	movs	r3, #12
    25b2:	4359      	muls	r1, r3
    25b4:	1853      	adds	r3, r2, r1
    25b6:	5851      	ldr	r1, [r2, r1]
    25b8:	685c      	ldr	r4, [r3, #4]
    25ba:	689a      	ldr	r2, [r3, #8]
    25bc:	b134      	cbz	r4, 25cc <run_test_by_id+0x34>
			shell_printf("run cmd: %d {%s}\n", cmd->idx, cmd->help);
    25be:	4808      	ldr	r0, [pc, #32]	; (25e0 <run_test_by_id+0x48>)
    25c0:	f7ff ff22 	bl	2408 <shell_printf>
			cmd->func();
    25c4:	4623      	mov	r3, r4
}
    25c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			cmd->func();
    25ca:	4718      	bx	r3
			shell_printf("cmd:%d {%s} is not implement\n", cmd->idx, cmd->help);
    25cc:	4805      	ldr	r0, [pc, #20]	; (25e4 <run_test_by_id+0x4c>)
}
    25ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			shell_printf("cmd:%d {%s} is not implement\n", cmd->idx, cmd->help);
    25d2:	f7ff bf19 	b.w	2408 <shell_printf>
    25d6:	bf00      	nop
    25d8:	000169c5 	.word	0x000169c5
    25dc:	000165a0 	.word	0x000165a0
    25e0:	000169dc 	.word	0x000169dc
    25e4:	000169ee 	.word	0x000169ee

000025e8 <run_shell_cli>:
#endif
	run_ebpf_eva(vid);
}


void run_shell_cli(void) {
    25e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    25ec:	b086      	sub	sp, #24
	// extern uint32_t SystemCoreClock;
	// shell_printf("SystemCoreClock: %d\n", SystemCoreClock);
	memset(&shell_cli, 0, sizeof(shell_cli));
    25ee:	2284      	movs	r2, #132	; 0x84
    25f0:	2100      	movs	r1, #0
    25f2:	4869      	ldr	r0, [pc, #420]	; (2798 <run_shell_cli+0x1b0>)
	cli_print_help();
	shell_echo_str(SHELL_PROMPT);
	exit_shell = false;
    25f4:	4e69      	ldr	r6, [pc, #420]	; (279c <run_shell_cli+0x1b4>)
	shell_echo_str(SHELL_PROMPT);
    25f6:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 27a0 <run_shell_cli+0x1b8>
	if (strcmp(argv[0], "q") == 0 ) {
    25fa:	f8df 91e4 	ldr.w	r9, [pc, #484]	; 27e0 <run_shell_cli+0x1f8>
void run_shell_cli(void) {
    25fe:	af00      	add	r7, sp, #0
	memset(&shell_cli, 0, sizeof(shell_cli));
    2600:	f7ff fdf3 	bl	21ea <memset>
	cli_print_help();
    2604:	f7ff ff16 	bl	2434 <cli_print_help>
	shell_echo_str(SHELL_PROMPT);
    2608:	4865      	ldr	r0, [pc, #404]	; (27a0 <run_shell_cli+0x1b8>)
    260a:	f00d fbb2 	bl	fd72 <shell_echo_str>
	exit_shell = false;
    260e:	2300      	movs	r3, #0
    2610:	7033      	strb	r3, [r6, #0]
	while (!exit_shell) {
		char c = shell_get_char();
    2612:	f00d fbbd 	bl	fd90 <shell_get_char>
    2616:	4604      	mov	r4, r0
	shell_put_char(c);
    2618:	f00d fbbf 	bl	fd9a <shell_put_char>
	if (c == '\r' || shell_cli.rx_pos >= SHELL_BUFFER_SIZE) {
    261c:	2c0d      	cmp	r4, #13
    261e:	d046      	beq.n	26ae <run_shell_cli+0xc6>
    2620:	4b5d      	ldr	r3, [pc, #372]	; (2798 <run_shell_cli+0x1b0>)
    2622:	6818      	ldr	r0, [r3, #0]
    2624:	287f      	cmp	r0, #127	; 0x7f
    2626:	d842      	bhi.n	26ae <run_shell_cli+0xc6>
	shell_cli.rx_buffer[shell_cli.rx_pos++] = c;
    2628:	1c45      	adds	r5, r0, #1
    262a:	601d      	str	r5, [r3, #0]
    262c:	4403      	add	r3, r0
	if (shell_last_char() != '\n' && shell_last_char() != '\r') {
    262e:	2c0a      	cmp	r4, #10
	shell_cli.rx_buffer[shell_cli.rx_pos++] = c;
    2630:	711c      	strb	r4, [r3, #4]
static void shell_process() {
    2632:	46ea      	mov	sl, sp
	if (shell_last_char() != '\n' && shell_last_char() != '\r') {
    2634:	d13b      	bne.n	26ae <run_shell_cli+0xc6>
    2636:	2300      	movs	r3, #0
    2638:	495a      	ldr	r1, [pc, #360]	; (27a4 <run_shell_cli+0x1bc>)
    263a:	461a      	mov	r2, r3
    263c:	461c      	mov	r4, r3
			*cur = '\0';
    263e:	469e      	mov	lr, r3
	for (int i = 0; i < shell_cli.rx_pos && argc < max_args; i++) {
    2640:	429d      	cmp	r5, r3
    2642:	d929      	bls.n	2698 <run_shell_cli+0xb0>
    2644:	2c04      	cmp	r4, #4
    2646:	dd0b      	ble.n	2660 <run_shell_cli+0x78>
	if (strcmp(argv[0], "q") == 0 ) {
    2648:	687d      	ldr	r5, [r7, #4]
    264a:	4649      	mov	r1, r9
    264c:	4628      	mov	r0, r5
    264e:	f7ff fde1 	bl	2214 <strcmp>
    2652:	bb98      	cbnz	r0, 26bc <run_shell_cli+0xd4>
		exit_shell = true;
    2654:	2301      	movs	r3, #1
		DEBUG_LOG("Exit shell mode!\n");
    2656:	4854      	ldr	r0, [pc, #336]	; (27a8 <run_shell_cli+0x1c0>)
		exit_shell = true;
    2658:	7033      	strb	r3, [r6, #0]
		DEBUG_LOG("Exit shell mode!\n");
    265a:	f00d fc78 	bl	ff4e <debug_log>
		return;
    265e:	e01d      	b.n	269c <run_shell_cli+0xb4>
		if (*cur == '\n' || *cur == ' ' || i == shell_cli.rx_pos - 1) {
    2660:	f891 c000 	ldrb.w	ip, [r1]
    2664:	f1bc 0f0a 	cmp.w	ip, #10
    2668:	d004      	beq.n	2674 <run_shell_cli+0x8c>
    266a:	f1bc 0f20 	cmp.w	ip, #32
    266e:	d001      	beq.n	2674 <run_shell_cli+0x8c>
    2670:	4298      	cmp	r0, r3
    2672:	d10d      	bne.n	2690 <run_shell_cli+0xa8>
			*cur = '\0';
    2674:	f881 e000 	strb.w	lr, [r1]
			if (next_arg) {
    2678:	b13a      	cbz	r2, 268a <run_shell_cli+0xa2>
				argv[argc++] = next_arg;
    267a:	f107 0c18 	add.w	ip, r7, #24
    267e:	eb0c 0c84 	add.w	ip, ip, r4, lsl #2
    2682:	3401      	adds	r4, #1
    2684:	f84c 2c14 	str.w	r2, [ip, #-20]
				next_arg = NULL;
    2688:	2200      	movs	r2, #0
	for (int i = 0; i < shell_cli.rx_pos && argc < max_args; i++) {
    268a:	3301      	adds	r3, #1
    268c:	3101      	adds	r1, #1
    268e:	e7d7      	b.n	2640 <run_shell_cli+0x58>
		} else if (next_arg == NULL){
    2690:	2a00      	cmp	r2, #0
    2692:	bf08      	it	eq
    2694:	460a      	moveq	r2, r1
    2696:	e7f8      	b.n	268a <run_shell_cli+0xa2>
	if (argc > 0) {
    2698:	2c00      	cmp	r4, #0
    269a:	d1d5      	bne.n	2648 <run_shell_cli+0x60>
	memset(&shell_cli, 0, sizeof(shell_cli));
    269c:	2284      	movs	r2, #132	; 0x84
    269e:	2100      	movs	r1, #0
    26a0:	483d      	ldr	r0, [pc, #244]	; (2798 <run_shell_cli+0x1b0>)
    26a2:	f7ff fda2 	bl	21ea <memset>
	shell_echo_str(SHELL_PROMPT);
    26a6:	4640      	mov	r0, r8
    26a8:	f00d fb63 	bl	fd72 <shell_echo_str>
    26ac:	46d5      	mov	sp, sl
	while (!exit_shell) {
    26ae:	7833      	ldrb	r3, [r6, #0]
    26b0:	2b00      	cmp	r3, #0
    26b2:	d0ae      	beq.n	2612 <run_shell_cli+0x2a>
		shell_receive_char(c);
	}
}
    26b4:	3718      	adds	r7, #24
    26b6:	46bd      	mov	sp, r7
    26b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (strcmp(argv[0], "h") == 0 || strcmp(argv[0], "help") == 0) {
    26bc:	493b      	ldr	r1, [pc, #236]	; (27ac <run_shell_cli+0x1c4>)
    26be:	4628      	mov	r0, r5
    26c0:	f7ff fda8 	bl	2214 <strcmp>
    26c4:	b910      	cbnz	r0, 26cc <run_shell_cli+0xe4>
		cli_print_help();
    26c6:	f7ff feb5 	bl	2434 <cli_print_help>
    26ca:	e7e7      	b.n	269c <run_shell_cli+0xb4>
	if (strcmp(argv[0], "h") == 0 || strcmp(argv[0], "help") == 0) {
    26cc:	4938      	ldr	r1, [pc, #224]	; (27b0 <run_shell_cli+0x1c8>)
    26ce:	4628      	mov	r0, r5
    26d0:	f7ff fda0 	bl	2214 <strcmp>
    26d4:	2800      	cmp	r0, #0
    26d6:	d0f6      	beq.n	26c6 <run_shell_cli+0xde>
	} else if (strcmp(argv[0], "run") == 0) {
    26d8:	4936      	ldr	r1, [pc, #216]	; (27b4 <run_shell_cli+0x1cc>)
    26da:	4628      	mov	r0, r5
    26dc:	f7ff fd9a 	bl	2214 <strcmp>
    26e0:	b940      	cbnz	r0, 26f4 <run_shell_cli+0x10c>
		if (argc >= 2) {
    26e2:	2c01      	cmp	r4, #1
    26e4:	d0da      	beq.n	269c <run_shell_cli+0xb4>
			int rid = str2int(argv[1]);
    26e6:	68b8      	ldr	r0, [r7, #8]
    26e8:	f00d fc3f 	bl	ff6a <str2int>
			run_test_by_id(rid);
    26ec:	b2c0      	uxtb	r0, r0
    26ee:	f7ff ff53 	bl	2598 <run_test_by_id>
    26f2:	e7d3      	b.n	269c <run_shell_cli+0xb4>
	} else if (strcmp(argv[0], "trigger") == 0) {
    26f4:	4930      	ldr	r1, [pc, #192]	; (27b8 <run_shell_cli+0x1d0>)
    26f6:	4628      	mov	r0, r5
    26f8:	f7ff fd8c 	bl	2214 <strcmp>
    26fc:	b9a8      	cbnz	r0, 272a <run_shell_cli+0x142>
		if (argc >= 2) {
    26fe:	2c01      	cmp	r4, #1
    2700:	d00f      	beq.n	2722 <run_shell_cli+0x13a>
			int tid = str2int(argv[1]);
    2702:	68b8      	ldr	r0, [r7, #8]
    2704:	f00d fc31 	bl	ff6a <str2int>
	if (tid >= n) {
    2708:	2802      	cmp	r0, #2
			int tid = str2int(argv[1]);
    270a:	4601      	mov	r1, r0
	if (tid >= n) {
    270c:	dd04      	ble.n	2718 <run_shell_cli+0x130>
		DEBUG_LOG("ERROR: trigger index out of range %d >= %d\n", tid, n);
    270e:	482b      	ldr	r0, [pc, #172]	; (27bc <run_shell_cli+0x1d4>)
    2710:	2203      	movs	r2, #3
		DEBUG_LOG("Command not find: %s argc: %d\n", argv[0], argc);
    2712:	f00d fc1c 	bl	ff4e <debug_log>
    2716:	e7c1      	b.n	269c <run_shell_cli+0xb4>
	dynamic_trigger_func_list[tid]();
    2718:	4b29      	ldr	r3, [pc, #164]	; (27c0 <run_shell_cli+0x1d8>)
    271a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    271e:	4798      	blx	r3
    2720:	e7bc      	b.n	269c <run_shell_cli+0xb4>
			shell_printf("Usage: trigger [cve]\n");
    2722:	4828      	ldr	r0, [pc, #160]	; (27c4 <run_shell_cli+0x1dc>)
			shell_printf("Usage: vm [cve]\n");
    2724:	f7ff fe70 	bl	2408 <shell_printf>
    2728:	e7b8      	b.n	269c <run_shell_cli+0xb4>
	} else if (strcmp(argv[0], "patch") == 0) {
    272a:	4927      	ldr	r1, [pc, #156]	; (27c8 <run_shell_cli+0x1e0>)
    272c:	4628      	mov	r0, r5
    272e:	f7ff fd71 	bl	2214 <strcmp>
    2732:	b9f0      	cbnz	r0, 2772 <run_shell_cli+0x18a>
		if (argc >= 2) {
    2734:	2c01      	cmp	r4, #1
    2736:	d013      	beq.n	2760 <run_shell_cli+0x178>
			int pid = str2int(argv[1]);
    2738:	68b8      	ldr	r0, [r7, #8]
    273a:	f00d fc16 	bl	ff6a <str2int>
    273e:	4604      	mov	r4, r0
	DEBUG_LOG("Use Dynamic Patch Points\n");	
    2740:	4822      	ldr	r0, [pc, #136]	; (27cc <run_shell_cli+0x1e4>)
    2742:	f00d fc04 	bl	ff4e <debug_log>
	show_local_patch_desc();
    2746:	f000 faff 	bl	2d48 <show_local_patch_desc>
	set_patch_mode(CORTEX_DEB_MON_PATCH);
    274a:	2001      	movs	r0, #1
    274c:	f000 fa5a 	bl	2c04 <set_patch_mode>
	read_local_patch(pid);
    2750:	4620      	mov	r0, r4
    2752:	f000 fb0f 	bl	2d74 <read_local_patch>
	show_hw_bkpt();
    2756:	f000 f88f 	bl	2878 <show_hw_bkpt>
	show_all_patches();
    275a:	f000 ff4d 	bl	35f8 <show_all_patches>
    275e:	e79d      	b.n	269c <run_shell_cli+0xb4>
			shell_printf("Usage: patch [cve]\n");
    2760:	481b      	ldr	r0, [pc, #108]	; (27d0 <run_shell_cli+0x1e8>)
    2762:	f7ff fe51 	bl	2408 <shell_printf>
	DEBUG_LOG("Use Dynamic Patch Points\n");	
    2766:	4819      	ldr	r0, [pc, #100]	; (27cc <run_shell_cli+0x1e4>)
    2768:	f00d fbf1 	bl	ff4e <debug_log>
	show_local_patch_desc();
    276c:	f000 faec 	bl	2d48 <show_local_patch_desc>
    2770:	e794      	b.n	269c <run_shell_cli+0xb4>
	} else if (strcmp(argv[0], "vm") == 0) {
    2772:	4918      	ldr	r1, [pc, #96]	; (27d4 <run_shell_cli+0x1ec>)
    2774:	4628      	mov	r0, r5
    2776:	f7ff fd4d 	bl	2214 <strcmp>
    277a:	b948      	cbnz	r0, 2790 <run_shell_cli+0x1a8>
		if (argc >= 2) {
    277c:	2c01      	cmp	r4, #1
    277e:	d005      	beq.n	278c <run_shell_cli+0x1a4>
			int tid = str2int(argv[1]);
    2780:	68b8      	ldr	r0, [r7, #8]
    2782:	f00d fbf2 	bl	ff6a <str2int>
	run_ebpf_eva(vid);
    2786:	f000 fd11 	bl	31ac <run_ebpf_eva>
    278a:	e787      	b.n	269c <run_shell_cli+0xb4>
			shell_printf("Usage: vm [cve]\n");
    278c:	4812      	ldr	r0, [pc, #72]	; (27d8 <run_shell_cli+0x1f0>)
    278e:	e7c9      	b.n	2724 <run_shell_cli+0x13c>
		DEBUG_LOG("Command not find: %s argc: %d\n", argv[0], argc);
    2790:	4622      	mov	r2, r4
    2792:	4629      	mov	r1, r5
    2794:	4811      	ldr	r0, [pc, #68]	; (27dc <run_shell_cli+0x1f4>)
    2796:	e7bc      	b.n	2712 <run_shell_cli+0x12a>
    2798:	20002058 	.word	0x20002058
    279c:	200056ac 	.word	0x200056ac
    27a0:	00016904 	.word	0x00016904
    27a4:	2000205c 	.word	0x2000205c
    27a8:	00016907 	.word	0x00016907
    27ac:	00017912 	.word	0x00017912
    27b0:	00016919 	.word	0x00016919
    27b4:	0001691e 	.word	0x0001691e
    27b8:	00016a33 	.word	0x00016a33
    27bc:	00016922 	.word	0x00016922
    27c0:	20010c58 	.word	0x20010c58
    27c4:	0001694e 	.word	0x0001694e
    27c8:	00017091 	.word	0x00017091
    27cc:	00016964 	.word	0x00016964
    27d0:	0001697e 	.word	0x0001697e
    27d4:	00016992 	.word	0x00016992
    27d8:	00016995 	.word	0x00016995
    27dc:	000169a6 	.word	0x000169a6
    27e0:	000189c3 	.word	0x000189c3

000027e4 <FPB_Handler0>:
//		__asm__ __volatile__("BX LR"); \


//DECLARE_FPB_HANDLE(0);
void FPB_Handler0(void)
{
    27e4:	b508      	push	{r3, lr}
	__asm__("NOP");
    27e6:	bf00      	nop
	__asm__("NOP");
    27e8:	bf00      	nop
	__asm__("NOP");
    27ea:	bf00      	nop
	__asm__("NOP");
    27ec:	bf00      	nop
	__asm__("PUSH {r0-r3, r12, lr}");
    27ee:	e92d 500f 	stmdb	sp!, {r0, r1, r2, r3, ip, lr}
	DEBUG_LOG("FPB_Handler0\n");
    27f2:	4809      	ldr	r0, [pc, #36]	; (2818 <FPB_Handler0+0x34>)
    27f4:	f00d fbab 	bl	ff4e <debug_log>
//	fpb_trampoline_0();
//	IMPORT leave_fpb_bpkt
//	__asm__("PUSH {r3, lr}");
	__asm__("TST lr, #4");
    27f8:	f01e 0f04 	tst.w	lr, #4
	__asm__("ITE EQ");
    27fc:	bf0c      	ite	eq
	__asm__("MRSEQ r0, MSP");
    27fe:	f3ef 8008 	mrseq	r0, MSP
	__asm__("MRSNE r0, PSP");
    2802:	f3ef 8009 	mrsne	r0, PSP
	__asm__("MOVS r1, #0");
    2806:	2100      	movs	r1, #0
	__asm__("BL leave_fpb_bpkt");
    2808:	f00d fb49 	bl	fe9e <leave_fpb_bpkt>
	// todo: return in other address
	__asm__("MOV r5, r0");
    280c:	4605      	mov	r5, r0
	__asm__("POP {r0-r3, r12, lr}");
    280e:	e8bd 500f 	ldmia.w	sp!, {r0, r1, r2, r3, ip, lr}
//	DEBUG_LOG("exit FPB_Handler0\n");
	__asm__("MOV PC, r5");
    2812:	46af      	mov	pc, r5
//	__asm__("BX LR");
//	__asm__("pop	{r3, pc}");
//	return 0;
}
    2814:	bd08      	pop	{r3, pc}
    2816:	bf00      	nop
    2818:	00016b26 	.word	0x00016b26

0000281c <RawBuggyFunc>:
	add_hw_bkpt(inst);
	DEBUG_LOG("add dynamic point to: 0x%08x\n", inst);
	show_hw_bkpt();
}

static void RawBuggyFunc() {
    281c:	b508      	push	{r3, lr}
	DEBUG_LOG("enter RawBuggyFunc\n");
    281e:	4804      	ldr	r0, [pc, #16]	; (2830 <RawBuggyFunc+0x14>)
    2820:	f00d fb95 	bl	ff4e <debug_log>
	DEBUG_LOG("exit RawBuggyFunc\n");
    2824:	4803      	ldr	r0, [pc, #12]	; (2834 <RawBuggyFunc+0x18>)
}
    2826:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	DEBUG_LOG("exit RawBuggyFunc\n");
    282a:	f00d bb90 	b.w	ff4e <debug_log>
    282e:	bf00      	nop
    2830:	00016b34 	.word	0x00016b34
    2834:	00016b48 	.word	0x00016b48

00002838 <test_freertos_cve>:
	IPHeader_t xIPHeader;
} IPPacket_t;
static int freertos_cve_func(const IPPacket_t * const pxIPPacket, NetworkBufferDescriptor_t * const pxNetworkBuffer);

// compare with HERA
static void test_freertos_cve() {
    2838:	b508      	push	{r3, lr}
		}
	};
	NetworkBufferDescriptor_t data = {
		.xDataLength = 0,
	};
	profile_add_event("HERA Compare");
    283a:	480d      	ldr	r0, [pc, #52]	; (2870 <test_freertos_cve+0x38>)
    283c:	f000 ff78 	bl	3730 <profile_add_event>
	
	profile_start(0);
    2840:	2000      	movs	r0, #0
    2842:	f000 ffa5 	bl	3790 <profile_start>
	int t = freertos_cve_func(&pkt, &data);
	profile_end(0);
    2846:	2000      	movs	r0, #0
    2848:	f000 ffac 	bl	37a4 <profile_end>
	
	profile_dump(0);
    284c:	2000      	movs	r0, #0
    284e:	f000 ffc9 	bl	37e4 <profile_dump>
	
	profile_start(1);
    2852:	2001      	movs	r0, #1
    2854:	f000 ff9c 	bl	3790 <profile_start>
	
	profile_end(1);
    2858:	2001      	movs	r0, #1
    285a:	f000 ffa3 	bl	37a4 <profile_end>
	hera_fix_func(&pkt, &data);
	profile_dump(1);
    285e:	2001      	movs	r0, #1
    2860:	f000 ffc0 	bl	37e4 <profile_dump>
	DEBUG_LOG("bug func: %d\n", t);
    2864:	2100      	movs	r1, #0
    2866:	4803      	ldr	r0, [pc, #12]	; (2874 <test_freertos_cve+0x3c>)
}
    2868:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	DEBUG_LOG("bug func: %d\n", t);
    286c:	f00d bb6f 	b.w	ff4e <debug_log>
    2870:	00016d40 	.word	0x00016d40
    2874:	00016d4d 	.word	0x00016d4d

00002878 <show_hw_bkpt>:
	DEBUG_LOG("Dump current hardware breakpoints, MODE-%s:\n", REMAP_ADDR.active ? "FPB" : "debug monitor");
    2878:	4b13      	ldr	r3, [pc, #76]	; (28c8 <show_hw_bkpt+0x50>)
void show_hw_bkpt(void) {
    287a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	DEBUG_LOG("Dump current hardware breakpoints, MODE-%s:\n", REMAP_ADDR.active ? "FPB" : "debug monitor");
    287c:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
    2880:	4a12      	ldr	r2, [pc, #72]	; (28cc <show_hw_bkpt+0x54>)
    2882:	4b13      	ldr	r3, [pc, #76]	; (28d0 <show_hw_bkpt+0x58>)
    2884:	4813      	ldr	r0, [pc, #76]	; (28d4 <show_hw_bkpt+0x5c>)
		const uint32_t fp_comp = FPB->COMP[i];
    2886:	4e14      	ldr	r6, [pc, #80]	; (28d8 <show_hw_bkpt+0x60>)
		uint32_t inst_addr = fp_comp & 0x1FFFFFFC;
    2888:	4f14      	ldr	r7, [pc, #80]	; (28dc <show_hw_bkpt+0x64>)
		DEBUG_LOG("  FP_COMP[%d] Enabled %d, Replace: %d, Address 0x%x\n",(int)i, (int)enabled, (int)replace, inst_addr);
    288a:	4d15      	ldr	r5, [pc, #84]	; (28e0 <show_hw_bkpt+0x68>)
	DEBUG_LOG("Dump current hardware breakpoints, MODE-%s:\n", REMAP_ADDR.active ? "FPB" : "debug monitor");
    288c:	2900      	cmp	r1, #0
    288e:	bf14      	ite	ne
    2890:	4611      	movne	r1, r2
    2892:	4619      	moveq	r1, r3
    2894:	f00d fb5b 	bl	ff4e <debug_log>
	for (int i = 0; i < MAX_BP; i++) {
    2898:	2400      	movs	r4, #0
		const uint32_t fp_comp = FPB->COMP[i];
    289a:	1ca3      	adds	r3, r4, #2
		DEBUG_LOG("  FP_COMP[%d] Enabled %d, Replace: %d, Address 0x%x\n",(int)i, (int)enabled, (int)replace, inst_addr);
    289c:	4628      	mov	r0, r5
		const uint32_t fp_comp = FPB->COMP[i];
    289e:	f856 1023 	ldr.w	r1, [r6, r3, lsl #2]
		const uint32_t replace = fp_comp >> 30;
    28a2:	0f8b      	lsrs	r3, r1, #30
		if (replace == 0x2) {
    28a4:	2b02      	cmp	r3, #2
		const int enabled = fp_comp & 0x1;
    28a6:	f001 0201 	and.w	r2, r1, #1
		uint32_t inst_addr = fp_comp & 0x1FFFFFFC;
    28aa:	ea01 0107 	and.w	r1, r1, r7
		  inst_addr |= 0x2;
    28ae:	bf08      	it	eq
    28b0:	f041 0102 	orreq.w	r1, r1, #2
		DEBUG_LOG("  FP_COMP[%d] Enabled %d, Replace: %d, Address 0x%x\n",(int)i, (int)enabled, (int)replace, inst_addr);
    28b4:	9100      	str	r1, [sp, #0]
    28b6:	4621      	mov	r1, r4
	for (int i = 0; i < MAX_BP; i++) {
    28b8:	3401      	adds	r4, #1
		DEBUG_LOG("  FP_COMP[%d] Enabled %d, Replace: %d, Address 0x%x\n",(int)i, (int)enabled, (int)replace, inst_addr);
    28ba:	f00d fb48 	bl	ff4e <debug_log>
	for (int i = 0; i < MAX_BP; i++) {
    28be:	2c06      	cmp	r4, #6
    28c0:	d1eb      	bne.n	289a <show_hw_bkpt+0x22>
}
    28c2:	b003      	add	sp, #12
    28c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    28c6:	bf00      	nop
    28c8:	200020dc 	.word	0x200020dc
    28cc:	00016c4a 	.word	0x00016c4a
    28d0:	00016c4e 	.word	0x00016c4e
    28d4:	00016c5c 	.word	0x00016c5c
    28d8:	e0002000 	.word	0xe0002000
    28dc:	1ffffffc 	.word	0x1ffffffc
    28e0:	00016c89 	.word	0x00016c89

000028e4 <add_hw_bkpt>:
int add_hw_bkpt(uint32_t inst_addr) {
    28e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!bpkt_is_init) {
    28e8:	4b68      	ldr	r3, [pc, #416]	; (2a8c <add_hw_bkpt+0x1a8>)
    28ea:	7819      	ldrb	r1, [r3, #0]
int add_hw_bkpt(uint32_t inst_addr) {
    28ec:	b08b      	sub	sp, #44	; 0x2c
    28ee:	4604      	mov	r4, r0
	if (!bpkt_is_init) {
    28f0:	b999      	cbnz	r1, 291a <add_hw_bkpt+0x36>
		bpkt_info.cur_idx = 0;
    28f2:	4a67      	ldr	r2, [pc, #412]	; (2a90 <add_hw_bkpt+0x1ac>)
    28f4:	7011      	strb	r1, [r2, #0]
		uint32_t fp_ctrl = FPB->CTRL;
    28f6:	4967      	ldr	r1, [pc, #412]	; (2a94 <add_hw_bkpt+0x1b0>)
    28f8:	6809      	ldr	r1, [r1, #0]
		bpkt_info.bpkt_num = get_hw_bkpt_num();
    28fa:	2106      	movs	r1, #6
    28fc:	7051      	strb	r1, [r2, #1]
	if (inst_addr >= 0x20000000) {
    28fe:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
		bpkt_is_init = true;
    2902:	f04f 0201 	mov.w	r2, #1
    2906:	701a      	strb	r2, [r3, #0]
	if (inst_addr >= 0x20000000) {
    2908:	d310      	bcc.n	292c <add_hw_bkpt+0x48>
		DEBUG_LOG("Cannot add breakpoint in RAM.\n");
    290a:	4863      	ldr	r0, [pc, #396]	; (2a98 <add_hw_bkpt+0x1b4>)
    290c:	f00d fb1f 	bl	ff4e <debug_log>
		return -1;
    2910:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    2914:	b00b      	add	sp, #44	; 0x2c
    2916:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (inst_addr >= 0x20000000) {
    291a:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
    291e:	d2f4      	bcs.n	290a <add_hw_bkpt+0x26>
	if (bpkt_info.cur_idx >= MAX_BP) {
    2920:	4b5b      	ldr	r3, [pc, #364]	; (2a90 <add_hw_bkpt+0x1ac>)
    2922:	781a      	ldrb	r2, [r3, #0]
    2924:	2a05      	cmp	r2, #5
		bpkt_info.cur_idx = 0;
    2926:	bf84      	itt	hi
    2928:	2200      	movhi	r2, #0
    292a:	701a      	strbhi	r2, [r3, #0]
	if (REMAP_ADDR.active) {
    292c:	f8df a178 	ldr.w	sl, [pc, #376]	; 2aa8 <add_hw_bkpt+0x1c4>
    2930:	4d57      	ldr	r5, [pc, #348]	; (2a90 <add_hw_bkpt+0x1ac>)
    2932:	f89a 0028 	ldrb.w	r0, [sl, #40]	; 0x28
    2936:	f004 0902 	and.w	r9, r4, #2
    293a:	2800      	cmp	r0, #0
    293c:	f000 8087 	beq.w	2a4e <add_hw_bkpt+0x16a>
	uint32_t trampolines[] = { (uint32_t) FPB_Handler0, (uint32_t) FPB_Handler1, 
    2940:	4f56      	ldr	r7, [pc, #344]	; (2a9c <add_hw_bkpt+0x1b8>)
	int idx = bpkt_info.cur_idx;
    2942:	f895 8000 	ldrb.w	r8, [r5]
	uint32_t trampolines[] = { (uint32_t) FPB_Handler0, (uint32_t) FPB_Handler1, 
    2946:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    2948:	ae04      	add	r6, sp, #16
    294a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    294c:	e897 0003 	ldmia.w	r7, {r0, r1}
	uint32_t trampoline_addr = ((trampolines[idx] & (~0x3)) + 3) & (~0x3);
    2950:	ab0a      	add	r3, sp, #40	; 0x28
	uint32_t trampolines[] = { (uint32_t) FPB_Handler0, (uint32_t) FPB_Handler1, 
    2952:	e886 0003 	stmia.w	r6, {r0, r1}
	uint32_t trampoline_addr = ((trampolines[idx] & (~0x3)) + 3) & (~0x3);
    2956:	eb03 0388 	add.w	r3, r3, r8, lsl #2
	uint32_t jump_inst = little_endian_16_bit(calc_branch_instr(inst_addr, trampoline_addr));
    295a:	4620      	mov	r0, r4
	uint32_t trampoline_addr = ((trampolines[idx] & (~0x3)) + 3) & (~0x3);
    295c:	f853 3c18 	ldr.w	r3, [r3, #-24]
    2960:	f023 0b03 	bic.w	fp, r3, #3
	uint32_t jump_inst = little_endian_16_bit(calc_branch_instr(inst_addr, trampoline_addr));
    2964:	4659      	mov	r1, fp
    2966:	f00d fa76 	bl	fe56 <calc_branch_instr>
    296a:	f00d fb12 	bl	ff92 <little_endian_16_bit>
	return ((uint32_t)(&REMAP_ADDR) + 0x1f) & (~0x1f);
    296e:	f10a 0a1f 	add.w	sl, sl, #31
    2972:	f02a 031f 	bic.w	r3, sl, #31
	inst_addr = inst_addr & (~0x1);
    2976:	f024 0701 	bic.w	r7, r4, #1
	uint32_t jump_inst = little_endian_16_bit(calc_branch_instr(inst_addr, trampoline_addr));
    297a:	4606      	mov	r6, r0
	const uint32_t PATCH_TBL = get_fpb_patch_remap();
    297c:	9303      	str	r3, [sp, #12]
	DEBUG_LOG("inst is half word: 0x%08x %d trampoline_addr: 0x%08x\n", inst_addr, inst_addr % 4, trampoline_addr);
    297e:	464a      	mov	r2, r9
    2980:	465b      	mov	r3, fp
    2982:	4639      	mov	r1, r7
    2984:	4846      	ldr	r0, [pc, #280]	; (2aa0 <add_hw_bkpt+0x1bc>)
    2986:	f00d fae2 	bl	ff4e <debug_log>
	DEBUG_LOG("[0x%08x] fpb jump to: 0x%08x inst: 0x%08x jump_inst: 0x%08x\n", &(PATCH_TBL), trampoline_addr, inst_addr, jump_inst);
    298a:	a903      	add	r1, sp, #12
    298c:	9600      	str	r6, [sp, #0]
    298e:	463b      	mov	r3, r7
    2990:	465a      	mov	r2, fp
    2992:	4844      	ldr	r0, [pc, #272]	; (2aa4 <add_hw_bkpt+0x1c0>)
    2994:	f00d fadb 	bl	ff4e <debug_log>
	if (inst_addr % 4 == 0) // Instruction is word aligned.
    2998:	7869      	ldrb	r1, [r5, #1]
    299a:	f1b9 0f00 	cmp.w	r9, #0
    299e:	d122      	bne.n	29e6 <add_hw_bkpt+0x102>
		uint32_t fp_comp = inst_addr | 0x1;
    29a0:	f047 0201 	orr.w	r2, r7, #1
		for (int i = 0; i < bpkt_info.bpkt_num; i++) {
    29a4:	4648      	mov	r0, r9
    29a6:	4288      	cmp	r0, r1
    29a8:	db0b      	blt.n	29c2 <add_hw_bkpt+0xde>
		*((uint32_t *) (PATCH_TBL + (idx * 4))) = jump_inst;
    29aa:	9b03      	ldr	r3, [sp, #12]
		FPB->COMP[bpkt_info.cur_idx] = fp_comp;
    29ac:	4939      	ldr	r1, [pc, #228]	; (2a94 <add_hw_bkpt+0x1b0>)
		*((uint32_t *) (PATCH_TBL + (idx * 4))) = jump_inst;
    29ae:	f843 6028 	str.w	r6, [r3, r8, lsl #2]
		FPB->COMP[bpkt_info.cur_idx] = fp_comp;
    29b2:	782b      	ldrb	r3, [r5, #0]
    29b4:	1c98      	adds	r0, r3, #2
		bpkt_info.cur_idx++;
    29b6:	3301      	adds	r3, #1
		FPB->COMP[bpkt_info.cur_idx] = fp_comp;
    29b8:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
		bpkt_info.cur_idx++;
    29bc:	702b      	strb	r3, [r5, #0]
	return bpkt_info.cur_idx;
    29be:	7828      	ldrb	r0, [r5, #0]
		return add_fpb_bkpt(inst_addr);
    29c0:	e7a8      	b.n	2914 <add_hw_bkpt+0x30>
			if (FPB->COMP[i] == fp_comp || FPB->COMP[i] == inst_addr) {
    29c2:	0083      	lsls	r3, r0, #2
    29c4:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    29c8:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    29cc:	689c      	ldr	r4, [r3, #8]
    29ce:	42a2      	cmp	r2, r4
    29d0:	d002      	beq.n	29d8 <add_hw_bkpt+0xf4>
    29d2:	689b      	ldr	r3, [r3, #8]
    29d4:	429f      	cmp	r7, r3
    29d6:	d104      	bne.n	29e2 <add_hw_bkpt+0xfe>
				FPB->COMP[i] = fp_comp;
    29d8:	1c83      	adds	r3, r0, #2
    29da:	492e      	ldr	r1, [pc, #184]	; (2a94 <add_hw_bkpt+0x1b0>)
    29dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				return i;
    29e0:	e798      	b.n	2914 <add_hw_bkpt+0x30>
		for (int i = 0; i < bpkt_info.bpkt_num; i++) {
    29e2:	3001      	adds	r0, #1
    29e4:	e7df      	b.n	29a6 <add_hw_bkpt+0xc2>
		uint32_t fp_comp1 = inst_addr & 0xFFFFFFFC;
    29e6:	f024 0403 	bic.w	r4, r4, #3
		uint32_t fp_comp2 = (inst_addr & 0xFFFFFFFC) + 4;
    29ea:	1d22      	adds	r2, r4, #4
		for (int i = 0; i < bpkt_info.bpkt_num - 1; i++) {
    29ec:	3901      	subs	r1, #1
    29ee:	2000      	movs	r0, #0
    29f0:	4288      	cmp	r0, r1
    29f2:	db1c      	blt.n	2a2e <add_hw_bkpt+0x14a>
		*((uint32_t *) (PATCH_TBL + idx * 4))       = ((jump_inst & 0x0000FFFF) << 16) | (old_instr[0] & 0x0000FFFF);
    29f4:	8823      	ldrh	r3, [r4, #0]
    29f6:	9903      	ldr	r1, [sp, #12]
		old_instr[1] = *((uint32_t *) ((inst_addr & 0xFFFFFFFC) + 4));
    29f8:	6860      	ldr	r0, [r4, #4]
		*((uint32_t *) (PATCH_TBL + idx * 4))       = ((jump_inst & 0x0000FFFF) << 16) | (old_instr[0] & 0x0000FFFF);
    29fa:	fa0f f888 	sxth.w	r8, r8
    29fe:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    2a02:	f841 3028 	str.w	r3, [r1, r8, lsl #2]
		*((uint32_t *) (PATCH_TBL + (idx + 1) * 4)) = (old_instr[1] & 0xFFFF0000) | ((jump_inst & 0xFFFF0000) >> 16);
    2a06:	9b03      	ldr	r3, [sp, #12]
    2a08:	0c00      	lsrs	r0, r0, #16
    2a0a:	eb03 0888 	add.w	r8, r3, r8, lsl #2
    2a0e:	0400      	lsls	r0, r0, #16
    2a10:	ea40 4016 	orr.w	r0, r0, r6, lsr #16
    2a14:	f8c8 0004 	str.w	r0, [r8, #4]
		FPB->COMP[bpkt_info.cur_idx] = fp_comp1;
    2a18:	7829      	ldrb	r1, [r5, #0]
    2a1a:	008b      	lsls	r3, r1, #2
    2a1c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    2a20:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
		bpkt_info.cur_idx += 2;
    2a24:	3102      	adds	r1, #2
		FPB->COMP[bpkt_info.cur_idx] = fp_comp1;
    2a26:	609c      	str	r4, [r3, #8]
		bpkt_info.cur_idx += 2;
    2a28:	7029      	strb	r1, [r5, #0]
		FPB->COMP[bpkt_info.cur_idx + 1] = fp_comp2;
    2a2a:	60da      	str	r2, [r3, #12]
		bpkt_info.cur_idx += 2;
    2a2c:	e7c7      	b.n	29be <add_hw_bkpt+0xda>
			if (FPB->COMP[i] == fp_comp1 && FPB->COMP[i + 1] == fp_comp2) {
    2a2e:	0083      	lsls	r3, r0, #2
    2a30:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    2a34:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    2a38:	1c47      	adds	r7, r0, #1
    2a3a:	f8d3 c008 	ldr.w	ip, [r3, #8]
    2a3e:	4564      	cmp	r4, ip
    2a40:	d103      	bne.n	2a4a <add_hw_bkpt+0x166>
    2a42:	68db      	ldr	r3, [r3, #12]
    2a44:	429a      	cmp	r2, r3
    2a46:	f43f af65 	beq.w	2914 <add_hw_bkpt+0x30>
		for (int i = 0; i < bpkt_info.bpkt_num; i++) {
    2a4a:	4638      	mov	r0, r7
    2a4c:	e7d0      	b.n	29f0 <add_hw_bkpt+0x10c>
	uint32_t replace = (inst_addr & 0x2) == 0 ? 1 : 2;
    2a4e:	f1b9 0f00 	cmp.w	r9, #0
	uint32_t fp_comp = (inst_addr & ~0x3) | 0x1 | (replace << 30);
    2a52:	bf14      	ite	ne
    2a54:	f04f 4300 	movne.w	r3, #2147483648	; 0x80000000
    2a58:	f04f 4380 	moveq.w	r3, #1073741824	; 0x40000000
    2a5c:	f024 0403 	bic.w	r4, r4, #3
    2a60:	431c      	orrs	r4, r3
	for (int i = 0; i < bpkt_info.bpkt_num; i++) {
    2a62:	786a      	ldrb	r2, [r5, #1]
    2a64:	4b0b      	ldr	r3, [pc, #44]	; (2a94 <add_hw_bkpt+0x1b0>)
	uint32_t fp_comp = (inst_addr & ~0x3) | 0x1 | (replace << 30);
    2a66:	f044 0401 	orr.w	r4, r4, #1
	for (int i = 0; i < bpkt_info.bpkt_num; i++) {
    2a6a:	4290      	cmp	r0, r2
    2a6c:	db06      	blt.n	2a7c <add_hw_bkpt+0x198>
	FPB->COMP[bpkt_info.cur_idx] = fp_comp;
    2a6e:	7828      	ldrb	r0, [r5, #0]
    2a70:	1c82      	adds	r2, r0, #2
    2a72:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
	return bpkt_info.cur_idx++;
    2a76:	1c43      	adds	r3, r0, #1
    2a78:	702b      	strb	r3, [r5, #0]
    2a7a:	e74b      	b.n	2914 <add_hw_bkpt+0x30>
		if (FPB->COMP[i] == fp_comp) {
    2a7c:	1c81      	adds	r1, r0, #2
    2a7e:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
    2a82:	428c      	cmp	r4, r1
    2a84:	f43f af46 	beq.w	2914 <add_hw_bkpt+0x30>
	for (int i = 0; i < bpkt_info.bpkt_num; i++) {
    2a88:	3001      	adds	r0, #1
    2a8a:	e7ee      	b.n	2a6a <add_hw_bkpt+0x186>
    2a8c:	200057af 	.word	0x200057af
    2a90:	200057ad 	.word	0x200057ad
    2a94:	e0002000 	.word	0xe0002000
    2a98:	00016b5b 	.word	0x00016b5b
    2a9c:	0001646c 	.word	0x0001646c
    2aa0:	00016b7a 	.word	0x00016b7a
    2aa4:	00016bb0 	.word	0x00016bb0
    2aa8:	200020dc 	.word	0x200020dc

00002aac <clear_all_hw_bkpt>:
	uint32_t fp_ctrl = FPB->CTRL;
    2aac:	490d      	ldr	r1, [pc, #52]	; (2ae4 <clear_all_hw_bkpt+0x38>)
    2aae:	680a      	ldr	r2, [r1, #0]
void clear_all_hw_bkpt() {
    2ab0:	b510      	push	{r4, lr}
	uint32_t num_code_comparators = (((fp_ctrl >> 12) & 0x7) << 4) | ((fp_ctrl >> 4) & 0xF);
    2ab2:	0a13      	lsrs	r3, r2, #8
    2ab4:	f003 0370 	and.w	r3, r3, #112	; 0x70
    2ab8:	f3c2 1203 	ubfx	r2, r2, #4, #4
    2abc:	4313      	orrs	r3, r2
	for (int i = 0; i < num_code_comparators; i++) {
    2abe:	2200      	movs	r2, #0
    2ac0:	4610      	mov	r0, r2
    2ac2:	429a      	cmp	r2, r3
    2ac4:	d109      	bne.n	2ada <clear_all_hw_bkpt+0x2e>
	bpkt_info.cur_idx = 0;
    2ac6:	4b08      	ldr	r3, [pc, #32]	; (2ae8 <clear_all_hw_bkpt+0x3c>)
	FPB->CTRL = (FPB->CTRL & ~0x3) | 0x2;
    2ac8:	4a06      	ldr	r2, [pc, #24]	; (2ae4 <clear_all_hw_bkpt+0x38>)
	bpkt_info.cur_idx = 0;
    2aca:	7018      	strb	r0, [r3, #0]
	FPB->CTRL = (FPB->CTRL & ~0x3) | 0x2;
    2acc:	6813      	ldr	r3, [r2, #0]
    2ace:	f023 0303 	bic.w	r3, r3, #3
    2ad2:	f043 0302 	orr.w	r3, r3, #2
    2ad6:	6013      	str	r3, [r2, #0]
}
    2ad8:	bd10      	pop	{r4, pc}
		FPB->COMP[i] = 0;
    2ada:	1c94      	adds	r4, r2, #2
	for (int i = 0; i < num_code_comparators; i++) {
    2adc:	3201      	adds	r2, #1
		FPB->COMP[i] = 0;
    2ade:	f841 0024 	str.w	r0, [r1, r4, lsl #2]
    2ae2:	e7ee      	b.n	2ac2 <clear_all_hw_bkpt+0x16>
    2ae4:	e0002000 	.word	0xe0002000
    2ae8:	200057ad 	.word	0x200057ad

00002aec <fpb_disable_cur_inst>:
	uint32_t cur_addr = FPB->COMP[bpkt_idx];
    2aec:	0080      	lsls	r0, r0, #2
void fpb_disable_cur_inst(int bpkt_idx) {
    2aee:	b510      	push	{r4, lr}
    2af0:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
    2af4:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
	uint32_t cur_addr = FPB->COMP[bpkt_idx];
    2af8:	68a0      	ldr	r0, [r4, #8]
		next_inst = calc_bpkt_pc(next_inst);
    2afa:	f00d fa41 	bl	ff80 <calc_bpkt_pc>
	while ((next_inst & 0x3) != 0) {
    2afe:	0783      	lsls	r3, r0, #30
    2b00:	d1fb      	bne.n	2afa <fpb_disable_cur_inst+0xe>
	FPB->COMP[FPB_CB_REG] = next_inst | (0x1);
    2b02:	4b0b      	ldr	r3, [pc, #44]	; (2b30 <fpb_disable_cur_inst+0x44>)
	uint32_t trampoline_addr = (((uint32_t) FPB_Handler5 & (~0x1)) + 3) & (~0x3);
    2b04:	490b      	ldr	r1, [pc, #44]	; (2b34 <fpb_disable_cur_inst+0x48>)
	FPB->COMP[FPB_CB_REG] = next_inst | (0x1);
    2b06:	f040 0201 	orr.w	r2, r0, #1
    2b0a:	61da      	str	r2, [r3, #28]
	FPB->COMP[bpkt_idx] &= ~(0x1);
    2b0c:	68a3      	ldr	r3, [r4, #8]
	uint32_t trampoline_addr = (((uint32_t) FPB_Handler5 & (~0x1)) + 3) & (~0x3);
    2b0e:	f021 0101 	bic.w	r1, r1, #1
	FPB->COMP[bpkt_idx] &= ~(0x1);
    2b12:	f023 0301 	bic.w	r3, r3, #1
	uint32_t trampoline_addr = (((uint32_t) FPB_Handler5 & (~0x1)) + 3) & (~0x3);
    2b16:	3103      	adds	r1, #3
	FPB->COMP[bpkt_idx] &= ~(0x1);
    2b18:	60a3      	str	r3, [r4, #8]
	uint32_t jump_inst = calc_branch_instr(next_inst, trampoline_addr);
    2b1a:	f021 0103 	bic.w	r1, r1, #3
    2b1e:	f00d f99a 	bl	fe56 <calc_branch_instr>
	*((uint32_t *) (PATCH_TBL + (FPB_CB_REG * 4))) = little_endian_16_bit(jump_inst);
    2b22:	f00d fa36 	bl	ff92 <little_endian_16_bit>
	return ((uint32_t)(&REMAP_ADDR) + 0x1f) & (~0x1f);
    2b26:	4b04      	ldr	r3, [pc, #16]	; (2b38 <fpb_disable_cur_inst+0x4c>)
    2b28:	f023 031f 	bic.w	r3, r3, #31
	*((uint32_t *) (PATCH_TBL + (FPB_CB_REG * 4))) = little_endian_16_bit(jump_inst);
    2b2c:	6158      	str	r0, [r3, #20]
}
    2b2e:	bd10      	pop	{r4, pc}
    2b30:	e0002000 	.word	0xe0002000
    2b34:	0000fe1d 	.word	0x0000fe1d
    2b38:	200020fb 	.word	0x200020fb

00002b3c <fpb_enable_callback>:
	uint32_t cur_inst = FPB->COMP[FPB_CB_REG];
    2b3c:	4b0b      	ldr	r3, [pc, #44]	; (2b6c <fpb_enable_callback+0x30>)
    2b3e:	69d8      	ldr	r0, [r3, #28]
	for (int i = 0; i < FPB_CB_REG; i++) {
    2b40:	2200      	movs	r2, #0
		if (FPB->COMP[i] != 0) {
    2b42:	0093      	lsls	r3, r2, #2
    2b44:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    2b48:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
    2b4c:	6899      	ldr	r1, [r3, #8]
    2b4e:	b119      	cbz	r1, 2b58 <fpb_enable_callback+0x1c>
			FPB->COMP[i] |= 1;
    2b50:	6899      	ldr	r1, [r3, #8]
    2b52:	f041 0101 	orr.w	r1, r1, #1
    2b56:	6099      	str	r1, [r3, #8]
	for (int i = 0; i < FPB_CB_REG; i++) {
    2b58:	3201      	adds	r2, #1
    2b5a:	2a05      	cmp	r2, #5
    2b5c:	d1f1      	bne.n	2b42 <fpb_enable_callback+0x6>
	FPB->COMP[FPB_CB_REG] &= ~(0x1);
    2b5e:	4a03      	ldr	r2, [pc, #12]	; (2b6c <fpb_enable_callback+0x30>)
    2b60:	69d3      	ldr	r3, [r2, #28]
    2b62:	f023 0301 	bic.w	r3, r3, #1
    2b66:	61d3      	str	r3, [r2, #28]
}
    2b68:	4770      	bx	lr
    2b6a:	bf00      	nop
    2b6c:	e0002000 	.word	0xe0002000

00002b70 <leave_debug_monitor>:
void leave_debug_monitor(stack_context *ctx) {
    2b70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const bool is_dwt_dbg_evt = (*dfsr & dfsr_dwt_evt_bitmask);
    2b72:	4b21      	ldr	r3, [pc, #132]	; (2bf8 <leave_debug_monitor+0x88>)
    2b74:	681a      	ldr	r2, [r3, #0]
	const bool is_bkpt_dbg_evt = (*dfsr & dfsr_bkpt_evt_bitmask);
    2b76:	6819      	ldr	r1, [r3, #0]
	const bool is_halt_dbg_evt = (*dfsr & dfsr_halt_evt_bitmask);
    2b78:	681a      	ldr	r2, [r3, #0]
	if (is_bkpt_dbg_evt) {
    2b7a:	f011 0f02 	tst.w	r1, #2
void leave_debug_monitor(stack_context *ctx) {
    2b7e:	4604      	mov	r4, r0
    2b80:	461f      	mov	r7, r3
	if (is_bkpt_dbg_evt) {
    2b82:	d02a      	beq.n	2bda <leave_debug_monitor+0x6a>
	ebpf_patch *patch = get_dynamic_patch_by_bpkt(ctx->pc);
    2b84:	6980      	ldr	r0, [r0, #24]
    2b86:	f000 fd6b 	bl	3660 <get_dynamic_patch_by_bpkt>
	if (patch != NULL) {
    2b8a:	4605      	mov	r5, r0
    2b8c:	b1b0      	cbz	r0, 2bbc <leave_debug_monitor+0x4c>
		profile_start(EV1);
    2b8e:	2001      	movs	r0, #1
    2b90:	f000 fdfe 	bl	3790 <profile_start>
		ret = run_ebpf_filter(patch, args, sizeof(ebpf_args_frame));
    2b94:	2210      	movs	r2, #16
    2b96:	4628      	mov	r0, r5
    2b98:	4621      	mov	r1, r4
    2b9a:	f00d f9c6 	bl	ff2a <run_ebpf_filter>
    2b9e:	460e      	mov	r6, r1
    2ba0:	4605      	mov	r5, r0
		profile_end(EV1);
    2ba2:	2001      	movs	r0, #1
    2ba4:	f000 fdfe 	bl	37a4 <profile_end>
		if (op == FILTER_DROP) {
    2ba8:	2e01      	cmp	r6, #1
    2baa:	d103      	bne.n	2bb4 <leave_debug_monitor+0x44>
			*(volatile uint32_t *) &(ctx->pc) = ctx->lr; // calc_bpkt_addr(ctx->lr); //
    2bac:	6963      	ldr	r3, [r4, #20]
			*(volatile uint32_t *) &(ctx->r0) = ret_code;
    2bae:	6025      	str	r5, [r4, #0]
			*(volatile uint32_t *) &(ctx->pc) = ctx->lr; // calc_bpkt_addr(ctx->lr); //
    2bb0:	61a3      	str	r3, [r4, #24]
}
    2bb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		} else if (op == FILTER_REDIRECT) { // redirect pc to other address
    2bb4:	2e02      	cmp	r6, #2
    2bb6:	d101      	bne.n	2bbc <leave_debug_monitor+0x4c>
			*(volatile uint32_t *) &(ctx->pc) = ret_code; 
    2bb8:	61a5      	str	r5, [r4, #24]
		if (skip) { 
    2bba:	e7fa      	b.n	2bb2 <leave_debug_monitor+0x42>
		*demcr |= demcr_single_step_mask;
    2bbc:	4a0f      	ldr	r2, [pc, #60]	; (2bfc <leave_debug_monitor+0x8c>)
    2bbe:	6813      	ldr	r3, [r2, #0]
    2bc0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    2bc4:	6013      	str	r3, [r2, #0]
		*dfsr = dfsr_bkpt_evt_bitmask;
    2bc6:	2302      	movs	r3, #2
	FPB->CTRL = (FPB->CTRL & ~0x3) | 0x2;
    2bc8:	4a0d      	ldr	r2, [pc, #52]	; (2c00 <leave_debug_monitor+0x90>)
		*dfsr = dfsr_bkpt_evt_bitmask;
    2bca:	603b      	str	r3, [r7, #0]
	FPB->CTRL = (FPB->CTRL & ~0x3) | 0x2;
    2bcc:	6813      	ldr	r3, [r2, #0]
    2bce:	f023 0303 	bic.w	r3, r3, #3
    2bd2:	f043 0302 	orr.w	r3, r3, #2
	FPB->CTRL |= 0x3;
    2bd6:	6013      	str	r3, [r2, #0]
		TEST_LOG("is_halt_dbg_evt\n");
    2bd8:	e7eb      	b.n	2bb2 <leave_debug_monitor+0x42>
	} else if (is_halt_dbg_evt) {
    2bda:	07d2      	lsls	r2, r2, #31
    2bdc:	d5e9      	bpl.n	2bb2 <leave_debug_monitor+0x42>
		*demcr &= ~(demcr_single_step_mask);
    2bde:	4907      	ldr	r1, [pc, #28]	; (2bfc <leave_debug_monitor+0x8c>)
    2be0:	680a      	ldr	r2, [r1, #0]
    2be2:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
    2be6:	600a      	str	r2, [r1, #0]
		*dfsr = dfsr_halt_evt_bitmask;
    2be8:	2201      	movs	r2, #1
    2bea:	601a      	str	r2, [r3, #0]
	FPB->CTRL |= 0x3;
    2bec:	4a04      	ldr	r2, [pc, #16]	; (2c00 <leave_debug_monitor+0x90>)
    2bee:	6813      	ldr	r3, [r2, #0]
    2bf0:	f043 0303 	orr.w	r3, r3, #3
    2bf4:	e7ef      	b.n	2bd6 <leave_debug_monitor+0x66>
    2bf6:	bf00      	nop
    2bf8:	e000ed30 	.word	0xe000ed30
    2bfc:	e000edfc 	.word	0xe000edfc
    2c00:	e0002000 	.word	0xe0002000

00002c04 <set_patch_mode>:
void set_patch_mode(patch_mode_t mode) {
    2c04:	b538      	push	{r3, r4, r5, lr}
	memset(&REMAP_ADDR, 0, sizeof(REMAP_ADDR));
    2c06:	4c20      	ldr	r4, [pc, #128]	; (2c88 <set_patch_mode+0x84>)
void set_patch_mode(patch_mode_t mode) {
    2c08:	4605      	mov	r5, r0
	clear_all_hw_bkpt();
    2c0a:	f7ff ff4f 	bl	2aac <clear_all_hw_bkpt>
	memset(&REMAP_ADDR, 0, sizeof(REMAP_ADDR));
    2c0e:	222c      	movs	r2, #44	; 0x2c
    2c10:	2100      	movs	r1, #0
    2c12:	4620      	mov	r0, r4
    2c14:	f7ff fae9 	bl	21ea <memset>
	FPB->REMAP = 0;
    2c18:	4b1c      	ldr	r3, [pc, #112]	; (2c8c <set_patch_mode+0x88>)
    2c1a:	2200      	movs	r2, #0
    2c1c:	605a      	str	r2, [r3, #4]
	if (mode == CORTEX_FPB_PATCH) { // use fpb
    2c1e:	b965      	cbnz	r5, 2c3a <set_patch_mode+0x36>
	return ((uint32_t)(&REMAP_ADDR) + 0x1f) & (~0x1f);
    2c20:	f104 021f 	add.w	r2, r4, #31
    2c24:	f022 021f 	bic.w	r2, r2, #31
	FPB->REMAP = remap_addr;
    2c28:	605a      	str	r2, [r3, #4]
	REMAP_ADDR.active = true;
    2c2a:	2201      	movs	r2, #1
    2c2c:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
	FPB->CTRL |= 0x3;
    2c30:	681a      	ldr	r2, [r3, #0]
    2c32:	f042 0203 	orr.w	r2, r2, #3
	*shp8 = -1;
    2c36:	601a      	str	r2, [r3, #0]
}
    2c38:	bd38      	pop	{r3, r4, r5, pc}
	} else if (mode == CORTEX_DEB_MON_PATCH) {
    2c3a:	2d01      	cmp	r5, #1
    2c3c:	d1fc      	bne.n	2c38 <set_patch_mode+0x34>
	*scb_hfsr = (1 << 31);
    2c3e:	4a14      	ldr	r2, [pc, #80]	; (2c90 <set_patch_mode+0x8c>)
    2c40:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    2c44:	6011      	str	r1, [r2, #0]
	*scb_dfsr = (1 << 2);
    2c46:	2104      	movs	r1, #4
    2c48:	f8c2 1d04 	str.w	r1, [r2, #3332]	; 0xd04
	return (((*dhcsr) & 0x1) != 0);
    2c4c:	f602 52c4 	addw	r2, r2, #3524	; 0xdc4
    2c50:	6812      	ldr	r2, [r2, #0]
	if (halting_debug_enabled()) {
    2c52:	07d2      	lsls	r2, r2, #31
    2c54:	d504      	bpl.n	2c60 <set_patch_mode+0x5c>
		DEBUG_LOG("Halting Debug Enabled - Can't Enable Monitor Mode Debug!");
    2c56:	480f      	ldr	r0, [pc, #60]	; (2c94 <set_patch_mode+0x90>)
}
    2c58:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		DEBUG_LOG("Halting Debug Enabled - Can't Enable Monitor Mode Debug!");
    2c5c:	f00d b977 	b.w	ff4e <debug_log>
	*demcr |= DCB_DEMCR_MON_EN; 
    2c60:	4a0d      	ldr	r2, [pc, #52]	; (2c98 <set_patch_mode+0x94>)
	DEBUG_LOG("debug_monitor_init setup dhcsr: %u\n", *demcr);
    2c62:	480e      	ldr	r0, [pc, #56]	; (2c9c <set_patch_mode+0x98>)
	*demcr |= DCB_DEMCR_MON_EN; 
    2c64:	6811      	ldr	r1, [r2, #0]
    2c66:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
    2c6a:	6011      	str	r1, [r2, #0]
	FPB->CTRL |= 0x3;
    2c6c:	6819      	ldr	r1, [r3, #0]
    2c6e:	f041 0103 	orr.w	r1, r1, #3
    2c72:	6019      	str	r1, [r3, #0]
	DEBUG_LOG("debug_monitor_init setup dhcsr: %u\n", *demcr);
    2c74:	6811      	ldr	r1, [r2, #0]
    2c76:	f00d f96a 	bl	ff4e <debug_log>
	*shp8 = 0xff;
    2c7a:	4b09      	ldr	r3, [pc, #36]	; (2ca0 <set_patch_mode+0x9c>)
    2c7c:	22ff      	movs	r2, #255	; 0xff
    2c7e:	601a      	str	r2, [r3, #0]
	*shp8 = -1;
    2c80:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2c84:	e7d7      	b.n	2c36 <set_patch_mode+0x32>
    2c86:	bf00      	nop
    2c88:	200020dc 	.word	0x200020dc
    2c8c:	e0002000 	.word	0xe0002000
    2c90:	e000e02c 	.word	0xe000e02c
    2c94:	00016bed 	.word	0x00016bed
    2c98:	e000edfc 	.word	0xe000edfc
    2c9c:	00016c26 	.word	0x00016c26
    2ca0:	e000ed20 	.word	0xe000ed20

00002ca4 <test_debugmon_patch>:
	// enable flash patch break point
	FPB->REMAP = PATCH_TBL;
	FPB->CTRL = 3;
}

void test_debugmon_patch() {
    2ca4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint32_t buggy_addr = (uint32_t) RawBuggyFunc & 0xFFFFFFFE;
    2ca8:	4c18      	ldr	r4, [pc, #96]	; (2d0c <test_debugmon_patch+0x68>)
	fixed_addr = (uint32_t) FPB_Handler0 & 0xFFFFFFFE;
    2caa:	4e19      	ldr	r6, [pc, #100]	; (2d10 <test_debugmon_patch+0x6c>)
	//RawBuggyFunc();
	DEBUG_LOG("test_debugmon_patch\n");
    2cac:	4819      	ldr	r0, [pc, #100]	; (2d14 <test_debugmon_patch+0x70>)
	FPB->COMP[fidx] = buggy_addr | 0x1;
    2cae:	4f1a      	ldr	r7, [pc, #104]	; (2d18 <test_debugmon_patch+0x74>)
	const uint32_t PATCH_TBL = (uint32_t) (&REMAP_ADDR) & (~0x1F);
    2cb0:	f8df 8074 	ldr.w	r8, [pc, #116]	; 2d28 <test_debugmon_patch+0x84>
	uint32_t buggy_addr = (uint32_t) RawBuggyFunc & 0xFFFFFFFE;
    2cb4:	f024 0401 	bic.w	r4, r4, #1
	DEBUG_LOG("test_debugmon_patch\n");
    2cb8:	f00d f949 	bl	ff4e <debug_log>
	fixed_addr = (uint32_t) FPB_Handler0 & 0xFFFFFFFE;
    2cbc:	f026 0601 	bic.w	r6, r6, #1
	test_freertos_cve();
    2cc0:	f7ff fdba 	bl	2838 <test_freertos_cve>
	FPB->COMP[fidx] = buggy_addr | 0x1;
    2cc4:	f044 0301 	orr.w	r3, r4, #1
    2cc8:	617b      	str	r3, [r7, #20]
	uint32_t jmp_inst = calc_branch_instr(buggy_addr, fixed_addr);
    2cca:	4631      	mov	r1, r6
    2ccc:	4620      	mov	r0, r4
    2cce:	f00d f8c2 	bl	fe56 <calc_branch_instr>
    2cd2:	4681      	mov	r9, r0
	*((volatile uint32_t *) (PATCH_TBL + fidx * 4)) = little_endian_16_bit(jmp_inst);
    2cd4:	f00d f95d 	bl	ff92 <little_endian_16_bit>
	const uint32_t PATCH_TBL = (uint32_t) (&REMAP_ADDR) & (~0x1F);
    2cd8:	f028 051f 	bic.w	r5, r8, #31
	DEBUG_LOG("buggy_addr: 0x%08x fixed_addr: 0x%08x\n", buggy_addr, fixed_addr);
    2cdc:	4632      	mov	r2, r6
    2cde:	4621      	mov	r1, r4
	*((volatile uint32_t *) (PATCH_TBL + fidx * 4)) = little_endian_16_bit(jmp_inst);
    2ce0:	60e8      	str	r0, [r5, #12]
	DEBUG_LOG("buggy_addr: 0x%08x fixed_addr: 0x%08x\n", buggy_addr, fixed_addr);
    2ce2:	480e      	ldr	r0, [pc, #56]	; (2d1c <test_debugmon_patch+0x78>)
    2ce4:	f00d f933 	bl	ff4e <debug_log>
	DEBUG_LOG("ADDR: 0x%08x excepted value: 0x%08x\n", (&REMAP_ADDR), little_endian_16_bit(jmp_inst));
    2ce8:	4648      	mov	r0, r9
    2cea:	f00d f952 	bl	ff92 <little_endian_16_bit>
    2cee:	4641      	mov	r1, r8
    2cf0:	4602      	mov	r2, r0
    2cf2:	480b      	ldr	r0, [pc, #44]	; (2d20 <test_debugmon_patch+0x7c>)
    2cf4:	f00d f92b 	bl	ff4e <debug_log>
	DEBUG_LOG("remap: 0x%08x inst addr: 0x%08x\n", PATCH_TBL, *((volatile uint32_t *) (PATCH_TBL + fidx * 4)));
    2cf8:	68ea      	ldr	r2, [r5, #12]
    2cfa:	480a      	ldr	r0, [pc, #40]	; (2d24 <test_debugmon_patch+0x80>)
    2cfc:	4629      	mov	r1, r5
    2cfe:	f00d f926 	bl	ff4e <debug_log>
	FPB->CTRL = 3;
    2d02:	2303      	movs	r3, #3
	FPB->REMAP = PATCH_TBL;
    2d04:	607d      	str	r5, [r7, #4]
	FPB->CTRL = 3;
    2d06:	603b      	str	r3, [r7, #0]
	// load dummy patch
	//set_patch_mode(CORTEX_FPB_PATCH);
	fpb_setup_test();
	
	/* Our approach */
}
    2d08:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2d0c:	0000281d 	.word	0x0000281d
    2d10:	000027e5 	.word	0x000027e5
    2d14:	00016cbe 	.word	0x00016cbe
    2d18:	e0002000 	.word	0xe0002000
    2d1c:	00016cd3 	.word	0x00016cd3
    2d20:	00016cfa 	.word	0x00016cfa
    2d24:	00016d1f 	.word	0x00016d1f
    2d28:	200020dc 	.word	0x200020dc

00002d2c <test_dynamic_bug>:
		DEBUG_LOG("%d -> %s\n", i, patch_list[i].cve);
	}
	setup_cve_list();
}

int test_dynamic_bug(int v) {
    2d2c:	b510      	push	{r4, lr}
    2d2e:	4604      	mov	r4, r0
	DEBUG_LOG("halo\n");
    2d30:	4804      	ldr	r0, [pc, #16]	; (2d44 <test_dynamic_bug+0x18>)
    2d32:	f00d f90c 	bl	ff4e <debug_log>
		//DEBUG_LOG("test_dynamic_bug-112: %d\n", v);
		return -1;
	}
	//DEBUG_LOG("test_dynamic_bug-: %d\n", v);
	return 0;
}
    2d36:	f5b4 6ffa 	cmp.w	r4, #2000	; 0x7d0
    2d3a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2d3e:	bfd8      	it	le
    2d40:	2000      	movle	r0, #0
    2d42:	bd10      	pop	{r4, pc}
    2d44:	00016e0a 	.word	0x00016e0a

00002d48 <show_local_patch_desc>:
void show_local_patch_desc() {
    2d48:	b570      	push	{r4, r5, r6, lr}
		DEBUG_LOG("%d -> %s\n", i, patch_list[i].cve);
    2d4a:	4d07      	ldr	r5, [pc, #28]	; (2d68 <show_local_patch_desc+0x20>)
    2d4c:	4e07      	ldr	r6, [pc, #28]	; (2d6c <show_local_patch_desc+0x24>)
	for (int i = 0; i < n; i++) {
    2d4e:	2400      	movs	r4, #0
		DEBUG_LOG("%d -> %s\n", i, patch_list[i].cve);
    2d50:	0123      	lsls	r3, r4, #4
    2d52:	4621      	mov	r1, r4
    2d54:	595a      	ldr	r2, [r3, r5]
    2d56:	4630      	mov	r0, r6
	for (int i = 0; i < n; i++) {
    2d58:	3401      	adds	r4, #1
		DEBUG_LOG("%d -> %s\n", i, patch_list[i].cve);
    2d5a:	f00d f8f8 	bl	ff4e <debug_log>
	for (int i = 0; i < n; i++) {
    2d5e:	2c04      	cmp	r4, #4
    2d60:	d1f6      	bne.n	2d50 <show_local_patch_desc+0x8>
	patch_list[0].loc = (uint32_t) test_dynamic_bug;
    2d62:	4b03      	ldr	r3, [pc, #12]	; (2d70 <show_local_patch_desc+0x28>)
    2d64:	606b      	str	r3, [r5, #4]
}
    2d66:	bd70      	pop	{r4, r5, r6, pc}
    2d68:	20010c64 	.word	0x20010c64
    2d6c:	00016d8a 	.word	0x00016d8a
    2d70:	00002d2d 	.word	0x00002d2d

00002d74 <read_local_patch>:

ebpf_patch* read_local_patch(int pid) {
	int n = sizeof(patch_list) / sizeof(struct local_patch);
	if (pid > n) {
    2d74:	2804      	cmp	r0, #4
ebpf_patch* read_local_patch(int pid) {
    2d76:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2d78:	4604      	mov	r4, r0
	if (pid > n) {
    2d7a:	dd07      	ble.n	2d8c <read_local_patch+0x18>
		show_local_patch_desc();
    2d7c:	f7ff ffe4 	bl	2d48 <show_local_patch_desc>
		DEBUG_LOG("patch id less than %d\n", n);
    2d80:	4821      	ldr	r0, [pc, #132]	; (2e08 <read_local_patch+0x94>)
    2d82:	2104      	movs	r1, #4
    2d84:	f00d f8e3 	bl	ff4e <debug_log>
		return NULL;
    2d88:	2000      	movs	r0, #0
	_patch->vm = vm;
	load_local_patch_to_ctx(_patch);
	// _patch->is_active = false;
	DEBUG_LOG("load patch %s success!\n", pt->cve);
	return _patch;
}
    2d8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!is_init) {
    2d8c:	4e1f      	ldr	r6, [pc, #124]	; (2e0c <read_local_patch+0x98>)
    2d8e:	4d20      	ldr	r5, [pc, #128]	; (2e10 <read_local_patch+0x9c>)
    2d90:	7833      	ldrb	r3, [r6, #0]
    2d92:	4f20      	ldr	r7, [pc, #128]	; (2e14 <read_local_patch+0xa0>)
    2d94:	b96b      	cbnz	r3, 2db2 <read_local_patch+0x3e>
		_desc = ebpf_calloc(1, sizeof(patch_desc));
    2d96:	2108      	movs	r1, #8
    2d98:	2001      	movs	r0, #1
    2d9a:	f000 fd77 	bl	388c <ebpf_calloc>
		_patch = ebpf_calloc(1, sizeof(ebpf_patch));
    2d9e:	210c      	movs	r1, #12
		_desc = ebpf_calloc(1, sizeof(patch_desc));
    2da0:	6028      	str	r0, [r5, #0]
		_patch = ebpf_calloc(1, sizeof(ebpf_patch));
    2da2:	2001      	movs	r0, #1
    2da4:	f000 fd72 	bl	388c <ebpf_calloc>
		is_init = true;
    2da8:	2301      	movs	r3, #1
		_patch = ebpf_calloc(1, sizeof(ebpf_patch));
    2daa:	6038      	str	r0, [r7, #0]
		is_init = true;
    2dac:	7033      	strb	r3, [r6, #0]
		init_patch_sys();
    2dae:	f000 fc05 	bl	35bc <init_patch_sys>
	_desc->type = DynamicPatchPoint;
    2db2:	682b      	ldr	r3, [r5, #0]
	_desc->inst_addr = pt->loc;
    2db4:	4e18      	ldr	r6, [pc, #96]	; (2e18 <read_local_patch+0xa4>)
	_desc->type = DynamicPatchPoint;
    2db6:	2200      	movs	r2, #0
	_desc->inst_addr = pt->loc;
    2db8:	0124      	lsls	r4, r4, #4
	_desc->type = DynamicPatchPoint;
    2dba:	705a      	strb	r2, [r3, #1]
	_desc->code_len = 0; // code do not save in desc now
    2dbc:	709a      	strb	r2, [r3, #2]
    2dbe:	70da      	strb	r2, [r3, #3]
	_desc->inst_addr = pt->loc;
    2dc0:	1932      	adds	r2, r6, r4
	_desc->type = DynamicPatchPoint;
    2dc2:	2102      	movs	r1, #2
    2dc4:	7019      	strb	r1, [r3, #0]
	_desc->inst_addr = pt->loc;
    2dc6:	6851      	ldr	r1, [r2, #4]
    2dc8:	6059      	str	r1, [r3, #4]
	_patch->desc = _desc;
    2dca:	6839      	ldr	r1, [r7, #0]
	ebpf_vm *vm = _patch->vm;
    2dcc:	684d      	ldr	r5, [r1, #4]
	_patch->desc = _desc;
    2dce:	600b      	str	r3, [r1, #0]
	if (vm == NULL) {
    2dd0:	b925      	cbnz	r5, 2ddc <read_local_patch+0x68>
		vm = init_ebpf_vm(pt->code, pt->code_len);
    2dd2:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
    2dd6:	f00d f91d 	bl	10014 <init_ebpf_vm>
    2dda:	4605      	mov	r5, r0
	ebpf_vm_set_inst(vm, pt->code, pt->code_len);
    2ddc:	1933      	adds	r3, r6, r4
    2dde:	e9d3 1202 	ldrd	r1, r2, [r3, #8]
    2de2:	4628      	mov	r0, r5
    2de4:	f00d f926 	bl	10034 <ebpf_vm_set_inst>
	vm->use_jit = true;
    2de8:	2301      	movs	r3, #1
    2dea:	752b      	strb	r3, [r5, #20]
		gen_jit_code(vm);
    2dec:	4628      	mov	r0, r5
    2dee:	f00e fab9 	bl	11364 <gen_jit_code>
	_patch->vm = vm;
    2df2:	6838      	ldr	r0, [r7, #0]
    2df4:	6045      	str	r5, [r0, #4]
	load_local_patch_to_ctx(_patch);
    2df6:	f000 fc49 	bl	368c <load_local_patch_to_ctx>
	DEBUG_LOG("load patch %s success!\n", pt->cve);
    2dfa:	4808      	ldr	r0, [pc, #32]	; (2e1c <read_local_patch+0xa8>)
    2dfc:	5931      	ldr	r1, [r6, r4]
    2dfe:	f00d f8a6 	bl	ff4e <debug_log>
	return _patch;
    2e02:	6838      	ldr	r0, [r7, #0]
    2e04:	e7c1      	b.n	2d8a <read_local_patch+0x16>
    2e06:	bf00      	nop
    2e08:	00016d5b 	.word	0x00016d5b
    2e0c:	200057b0 	.word	0x200057b0
    2e10:	20002108 	.word	0x20002108
    2e14:	2000210c 	.word	0x2000210c
    2e18:	20010c64 	.word	0x20010c64
    2e1c:	00016d72 	.word	0x00016d72

00002e20 <my_memmove>:
	char *src = (char *) arg2;
	int len = arg3;
	// for (int i = 0; i < len; i++) {
	// 	dst[i] = src[i];
	// }
	DEBUG_LOG("my_memmove: %d %d %d\n", dst, src, len);
    2e20:	4601      	mov	r1, r0
    2e22:	9b00      	ldr	r3, [sp, #0]
    2e24:	4801      	ldr	r0, [pc, #4]	; (2e2c <my_memmove+0xc>)
    2e26:	f00d b892 	b.w	ff4e <debug_log>
    2e2a:	bf00      	nop
    2e2c:	00016e9f 	.word	0x00016e9f

00002e30 <ebpf_eva>:
		.r2 = opt_ptr,
	};
	ebpf_eva(code12, sizeof(code12), &args_frame, sizeof(args_frame));
}

void ebpf_eva(uint8_t *code, int code_len, void *args, int ags_len) {
    2e30:	b5f0      	push	{r4, r5, r6, r7, lr}
    2e32:	b089      	sub	sp, #36	; 0x24
    2e34:	4614      	mov	r4, r2
	bool test_jit = true;
	// test_jit = false;
	ebpf_vm vm;
	ebpf_vm_set_inst(&vm, code, code_len);
    2e36:	460a      	mov	r2, r1
    2e38:	4601      	mov	r1, r0
    2e3a:	a802      	add	r0, sp, #8
void ebpf_eva(uint8_t *code, int code_len, void *args, int ags_len) {
    2e3c:	461d      	mov	r5, r3
	ebpf_vm_set_inst(&vm, code, code_len);
    2e3e:	f00d f8f9 	bl	10034 <ebpf_vm_set_inst>
	//profile_exit();
	profile_add_event("ebpf");
    2e42:	4821      	ldr	r0, [pc, #132]	; (2ec8 <ebpf_eva+0x98>)
    2e44:	f000 fc74 	bl	3730 <profile_add_event>
	uint64_t ret1 = 0, ret2 = 0;
	profile_start(EV0);
    2e48:	2000      	movs	r0, #0
    2e4a:	f000 fca1 	bl	3790 <profile_start>
	ret1 = ebpf_vm_exec(&vm, args, ags_len);
    2e4e:	462a      	mov	r2, r5
    2e50:	4621      	mov	r1, r4
    2e52:	a802      	add	r0, sp, #8
    2e54:	f00d f900 	bl	10058 <ebpf_vm_exec>
    2e58:	4607      	mov	r7, r0
	profile_end(EV0);
    2e5a:	2000      	movs	r0, #0
	ret1 = ebpf_vm_exec(&vm, args, ags_len);
    2e5c:	460e      	mov	r6, r1
	profile_end(EV0);
    2e5e:	f000 fca1 	bl	37a4 <profile_end>
	// jit_compile
	if (test_jit) {
		gen_jit_code(&vm);
    2e62:	a802      	add	r0, sp, #8
    2e64:	f00e fa7e 	bl	11364 <gen_jit_code>
		profile_start(EV1);
    2e68:	2001      	movs	r0, #1
    2e6a:	f000 fc91 	bl	3790 <profile_start>
		ret2 = vm.jit_func(args, ags_len);
    2e6e:	9b05      	ldr	r3, [sp, #20]
    2e70:	b2a9      	uxth	r1, r5
    2e72:	4620      	mov	r0, r4
    2e74:	4798      	blx	r3
    2e76:	4605      	mov	r5, r0
		profile_end(EV1);
    2e78:	2001      	movs	r0, #1
		ret2 = vm.jit_func(args, ags_len);
    2e7a:	460c      	mov	r4, r1
		profile_end(EV1);
    2e7c:	f000 fc92 	bl	37a4 <profile_end>
		DEBUG_LOG("jit_func address: 0x%08x\n", (uint32_t) vm.jit_func);
    2e80:	9905      	ldr	r1, [sp, #20]
    2e82:	4812      	ldr	r0, [pc, #72]	; (2ecc <ebpf_eva+0x9c>)
    2e84:	f00d f863 	bl	ff4e <debug_log>
		jit_mem_free(vm.jmem);
    2e88:	9806      	ldr	r0, [sp, #24]
    2e8a:	f00e fa5e 	bl	1134a <jit_mem_free>
	}
	
	DEBUG_LOG("Interupter: Op=%d Ret=%d Jit: Op=%d Ret=%d\n", (int) (ret1 >> 32), (int) (ret1 & 0xffffffff), 
    2e8e:	4623      	mov	r3, r4
    2e90:	463a      	mov	r2, r7
    2e92:	4631      	mov	r1, r6
    2e94:	9500      	str	r5, [sp, #0]
    2e96:	480e      	ldr	r0, [pc, #56]	; (2ed0 <ebpf_eva+0xa0>)
    2e98:	f00d f859 	bl	ff4e <debug_log>
		(int) (ret2 >> 32), (int) (ret2 & 0xffffffff));
	profile_dump(EV0);
    2e9c:	2000      	movs	r0, #0
    2e9e:	f000 fca1 	bl	37e4 <profile_dump>
	profile_dump(EV1);
    2ea2:	2001      	movs	r0, #1
    2ea4:	f000 fc9e 	bl	37e4 <profile_dump>

	int total_mem = jit_mem_statistic(&vm) + get_ebpf_alloc_size();
    2ea8:	a802      	add	r0, sp, #8
    2eaa:	f00e fa87 	bl	113bc <jit_mem_statistic>
    2eae:	4604      	mov	r4, r0
    2eb0:	f000 fcf4 	bl	389c <get_ebpf_alloc_size>
	DEBUG_LOG("mem size: %d bytes\n", total_mem);
    2eb4:	1821      	adds	r1, r4, r0
    2eb6:	4807      	ldr	r0, [pc, #28]	; (2ed4 <ebpf_eva+0xa4>)
    2eb8:	f00d f849 	bl	ff4e <debug_log>
	DEBUG_LOG("finish----------------------------------------\n");
    2ebc:	4806      	ldr	r0, [pc, #24]	; (2ed8 <ebpf_eva+0xa8>)
    2ebe:	f00d f846 	bl	ff4e <debug_log>
}
    2ec2:	b009      	add	sp, #36	; 0x24
    2ec4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2ec6:	bf00      	nop
    2ec8:	00016e10 	.word	0x00016e10
    2ecc:	00016e15 	.word	0x00016e15
    2ed0:	00016e2f 	.word	0x00016e2f
    2ed4:	00016e5b 	.word	0x00016e5b
    2ed8:	00016e6f 	.word	0x00016e6f

00002edc <test_ebpf_c0>:
void test_ebpf_c0() {
    2edc:	b500      	push	{lr}
    2ede:	b089      	sub	sp, #36	; 0x24
	args_frame.r0 = 2500;
    2ee0:	f640 13c4 	movw	r3, #2500	; 0x9c4
	ebpf_eva(code0, sizeof(code0), &args_frame, sizeof(args_frame));
    2ee4:	466a      	mov	r2, sp
    2ee6:	2151      	movs	r1, #81	; 0x51
	args_frame.r0 = 2500;
    2ee8:	9300      	str	r3, [sp, #0]
	ebpf_eva(code0, sizeof(code0), &args_frame, sizeof(args_frame));
    2eea:	4808      	ldr	r0, [pc, #32]	; (2f0c <test_ebpf_c0+0x30>)
    2eec:	2320      	movs	r3, #32
    2eee:	f7ff ff9f 	bl	2e30 <ebpf_eva>
	profile_start(EV0);
    2ef2:	2000      	movs	r0, #0
    2ef4:	f000 fc4c 	bl	3790 <profile_start>
	profile_end(EV0);
    2ef8:	2000      	movs	r0, #0
    2efa:	f000 fc53 	bl	37a4 <profile_end>
	profile_dump(EV0);
    2efe:	2000      	movs	r0, #0
    2f00:	f000 fc70 	bl	37e4 <profile_dump>
}
    2f04:	b009      	add	sp, #36	; 0x24
    2f06:	f85d fb04 	ldr.w	pc, [sp], #4
    2f0a:	bf00      	nop
    2f0c:	2001106c 	.word	0x2001106c

00002f10 <test_ebpf_c1>:
void test_ebpf_c1() {
    2f10:	b500      	push	{lr}
	unsigned char testcase[] = {
    2f12:	4a0a      	ldr	r2, [pc, #40]	; (2f3c <test_ebpf_c1+0x2c>)
void test_ebpf_c1() {
    2f14:	b08b      	sub	sp, #44	; 0x2c
	unsigned char testcase[] = {
    2f16:	6810      	ldr	r0, [r2, #0]
    2f18:	6851      	ldr	r1, [r2, #4]
	args_frame.r1 = (uint32_t) testcase;
    2f1a:	f8cd d00c 	str.w	sp, [sp, #12]
	unsigned char testcase[] = {
    2f1e:	466b      	mov	r3, sp
    2f20:	c303      	stmia	r3!, {r0, r1}
	args_frame.r2 = 500;
    2f22:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    2f26:	9304      	str	r3, [sp, #16]
	ebpf_eva(code1, sizeof(code1), &args_frame, sizeof(args_frame));
    2f28:	aa02      	add	r2, sp, #8
    2f2a:	2320      	movs	r3, #32
    2f2c:	2151      	movs	r1, #81	; 0x51
    2f2e:	4804      	ldr	r0, [pc, #16]	; (2f40 <test_ebpf_c1+0x30>)
    2f30:	f7ff ff7e 	bl	2e30 <ebpf_eva>
}
    2f34:	b00b      	add	sp, #44	; 0x2c
    2f36:	f85d fb04 	ldr.w	pc, [sp], #4
    2f3a:	bf00      	nop
    2f3c:	00016490 	.word	0x00016490
    2f40:	200110bd 	.word	0x200110bd

00002f44 <test_ebpf_c2>:
void test_ebpf_c2() {
    2f44:	b500      	push	{lr}
	args_stack_frame args_frame ={
    2f46:	22e9      	movs	r2, #233	; 0xe9
void test_ebpf_c2() {
    2f48:	b08b      	sub	sp, #44	; 0x2c
	args_stack_frame args_frame ={
    2f4a:	2314      	movs	r3, #20
    2f4c:	e9cd 2301 	strd	r2, r3, [sp, #4]
		.r1 = ((uint32_t)(&mem_size)),
    2f50:	ab01      	add	r3, sp, #4
	args_stack_frame args_frame ={
    2f52:	9303      	str	r3, [sp, #12]
    2f54:	2300      	movs	r3, #0
    2f56:	e9cd 3304 	strd	r3, r3, [sp, #16]
    2f5a:	e9cd 3306 	strd	r3, r3, [sp, #24]
    2f5e:	e9cd 3308 	strd	r3, r3, [sp, #32]
	ebpf_eva(code2, sizeof(code2), &args_frame, sizeof(args_frame));
    2f62:	aa02      	add	r2, sp, #8
    2f64:	2320      	movs	r3, #32
    2f66:	2141      	movs	r1, #65	; 0x41
    2f68:	4802      	ldr	r0, [pc, #8]	; (2f74 <test_ebpf_c2+0x30>)
    2f6a:	f7ff ff61 	bl	2e30 <ebpf_eva>
}
    2f6e:	b00b      	add	sp, #44	; 0x2c
    2f70:	f85d fb04 	ldr.w	pc, [sp], #4
    2f74:	200112a9 	.word	0x200112a9

00002f78 <test_ebpf_c3>:
void test_ebpf_c3() { 
    2f78:	b500      	push	{lr}
    2f7a:	b089      	sub	sp, #36	; 0x24
	args_stack_frame args_frame = {0};
    2f7c:	2218      	movs	r2, #24
    2f7e:	2100      	movs	r1, #0
    2f80:	a802      	add	r0, sp, #8
    2f82:	f7ff f932 	bl	21ea <memset>
	args_frame.r0 = test_str;
    2f86:	4b07      	ldr	r3, [pc, #28]	; (2fa4 <test_ebpf_c3+0x2c>)
    2f88:	9300      	str	r3, [sp, #0]
	args_frame.r1 = (uint32_t) my_memmove;
    2f8a:	4b07      	ldr	r3, [pc, #28]	; (2fa8 <test_ebpf_c3+0x30>)
    2f8c:	9301      	str	r3, [sp, #4]
	ebpf_eva(code3, sizeof(code3), &args_frame, sizeof(args_frame));
    2f8e:	466a      	mov	r2, sp
    2f90:	2320      	movs	r3, #32
    2f92:	f240 11e9 	movw	r1, #489	; 0x1e9
    2f96:	4805      	ldr	r0, [pc, #20]	; (2fac <test_ebpf_c3+0x34>)
    2f98:	f7ff ff4a 	bl	2e30 <ebpf_eva>
}
    2f9c:	b009      	add	sp, #36	; 0x24
    2f9e:	f85d fb04 	ldr.w	pc, [sp], #4
    2fa2:	bf00      	nop
    2fa4:	00016eff 	.word	0x00016eff
    2fa8:	00002e21 	.word	0x00002e21
    2fac:	200112ea 	.word	0x200112ea

00002fb0 <test_ebpf_c4>:
void test_ebpf_c4() {
    2fb0:	b500      	push	{lr}
	args_frame.xpsr = 7;
    2fb2:	2205      	movs	r2, #5
void test_ebpf_c4() {
    2fb4:	b089      	sub	sp, #36	; 0x24
	args_frame.xpsr = 7;
    2fb6:	2307      	movs	r3, #7
    2fb8:	e9cd 2306 	strd	r2, r3, [sp, #24]
	ebpf_eva(code4, sizeof(code4), &args_frame, sizeof(args_frame));
    2fbc:	2169      	movs	r1, #105	; 0x69
    2fbe:	2320      	movs	r3, #32
    2fc0:	466a      	mov	r2, sp
    2fc2:	4803      	ldr	r0, [pc, #12]	; (2fd0 <test_ebpf_c4+0x20>)
    2fc4:	f7ff ff34 	bl	2e30 <ebpf_eva>
}
    2fc8:	b009      	add	sp, #36	; 0x24
    2fca:	f85d fb04 	ldr.w	pc, [sp], #4
    2fce:	bf00      	nop
    2fd0:	200114d3 	.word	0x200114d3

00002fd4 <test_ebpf_c5>:
void test_ebpf_c5() {
    2fd4:	b510      	push	{r4, lr}
    2fd6:	b090      	sub	sp, #64	; 0x40
	struct gpio_struct2 g2 = {
    2fd8:	ab03      	add	r3, sp, #12
    2fda:	4618      	mov	r0, r3
    2fdc:	2214      	movs	r2, #20
    2fde:	2100      	movs	r1, #0
    2fe0:	f7ff f903 	bl	21ea <memset>
	args_stack_frame args_frame = {
    2fe4:	2420      	movs	r4, #32
	struct gpio_struct1 g1 = {
    2fe6:	2100      	movs	r1, #0
    2fe8:	e9cd 1001 	strd	r1, r0, [sp, #4]
	args_stack_frame args_frame = {
    2fec:	4622      	mov	r2, r4
    2fee:	eb0d 0004 	add.w	r0, sp, r4
    2ff2:	f7ff f8fa 	bl	21ea <memset>
    2ff6:	ab01      	add	r3, sp, #4
    2ff8:	9309      	str	r3, [sp, #36]	; 0x24
	ebpf_eva(code5, sizeof(code5), &args_frame, sizeof(args_frame));
    2ffa:	eb0d 0204 	add.w	r2, sp, r4
    2ffe:	4623      	mov	r3, r4
    3000:	2141      	movs	r1, #65	; 0x41
    3002:	4802      	ldr	r0, [pc, #8]	; (300c <CONFIG_USB_DEVICE_VID+0x29>)
    3004:	f7ff ff14 	bl	2e30 <ebpf_eva>
}
    3008:	b010      	add	sp, #64	; 0x40
    300a:	bd10      	pop	{r4, pc}
    300c:	2001153c 	.word	0x2001153c

00003010 <test_ebpf_c6>:
void test_ebpf_c6() {
    3010:	b500      	push	{lr}
	unsigned char mqtt_buf[6] = {0x81, 0x21, 0x12, 0, 0, 0};
    3012:	4b0f      	ldr	r3, [pc, #60]	; (3050 <test_ebpf_c6+0x40>)
    3014:	f853 0f08 	ldr.w	r0, [r3, #8]!
void test_ebpf_c6() {
    3018:	b08d      	sub	sp, #52	; 0x34
	unsigned char mqtt_buf[6] = {0x81, 0x21, 0x12, 0, 0, 0};
    301a:	889b      	ldrh	r3, [r3, #4]
    301c:	9000      	str	r0, [sp, #0]
    301e:	f8ad 3004 	strh.w	r3, [sp, #4]
	args_stack_frame args_frame = {
    3022:	221c      	movs	r2, #28
	struct mqtt_buf_ctx mbc = {
    3024:	f10d 030a 	add.w	r3, sp, #10
	args_stack_frame args_frame = {
    3028:	2100      	movs	r1, #0
    302a:	a805      	add	r0, sp, #20
	struct mqtt_buf_ctx mbc = {
    302c:	9303      	str	r3, [sp, #12]
    302e:	f8cd d008 	str.w	sp, [sp, #8]
	args_stack_frame args_frame = {
    3032:	f7ff f8da 	bl	21ea <memset>
    3036:	ab02      	add	r3, sp, #8
    3038:	9304      	str	r3, [sp, #16]
	ebpf_eva(code6, sizeof(code6), &args_frame, sizeof(args_frame));
    303a:	aa04      	add	r2, sp, #16
    303c:	2320      	movs	r3, #32
    303e:	f240 11b1 	movw	r1, #433	; 0x1b1
    3042:	4804      	ldr	r0, [pc, #16]	; (3054 <test_ebpf_c6+0x44>)
    3044:	f7ff fef4 	bl	2e30 <ebpf_eva>
}
    3048:	b00d      	add	sp, #52	; 0x34
    304a:	f85d fb04 	ldr.w	pc, [sp], #4
    304e:	bf00      	nop
    3050:	00016490 	.word	0x00016490
    3054:	2001157d 	.word	0x2001157d

00003058 <test_ebpf_c7>:
void test_ebpf_c7() {
    3058:	b510      	push	{r4, lr}
    305a:	b09e      	sub	sp, #120	; 0x78
	struct TCPPacket tcppkt = {
    305c:	ac0f      	add	r4, sp, #60	; 0x3c
    305e:	223c      	movs	r2, #60	; 0x3c
    3060:	2100      	movs	r1, #0
    3062:	4620      	mov	r0, r4
    3064:	f7ff f8c1 	bl	21ea <memset>
	struct IPPacket ippkt = {
    3068:	2218      	movs	r2, #24
    306a:	2100      	movs	r1, #0
    306c:	4668      	mov	r0, sp
    306e:	f7ff f8bc 	bl	21ea <memset>
    3072:	9406      	str	r4, [sp, #24]
	args_stack_frame args_frame = {
    3074:	2420      	movs	r4, #32
    3076:	4622      	mov	r2, r4
    3078:	2100      	movs	r1, #0
    307a:	a807      	add	r0, sp, #28
    307c:	f7ff f8b5 	bl	21ea <memset>
	ebpf_eva(code7, sizeof(code7), &args_frame, sizeof(args_frame));
    3080:	4623      	mov	r3, r4
    3082:	aa07      	add	r2, sp, #28
    3084:	f240 1159 	movw	r1, #345	; 0x159
    3088:	4803      	ldr	r0, [pc, #12]	; (3098 <test_ebpf_c7+0x40>)
	args_stack_frame args_frame = {
    308a:	f8cd d020 	str.w	sp, [sp, #32]
	ebpf_eva(code7, sizeof(code7), &args_frame, sizeof(args_frame));
    308e:	f7ff fecf 	bl	2e30 <ebpf_eva>
}
    3092:	b01e      	add	sp, #120	; 0x78
    3094:	bd10      	pop	{r4, pc}
    3096:	bf00      	nop
    3098:	2001172e 	.word	0x2001172e

0000309c <test_ebpf_c8>:
void test_ebpf_c8() {
    309c:	b500      	push	{lr}
	args_frame.r1 = 0; // 1 success, 0 failed
    309e:	220c      	movs	r2, #12
void test_ebpf_c8() {
    30a0:	b089      	sub	sp, #36	; 0x24
	args_frame.r1 = 0; // 1 success, 0 failed
    30a2:	2300      	movs	r3, #0
    30a4:	e9cd 2300 	strd	r2, r3, [sp]
	ebpf_eva(code8_1, sizeof(code8_1), &args_frame, sizeof(args_frame));
    30a8:	2151      	movs	r1, #81	; 0x51
    30aa:	466a      	mov	r2, sp
    30ac:	2320      	movs	r3, #32
    30ae:	4806      	ldr	r0, [pc, #24]	; (30c8 <test_ebpf_c8+0x2c>)
    30b0:	f7ff febe 	bl	2e30 <ebpf_eva>
	ebpf_eva(code8_2, sizeof(code8_2), &args_frame, sizeof(args_frame));
    30b4:	2320      	movs	r3, #32
    30b6:	466a      	mov	r2, sp
    30b8:	2169      	movs	r1, #105	; 0x69
    30ba:	4804      	ldr	r0, [pc, #16]	; (30cc <test_ebpf_c8+0x30>)
    30bc:	f7ff feb8 	bl	2e30 <ebpf_eva>
}
    30c0:	b009      	add	sp, #36	; 0x24
    30c2:	f85d fb04 	ldr.w	pc, [sp], #4
    30c6:	bf00      	nop
    30c8:	20011887 	.word	0x20011887
    30cc:	200118d8 	.word	0x200118d8

000030d0 <test_ebpf_c9>:
void test_ebpf_c9() {
    30d0:	b530      	push	{r4, r5, lr}
    30d2:	b093      	sub	sp, #76	; 0x4c
	struct ETHPacket ethpkt = {
    30d4:	ad08      	add	r5, sp, #32
    30d6:	2420      	movs	r4, #32
    30d8:	4622      	mov	r2, r4
    30da:	2100      	movs	r1, #0
    30dc:	4628      	mov	r0, r5
    30de:	f7ff f884 	bl	21ea <memset>
    30e2:	2300      	movs	r3, #0
    30e4:	2264      	movs	r2, #100	; 0x64
    30e6:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
	args_stack_frame args_frame = {
    30ea:	2100      	movs	r1, #0
    30ec:	221c      	movs	r2, #28
    30ee:	a801      	add	r0, sp, #4
    30f0:	f7ff f87b 	bl	21ea <memset>
	ebpf_eva(code9, sizeof(code9), &args_frame, sizeof(args_frame));
    30f4:	4623      	mov	r3, r4
    30f6:	466a      	mov	r2, sp
    30f8:	2149      	movs	r1, #73	; 0x49
    30fa:	4803      	ldr	r0, [pc, #12]	; (3108 <test_ebpf_c9+0x38>)
	args_stack_frame args_frame = {
    30fc:	9500      	str	r5, [sp, #0]
	ebpf_eva(code9, sizeof(code9), &args_frame, sizeof(args_frame));
    30fe:	f7ff fe97 	bl	2e30 <ebpf_eva>
}
    3102:	b013      	add	sp, #76	; 0x4c
    3104:	bd30      	pop	{r4, r5, pc}
    3106:	bf00      	nop
    3108:	20011941 	.word	0x20011941

0000310c <test_ebpf_c10>:
void test_ebpf_c10() {
    310c:	b500      	push	{lr}
    310e:	b089      	sub	sp, #36	; 0x24
	args_frame.pc = 2020;
    3110:	f240 73e4 	movw	r3, #2020	; 0x7e4
    3114:	9306      	str	r3, [sp, #24]
	ebpf_eva(code10, sizeof(code10), &args_frame, sizeof(args_frame));
    3116:	466a      	mov	r2, sp
    3118:	2320      	movs	r3, #32
    311a:	2141      	movs	r1, #65	; 0x41
    311c:	4802      	ldr	r0, [pc, #8]	; (3128 <test_ebpf_c10+0x1c>)
    311e:	f7ff fe87 	bl	2e30 <ebpf_eva>
}
    3122:	b009      	add	sp, #36	; 0x24
    3124:	f85d fb04 	ldr.w	pc, [sp], #4
    3128:	2001110e 	.word	0x2001110e

0000312c <test_ebpf_c11>:
void test_ebpf_c11() {
    312c:	b510      	push	{r4, lr}
    312e:	b092      	sub	sp, #72	; 0x48
	struct PicoFrame pf = {
    3130:	ac08      	add	r4, sp, #32
    3132:	2226      	movs	r2, #38	; 0x26
    3134:	2100      	movs	r1, #0
    3136:	4620      	mov	r0, r4
    3138:	f7ff f857 	bl	21ea <memset>
    313c:	2307      	movs	r3, #7
	args_stack_frame args_frame = {
    313e:	221c      	movs	r2, #28
    3140:	2100      	movs	r1, #0
    3142:	a801      	add	r0, sp, #4
	struct PicoFrame pf = {
    3144:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
	args_stack_frame args_frame = {
    3148:	f7ff f84f 	bl	21ea <memset>
	ebpf_eva(code11, sizeof(code11), &args_frame, sizeof(args_frame));
    314c:	2320      	movs	r3, #32
    314e:	466a      	mov	r2, sp
    3150:	2141      	movs	r1, #65	; 0x41
    3152:	4803      	ldr	r0, [pc, #12]	; (3160 <test_ebpf_c11+0x34>)
	args_stack_frame args_frame = {
    3154:	9400      	str	r4, [sp, #0]
	ebpf_eva(code11, sizeof(code11), &args_frame, sizeof(args_frame));
    3156:	f7ff fe6b 	bl	2e30 <ebpf_eva>
}
    315a:	b012      	add	sp, #72	; 0x48
    315c:	bd10      	pop	{r4, pc}
    315e:	bf00      	nop
    3160:	2001114f 	.word	0x2001114f

00003164 <test_ebpf_c12>:
void test_ebpf_c12() {
    3164:	b500      	push	{lr}
    3166:	b097      	sub	sp, #92	; 0x5c
	uint8_t destopt[50] = {1, -2, -2, -2, -2, -2};
    3168:	222c      	movs	r2, #44	; 0x2c
    316a:	2100      	movs	r1, #0
    316c:	f10d 002a 	add.w	r0, sp, #42	; 0x2a
    3170:	f7ff f83b 	bl	21ea <memset>
    3174:	4b0b      	ldr	r3, [pc, #44]	; (31a4 <test_ebpf_c12+0x40>)
    3176:	9309      	str	r3, [sp, #36]	; 0x24
	args_stack_frame args_frame = {
    3178:	221c      	movs	r2, #28
	uint8_t destopt[50] = {1, -2, -2, -2, -2, -2};
    317a:	f64f 63fe 	movw	r3, #65278	; 0xfefe
	args_stack_frame args_frame = {
    317e:	2100      	movs	r1, #0
    3180:	a802      	add	r0, sp, #8
	uint8_t destopt[50] = {1, -2, -2, -2, -2, -2};
    3182:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
	args_stack_frame args_frame = {
    3186:	f7ff f830 	bl	21ea <memset>
    318a:	ab09      	add	r3, sp, #36	; 0x24
    318c:	9301      	str	r3, [sp, #4]
	ebpf_eva(code12, sizeof(code12), &args_frame, sizeof(args_frame));
    318e:	aa01      	add	r2, sp, #4
    3190:	2320      	movs	r3, #32
    3192:	f240 1119 	movw	r1, #281	; 0x119
    3196:	4804      	ldr	r0, [pc, #16]	; (31a8 <test_ebpf_c12+0x44>)
    3198:	f7ff fe4a 	bl	2e30 <ebpf_eva>
}
    319c:	b017      	add	sp, #92	; 0x5c
    319e:	f85d fb04 	ldr.w	pc, [sp], #4
    31a2:	bf00      	nop
    31a4:	fefefe01 	.word	0xfefefe01
    31a8:	20011190 	.word	0x20011190

000031ac <run_ebpf_eva>:
Load prog to VM directly
*/
void run_ebpf_eva(int eid) {
#ifdef EBPF_EVA
	int n = sizeof(test_funcs) / sizeof(ebpf_test_func);
	if (eid < 0 || eid >= n) {
    31ac:	280c      	cmp	r0, #12
void run_ebpf_eva(int eid) {
    31ae:	4601      	mov	r1, r0
	if (eid < 0 || eid >= n) {
    31b0:	d903      	bls.n	31ba <run_ebpf_eva+0xe>
		DEBUG_LOG("Invalide idx: %d (should be 0~%d)\n", eid, n);
    31b2:	220d      	movs	r2, #13
    31b4:	4803      	ldr	r0, [pc, #12]	; (31c4 <run_ebpf_eva+0x18>)
    31b6:	f00c beca 	b.w	ff4e <debug_log>
		return;
	}
	ebpf_test_func func = test_funcs[eid];
    31ba:	4b03      	ldr	r3, [pc, #12]	; (31c8 <run_ebpf_eva+0x1c>)
	func();
    31bc:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    31c0:	4718      	bx	r3
    31c2:	bf00      	nop
    31c4:	00016ec5 	.word	0x00016ec5
    31c8:	20010ca4 	.word	0x20010ca4

000031cc <patch_num_eva>:
// 
struct patch_list {
	arraymap *patches;
};

void patch_num_eva(struct patch_list *plist, int n, int times) {
    31cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (plist->patches == NULL) {
    31d0:	6803      	ldr	r3, [r0, #0]
void patch_num_eva(struct patch_list *plist, int n, int times) {
    31d2:	4606      	mov	r6, r0
    31d4:	460d      	mov	r5, r1
    31d6:	4691      	mov	r9, r2
	if (plist->patches == NULL) {
    31d8:	b91b      	cbnz	r3, 31e2 <patch_num_eva+0x16>
		plist->patches = arraymap_new(72);
    31da:	2048      	movs	r0, #72	; 0x48
    31dc:	f00e f81e 	bl	1121c <arraymap_new>
    31e0:	6030      	str	r0, [r6, #0]
void patch_num_eva(struct patch_list *plist, int n, int times) {
    31e2:	2700      	movs	r7, #0
	}
	for (int i = 0; i < n; i++) {
    31e4:	42af      	cmp	r7, r5
    31e6:	db1b      	blt.n	3220 <patch_num_eva+0x54>
		arraymap_set(plist->patches, i, 1);
	}
	int start = get_cur_tick();
    31e8:	f000 fa9c 	bl	3724 <get_cur_tick>
	for (int t = 0; t < times; t++) {
    31ec:	f04f 0800 	mov.w	r8, #0
	int start = get_cur_tick();
    31f0:	4604      	mov	r4, r0
	for (int t = 0; t < times; t++) {
    31f2:	45c8      	cmp	r8, r9
    31f4:	db25      	blt.n	3242 <patch_num_eva+0x76>
		for (int i = 0; i < n; i++) {
			int val = arraymap_get(plist->patches, i);
			(void) val;
		}
	}
	int cycles = get_cur_tick() - start;
    31f6:	f000 fa95 	bl	3724 <get_cur_tick>
    31fa:	1b00      	subs	r0, r0, r4
	DEBUG_LOG("num: %d ti: %d\n", n, (int) (cycles2us(cycles / times / n) * 100));
    31fc:	fb90 f0f9 	sdiv	r0, r0, r9
    3200:	fb90 f0f5 	sdiv	r0, r0, r5
    3204:	f000 fade 	bl	37c4 <cycles2us>
    3208:	490f      	ldr	r1, [pc, #60]	; (3248 <patch_num_eva+0x7c>)
    320a:	f7fd f8d7 	bl	3bc <__aeabi_fmul>
    320e:	f7fd fa25 	bl	65c <__aeabi_f2iz>
    3212:	4629      	mov	r1, r5
    3214:	4602      	mov	r2, r0
}
    3216:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	DEBUG_LOG("num: %d ti: %d\n", n, (int) (cycles2us(cycles / times / n) * 100));
    321a:	480c      	ldr	r0, [pc, #48]	; (324c <patch_num_eva+0x80>)
    321c:	f00c be97 	b.w	ff4e <debug_log>
		arraymap_set(plist->patches, i, 1);
    3220:	4639      	mov	r1, r7
    3222:	2201      	movs	r2, #1
    3224:	6830      	ldr	r0, [r6, #0]
    3226:	f00e f81a 	bl	1125e <arraymap_set>
	for (int i = 0; i < n; i++) {
    322a:	3701      	adds	r7, #1
    322c:	e7da      	b.n	31e4 <patch_num_eva+0x18>
			int val = arraymap_get(plist->patches, i);
    322e:	4639      	mov	r1, r7
    3230:	6830      	ldr	r0, [r6, #0]
    3232:	f00e f871 	bl	11318 <arraymap_get>
		for (int i = 0; i < n; i++) {
    3236:	3701      	adds	r7, #1
    3238:	42af      	cmp	r7, r5
    323a:	dbf8      	blt.n	322e <patch_num_eva+0x62>
	for (int t = 0; t < times; t++) {
    323c:	f108 0801 	add.w	r8, r8, #1
    3240:	e7d7      	b.n	31f2 <patch_num_eva+0x26>
		for (int i = 0; i < n; i++) {
    3242:	2700      	movs	r7, #0
    3244:	e7f8      	b.n	3238 <patch_num_eva+0x6c>
    3246:	bf00      	nop
    3248:	42c80000 	.word	0x42c80000
    324c:	00016eb5 	.word	0x00016eb5

00003250 <test_patch_dispatcher>:
num: 4 ti: 1.531250
num: 8 ti: 3.671875
num: 16 ti: 2.859375
num: 32 ti: 2.578125
*/
void test_patch_dispatcher() {
    3250:	b513      	push	{r0, r1, r4, lr}
	// setup patch list
	profile_add_event("EV0");
    3252:	4810      	ldr	r0, [pc, #64]	; (3294 <test_patch_dispatcher+0x44>)
    3254:	f000 fa6c 	bl	3730 <profile_add_event>
	profile_start(EV0);
    3258:	2000      	movs	r0, #0
    325a:	f000 fa99 	bl	3790 <profile_start>
	profile_end(EV0);
    325e:	2000      	movs	r0, #0
    3260:	f000 faa0 	bl	37a4 <profile_end>
	profile_dump(EV0);
    3264:	2000      	movs	r0, #0
    3266:	f000 fabd 	bl	37e4 <profile_dump>
	struct patch_list plist;
	plist.patches = NULL;
    326a:	2300      	movs	r3, #0
    326c:	9301      	str	r3, [sp, #4]
	int TI = 100;
	for (int i = 1; i < 65; i += 4) {
    326e:	2401      	movs	r4, #1
		patch_num_eva(&plist, i, TI);
    3270:	4621      	mov	r1, r4
    3272:	2264      	movs	r2, #100	; 0x64
    3274:	a801      	add	r0, sp, #4
	for (int i = 1; i < 65; i += 4) {
    3276:	3404      	adds	r4, #4
		patch_num_eva(&plist, i, TI);
    3278:	f7ff ffa8 	bl	31cc <patch_num_eva>
	for (int i = 1; i < 65; i += 4) {
    327c:	2c41      	cmp	r4, #65	; 0x41
    327e:	d1f7      	bne.n	3270 <test_patch_dispatcher+0x20>
	}
	patch_num_eva(&plist, 64, TI);
    3280:	2264      	movs	r2, #100	; 0x64
    3282:	2140      	movs	r1, #64	; 0x40
    3284:	a801      	add	r0, sp, #4
    3286:	f7ff ffa1 	bl	31cc <patch_num_eva>
	arraymap_destroy(plist.patches);
    328a:	9801      	ldr	r0, [sp, #4]
    328c:	f00d ffda 	bl	11244 <arraymap_destroy>
}
    3290:	b002      	add	sp, #8
    3292:	bd10      	pop	{r4, pc}
    3294:	00016f05 	.word	0x00016f05

00003298 <run_ebpf_test>:
	int t;
	//__atomic_test_and_set(&t, __ATOMIC_ACQUIRE);
	//__atomic_clear(&t, __ATOMIC_RELEASE);
}

void run_ebpf_test() {
    3298:	b508      	push	{r3, lr}
	DEBUG_LOG("run_ebpf_test >>>>>> \n");
    329a:	4803      	ldr	r0, [pc, #12]	; (32a8 <run_ebpf_test+0x10>)
    329c:	f00c fe57 	bl	ff4e <debug_log>
	// profile_start(eid);
	// DEBUG_LOG("this is a single printf:%d\n", eid);
	// profile_end(eid);
	// profile_dump(eid);
	// profile_exit();
}
    32a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	test_patch_dispatcher();
    32a4:	f7ff bfd4 	b.w	3250 <test_patch_dispatcher>
    32a8:	00016ee8 	.word	0x00016ee8

000032ac <show_fixed_patch_desc>:
#else
static struct local_patch patch_list[] = {};
void setup_cve_list() {}
#endif

void show_fixed_patch_desc() {
    32ac:	b510      	push	{r4, lr}
	int n = sizeof(patch_list) / sizeof(struct local_patch);
	for (int i = 0; i < n; i++) {
		DEBUG_LOG("%d -> %s\n", i, patch_list[i].cve);
    32ae:	4c09      	ldr	r4, [pc, #36]	; (32d4 <show_fixed_patch_desc+0x28>)
    32b0:	4a09      	ldr	r2, [pc, #36]	; (32d8 <show_fixed_patch_desc+0x2c>)
    32b2:	4620      	mov	r0, r4
    32b4:	2100      	movs	r1, #0
    32b6:	f00c fe4a 	bl	ff4e <debug_log>
    32ba:	4620      	mov	r0, r4
    32bc:	4a07      	ldr	r2, [pc, #28]	; (32dc <show_fixed_patch_desc+0x30>)
    32be:	2101      	movs	r1, #1
    32c0:	f00c fe45 	bl	ff4e <debug_log>
    32c4:	4620      	mov	r0, r4
    32c6:	4a06      	ldr	r2, [pc, #24]	; (32e0 <show_fixed_patch_desc+0x34>)
    32c8:	2102      	movs	r1, #2
	}
	setup_cve_list();
}
    32ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		DEBUG_LOG("%d -> %s\n", i, patch_list[i].cve);
    32ce:	f00c be3e 	b.w	ff4e <debug_log>
    32d2:	bf00      	nop
    32d4:	00016d8a 	.word	0x00016d8a
    32d8:	00016f5e 	.word	0x00016f5e
    32dc:	00016da0 	.word	0x00016da0
    32e0:	00016f71 	.word	0x00016f71

000032e4 <load_local_fixed_patch>:

void load_local_fixed_patch(int pid) {
	int n = sizeof(patch_list) / sizeof(struct local_patch);
	if (pid > n) {
    32e4:	2803      	cmp	r0, #3
void load_local_fixed_patch(int pid) {
    32e6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    32ea:	4604      	mov	r4, r0
	if (pid > n) {
    32ec:	dd07      	ble.n	32fe <load_local_fixed_patch+0x1a>
		show_fixed_patch_desc();
    32ee:	f7ff ffdd 	bl	32ac <show_fixed_patch_desc>
		DEBUG_LOG("patch id should less than %d\n", n);
    32f2:	4821      	ldr	r0, [pc, #132]	; (3378 <load_local_fixed_patch+0x94>)
    32f4:	2103      	movs	r1, #3
		gen_jit_code(vm);
	}
	_patch->vm = vm;
	load_local_patch_to_ctx(_patch);
	DEBUG_LOG("load fixed patch %s success!\n", pt->cve);
    32f6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	DEBUG_LOG("load fixed patch %s success!\n", pt->cve);
    32fa:	f00c be28 	b.w	ff4e <debug_log>
	if (!is_init) {
    32fe:	4e1f      	ldr	r6, [pc, #124]	; (337c <load_local_fixed_patch+0x98>)
    3300:	4d1f      	ldr	r5, [pc, #124]	; (3380 <load_local_fixed_patch+0x9c>)
    3302:	7833      	ldrb	r3, [r6, #0]
    3304:	4f1f      	ldr	r7, [pc, #124]	; (3384 <load_local_fixed_patch+0xa0>)
    3306:	b96b      	cbnz	r3, 3324 <load_local_fixed_patch+0x40>
		_desc = ebpf_calloc(1, sizeof(patch_desc));
    3308:	2108      	movs	r1, #8
    330a:	2001      	movs	r0, #1
    330c:	f000 fabe 	bl	388c <ebpf_calloc>
		_patch = ebpf_calloc(1, sizeof(ebpf_patch));
    3310:	210c      	movs	r1, #12
		_desc = ebpf_calloc(1, sizeof(patch_desc));
    3312:	6028      	str	r0, [r5, #0]
		_patch = ebpf_calloc(1, sizeof(ebpf_patch));
    3314:	2001      	movs	r0, #1
    3316:	f000 fab9 	bl	388c <ebpf_calloc>
		is_init = true;
    331a:	2301      	movs	r3, #1
		_patch = ebpf_calloc(1, sizeof(ebpf_patch));
    331c:	6038      	str	r0, [r7, #0]
		is_init = true;
    331e:	7033      	strb	r3, [r6, #0]
		init_patch_sys();
    3320:	f000 f94c 	bl	35bc <init_patch_sys>
	DEBUG_LOG("start to load patch: %d\n", pid);
    3324:	4621      	mov	r1, r4
    3326:	4818      	ldr	r0, [pc, #96]	; (3388 <load_local_fixed_patch+0xa4>)
    3328:	f00c fe11 	bl	ff4e <debug_log>
	_desc->type = FixedPatchPoint;
    332c:	682b      	ldr	r3, [r5, #0]
	_desc->fixed_id = pt->loc;
    332e:	4d17      	ldr	r5, [pc, #92]	; (338c <load_local_fixed_patch+0xa8>)
	_desc->type = FixedPatchPoint;
    3330:	2200      	movs	r2, #0
	_desc->fixed_id = pt->loc;
    3332:	0126      	lsls	r6, r4, #4
	_desc->type = FixedPatchPoint;
    3334:	705a      	strb	r2, [r3, #1]
	_desc->code_len = 0; // code do not save in desc now
    3336:	709a      	strb	r2, [r3, #2]
    3338:	70da      	strb	r2, [r3, #3]
	_desc->fixed_id = pt->loc;
    333a:	19aa      	adds	r2, r5, r6
	_desc->type = FixedPatchPoint;
    333c:	2101      	movs	r1, #1
    333e:	7019      	strb	r1, [r3, #0]
	_desc->fixed_id = pt->loc;
    3340:	6851      	ldr	r1, [r2, #4]
    3342:	6059      	str	r1, [r3, #4]
	_patch->desc = _desc;
    3344:	6839      	ldr	r1, [r7, #0]
	ebpf_vm *vm = _patch->vm;
    3346:	684c      	ldr	r4, [r1, #4]
	_patch->desc = _desc;
    3348:	600b      	str	r3, [r1, #0]
	if (vm == NULL) {
    334a:	e9d2 8902 	ldrd	r8, r9, [r2, #8]
    334e:	b924      	cbnz	r4, 335a <load_local_fixed_patch+0x76>
		vm = init_ebpf_vm(pt->code, pt->code_len);
    3350:	4649      	mov	r1, r9
    3352:	4640      	mov	r0, r8
    3354:	f00c fe5e 	bl	10014 <init_ebpf_vm>
    3358:	4604      	mov	r4, r0
	ebpf_vm_set_inst(vm, pt->code, pt->code_len);
    335a:	4641      	mov	r1, r8
    335c:	464a      	mov	r2, r9
    335e:	4620      	mov	r0, r4
    3360:	f00c fe68 	bl	10034 <ebpf_vm_set_inst>
	_patch->vm = vm;
    3364:	6838      	ldr	r0, [r7, #0]
	vm->use_jit = false;
    3366:	2300      	movs	r3, #0
    3368:	7523      	strb	r3, [r4, #20]
	_patch->vm = vm;
    336a:	6044      	str	r4, [r0, #4]
	load_local_patch_to_ctx(_patch);
    336c:	f000 f98e 	bl	368c <load_local_patch_to_ctx>
	DEBUG_LOG("load fixed patch %s success!\n", pt->cve);
    3370:	59a9      	ldr	r1, [r5, r6]
    3372:	4807      	ldr	r0, [pc, #28]	; (3390 <load_local_fixed_patch+0xac>)
    3374:	e7bf      	b.n	32f6 <load_local_fixed_patch+0x12>
    3376:	bf00      	nop
    3378:	00016f09 	.word	0x00016f09
    337c:	200057b1 	.word	0x200057b1
    3380:	20002110 	.word	0x20002110
    3384:	20002114 	.word	0x20002114
    3388:	00016f27 	.word	0x00016f27
    338c:	000165e8 	.word	0x000165e8
    3390:	00016f40 	.word	0x00016f40

00003394 <dummy_buggy_MQTT_packet_length_decode>:
	DEBUG_LOG("p1=%d p1-c=%c %d p2=%d p2-c=%c %d\n", p1->v1, p1->v2, p1->v3, p2->v1, p2->v2, p2->v3);
#endif
}

static int dummy_buggy_MQTT_packet_length_decode(struct dummy_MQTT_buf_ctx *buf, uint32_t *length)
{
    3394:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3396:	4604      	mov	r4, r0
    3398:	460e      	mov	r6, r1
	PATCH_FUNCTION_ERR_CODE;
    339a:	f00c fdb9 	bl	ff10 <fixed_patch_point_hanlder>
    339e:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
    33a2:	d11e      	bne.n	33e2 <dummy_buggy_MQTT_packet_length_decode+0x4e>
	uint8_t shift = 0U;
	uint8_t bytes = 0U;

	int ERR = -1;

	*length = 0U;
    33a4:	2200      	movs	r2, #0
	do {
		if (bytes > 4) {
			return ERR;
		}

		if (buf->cur >= buf->end) {
    33a6:	6867      	ldr	r7, [r4, #4]
	*length = 0U;
    33a8:	6032      	str	r2, [r6, #0]
		if (buf->cur >= buf->end) {
    33aa:	6820      	ldr	r0, [r4, #0]
    33ac:	42b8      	cmp	r0, r7
    33ae:	d216      	bcs.n	33de <dummy_buggy_MQTT_packet_length_decode+0x4a>
			return ERR;
		}

		*length += ((uint32_t)*(buf->cur) & 0x7f)
    33b0:	4605      	mov	r5, r0
    33b2:	6831      	ldr	r1, [r6, #0]
    33b4:	f815 3b01 	ldrb.w	r3, [r5], #1
    33b8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
								<< shift;
    33bc:	4093      	lsls	r3, r2
		*length += ((uint32_t)*(buf->cur) & 0x7f)
    33be:	440b      	add	r3, r1
    33c0:	6033      	str	r3, [r6, #0]
		shift += 7;
		bytes++;
	} while ((*(buf->cur++) & 0x80) != 0U);
    33c2:	6025      	str	r5, [r4, #0]
    33c4:	f990 1000 	ldrsb.w	r1, [r0]
    33c8:	2900      	cmp	r1, #0
    33ca:	db05      	blt.n	33d8 <dummy_buggy_MQTT_packet_length_decode+0x44>

	DEBUG_LOG("dummy MQTT packet length:0x%08x \n", *length);
    33cc:	4805      	ldr	r0, [pc, #20]	; (33e4 <dummy_buggy_MQTT_packet_length_decode+0x50>)
    33ce:	4619      	mov	r1, r3
    33d0:	f00c fdbd 	bl	ff4e <debug_log>

	return 0;
    33d4:	2000      	movs	r0, #0
    33d6:	e004      	b.n	33e2 <dummy_buggy_MQTT_packet_length_decode+0x4e>
		if (bytes > 4) {
    33d8:	3207      	adds	r2, #7
    33da:	2a23      	cmp	r2, #35	; 0x23
    33dc:	d1e5      	bne.n	33aa <dummy_buggy_MQTT_packet_length_decode+0x16>
			return ERR;
    33de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    33e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    33e4:	00017069 	.word	0x00017069

000033e8 <call_dummy_buggy_MQTT_function>:

static void call_dummy_buggy_MQTT_function() {
    33e8:	b530      	push	{r4, r5, lr}
	// setup test arguments
	DEBUG_LOG("addr ground-truth bug:0x%08x test:0x%08x \n", dummy_buggy_MQTT_packet_length_decode, call_dummy_buggy_MQTT_function);
    33ea:	4917      	ldr	r1, [pc, #92]	; (3448 <call_dummy_buggy_MQTT_function+0x60>)
    33ec:	4a17      	ldr	r2, [pc, #92]	; (344c <call_dummy_buggy_MQTT_function+0x64>)
    33ee:	4818      	ldr	r0, [pc, #96]	; (3450 <call_dummy_buggy_MQTT_function+0x68>)
static void call_dummy_buggy_MQTT_function() {
    33f0:	b087      	sub	sp, #28
	DEBUG_LOG("addr ground-truth bug:0x%08x test:0x%08x \n", dummy_buggy_MQTT_packet_length_decode, call_dummy_buggy_MQTT_function);
    33f2:	f00c fdac 	bl	ff4e <debug_log>
	
	uint8_t packet_buf[10];
	
	for (int i=0; i<4; ++i) packet_buf[i] = 0xff;
	packet_buf[4] = 0x7f;
    33f6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    33fa:	237f      	movs	r3, #127	; 0x7f
    33fc:	e9cd 2303 	strd	r2, r3, [sp, #12]
	for (int i=5; i<10; ++i) packet_buf[i] = 0;
    3400:	2400      	movs	r4, #0

	struct dummy_MQTT_buf_ctx dbc;
	dbc.cur = &packet_buf[0];
    3402:	ab03      	add	r3, sp, #12
    3404:	9301      	str	r3, [sp, #4]
	dbc.end = &packet_buf[9];	

	uint32_t pkt_length = 0;
	
	profile_start(0);
    3406:	4620      	mov	r0, r4
	dbc.end = &packet_buf[9];	
    3408:	f10d 0315 	add.w	r3, sp, #21
    340c:	9302      	str	r3, [sp, #8]
	for (int i=5; i<10; ++i) packet_buf[i] = 0;
    340e:	f8ad 4014 	strh.w	r4, [sp, #20]
	uint32_t pkt_length = 0;
    3412:	9400      	str	r4, [sp, #0]
	profile_start(0);
    3414:	f000 f9bc 	bl	3790 <profile_start>
	int ret = dummy_buggy_MQTT_packet_length_decode(&dbc, &pkt_length);
    3418:	4669      	mov	r1, sp
    341a:	a801      	add	r0, sp, #4
    341c:	f7ff ffba 	bl	3394 <dummy_buggy_MQTT_packet_length_decode>
    3420:	4605      	mov	r5, r0
	profile_end(0);
    3422:	4620      	mov	r0, r4
    3424:	f000 f9be 	bl	37a4 <profile_end>

	DEBUG_LOG("Decoded MQTT packet length is %d\n", pkt_length);
    3428:	9900      	ldr	r1, [sp, #0]
    342a:	480a      	ldr	r0, [pc, #40]	; (3454 <call_dummy_buggy_MQTT_function+0x6c>)
    342c:	f00c fd8f 	bl	ff4e <debug_log>

	DEBUG_LOG("Bug function return %d ", ret);
    3430:	4629      	mov	r1, r5
    3432:	4809      	ldr	r0, [pc, #36]	; (3458 <call_dummy_buggy_MQTT_function+0x70>)
    3434:	f00c fd8b 	bl	ff4e <debug_log>
	if (ret != 0) {
    3438:	b125      	cbz	r5, 3444 <call_dummy_buggy_MQTT_function+0x5c>
		DEBUG_LOG("is still vulnerable!\n\n");
    343a:	4808      	ldr	r0, [pc, #32]	; (345c <call_dummy_buggy_MQTT_function+0x74>)
	} else {
		DEBUG_LOG("is fixed!\n");
    343c:	f00c fd87 	bl	ff4e <debug_log>
	}
}
    3440:	b007      	add	sp, #28
    3442:	bd30      	pop	{r4, r5, pc}
		DEBUG_LOG("is fixed!\n");
    3444:	4806      	ldr	r0, [pc, #24]	; (3460 <call_dummy_buggy_MQTT_function+0x78>)
    3446:	e7f9      	b.n	343c <call_dummy_buggy_MQTT_function+0x54>
    3448:	00003395 	.word	0x00003395
    344c:	000033e9 	.word	0x000033e9
    3450:	00016fad 	.word	0x00016fad
    3454:	00016fd8 	.word	0x00016fd8
    3458:	00016ffa 	.word	0x00016ffa
    345c:	00017012 	.word	0x00017012
    3460:	00017029 	.word	0x00017029

00003464 <test_fixed_patch_point>:
void test_fixed_patch_point() {
    3464:	b508      	push	{r3, lr}
	profile_add_event("fixed patch");
    3466:	4805      	ldr	r0, [pc, #20]	; (347c <test_fixed_patch_point+0x18>)
    3468:	f000 f962 	bl	3730 <profile_add_event>
	call_dummy_buggy_MQTT_function();
    346c:	f7ff ffbc 	bl	33e8 <call_dummy_buggy_MQTT_function>
	profile_dump(0);
    3470:	2000      	movs	r0, #0
}
    3472:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	profile_dump(0);
    3476:	f000 b9b5 	b.w	37e4 <profile_dump>
    347a:	bf00      	nop
    347c:	0001708b 	.word	0x0001708b

00003480 <dispatch_fixed_patch_point>:
void dispatch_fixed_patch_point(uint32_t sp) {
    3480:	b570      	push	{r4, r5, r6, lr}
	uint32_t addr = (lr - 4) & (~0x3);
    3482:	6845      	ldr	r5, [r0, #4]
    3484:	3d04      	subs	r5, #4
    3486:	f025 0503 	bic.w	r5, r5, #3
void dispatch_fixed_patch_point(uint32_t sp) {
    348a:	4604      	mov	r4, r0
	ebpf_patch *patch = get_fixed_patch_by_lr(addr);
    348c:	4628      	mov	r0, r5
    348e:	f000 f8d1 	bl	3634 <get_fixed_patch_by_lr>
	DEBUG_LOG("try to get patch at: 0x%08x\n", addr);
    3492:	4629      	mov	r1, r5
	ebpf_patch *patch = get_fixed_patch_by_lr(addr);
    3494:	4606      	mov	r6, r0
	DEBUG_LOG("try to get patch at: 0x%08x\n", addr);
    3496:	480f      	ldr	r0, [pc, #60]	; (34d4 <dispatch_fixed_patch_point+0x54>)
    3498:	f00c fd59 	bl	ff4e <debug_log>
	if (patch == NULL) {
    349c:	b93e      	cbnz	r6, 34ae <dispatch_fixed_patch_point+0x2e>
		*(volatile uint32_t *) &(args->r0_1) = FIXED_OP_PASS;
    349e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    34a2:	6023      	str	r3, [r4, #0]
		DEBUG_LOG("Do not find Patch here\n");
    34a4:	480c      	ldr	r0, [pc, #48]	; (34d8 <dispatch_fixed_patch_point+0x58>)
}
    34a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		DEBUG_LOG("Do not find Patch here\n");
    34aa:	f00c bd50 	b.w	ff4e <debug_log>
	ret = run_ebpf_filter(patch, args, sizeof(fixed_stack_frame));
    34ae:	2208      	movs	r2, #8
    34b0:	4621      	mov	r1, r4
    34b2:	4630      	mov	r0, r6
    34b4:	f00c fd39 	bl	ff2a <run_ebpf_filter>
	if (op == FILTER_DROP) {
    34b8:	2901      	cmp	r1, #1
    34ba:	d102      	bne.n	34c2 <dispatch_fixed_patch_point+0x42>
		*(volatile uint32_t *) &(args->r0_1) = 0; 
    34bc:	2300      	movs	r3, #0
		*(volatile uint32_t *) &(args->r0_1) = FIXED_OP_PASS;
    34be:	6023      	str	r3, [r4, #0]
		return;
    34c0:	e003      	b.n	34ca <dispatch_fixed_patch_point+0x4a>
	} else if (op == FILTER_REDIRECT) {
    34c2:	2902      	cmp	r1, #2
    34c4:	d102      	bne.n	34cc <dispatch_fixed_patch_point+0x4c>
		*(volatile uint32_t *) (args->lr) = ret_code;
    34c6:	6863      	ldr	r3, [r4, #4]
    34c8:	6018      	str	r0, [r3, #0]
}
    34ca:	bd70      	pop	{r4, r5, r6, pc}
		*(volatile uint32_t *) &(args->r0_1) = FIXED_OP_PASS;
    34cc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    34d0:	e7f5      	b.n	34be <dispatch_fixed_patch_point+0x3e>
    34d2:	bf00      	nop
    34d4:	00017034 	.word	0x00017034
    34d8:	00017051 	.word	0x00017051

000034dc <update_bits_filter>:

// global patch context
static bool ctx_init = false;
patch_context pctx;

static void update_bits_filter() {
    34dc:	b538      	push	{r3, r4, r5, lr}
	pctx.fbits_filter = 0;
    34de:	4c13      	ldr	r4, [pc, #76]	; (352c <update_bits_filter+0x50>)
    34e0:	2500      	movs	r5, #0
    34e2:	6065      	str	r5, [r4, #4]

	for (int i = 0; i < pctx.fpatch_list.fiexed_patches->cur_size; i++) {
    34e4:	68a0      	ldr	r0, [r4, #8]
    34e6:	8843      	ldrh	r3, [r0, #2]
    34e8:	42ab      	cmp	r3, r5
    34ea:	dc0a      	bgt.n	3502 <update_bits_filter+0x26>
		if (patch != NULL && patch->is_active) {
			pctx.fbits_filter |= patch->desc->fixed_id;
		}
	}

	pctx.dbits_filter_pc = pctx.dbits_filter_bpkt = 0;
    34ec:	2300      	movs	r3, #0
    34ee:	e9c4 3303 	strd	r3, r3, [r4, #12]
	dynamic_patch *dp = pctx.dpatch_list.next;
    34f2:	69a2      	ldr	r2, [r4, #24]
	while (dp != NULL) {
    34f4:	4618      	mov	r0, r3
    34f6:	4619      	mov	r1, r3
    34f8:	b982      	cbnz	r2, 351c <update_bits_filter+0x40>
    34fa:	b108      	cbz	r0, 3500 <update_bits_filter+0x24>
    34fc:	e9c4 3103 	strd	r3, r1, [r4, #12]
		pctx.dbits_filter_pc |= dp->pc_addr;
		pctx.dbits_filter_bpkt |= dp->inst_addr;
		dp = dp->next;
	}
}
    3500:	bd38      	pop	{r3, r4, r5, pc}
		const ebpf_patch *patch = arraymap_iter_val(pctx.fpatch_list.fiexed_patches, i);
    3502:	4629      	mov	r1, r5
    3504:	f00d ff16 	bl	11334 <arraymap_iter_val>
		if (patch != NULL && patch->is_active) {
    3508:	b130      	cbz	r0, 3518 <update_bits_filter+0x3c>
    350a:	7a03      	ldrb	r3, [r0, #8]
    350c:	b123      	cbz	r3, 3518 <update_bits_filter+0x3c>
			pctx.fbits_filter |= patch->desc->fixed_id;
    350e:	6803      	ldr	r3, [r0, #0]
    3510:	6862      	ldr	r2, [r4, #4]
    3512:	685b      	ldr	r3, [r3, #4]
    3514:	4313      	orrs	r3, r2
    3516:	6063      	str	r3, [r4, #4]
	for (int i = 0; i < pctx.fpatch_list.fiexed_patches->cur_size; i++) {
    3518:	3501      	adds	r5, #1
    351a:	e7e3      	b.n	34e4 <update_bits_filter+0x8>
		pctx.dbits_filter_pc |= dp->pc_addr;
    351c:	68d0      	ldr	r0, [r2, #12]
    351e:	4301      	orrs	r1, r0
		pctx.dbits_filter_bpkt |= dp->inst_addr;
    3520:	6890      	ldr	r0, [r2, #8]
		dp = dp->next;
    3522:	6852      	ldr	r2, [r2, #4]
		pctx.dbits_filter_bpkt |= dp->inst_addr;
    3524:	4303      	orrs	r3, r0
		dp = dp->next;
    3526:	2001      	movs	r0, #1
    3528:	e7e6      	b.n	34f8 <update_bits_filter+0x1c>
    352a:	bf00      	nop
    352c:	20002118 	.word	0x20002118

00003530 <add_dynamic_patch_to_ctx>:
	}
	
	patch->is_active = true;
}

static dynamic_patch* add_dynamic_patch_to_ctx(ebpf_patch *patch) {
    3530:	b570      	push	{r4, r5, r6, lr}
	dynamic_patch *dp = pctx.dpatch_list.next;
    3532:	4d14      	ldr	r5, [pc, #80]	; (3584 <add_dynamic_patch_to_ctx+0x54>)
static dynamic_patch* add_dynamic_patch_to_ctx(ebpf_patch *patch) {
    3534:	4606      	mov	r6, r0
	dynamic_patch *dp = pctx.dpatch_list.next;
    3536:	69ac      	ldr	r4, [r5, #24]
	dynamic_patch *cur = NULL, *tail = &pctx.dpatch_list;
	int cnt = 0;
    3538:	2300      	movs	r3, #0
	dynamic_patch *cur = NULL, *tail = &pctx.dpatch_list;
    353a:	3514      	adds	r5, #20
	while (dp != NULL) {
    353c:	b93c      	cbnz	r4, 354e <add_dynamic_patch_to_ctx+0x1e>
		tail = dp;
		dp = dp->next;
		cnt++;
	}
	if (cur == NULL) {
		if (cnt > MAX_DP_NUM) { // overwrite the last one
    353e:	2b06      	cmp	r3, #6
    3540:	dc0e      	bgt.n	3560 <add_dynamic_patch_to_ctx+0x30>
			//return NULL;
			DEBUG_LOG("Warning: dynamic patch exceed the maximum number(6).\n");
			cur = tail;
		} else {
			cur = ebpf_malloc(sizeof(dynamic_patch));
    3542:	2010      	movs	r0, #16
    3544:	f000 f974 	bl	3830 <ebpf_malloc>
    3548:	4604      	mov	r4, r0
			tail->next = cur;
    354a:	6068      	str	r0, [r5, #4]
    354c:	e00c      	b.n	3568 <add_dynamic_patch_to_ctx+0x38>
		if (dp->inst_addr == patch->desc->inst_addr) {
    354e:	6832      	ldr	r2, [r6, #0]
    3550:	68a1      	ldr	r1, [r4, #8]
    3552:	6852      	ldr	r2, [r2, #4]
    3554:	4291      	cmp	r1, r2
    3556:	d007      	beq.n	3568 <add_dynamic_patch_to_ctx+0x38>
		cnt++;
    3558:	4625      	mov	r5, r4
    355a:	3301      	adds	r3, #1
		dp = dp->next;
    355c:	6864      	ldr	r4, [r4, #4]
    355e:	e7ed      	b.n	353c <add_dynamic_patch_to_ctx+0xc>
			DEBUG_LOG("Warning: dynamic patch exceed the maximum number(6).\n");
    3560:	4809      	ldr	r0, [pc, #36]	; (3588 <add_dynamic_patch_to_ctx+0x58>)
    3562:	f00c fcf4 	bl	ff4e <debug_log>
			cur = tail;
    3566:	462c      	mov	r4, r5
		}
	}
	cur->next = NULL;
    3568:	2300      	movs	r3, #0
    356a:	6063      	str	r3, [r4, #4]
	cur->inst_addr = calc_bpkt_addr(patch->desc->inst_addr);
    356c:	6833      	ldr	r3, [r6, #0]
    356e:	6858      	ldr	r0, [r3, #4]
    3570:	f00c fc5d 	bl	fe2e <calc_bpkt_addr>
    3574:	60a0      	str	r0, [r4, #8]
	cur->pc_addr = calc_bpkt_pc(cur->inst_addr);
    3576:	f00c fd03 	bl	ff80 <calc_bpkt_pc>
	cur->patch = patch;
    357a:	6026      	str	r6, [r4, #0]
	cur->pc_addr = calc_bpkt_pc(cur->inst_addr);
    357c:	60e0      	str	r0, [r4, #12]
	return cur;
}
    357e:	4620      	mov	r0, r4
    3580:	bd70      	pop	{r4, r5, r6, pc}
    3582:	bf00      	nop
    3584:	20002118 	.word	0x20002118
    3588:	00017097 	.word	0x00017097

0000358c <active_patch>:
static void active_patch(ebpf_patch *patch) {
    358c:	b510      	push	{r4, lr}
    358e:	4604      	mov	r4, r0
	update_bits_filter();
    3590:	f7ff ffa4 	bl	34dc <update_bits_filter>
	if (patch->desc->type == FixedPatchPoint) {
    3594:	6823      	ldr	r3, [r4, #0]
    3596:	881a      	ldrh	r2, [r3, #0]
    3598:	2a01      	cmp	r2, #1
    359a:	d107      	bne.n	35ac <active_patch+0x20>
		pctx.fbits_filter |= patch->desc->fixed_id;
    359c:	4a06      	ldr	r2, [pc, #24]	; (35b8 <active_patch+0x2c>)
    359e:	6859      	ldr	r1, [r3, #4]
    35a0:	6853      	ldr	r3, [r2, #4]
    35a2:	430b      	orrs	r3, r1
    35a4:	6053      	str	r3, [r2, #4]
	patch->is_active = true;
    35a6:	2301      	movs	r3, #1
    35a8:	7223      	strb	r3, [r4, #8]
}
    35aa:	bd10      	pop	{r4, pc}
	} else if (patch->desc->type == DynamicPatchPoint) {
    35ac:	2a02      	cmp	r2, #2
    35ae:	d1fa      	bne.n	35a6 <active_patch+0x1a>
		add_hw_bkpt(patch->desc->inst_addr);
    35b0:	6858      	ldr	r0, [r3, #4]
    35b2:	f7ff f997 	bl	28e4 <add_hw_bkpt>
    35b6:	e7f6      	b.n	35a6 <active_patch+0x1a>
    35b8:	20002118 	.word	0x20002118

000035bc <init_patch_sys>:
		add_dynamic_patch_to_ctx(patch);
	}
	return patch;
}

void init_patch_sys(void) {
    35bc:	b570      	push	{r4, r5, r6, lr}
	if (ctx_init) {
    35be:	4c0b      	ldr	r4, [pc, #44]	; (35ec <init_patch_sys+0x30>)
    35c0:	7826      	ldrb	r6, [r4, #0]
    35c2:	b98e      	cbnz	r6, 35e8 <init_patch_sys+0x2c>
		return;
	}
	int v = 1;
	DEBUG_LOG("init_patch_sys: %d\n", v);
	const int init_size = 8;
	memset(&pctx, 0, sizeof(pctx));
    35c4:	4d0a      	ldr	r5, [pc, #40]	; (35f0 <init_patch_sys+0x34>)
	DEBUG_LOG("init_patch_sys: %d\n", v);
    35c6:	480b      	ldr	r0, [pc, #44]	; (35f4 <init_patch_sys+0x38>)
    35c8:	2101      	movs	r1, #1
    35ca:	f00c fcc0 	bl	ff4e <debug_log>
	memset(&pctx, 0, sizeof(pctx));
    35ce:	2224      	movs	r2, #36	; 0x24
    35d0:	4631      	mov	r1, r6
    35d2:	4628      	mov	r0, r5
    35d4:	f7fe fe09 	bl	21ea <memset>
	pctx.fpatch_list.fiexed_patches = arraymap_new(4);
    35d8:	2004      	movs	r0, #4
    35da:	f00d fe1f 	bl	1121c <arraymap_new>
    35de:	60a8      	str	r0, [r5, #8]
	update_bits_filter();
    35e0:	f7ff ff7c 	bl	34dc <update_bits_filter>
	ctx_init = true;
    35e4:	2301      	movs	r3, #1
    35e6:	7023      	strb	r3, [r4, #0]
}
    35e8:	bd70      	pop	{r4, r5, r6, pc}
    35ea:	bf00      	nop
    35ec:	200057b2 	.word	0x200057b2
    35f0:	20002118 	.word	0x20002118
    35f4:	000170cd 	.word	0x000170cd

000035f8 <show_all_patches>:
		ebpf_free(patch->vm);
		ebpf_free(patch);
	}
}

void show_all_patches(void) {
    35f8:	b538      	push	{r3, r4, r5, lr}
	DEBUG_LOG("Dynamic Patch List:\n");
    35fa:	480a      	ldr	r0, [pc, #40]	; (3624 <show_all_patches+0x2c>)
	dynamic_patch *dp = pctx.dpatch_list.next;
	while (dp != NULL) {
		DEBUG_LOG("dypk inst_addr: 0x%08x pc_addr: 0x%08x is_active: %d\n", dp->inst_addr, dp->pc_addr, dp->patch->is_active);
    35fc:	4d0a      	ldr	r5, [pc, #40]	; (3628 <show_all_patches+0x30>)
	DEBUG_LOG("Dynamic Patch List:\n");
    35fe:	f00c fca6 	bl	ff4e <debug_log>
	dynamic_patch *dp = pctx.dpatch_list.next;
    3602:	4b0a      	ldr	r3, [pc, #40]	; (362c <show_all_patches+0x34>)
    3604:	699c      	ldr	r4, [r3, #24]
	while (dp != NULL) {
    3606:	b924      	cbnz	r4, 3612 <show_all_patches+0x1a>
		dp = dp->next;
	}

	DEBUG_LOG("Fixed Patch List:\n");
    3608:	4809      	ldr	r0, [pc, #36]	; (3630 <show_all_patches+0x38>)
}
    360a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	DEBUG_LOG("Fixed Patch List:\n");
    360e:	f00c bc9e 	b.w	ff4e <debug_log>
		DEBUG_LOG("dypk inst_addr: 0x%08x pc_addr: 0x%08x is_active: %d\n", dp->inst_addr, dp->pc_addr, dp->patch->is_active);
    3612:	6823      	ldr	r3, [r4, #0]
    3614:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
    3618:	7a1b      	ldrb	r3, [r3, #8]
    361a:	4628      	mov	r0, r5
    361c:	f00c fc97 	bl	ff4e <debug_log>
		dp = dp->next;
    3620:	6864      	ldr	r4, [r4, #4]
    3622:	e7f0      	b.n	3606 <show_all_patches+0xe>
    3624:	00017107 	.word	0x00017107
    3628:	0001711c 	.word	0x0001711c
    362c:	20002118 	.word	0x20002118
    3630:	00017152 	.word	0x00017152

00003634 <get_fixed_patch_by_lr>:
	ebpf_patch *patch = add_ebpf_patch(desc);
	// TODO: use lock to load to memory and active patch
	active_patch(patch);
}

ebpf_patch* get_fixed_patch_by_lr(uint32_t lr) {
    3634:	b508      	push	{r3, lr}
	if ((pctx.fbits_filter & lr) != lr) {
    3636:	4b09      	ldr	r3, [pc, #36]	; (365c <get_fixed_patch_by_lr+0x28>)
    3638:	685a      	ldr	r2, [r3, #4]
    363a:	ea00 0102 	and.w	r1, r0, r2
    363e:	ea30 0202 	bics.w	r2, r0, r2
    3642:	d001      	beq.n	3648 <get_fixed_patch_by_lr+0x14>
		return NULL;
    3644:	2000      	movs	r0, #0
	ebpf_patch *patch = arraymap_get(pctx.fpatch_list.fiexed_patches, lr);
	if (patch != NULL && patch->is_active) {
		return patch;
	}
	return NULL;
}
    3646:	bd08      	pop	{r3, pc}
	ebpf_patch *patch = arraymap_get(pctx.fpatch_list.fiexed_patches, lr);
    3648:	6898      	ldr	r0, [r3, #8]
    364a:	f00d fe65 	bl	11318 <arraymap_get>
	if (patch != NULL && patch->is_active) {
    364e:	2800      	cmp	r0, #0
    3650:	d0f8      	beq.n	3644 <get_fixed_patch_by_lr+0x10>
    3652:	7a03      	ldrb	r3, [r0, #8]
    3654:	2b00      	cmp	r3, #0
    3656:	d1f6      	bne.n	3646 <get_fixed_patch_by_lr+0x12>
    3658:	e7f4      	b.n	3644 <get_fixed_patch_by_lr+0x10>
    365a:	bf00      	nop
    365c:	20002118 	.word	0x20002118

00003660 <get_dynamic_patch_by_bpkt>:
	}
	return NULL;
}

ebpf_patch* get_dynamic_patch_by_bpkt(uint32_t loc) {
if ((pctx.dbits_filter_bpkt & loc) != loc) {
    3660:	4b09      	ldr	r3, [pc, #36]	; (3688 <get_dynamic_patch_by_bpkt+0x28>)
    3662:	68da      	ldr	r2, [r3, #12]
    3664:	ea30 0202 	bics.w	r2, r0, r2
    3668:	d101      	bne.n	366e <get_dynamic_patch_by_bpkt+0xe>
		return NULL;
	}
	dynamic_patch *dp = pctx.dpatch_list.next;
    366a:	699b      	ldr	r3, [r3, #24]
	while (dp != NULL) {
    366c:	b913      	cbnz	r3, 3674 <get_dynamic_patch_by_bpkt+0x14>
		return NULL;
    366e:	2200      	movs	r2, #0
			return dp->patch;
		}
		dp = dp->next;
	}
	return NULL;
}
    3670:	4610      	mov	r0, r2
    3672:	4770      	bx	lr
		if (dp->inst_addr == loc && dp->patch->is_active) {
    3674:	689a      	ldr	r2, [r3, #8]
    3676:	4282      	cmp	r2, r0
    3678:	d103      	bne.n	3682 <get_dynamic_patch_by_bpkt+0x22>
    367a:	681a      	ldr	r2, [r3, #0]
    367c:	7a11      	ldrb	r1, [r2, #8]
    367e:	2900      	cmp	r1, #0
    3680:	d1f6      	bne.n	3670 <get_dynamic_patch_by_bpkt+0x10>
		dp = dp->next;
    3682:	685b      	ldr	r3, [r3, #4]
    3684:	e7f2      	b.n	366c <get_dynamic_patch_by_bpkt+0xc>
    3686:	bf00      	nop
    3688:	20002118 	.word	0x20002118

0000368c <load_local_patch_to_ctx>:
		}
	}
	return NULL;
}

void load_local_patch_to_ctx(ebpf_patch *patch) {
    368c:	b538      	push	{r3, r4, r5, lr}
	if (patch->desc->type == FixedPatchPoint) { 
    368e:	6803      	ldr	r3, [r0, #0]
    3690:	881a      	ldrh	r2, [r3, #0]
    3692:	2a01      	cmp	r2, #1
void load_local_patch_to_ctx(ebpf_patch *patch) {
    3694:	4605      	mov	r5, r0
	if (patch->desc->type == FixedPatchPoint) { 
    3696:	d10a      	bne.n	36ae <load_local_patch_to_ctx+0x22>
	arraymap_set(pctx.fpatch_list.fiexed_patches, patch->desc->fixed_id, patch);
    3698:	6859      	ldr	r1, [r3, #4]
    369a:	4b13      	ldr	r3, [pc, #76]	; (36e8 <load_local_patch_to_ctx+0x5c>)
    369c:	4602      	mov	r2, r0
    369e:	6898      	ldr	r0, [r3, #8]
    36a0:	f00d fddd 	bl	1125e <arraymap_set>
		} else { // update current value
			dp->inst_addr = calc_bpkt_addr(patch->desc->inst_addr);
			dp->pc_addr = calc_bpkt_pc(dp->inst_addr);
		}
		DEBUG_LOG("dynamic patch: pc=0x%08x inst=0x%08x\n", dp->pc_addr, dp->inst_addr);
		active_patch(patch);
    36a4:	4628      	mov	r0, r5
	}
}
    36a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		active_patch(patch);
    36aa:	f7ff bf6f 	b.w	358c <active_patch>
	} else if (patch->desc->type == DynamicPatchPoint) {
    36ae:	2a02      	cmp	r2, #2
    36b0:	d119      	bne.n	36e6 <load_local_patch_to_ctx+0x5a>
		dynamic_patch *dp = pctx.dpatch_list.next;
    36b2:	4a0d      	ldr	r2, [pc, #52]	; (36e8 <load_local_patch_to_ctx+0x5c>)
    36b4:	6994      	ldr	r4, [r2, #24]
		while (dp != NULL) {
    36b6:	b94c      	cbnz	r4, 36cc <load_local_patch_to_ctx+0x40>
			dp = add_dynamic_patch_to_ctx(patch);
    36b8:	4628      	mov	r0, r5
    36ba:	f7ff ff39 	bl	3530 <add_dynamic_patch_to_ctx>
    36be:	4604      	mov	r4, r0
		DEBUG_LOG("dynamic patch: pc=0x%08x inst=0x%08x\n", dp->pc_addr, dp->inst_addr);
    36c0:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
    36c4:	4809      	ldr	r0, [pc, #36]	; (36ec <load_local_patch_to_ctx+0x60>)
    36c6:	f00c fc42 	bl	ff4e <debug_log>
    36ca:	e7eb      	b.n	36a4 <load_local_patch_to_ctx+0x18>
			if (dp->patch == patch) {
    36cc:	6822      	ldr	r2, [r4, #0]
    36ce:	42aa      	cmp	r2, r5
    36d0:	d001      	beq.n	36d6 <load_local_patch_to_ctx+0x4a>
			dp = dp->next;
    36d2:	6864      	ldr	r4, [r4, #4]
    36d4:	e7ef      	b.n	36b6 <load_local_patch_to_ctx+0x2a>
			dp->inst_addr = calc_bpkt_addr(patch->desc->inst_addr);
    36d6:	6858      	ldr	r0, [r3, #4]
    36d8:	f00c fba9 	bl	fe2e <calc_bpkt_addr>
    36dc:	60a0      	str	r0, [r4, #8]
			dp->pc_addr = calc_bpkt_pc(dp->inst_addr);
    36de:	f00c fc4f 	bl	ff80 <calc_bpkt_pc>
    36e2:	60e0      	str	r0, [r4, #12]
    36e4:	e7ec      	b.n	36c0 <load_local_patch_to_ctx+0x34>
}
    36e6:	bd38      	pop	{r3, r4, r5, pc}
    36e8:	20002118 	.word	0x20002118
    36ec:	000170e1 	.word	0x000170e1

000036f0 <dwt_init>:
#define DWT_CYCCNT (volatile uint32_t *) (0xE0001004) // page e156
#define MSK_DEMCR_TRCENA (1 << 24) // page 464
#define MSK_DWT_CYCCNTENA (1 << 0) // page e159

static inline void dwt_init() {
	ticks_per_us = SYSCoreClock / 1000000;
    36f0:	4b08      	ldr	r3, [pc, #32]	; (3714 <dwt_init+0x24>)
    36f2:	2240      	movs	r2, #64	; 0x40
    36f4:	601a      	str	r2, [r3, #0]
	*COREDEBUG_DEMCR |= MSK_DEMCR_TRCENA;
    36f6:	4a08      	ldr	r2, [pc, #32]	; (3718 <dwt_init+0x28>)
    36f8:	6813      	ldr	r3, [r2, #0]
    36fa:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    36fe:	6013      	str	r3, [r2, #0]
	*DWT_CYCCNT = 0;
    3700:	4b06      	ldr	r3, [pc, #24]	; (371c <dwt_init+0x2c>)
    3702:	2200      	movs	r2, #0
    3704:	601a      	str	r2, [r3, #0]
	*DWT_CTRL |= MSK_DWT_CYCCNTENA;
    3706:	4a06      	ldr	r2, [pc, #24]	; (3720 <dwt_init+0x30>)
    3708:	6813      	ldr	r3, [r2, #0]
    370a:	f043 0301 	orr.w	r3, r3, #1
    370e:	6013      	str	r3, [r2, #0]
}
    3710:	4770      	bx	lr
    3712:	bf00      	nop
    3714:	20010cd8 	.word	0x20010cd8
    3718:	e000edfc 	.word	0xe000edfc
    371c:	e0001004 	.word	0xe0001004
    3720:	e0001000 	.word	0xe0001000

00003724 <get_cur_tick>:
	*DWT_CYCCNT = 0;
	*COREDEBUG_DEMCR &= ~MSK_DEMCR_TRCENA;
}

static inline uint32_t dwt_get_counter() {
	return *DWT_CYCCNT;
    3724:	4b01      	ldr	r3, [pc, #4]	; (372c <get_cur_tick+0x8>)
    3726:	6818      	ldr	r0, [r3, #0]
}


int get_cur_tick() {
	return dwt_get_counter();
}
    3728:	4770      	bx	lr
    372a:	bf00      	nop
    372c:	e0001004 	.word	0xe0001004

00003730 <profile_add_event>:
	dwt_init();
	profiler.event_name[EV0] = EV0_TAG;
	profiler.event_name[EV1] = EV1_TAG;
}

int profile_add_event(const char *event) {
    3730:	b508      	push	{r3, lr}
	if (!profiler_is_init) {
    3732:	4b13      	ldr	r3, [pc, #76]	; (3780 <profile_add_event+0x50>)
    3734:	4913      	ldr	r1, [pc, #76]	; (3784 <profile_add_event+0x54>)
    3736:	781b      	ldrb	r3, [r3, #0]
    3738:	b9cb      	cbnz	r3, 376e <profile_add_event+0x3e>
	profiler.event_count = 0;
    373a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
	dwt_init();
    373e:	f7ff ffd7 	bl	36f0 <dwt_init>
	profiler.event_name[EV0] = EV0_TAG;
    3742:	4b11      	ldr	r3, [pc, #68]	; (3788 <profile_add_event+0x58>)
    3744:	660b      	str	r3, [r1, #96]	; 0x60
	profiler.event_name[EV1] = EV1_TAG;
    3746:	4b11      	ldr	r3, [pc, #68]	; (378c <profile_add_event+0x5c>)
    3748:	664b      	str	r3, [r1, #100]	; 0x64
	}
	
	if (profiler.event_count >= PROFILER_EVENTS_MAX) {
		profiler.event_count = 0;
	} 
	int event_count = profiler.event_count;
    374a:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
	profiler.event_name[event_count] = event;
    374e:	f103 0218 	add.w	r2, r3, #24
    3752:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	profiler.start_tick[event_count] = profiler.end_tick[event_count] = 0;
    3756:	f103 000c 	add.w	r0, r3, #12
    375a:	2200      	movs	r2, #0
    375c:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
    3760:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	profiler.event_count++;
    3764:	1c5a      	adds	r2, r3, #1
    3766:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
	return event_count;
}
    376a:	4618      	mov	r0, r3
    376c:	bd08      	pop	{r3, pc}
	if (profiler.event_count >= PROFILER_EVENTS_MAX) {
    376e:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
    3772:	2b0b      	cmp	r3, #11
		profiler.event_count = 0;
    3774:	bfc4      	itt	gt
    3776:	2300      	movgt	r3, #0
    3778:	f8c1 3090 	strgt.w	r3, [r1, #144]	; 0x90
    377c:	e7e5      	b.n	374a <profile_add_event+0x1a>
    377e:	bf00      	nop
    3780:	200057b3 	.word	0x200057b3
    3784:	2000213c 	.word	0x2000213c
    3788:	00016f05 	.word	0x00016f05
    378c:	00017165 	.word	0x00017165

00003790 <profile_start>:
	return *DWT_CYCCNT;
    3790:	4b02      	ldr	r3, [pc, #8]	; (379c <profile_start+0xc>)
    3792:	681a      	ldr	r2, [r3, #0]

void profile_start(int eid) {
	// if (!profiler_is_init) {
	// 	setup_profiler();
	// }
	profiler.start_tick[eid] = dwt_get_counter();
    3794:	4b02      	ldr	r3, [pc, #8]	; (37a0 <profile_start+0x10>)
    3796:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
}
    379a:	4770      	bx	lr
    379c:	e0001004 	.word	0xe0001004
    37a0:	2000213c 	.word	0x2000213c

000037a4 <profile_end>:

uint32_t profile_end(int eid) {
	profiler.end_tick[eid] = dwt_get_counter();
    37a4:	4a05      	ldr	r2, [pc, #20]	; (37bc <profile_end+0x18>)
	return *DWT_CYCCNT;
    37a6:	4b06      	ldr	r3, [pc, #24]	; (37c0 <profile_end+0x1c>)
	profiler.end_tick[eid] = dwt_get_counter();
    37a8:	f100 010c 	add.w	r1, r0, #12
	return *DWT_CYCCNT;
    37ac:	681b      	ldr	r3, [r3, #0]
	return profiler.end_tick[eid] - profiler.start_tick[eid];
    37ae:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
	profiler.end_tick[eid] = dwt_get_counter();
    37b2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
    37b6:	1a18      	subs	r0, r3, r0
    37b8:	4770      	bx	lr
    37ba:	bf00      	nop
    37bc:	2000213c 	.word	0x2000213c
    37c0:	e0001004 	.word	0xe0001004

000037c4 <cycles2us>:

float cycles2us(int cycles) {
    37c4:	b510      	push	{r4, lr}
	return cycles / (float) ticks_per_us;
    37c6:	f7fc fda1 	bl	30c <__aeabi_ui2f>
    37ca:	4b05      	ldr	r3, [pc, #20]	; (37e0 <cycles2us+0x1c>)
    37cc:	4604      	mov	r4, r0
    37ce:	6818      	ldr	r0, [r3, #0]
    37d0:	f7fc fd9c 	bl	30c <__aeabi_ui2f>
    37d4:	4601      	mov	r1, r0
    37d6:	4620      	mov	r0, r4
    37d8:	f7fc fea4 	bl	524 <__aeabi_fdiv>
	return cycles_to_us(cycles);
}
    37dc:	bd10      	pop	{r4, pc}
    37de:	bf00      	nop
    37e0:	20010cd8 	.word	0x20010cd8

000037e4 <profile_dump>:

void profile_dump(int eid) {
	uint32_t ticks = profiler.end_tick[eid] - profiler.start_tick[eid];
    37e4:	4b0f      	ldr	r3, [pc, #60]	; (3824 <profile_dump+0x40>)
    37e6:	f100 020c 	add.w	r2, r0, #12
void profile_dump(int eid) {
    37ea:	b570      	push	{r4, r5, r6, lr}
	uint32_t ticks = profiler.end_tick[eid] - profiler.start_tick[eid];
    37ec:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
    37f0:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    37f4:	1aa4      	subs	r4, r4, r2
void profile_dump(int eid) {
    37f6:	4605      	mov	r5, r0
	return cycles / (float) ticks_per_us;
    37f8:	4620      	mov	r0, r4
    37fa:	f7fc fd87 	bl	30c <__aeabi_ui2f>
    37fe:	4b0a      	ldr	r3, [pc, #40]	; (3828 <profile_dump+0x44>)
    3800:	4606      	mov	r6, r0
    3802:	6818      	ldr	r0, [r3, #0]
    3804:	f7fc fd82 	bl	30c <__aeabi_ui2f>
    3808:	4601      	mov	r1, r0
    380a:	4630      	mov	r0, r6
    380c:	f7fc fe8a 	bl	524 <__aeabi_fdiv>
	*/
	float us = cycles_to_us(ticks);
	DEBUG_LOG("Event %d -> cycle: %d time(us): %f\n", eid, ticks, us);
#elif defined(ZEPHYR_OS)
	// zephyr do not support printf float
	int us = cycles_to_us(ticks);
    3810:	f7fc ff24 	bl	65c <__aeabi_f2iz>
	//us = ticks * 10 / 189;
	DEBUG_LOG("Event %d -> cycle: %d time(us): %d\n", eid, ticks, us);
    3814:	4622      	mov	r2, r4
    3816:	4603      	mov	r3, r0
    3818:	4629      	mov	r1, r5
    381a:	4804      	ldr	r0, [pc, #16]	; (382c <profile_dump+0x48>)
#else
	DEBUG_LOG("QEMU Event %d -> cycle: %d %d\n", ticks);
#endif
}
    381c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	DEBUG_LOG("Event %d -> cycle: %d time(us): %d\n", eid, ticks, us);
    3820:	f00c bb95 	b.w	ff4e <debug_log>
    3824:	2000213c 	.word	0x2000213c
    3828:	20010cd8 	.word	0x20010cd8
    382c:	00017169 	.word	0x00017169

00003830 <ebpf_malloc>:
*/

int mem_size = 0;

void* ebpf_malloc(size_t size) {
	mem_size += size;
    3830:	4a02      	ldr	r2, [pc, #8]	; (383c <ebpf_malloc+0xc>)
    3832:	6813      	ldr	r3, [r2, #0]
    3834:	4403      	add	r3, r0
    3836:	6013      	str	r3, [r2, #0]
	return (void *) my_os_malloc(size);
    3838:	f00b bb08 	b.w	ee4c <k_malloc>
    383c:	200021d0 	.word	0x200021d0

00003840 <ebpf_realloc>:

// void* ebpf_realloc(void* rmem, size_t newsize) {
// 	return (void*) my_os_realloc(rmem, newsize);
// }

void* ebpf_realloc(void *rmem, size_t orisize, size_t newsize) {
    3840:	b570      	push	{r4, r5, r6, lr}
    3842:	4614      	mov	r4, r2
	mem_size += newsize - orisize;
    3844:	4a10      	ldr	r2, [pc, #64]	; (3888 <ebpf_realloc+0x48>)
    3846:	1a63      	subs	r3, r4, r1
void* ebpf_realloc(void *rmem, size_t orisize, size_t newsize) {
    3848:	460e      	mov	r6, r1
	mem_size += newsize - orisize;
    384a:	6811      	ldr	r1, [r2, #0]
    384c:	440b      	add	r3, r1
void* ebpf_realloc(void *rmem, size_t orisize, size_t newsize) {
    384e:	4605      	mov	r5, r0
	mem_size += newsize - orisize;
    3850:	6013      	str	r3, [r2, #0]
	if (newsize == 0) {
    3852:	b91c      	cbnz	r4, 385c <ebpf_realloc+0x1c>
	mem_size += elmsize;
	return (void*) my_os_calloc(nelem, elmsize);
}

void ebpf_free(void* rmem) {
	my_os_free(rmem);
    3854:	f012 f8b4 	bl	159c0 <k_free>
}
    3858:	4620      	mov	r0, r4
    385a:	bd70      	pop	{r4, r5, r6, pc}
	} else if (rmem == NULL) {
    385c:	b920      	cbnz	r0, 3868 <ebpf_realloc+0x28>
		return ebpf_malloc(newsize);
    385e:	4620      	mov	r0, r4
}
    3860:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return ebpf_malloc(newsize);
    3864:	f7ff bfe4 	b.w	3830 <ebpf_malloc>
	} else if (newsize <= orisize) {
    3868:	42b4      	cmp	r4, r6
    386a:	d90b      	bls.n	3884 <ebpf_realloc+0x44>
		void *pnew = ebpf_malloc(newsize);
    386c:	4620      	mov	r0, r4
    386e:	f7ff ffdf 	bl	3830 <ebpf_malloc>
		if (pnew != NULL) {
    3872:	4604      	mov	r4, r0
    3874:	2800      	cmp	r0, #0
    3876:	d0ef      	beq.n	3858 <ebpf_realloc+0x18>
__ ## fun ## _ichk(type1 __restrict dst, type2 __restrict src) { \
	return __builtin___ ## fun ## _chk(dst, src, __ssp_bos0(dst)); \
}

__BEGIN_DECLS
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    3878:	4632      	mov	r2, r6
    387a:	4629      	mov	r1, r5
    387c:	f7fe fc7a 	bl	2174 <memcpy>
	my_os_free(rmem);
    3880:	4628      	mov	r0, r5
    3882:	e7e7      	b.n	3854 <ebpf_realloc+0x14>
    3884:	4604      	mov	r4, r0
    3886:	e7e7      	b.n	3858 <ebpf_realloc+0x18>
    3888:	200021d0 	.word	0x200021d0

0000388c <ebpf_calloc>:
	mem_size += elmsize;
    388c:	4a02      	ldr	r2, [pc, #8]	; (3898 <ebpf_calloc+0xc>)
    388e:	6813      	ldr	r3, [r2, #0]
    3890:	440b      	add	r3, r1
    3892:	6013      	str	r3, [r2, #0]
	return (void*) my_os_calloc(nelem, elmsize);
    3894:	f012 b899 	b.w	159ca <k_calloc>
    3898:	200021d0 	.word	0x200021d0

0000389c <get_ebpf_alloc_size>:
}

int get_ebpf_alloc_size() {
	return mem_size;
    389c:	4b01      	ldr	r3, [pc, #4]	; (38a4 <get_ebpf_alloc_size+0x8>)
    389e:	6818      	ldr	r0, [r3, #0]
    38a0:	4770      	bx	lr
    38a2:	bf00      	nop
    38a4:	200021d0 	.word	0x200021d0

000038a8 <tmp_map_save_val>:
uint64_t dval;
static void tmp_map_save_val(void *mp, uint64_t key, uint64_t val) {
	if (mp == NULL) {

	}
	dval = val;
    38a8:	e9dd 0100 	ldrd	r0, r1, [sp]
    38ac:	4b01      	ldr	r3, [pc, #4]	; (38b4 <tmp_map_save_val+0xc>)
    38ae:	e9c3 0100 	strd	r0, r1, [r3]
}
    38b2:	4770      	bx	lr
    38b4:	20002008 	.word	0x20002008

000038b8 <tmp_map_get_val>:

static uint64_t tmp_map_get_val(void *mp, uint64_t key) {
	return dval;
}
    38b8:	4b01      	ldr	r3, [pc, #4]	; (38c0 <tmp_map_get_val+0x8>)
    38ba:	e9d3 0100 	ldrd	r0, r1, [r3]
    38be:	4770      	bx	lr
    38c0:	20002008 	.word	0x20002008

000038c4 <iot_call_C_func_noret>:
static void iot_call_C_func_noret(uint64_t func_addr, uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3) {
    38c4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    38c8:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    38ca:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    38cc:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
	func(arg0, arg1, arg2, arg3);
    38d0:	f8cd 8008 	str.w	r8, [sp, #8]
static void iot_call_C_func_noret(uint64_t func_addr, uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3) {
    38d4:	4619      	mov	r1, r3
	func(arg0, arg1, arg2, arg3);
    38d6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    38d8:	9303      	str	r3, [sp, #12]
static void iot_call_C_func_noret(uint64_t func_addr, uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3) {
    38da:	4615      	mov	r5, r2
	func(arg0, arg1, arg2, arg3);
    38dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    38de:	9301      	str	r3, [sp, #4]
static void iot_call_C_func_noret(uint64_t func_addr, uint64_t arg0, uint64_t arg1, uint64_t arg2, uint64_t arg3) {
    38e0:	4604      	mov	r4, r0
	func(arg0, arg1, arg2, arg3);
    38e2:	4632      	mov	r2, r6
    38e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    38e6:	9700      	str	r7, [sp, #0]
    38e8:	4628      	mov	r0, r5
    38ea:	47a0      	blx	r4
	DEBUG_LOG("want to call c: func:0x%08x arg0:%d arg1:%d arg2:%d arg3:%d\n",  (u32) func_addr, (u32) arg0, (u32) arg1, (u32) arg2, (u32) arg3);
    38ec:	4805      	ldr	r0, [pc, #20]	; (3904 <iot_call_C_func_noret+0x40>)
    38ee:	4633      	mov	r3, r6
    38f0:	462a      	mov	r2, r5
    38f2:	4621      	mov	r1, r4
    38f4:	e9cd 780a 	strd	r7, r8, [sp, #40]	; 0x28
}
    38f8:	b004      	add	sp, #16
    38fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	DEBUG_LOG("want to call c: func:0x%08x arg0:%d arg1:%d arg2:%d arg3:%d\n",  (u32) func_addr, (u32) arg0, (u32) arg1, (u32) arg2, (u32) arg3);
    38fe:	f00c bb26 	b.w	ff4e <debug_log>
    3902:	bf00      	nop
    3904:	0001718d 	.word	0x0001718d

00003908 <use_default_helper_func>:
	// DEBUG_LOG("ebpf_register: 0x%08x 0x%08x\n", vm->helper_func->ext_funcs, fn);
	// vm->helper_func->ext_func_names[idx] = name;
	return 0;
}

static ebpf_helper_env* use_default_helper_func() {
    3908:	b538      	push	{r3, r4, r5, lr}
	if (g_helper_func == NULL) {
    390a:	4c09      	ldr	r4, [pc, #36]	; (3930 <use_default_helper_func+0x28>)
    390c:	6823      	ldr	r3, [r4, #0]
    390e:	b953      	cbnz	r3, 3926 <use_default_helper_func+0x1e>
		g_helper_func = ebpf_calloc(1, sizeof(ebpf_helper_env));
    3910:	210c      	movs	r1, #12
    3912:	2001      	movs	r0, #1
    3914:	f7ff ffba 	bl	388c <ebpf_calloc>
		g_helper_func->ext_funcs = ebpf_calloc(MAX_EXT_FUNCS, sizeof(ext_func));
    3918:	2104      	movs	r1, #4
		g_helper_func = ebpf_calloc(1, sizeof(ebpf_helper_env));
    391a:	4605      	mov	r5, r0
    391c:	6020      	str	r0, [r4, #0]
		g_helper_func->ext_funcs = ebpf_calloc(MAX_EXT_FUNCS, sizeof(ext_func));
    391e:	200c      	movs	r0, #12
    3920:	f7ff ffb4 	bl	388c <ebpf_calloc>
    3924:	6028      	str	r0, [r5, #0]
		// g_helper_func->refcnt = 0;
	}
	g_helper_func->refcnt++;
    3926:	6820      	ldr	r0, [r4, #0]
    3928:	6883      	ldr	r3, [r0, #8]
    392a:	3301      	adds	r3, #1
    392c:	6083      	str	r3, [r0, #8]
	return g_helper_func;
}
    392e:	bd38      	pop	{r3, r4, r5, pc}
    3930:	200021d4 	.word	0x200021d4

00003934 <set_default_helpers>:

void set_default_helpers(struct ebpf_vm *vm) {
    3934:	b510      	push	{r4, lr}
	ebpf_register(vm, 1, "print_log", iot_print_log);
    3936:	4b0d      	ldr	r3, [pc, #52]	; (396c <set_default_helpers+0x38>)
    3938:	4a0d      	ldr	r2, [pc, #52]	; (3970 <set_default_helpers+0x3c>)
void set_default_helpers(struct ebpf_vm *vm) {
    393a:	4604      	mov	r4, r0
	ebpf_register(vm, 1, "print_log", iot_print_log);
    393c:	2101      	movs	r1, #1
    393e:	f00c fb4b 	bl	ffd8 <ebpf_register>
	ebpf_register(vm, 2, "call_c_func", iot_call_C_func_noret);
    3942:	4b0c      	ldr	r3, [pc, #48]	; (3974 <set_default_helpers+0x40>)
    3944:	4a0c      	ldr	r2, [pc, #48]	; (3978 <set_default_helpers+0x44>)
    3946:	2102      	movs	r1, #2
    3948:	4620      	mov	r0, r4
    394a:	f00c fb45 	bl	ffd8 <ebpf_register>
	// DEBUG_LOG("func 2: 0x%08x\n", iot_call_C_func_noret);
	ebpf_register(vm, 3, "map_set", tmp_map_save_val);
    394e:	4b0b      	ldr	r3, [pc, #44]	; (397c <set_default_helpers+0x48>)
    3950:	4a0b      	ldr	r2, [pc, #44]	; (3980 <set_default_helpers+0x4c>)
    3952:	2103      	movs	r1, #3
    3954:	4620      	mov	r0, r4
    3956:	f00c fb3f 	bl	ffd8 <ebpf_register>
	ebpf_register(vm, 4, "map_get", tmp_map_get_val);
    395a:	4620      	mov	r0, r4
    395c:	4b09      	ldr	r3, [pc, #36]	; (3984 <set_default_helpers+0x50>)
    395e:	4a0a      	ldr	r2, [pc, #40]	; (3988 <set_default_helpers+0x54>)
    3960:	2104      	movs	r1, #4
}
    3962:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ebpf_register(vm, 4, "map_get", tmp_map_get_val);
    3966:	f00c bb37 	b.w	ffd8 <ebpf_register>
    396a:	bf00      	nop
    396c:	0000ff9d 	.word	0x0000ff9d
    3970:	000171ca 	.word	0x000171ca
    3974:	000038c5 	.word	0x000038c5
    3978:	000171d4 	.word	0x000171d4
    397c:	000038a9 	.word	0x000038a9
    3980:	000171e0 	.word	0x000171e0
    3984:	000038b9 	.word	0x000038b9
    3988:	000171e8 	.word	0x000171e8

0000398c <jit_mem_allocate>:
static uint8_t offset_mem[1024];
#endif

jit_mem g_jit_mem;

jit_mem* jit_mem_allocate(int insts_num) {
    398c:	b538      	push	{r3, r4, r5, lr}
	jit_mem *mem = &g_jit_mem;
	mem->code_size = sizeof(jit_buffer);
    398e:	4c09      	ldr	r4, [pc, #36]	; (39b4 <jit_mem_allocate+0x28>)
	mem->jit_code = jit_buffer;
	mem->jmp_offsets = offset_mem;
    3990:	4d09      	ldr	r5, [pc, #36]	; (39b8 <jit_mem_allocate+0x2c>)
	mem->jit_code = jit_buffer;
    3992:	480a      	ldr	r0, [pc, #40]	; (39bc <jit_mem_allocate+0x30>)
    3994:	6020      	str	r0, [r4, #0]
	mem->code_size = sizeof(jit_buffer);
    3996:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	memset(jit_buffer, 0, sizeof(jit_buffer));
    399a:	2100      	movs	r1, #0
	mem->code_size = sizeof(jit_buffer);
    399c:	6062      	str	r2, [r4, #4]
	mem->jmp_offsets = offset_mem;
    399e:	60a5      	str	r5, [r4, #8]
	memset(jit_buffer, 0, sizeof(jit_buffer));
    39a0:	f7fe fc23 	bl	21ea <memset>
	memset(offset_mem, 0, sizeof(offset_mem));
    39a4:	f44f 6280 	mov.w	r2, #1024	; 0x400
    39a8:	2100      	movs	r1, #0
    39aa:	4628      	mov	r0, r5
    39ac:	f7fe fc1d 	bl	21ea <memset>
	return mem;
}
    39b0:	4620      	mov	r0, r4
    39b2:	bd38      	pop	{r3, r4, r5, pc}
    39b4:	200021d8 	.word	0x200021d8
    39b8:	20000000 	.word	0x20000000
    39bc:	20000400 	.word	0x20000400

000039c0 <_thumb32_LSRW_IMM_T2>:
    return (THUMB2_LSRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
}

// ARM_MOV_SI Page A7-282
static inline u32 _thumb32_LSRW_IMM_T2(s8 Rd, s8 Rm, s32 shiftImm5, u8 flagS) {
    if (shiftImm5 < 0 || shiftImm5 > 0b11111) {
    39c0:	2a1f      	cmp	r2, #31
static inline u32 _thumb32_LSRW_IMM_T2(s8 Rd, s8 Rm, s32 shiftImm5, u8 flagS) {
    39c2:	b510      	push	{r4, lr}
    if (shiftImm5 < 0 || shiftImm5 > 0b11111) {
    39c4:	dc0c      	bgt.n	39e0 <_thumb32_LSRW_IMM_T2+0x20>
        // DEBUG_LOG("Invalide imm value. Line:%d Val:%d\n", __LINE__, shiftImm5);
        return -1;
    }
    u32 imm3 = (shiftImm5 >> 2) & 0b111;
    u32 imm2 = shiftImm5 & 0b11; 
    u32 inst = (THUMB2_LSRW_IMM) | (flagS << 20) | (imm3 << 12) | (Rd << 8) | (imm2 << 6) | (Rm);
    39c6:	0194      	lsls	r4, r2, #6
    39c8:	b2e4      	uxtb	r4, r4
    39ca:	430c      	orrs	r4, r1
    39cc:	ea44 2400 	orr.w	r4, r4, r0, lsl #8
    39d0:	ea44 5403 	orr.w	r4, r4, r3, lsl #20
    u32 imm3 = (shiftImm5 >> 2) & 0b111;
    39d4:	1092      	asrs	r2, r2, #2
    u32 inst = (THUMB2_LSRW_IMM) | (flagS << 20) | (imm3 << 12) | (Rd << 8) | (imm2 << 6) | (Rm);
    39d6:	4804      	ldr	r0, [pc, #16]	; (39e8 <_thumb32_LSRW_IMM_T2+0x28>)
    39d8:	ea44 3402 	orr.w	r4, r4, r2, lsl #12
    39dc:	4320      	orrs	r0, r4
    return inst;
}
    39de:	bd10      	pop	{r4, pc}
        return -1;
    39e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    39e4:	e7fb      	b.n	39de <_thumb32_LSRW_IMM_T2+0x1e>
    39e6:	bf00      	nop
    39e8:	ea4f0010 	.word	0xea4f0010

000039ec <_emit_ldr_i>:
  A7-246
  verified _emit_ldr_i(state, 0, 1, 0xffe);
  Rn - Src
  Rt - Dst
*/
static void _emit_ldr_i(jit_state *state, const s8 Rt, const s8 Rn, s16 off) {
    39ec:	b410      	push	{r4}
    39ee:	0412      	lsls	r2, r2, #16
    39f0:	0309      	lsls	r1, r1, #12
    // } else if (off <= imm8 && off >= 0 && Rt < 8 && Rn < 8) { // 
    //     s32 inst = 0xf8500000 | (Rn << 16) | (Rt << 12) | (0b1110 << 8) | (off & 0xff);
    //     // my_printf("imm8 _emit_ldr_i: %x\n", inst);
    //     emit4(state, inst);
    // } 
    if (off == 0) { // imm12
    39f2:	b93b      	cbnz	r3, 3a04 <_emit_ldr_i+0x18>
        s32 inst = 0xf8d00000 | (Rn << 16) | (Rt << 12) | (off & 0xfff);
    39f4:	4311      	orrs	r1, r2
        emit4(state, inst);
    39f6:	f041 4178 	orr.w	r1, r1, #4160749568	; 0xf8000000
    39fa:	f441 0150 	orr.w	r1, r1, #13631488	; 0xd00000
        // u8 imm8 = off > 0 ? off : -off;
        // s32 inst = 0xf8500000 | (Rn << 16) | (Rt << 12) | (0b1 << 11) | (P << 10) | (U << 9) | (W << 8) | (imm8);
        // emit4(state, inst);
        emit4(state, _thumb32_LDR_IMM_T4(Rt, Rn, off));
    }
}
    39fe:	bc10      	pop	{r4}
        emit4(state, _thumb32_LDR_IMM_T4(Rt, Rn, off));
    3a00:	f00d bce9 	b.w	113d6 <emit4>
    u32 inst = (THUMB2_LDR_IMM_T4) | (Rn << 16) | (Rt << 12) | (flag << 8) | (imm8);
    3a04:	2b00      	cmp	r3, #0
    3a06:	bfac      	ite	ge
    3a08:	f44f 64c0 	movge.w	r4, #1536	; 0x600
    3a0c:	f44f 6480 	movlt.w	r4, #1024	; 0x400
    3a10:	430c      	orrs	r4, r1
    u32 imm8 = offImm8 > 0 ? offImm8 : -offImm8;
    3a12:	2b00      	cmp	r3, #0
    u32 inst = (THUMB2_LDR_IMM_T4) | (Rn << 16) | (Rt << 12) | (flag << 8) | (imm8);
    3a14:	ea44 0402 	orr.w	r4, r4, r2
    u32 imm8 = offImm8 > 0 ? offImm8 : -offImm8;
    3a18:	bfb8      	it	lt
    3a1a:	425b      	neglt	r3, r3
    3a1c:	4901      	ldr	r1, [pc, #4]	; (3a24 <_emit_ldr_i+0x38>)
    u32 inst = (THUMB2_LDR_IMM_T4) | (Rn << 16) | (Rt << 12) | (flag << 8) | (imm8);
    3a1e:	4323      	orrs	r3, r4
    3a20:	4319      	orrs	r1, r3
    3a22:	e7ec      	b.n	39fe <_emit_ldr_i+0x12>
    3a24:	f8500800 	.word	0xf8500800

00003a28 <emit_mov_reg64.part.7>:
	s8 rt = arm_bpf_get_reg32(state, src, tmp[0]);
	arm_bpf_put_reg32(state, dst, rt);
    // my_printf("emit_mov_reg src:%d dst:%d\n", src, dst);
}

static void emit_mov_reg64(jit_state *state, const bool is64, const s8 dst[], const s8 src[]) {
    3a28:	b570      	push	{r4, r5, r6, lr}
    if (!is64) {
        emit_a32_mov_reg(state, src_lo, dst_lo);
    } else if (is_stacked(src_lo) && is_stacked(dst_lo)) {
    3a2a:	f992 3001 	ldrsb.w	r3, [r2, #1]
    3a2e:	2b00      	cmp	r3, #0
static void emit_mov_reg64(jit_state *state, const bool is64, const s8 dst[], const s8 src[]) {
    3a30:	4614      	mov	r4, r2
    3a32:	4606      	mov	r6, r0
    3a34:	460d      	mov	r5, r1
    3a36:	f991 2001 	ldrsb.w	r2, [r1, #1]
    } else if (is_stacked(src_lo) && is_stacked(dst_lo)) {
    3a3a:	da11      	bge.n	3a60 <emit_mov_reg64.part.7+0x38>
	return reg < 0;
    3a3c:	b21b      	sxth	r3, r3
    } else if (is_stacked(src_lo) && is_stacked(dst_lo)) {
    3a3e:	2a00      	cmp	r2, #0
        const u8 *tmp = bpf2a32[TMP_REG_1];
        // emit(ARM_LDRD_I(tmp[1], ARM_FP, EBPF_SCRATCH_TO_ARM_FP(src_lo)), ctx);
        _emit_ldrd_i(state, tmp, ARM_FP, EBPF_SCRATCH_TO_ARM_FP(src_lo));
    3a40:	461a      	mov	r2, r3
    } else if (is_stacked(src_lo) && is_stacked(dst_lo)) {
    3a42:	da09      	bge.n	3a58 <emit_mov_reg64.part.7+0x30>
        _emit_ldrd_i(state, tmp, ARM_FP, EBPF_SCRATCH_TO_ARM_FP(src_lo));
    3a44:	490e      	ldr	r1, [pc, #56]	; (3a80 <emit_mov_reg64.part.7+0x58>)
    3a46:	f00d fd1a 	bl	1147e <_emit_ldrd_i.constprop.29>
        // emit(ARM_STRD_I(tmp[1], ARM_FP, EBPF_SCRATCH_TO_ARM_FP(dst_lo)), ctx);
        _emit_strd_i(state, tmp, ARM_FP, EBPF_SCRATCH_TO_ARM_FP(dst_lo));
    3a4a:	f995 2001 	ldrsb.w	r2, [r5, #1]
    3a4e:	490c      	ldr	r1, [pc, #48]	; (3a80 <emit_mov_reg64.part.7+0x58>)
    } else {
        // my_printf("emit_mov_reg64: %d %d\n", dst[0], src[0]);
        _emit_mov_reg(state, src[1], dst[1]);
        _emit_mov_reg(state, src[0], dst[0]);
    }
}
    3a50:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _emit_strd_i(state, src, ARM_FP, EBPF_SCRATCH_TO_ARM_FP(dst_lo));
    3a54:	f00d bcf1 	b.w	1143a <_emit_strd_i.constprop.27>
}
    3a58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _emit_ldrd_i(state, dst, ARM_FP, EBPF_SCRATCH_TO_ARM_FP(src_lo));
    3a5c:	f00d bd0f 	b.w	1147e <_emit_ldrd_i.constprop.29>
    }  else if (is_stacked(dst_lo)) {
    3a60:	2a00      	cmp	r2, #0
    3a62:	da01      	bge.n	3a68 <emit_mov_reg64.part.7+0x40>
        _emit_strd_i(state, src, ARM_FP, EBPF_SCRATCH_TO_ARM_FP(dst_lo));
    3a64:	4621      	mov	r1, r4
    3a66:	e7f3      	b.n	3a50 <emit_mov_reg64.part.7+0x28>
        _emit_mov_reg(state, src[1], dst[1]);
    3a68:	4619      	mov	r1, r3
    3a6a:	f00d fd35 	bl	114d8 <_emit_mov_reg>
        _emit_mov_reg(state, src[0], dst[0]);
    3a6e:	f995 2000 	ldrsb.w	r2, [r5]
    3a72:	f994 1000 	ldrsb.w	r1, [r4]
    3a76:	4630      	mov	r0, r6
}
    3a78:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _emit_mov_reg(state, src[0], dst[0]);
    3a7c:	f00d bd2c 	b.w	114d8 <_emit_mov_reg>
    3a80:	00017208 	.word	0x00017208

00003a84 <emit_mov_i64>:
        emit4(state, _thumb32_PUSHW_T2(reg_set));
    }
}

static void emit_mov_i64(jit_state *state, const s8 dst[], u64 val)
{
    3a84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3a86:	461f      	mov	r7, r3
    const s8 *tmp = bpf2a32[TMP_REG_1];
    const s8 *rd = is_stacked(dst_lo) ? tmp : dst;
    3a88:	4c0b      	ldr	r4, [pc, #44]	; (3ab8 <emit_mov_i64+0x34>)
    3a8a:	f991 3001 	ldrsb.w	r3, [r1, #1]
    3a8e:	ea14 0423 	ands.w	r4, r4, r3, asr #32
    3a92:	bf38      	it	cc
    3a94:	460c      	movcc	r4, r1
{
    3a96:	4606      	mov	r6, r0
    3a98:	460d      	mov	r5, r1
   
    emit_mov_imm(state, rd[1], (u32)val);
    3a9a:	7861      	ldrb	r1, [r4, #1]
    3a9c:	f00d fd74 	bl	11588 <emit_mov_imm>
    emit_mov_imm(state, rd[0], val >> 32);
    3aa0:	463a      	mov	r2, r7
    3aa2:	7821      	ldrb	r1, [r4, #0]
    3aa4:	4630      	mov	r0, r6
    3aa6:	f00d fd6f 	bl	11588 <emit_mov_imm>
    // DEBUG_LOG("emit_mov_i64: %d %d %d %d \n", dst_lo, dst_hi, rd[0], rd[1]);
    // DEBUG_LOG("emit_mov_i64: %d %d\n", dst[0], dst[1]);
    arm_bpf_put_reg64(state, dst, rd);
    3aaa:	4622      	mov	r2, r4
    3aac:	4629      	mov	r1, r5
    3aae:	4630      	mov	r0, r6
}
    3ab0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    arm_bpf_put_reg64(state, dst, rd);
    3ab4:	f00d bd49 	b.w	1154a <arm_bpf_put_reg64>
    3ab8:	00017208 	.word	0x00017208

00003abc <emit_a32_mul_r64>:
static inline void emit_a32_mul_r64(jit_state *state, const s8 dst[], const s8 src[]) {
    3abc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	rd = arm_bpf_get_reg64(state, dst, tmp);
    3ac0:	4f2b      	ldr	r7, [pc, #172]	; (3b70 <emit_a32_mul_r64+0xb4>)
static inline void emit_a32_mul_r64(jit_state *state, const s8 dst[], const s8 src[]) {
    3ac2:	4690      	mov	r8, r2
	rd = arm_bpf_get_reg64(state, dst, tmp);
    3ac4:	f107 0218 	add.w	r2, r7, #24
static inline void emit_a32_mul_r64(jit_state *state, const s8 dst[], const s8 src[]) {
    3ac8:	4604      	mov	r4, r0
    3aca:	460e      	mov	r6, r1
	rd = arm_bpf_get_reg64(state, dst, tmp);
    3acc:	f00d fcf8 	bl	114c0 <arm_bpf_get_reg64>
	rt = arm_bpf_get_reg64(state, src, tmp2);
    3ad0:	f107 021a 	add.w	r2, r7, #26
	rd = arm_bpf_get_reg64(state, dst, tmp);
    3ad4:	4605      	mov	r5, r0
	rt = arm_bpf_get_reg64(state, src, tmp2);
    3ad6:	4641      	mov	r1, r8
    3ad8:	4620      	mov	r0, r4
    3ada:	f00d fcf1 	bl	114c0 <arm_bpf_get_reg64>
    return (THUMB2_MUL_T2) | (Rn << 16) | (Rd << 8) | (Rm);
    3ade:	f995 3001 	ldrsb.w	r3, [r5, #1]
    3ae2:	f990 1000 	ldrsb.w	r1, [r0]
    3ae6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    3aea:	4607      	mov	r7, r0
    emit4(state, _thumb32_MUL_T2(ARM_IP, rd[1], rt[0]));
    3aec:	f041 417b 	orr.w	r1, r1, #4211081216	; 0xfb000000
    3af0:	4620      	mov	r0, r4
    3af2:	f441 417c 	orr.w	r1, r1, #64512	; 0xfc00
    3af6:	f00d fc6e 	bl	113d6 <emit4>
    3afa:	f995 3000 	ldrsb.w	r3, [r5]
    3afe:	f997 1001 	ldrsb.w	r1, [r7, #1]
    3b02:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    emit4(state, _thumb32_MUL_T2(ARM_LR, rd[0], rt[1]));
    3b06:	f041 417b 	orr.w	r1, r1, #4211081216	; 0xfb000000
    3b0a:	f441 417e 	orr.w	r1, r1, #65024	; 0xfe00
    3b0e:	f00d fc62 	bl	113d6 <emit4>
    emit2(state, _thumb16_ADD_REG_T2(ARM_LR, ARM_IP));
    3b12:	f244 41e6 	movw	r1, #17638	; 0x44e6
    3b16:	f00d fc54 	bl	113c2 <emit2>
    return (THUMB2_UMULL_T2) | (Rn << 16) | (RdLo << 12) | (RdHi << 8) | (Rm);
    3b1a:	f995 3000 	ldrsb.w	r3, [r5]
    3b1e:	f995 2001 	ldrsb.w	r2, [r5, #1]
    emit4(state, _thumb32_UMULL_T2(ARM_IP, rd[0], rd[1], rt[1]));
    3b22:	4914      	ldr	r1, [pc, #80]	; (3b74 <emit_a32_mul_r64+0xb8>)
    3b24:	021b      	lsls	r3, r3, #8
    3b26:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    3b2a:	f997 2001 	ldrsb.w	r2, [r7, #1]
    3b2e:	4313      	orrs	r3, r2
    3b30:	4319      	orrs	r1, r3
    3b32:	f00d fc50 	bl	113d6 <emit4>
     emit2(state, _thumb16_ADD_REG_T2(rd[0], ARM_LR));
    3b36:	f995 3000 	ldrsb.w	r3, [r5]
    return (THUMB2_ADD_REG_T2) | (DN << 7) | (Rm << 3) | (rdn);
    3b3a:	f3c3 01c0 	ubfx	r1, r3, #3, #1
    3b3e:	f003 0307 	and.w	r3, r3, #7
    3b42:	ea43 11c1 	orr.w	r1, r3, r1, lsl #7
    3b46:	f441 4188 	orr.w	r1, r1, #17408	; 0x4400
    3b4a:	f041 0170 	orr.w	r1, r1, #112	; 0x70
    3b4e:	f00d fc38 	bl	113c2 <emit2>
	arm_bpf_put_reg32(state, dst_lo, ARM_IP);
    3b52:	f996 1001 	ldrsb.w	r1, [r6, #1]
    3b56:	220c      	movs	r2, #12
    3b58:	f00d fcd9 	bl	1150e <arm_bpf_put_reg32>
	arm_bpf_put_reg32(state, dst_hi, rd[0]);
    3b5c:	f995 2000 	ldrsb.w	r2, [r5]
    3b60:	f996 1000 	ldrsb.w	r1, [r6]
    3b64:	4620      	mov	r0, r4
}
    3b66:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	arm_bpf_put_reg32(state, dst_hi, rd[0]);
    3b6a:	f00d bcd0 	b.w	1150e <arm_bpf_put_reg32>
    3b6e:	bf00      	nop
    3b70:	000171f0 	.word	0x000171f0
    3b74:	fba0c000 	.word	0xfba0c000

00003b78 <_emit_b_cond>:
    if (!_use_b4(state) && off >= -256 && off <= 254) {
    3b78:	6843      	ldr	r3, [r0, #4]
    3b7a:	2b14      	cmp	r3, #20
static void inline _emit_b_cond(jit_state *state, s32 off, u8 cond) {
    3b7c:	b410      	push	{r4}
    3b7e:	4604      	mov	r4, r0
    if (!_use_b4(state) && off >= -256 && off <= 254) {
    3b80:	dc0d      	bgt.n	3b9e <_emit_b_cond+0x26>
    3b82:	f501 7380 	add.w	r3, r1, #256	; 0x100
    3b86:	f5b3 7fff 	cmp.w	r3, #510	; 0x1fe
    3b8a:	d808      	bhi.n	3b9e <_emit_b_cond+0x26>
    u16 imm8 = (offImm9 >> 1) & 0x00ff;
    3b8c:	f3c1 0147 	ubfx	r1, r1, #1, #8
    return (THUMB2_B_COND_T1) | (cond << 8) | (imm8);
    3b90:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
        emit2(state, _thumb16_B_T1(off, cond));
    3b94:	f441 4150 	orr.w	r1, r1, #53248	; 0xd000
}
    3b98:	bc10      	pop	{r4}
        emit2(state, _thumb16_B_T1(off, cond));
    3b9a:	f00d bc12 	b.w	113c2 <emit2>
    } else if (off > -1048576 && off < 1048574) {
    3b9e:	f501 207f 	add.w	r0, r1, #1044480	; 0xff000
    3ba2:	4b11      	ldr	r3, [pc, #68]	; (3be8 <_emit_b_cond+0x70>)
    3ba4:	f600 70ff 	addw	r0, r0, #4095	; 0xfff
    3ba8:	4298      	cmp	r0, r3
    3baa:	d81a      	bhi.n	3be2 <_emit_b_cond+0x6a>
    return (THUMB2_BW_COND_T3) | (S << 26) | (cond << 22) | (imm6 << 16) | (J1 << 13) | (J2 << 11) | (imm11);
    3bac:	0a0b      	lsrs	r3, r1, #8
    3bae:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    3bb2:	ea43 5382 	orr.w	r3, r3, r2, lsl #22
    u32 imm11 = (offImm20 >> 1) & 0x7ff;
    3bb6:	f3c1 024a 	ubfx	r2, r1, #1, #11
    return (THUMB2_BW_COND_T3) | (S << 26) | (cond << 22) | (imm6 << 16) | (J1 << 13) | (J2 << 11) | (imm11);
    3bba:	4313      	orrs	r3, r2
    u32 S = offImm20 < 0;
    3bbc:	0fca      	lsrs	r2, r1, #31
    return (THUMB2_BW_COND_T3) | (S << 26) | (cond << 22) | (imm6 << 16) | (J1 << 13) | (J2 << 11) | (imm11);
    3bbe:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
    3bc2:	010a      	lsls	r2, r1, #4
    3bc4:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
    3bc8:	0949      	lsrs	r1, r1, #5
    3bca:	4313      	orrs	r3, r2
    3bcc:	f401 5100 	and.w	r1, r1, #8192	; 0x2000
    3bd0:	4319      	orrs	r1, r3
        emit4(state, _thumb32_BW_T3(off, cond));
    3bd2:	f041 4170 	orr.w	r1, r1, #4026531840	; 0xf0000000
    3bd6:	4620      	mov	r0, r4
    3bd8:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
}
    3bdc:	bc10      	pop	{r4}
        emit4(state, _thumb32_BW_T3(off, cond));
    3bde:	f00d bbfa 	b.w	113d6 <emit4>
}
    3be2:	bc10      	pop	{r4}
    3be4:	4770      	bx	lr
    3be6:	bf00      	nop
    3be8:	001ffffc 	.word	0x001ffffc

00003bec <emit_push_r64>:
static void emit_push_r64(jit_state *state, s8 src[]) {
    3bec:	b538      	push	{r3, r4, r5, lr}
    rt = arm_bpf_get_reg64(state, src, tmp2);
    3bee:	4a19      	ldr	r2, [pc, #100]	; (3c54 <emit_push_r64+0x68>)
static void emit_push_r64(jit_state *state, s8 src[]) {
    3bf0:	4604      	mov	r4, r0
    rt = arm_bpf_get_reg64(state, src, tmp2);
    3bf2:	f00d fc65 	bl	114c0 <arm_bpf_get_reg64>
    reg_set = (1 << rt[1]) | (1 << rt[0]);
    3bf6:	f990 5001 	ldrsb.w	r5, [r0, #1]
    3bfa:	f990 0000 	ldrsb.w	r0, [r0]
    3bfe:	2201      	movs	r2, #1
    3c00:	fa02 f305 	lsl.w	r3, r2, r5
    3c04:	4082      	lsls	r2, r0
    3c06:	4313      	orrs	r3, r2
    3c08:	b29b      	uxth	r3, r3
    if ((rt[0] == ARM_LR || rt[0] < 8) && (rt[1] == ARM_LR || rt[1] < 8)) {
    3c0a:	280e      	cmp	r0, #14
    3c0c:	ea4f 31a3 	mov.w	r1, r3, asr #14
    3c10:	d001      	beq.n	3c16 <emit_push_r64+0x2a>
    3c12:	2807      	cmp	r0, #7
    3c14:	dc0f      	bgt.n	3c36 <emit_push_r64+0x4a>
    3c16:	2d0e      	cmp	r5, #14
    3c18:	d001      	beq.n	3c1e <emit_push_r64+0x32>
    3c1a:	2d07      	cmp	r5, #7
    3c1c:	dc0b      	bgt.n	3c36 <emit_push_r64+0x4a>
    u16 reg_list = reg_mask & 0xff;
    3c1e:	b2db      	uxtb	r3, r3
    return (THUMB2_PUSH_T1) | (M << 8) | (reg_list);
    3c20:	f001 0101 	and.w	r1, r1, #1
    3c24:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
        emit2(state, _thumb16_PUSH_T1(reg_set));
    3c28:	4620      	mov	r0, r4
    3c2a:	f441 4134 	orr.w	r1, r1, #46080	; 0xb400
}
    3c2e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        emit2(state, _thumb16_PUSH_T1(reg_set));
    3c32:	f00d bbc6 	b.w	113c2 <emit2>
    return (THUMB2_PUSH_W) | (M << 14) | (reg_list);
    3c36:	0389      	lsls	r1, r1, #14
    u32 reg_list = reg_mask & 0x1fff;
    3c38:	f3c3 030c 	ubfx	r3, r3, #0, #13
    return (THUMB2_PUSH_W) | (M << 14) | (reg_list);
    3c3c:	f401 4180 	and.w	r1, r1, #16384	; 0x4000
    3c40:	4319      	orrs	r1, r3
        emit4(state, _thumb32_PUSHW_T2(reg_set));
    3c42:	f041 4169 	orr.w	r1, r1, #3909091328	; 0xe9000000
    3c46:	4620      	mov	r0, r4
    3c48:	f441 1134 	orr.w	r1, r1, #2949120	; 0x2d0000
}
    3c4c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        emit4(state, _thumb32_PUSHW_T2(reg_set));
    3c50:	f00d bbc1 	b.w	113d6 <emit4>
    3c54:	0001720a 	.word	0x0001720a

00003c58 <_emit_b>:
    if (off > -2048 && off < 2046) {
    3c58:	f201 72ff 	addw	r2, r1, #2047	; 0x7ff
    3c5c:	f640 73fc 	movw	r3, #4092	; 0xffc
    3c60:	429a      	cmp	r2, r3
static void inline _emit_b(jit_state *state, s32 off) {
    3c62:	b410      	push	{r4}
    if (off > -2048 && off < 2046) {
    3c64:	d806      	bhi.n	3c74 <_emit_b+0x1c>
    u16 imm11 = (offImm12 >> 1) & 0x7ff;
    3c66:	f3c1 014a 	ubfx	r1, r1, #1, #11
        emit2(state, _thumb16_B_T2(off));
    3c6a:	f441 4160 	orr.w	r1, r1, #57344	; 0xe000
}
    3c6e:	bc10      	pop	{r4}
        emit2(state, _thumb16_B_T2(off));
    3c70:	f00d bba7 	b.w	113c2 <emit2>
    } else if (off > -16777216 && off < 16777214) {
    3c74:	f101 13ff 	add.w	r3, r1, #16711935	; 0xff00ff
    3c78:	4a12      	ldr	r2, [pc, #72]	; (3cc4 <_emit_b+0x6c>)
    3c7a:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    3c7e:	4293      	cmp	r3, r2
    3c80:	d81e      	bhi.n	3cc0 <_emit_b+0x68>
    s32 S = offImm23 < 0;
    3c82:	0fca      	lsrs	r2, r1, #31
    s32 I2 = (offImm23 >> 19) & 0x1;
    3c84:	f3c1 43c0 	ubfx	r3, r1, #19, #1
    s32 J2 = (~I2 ^ S) & 0x1;
    3c88:	1a9b      	subs	r3, r3, r2
    3c8a:	425c      	negs	r4, r3
    3c8c:	415c      	adcs	r4, r3
    s32 imm11 = (offImm23 >> 1) & 0x7ff;
    3c8e:	f3c1 034a 	ubfx	r3, r1, #1, #11
    return (THUMB2_BW_COND_T3) | (S << 26) | (imm10 << 16) | (J1 << 13) | (J2 << 11) | (imm11);
    3c92:	ea43 23c4 	orr.w	r3, r3, r4, lsl #11
    3c96:	4c0c      	ldr	r4, [pc, #48]	; (3cc8 <_emit_b+0x70>)
    3c98:	ea04 1401 	and.w	r4, r4, r1, lsl #4
    s32 I1 = (offImm23 >> 18) & 0x1;
    3c9c:	f3c1 4180 	ubfx	r1, r1, #18, #1
    return (THUMB2_BW_COND_T3) | (S << 26) | (imm10 << 16) | (J1 << 13) | (J2 << 11) | (imm11);
    3ca0:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
    s32 J1 = (~I1 ^ S) & 0x1;
    3ca4:	1a8a      	subs	r2, r1, r2
    3ca6:	4251      	negs	r1, r2
    return (THUMB2_BW_COND_T3) | (S << 26) | (imm10 << 16) | (J1 << 13) | (J2 << 11) | (imm11);
    3ca8:	ea43 0304 	orr.w	r3, r3, r4
    s32 J1 = (~I1 ^ S) & 0x1;
    3cac:	4151      	adcs	r1, r2
    return (THUMB2_BW_COND_T3) | (S << 26) | (imm10 << 16) | (J1 << 13) | (J2 << 11) | (imm11);
    3cae:	ea43 3141 	orr.w	r1, r3, r1, lsl #13
        emit4(state, _thumb32_BW_T4(off));
    3cb2:	f041 4170 	orr.w	r1, r1, #4026531840	; 0xf0000000
    3cb6:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
}
    3cba:	bc10      	pop	{r4}
        emit4(state, _thumb32_BW_T4(off));
    3cbc:	f00d bb8b 	b.w	113d6 <emit4>
}
    3cc0:	bc10      	pop	{r4}
    3cc2:	4770      	bx	lr
    3cc4:	01fffffc 	.word	0x01fffffc
    3cc8:	03ff0000 	.word	0x03ff0000

00003ccc <emit_alu32_reg.constprop.14>:
static void emit_alu32_reg(jit_state *state, const s8 dst, const s8 src, 
    3ccc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3cd0:	4688      	mov	r8, r1
    3cd2:	4611      	mov	r1, r2
    rn = arm_bpf_get_reg32(state, src, tmp[1]);
    3cd4:	2206      	movs	r2, #6
static void emit_alu32_reg(jit_state *state, const s8 dst, const s8 src, 
    3cd6:	4606      	mov	r6, r0
    3cd8:	4699      	mov	r9, r3
    3cda:	f89d 7020 	ldrb.w	r7, [sp, #32]
    rn = arm_bpf_get_reg32(state, src, tmp[1]);
    3cde:	f00d fb84 	bl	113ea <arm_bpf_get_reg32>
    rd = arm_bpf_get_reg32(state, dst, tmp[0]);
    3ce2:	2207      	movs	r2, #7
    rn = arm_bpf_get_reg32(state, src, tmp[1]);
    3ce4:	4604      	mov	r4, r0
    rd = arm_bpf_get_reg32(state, dst, tmp[0]);
    3ce6:	4641      	mov	r1, r8
    3ce8:	4630      	mov	r0, r6
    3cea:	f00d fb7e 	bl	113ea <arm_bpf_get_reg32>
    switch (op)
    3cee:	2f50      	cmp	r7, #80	; 0x50
    rd = arm_bpf_get_reg32(state, dst, tmp[0]);
    3cf0:	4605      	mov	r5, r0
    switch (op)
    3cf2:	d070      	beq.n	3dd6 <emit_alu32_reg.constprop.14+0x10a>
    3cf4:	d820      	bhi.n	3d38 <emit_alu32_reg.constprop.14+0x6c>
    3cf6:	2f10      	cmp	r7, #16
    3cf8:	d057      	beq.n	3daa <emit_alu32_reg.constprop.14+0xde>
    3cfa:	d808      	bhi.n	3d0e <emit_alu32_reg.constprop.14+0x42>
    3cfc:	2f00      	cmp	r7, #0
    3cfe:	d042      	beq.n	3d86 <emit_alu32_reg.constprop.14+0xba>
	arm_bpf_put_reg32(state, dst, rd);
    3d00:	462a      	mov	r2, r5
    3d02:	4641      	mov	r1, r8
    3d04:	4630      	mov	r0, r6
}
    3d06:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	arm_bpf_put_reg32(state, dst, rd);
    3d0a:	f00d bc00 	b.w	1150e <arm_bpf_put_reg32>
    switch (op)
    3d0e:	2f20      	cmp	r7, #32
    3d10:	f000 8088 	beq.w	3e24 <emit_alu32_reg.constprop.14+0x158>
    3d14:	2f40      	cmp	r7, #64	; 0x40
    3d16:	d1f3      	bne.n	3d00 <emit_alu32_reg.constprop.14+0x34>
    if (dst < 8 && src < 8) {
    3d18:	2807      	cmp	r0, #7
    3d1a:	dc55      	bgt.n	3dc8 <emit_alu32_reg.constprop.14+0xfc>
    3d1c:	2c07      	cmp	r4, #7
    3d1e:	dc53      	bgt.n	3dc8 <emit_alu32_reg.constprop.14+0xfc>

static inline u16 _thumb16_ORR_REG_T1(s8 RDn, s8 Rm) {
    u16 RDn3 = RDn & 0b111;
    u16 Rm3 = Rm & 0b111;
    return (THUMB2_ORR_REG) | (RDn3 << 4) | (Rm3);
    3d20:	f000 0107 	and.w	r1, r0, #7
    3d24:	f004 0407 	and.w	r4, r4, #7
    3d28:	ea44 1101 	orr.w	r1, r4, r1, lsl #4
        emit2(state, _thumb16_ORR_REG_T1(dst, src));
    3d2c:	f441 4186 	orr.w	r1, r1, #17152	; 0x4300
            emit2(state, (0x4100) | (rn << 3) | (rd));
    3d30:	4630      	mov	r0, r6
    3d32:	f00d fb46 	bl	113c2 <emit2>
    3d36:	e7e3      	b.n	3d00 <emit_alu32_reg.constprop.14+0x34>
    switch (op)
    3d38:	2f70      	cmp	r7, #112	; 0x70
    3d3a:	f000 8090 	beq.w	3e5e <emit_alu32_reg.constprop.14+0x192>
    3d3e:	d80f      	bhi.n	3d60 <emit_alu32_reg.constprop.14+0x94>
    3d40:	2f60      	cmp	r7, #96	; 0x60
    3d42:	d1dd      	bne.n	3d00 <emit_alu32_reg.constprop.14+0x34>
        if (rn > 0 && rn < 8 && rd > 0 && rd < 8) {
    3d44:	1e63      	subs	r3, r4, #1
    3d46:	b2db      	uxtb	r3, r3
    3d48:	2b06      	cmp	r3, #6
    3d4a:	f200 8081 	bhi.w	3e50 <emit_alu32_reg.constprop.14+0x184>
    3d4e:	1e43      	subs	r3, r0, #1
    3d50:	b2db      	uxtb	r3, r3
    3d52:	2b06      	cmp	r3, #6
    3d54:	d87c      	bhi.n	3e50 <emit_alu32_reg.constprop.14+0x184>
            emit2(state, (0x4080) | (rn << 3) | (rd));
    3d56:	ea40 01c4 	orr.w	r1, r0, r4, lsl #3
    3d5a:	f441 4181 	orr.w	r1, r1, #16512	; 0x4080
    3d5e:	e042      	b.n	3de6 <emit_alu32_reg.constprop.14+0x11a>
    switch (op)
    3d60:	2fa0      	cmp	r7, #160	; 0xa0
    3d62:	d049      	beq.n	3df8 <emit_alu32_reg.constprop.14+0x12c>
    3d64:	2fc0      	cmp	r7, #192	; 0xc0
    3d66:	d1cb      	bne.n	3d00 <emit_alu32_reg.constprop.14+0x34>
        if (rn > 0 && rn < 8 && rd > 0 && rd < 8) {
    3d68:	1e63      	subs	r3, r4, #1
    3d6a:	b2db      	uxtb	r3, r3
    3d6c:	2b06      	cmp	r3, #6
    3d6e:	f200 8089 	bhi.w	3e84 <emit_alu32_reg.constprop.14+0x1b8>
    3d72:	1e43      	subs	r3, r0, #1
    3d74:	b2db      	uxtb	r3, r3
    3d76:	2b06      	cmp	r3, #6
    3d78:	f200 8084 	bhi.w	3e84 <emit_alu32_reg.constprop.14+0x1b8>
            emit2(state, (0x4100) | (rn << 3) | (rd));
    3d7c:	ea40 01c4 	orr.w	r1, r0, r4, lsl #3
    3d80:	f441 4182 	orr.w	r1, r1, #16640	; 0x4100
    3d84:	e02f      	b.n	3de6 <emit_alu32_reg.constprop.14+0x11a>
        if (hi) { // ADC should not update flag
    3d86:	0421      	lsls	r1, r4, #16
    3d88:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    3d8c:	4301      	orrs	r1, r0
            emit4(state, inst);
    3d8e:	f041 416b 	orr.w	r1, r1, #3942645760	; 0xeb000000
        if (hi) { // ADC should not update flag
    3d92:	f1b9 0f00 	cmp.w	r9, #0
    3d96:	d002      	beq.n	3d9e <emit_alu32_reg.constprop.14+0xd2>
        emit4(state, _thumb32_ORRW_REG_T2(dst, dst, src, 0, SRTYPE_ASL, FLAG_NOS));
    3d98:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
    3d9c:	e001      	b.n	3da2 <emit_alu32_reg.constprop.14+0xd6>
            emit4(state, inst);
    3d9e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
            emit4(state, _thumb32_ASRW_REG_T2(rd, rd, rn, FLAG_NOS));
    3da2:	4630      	mov	r0, r6
    3da4:	f00d fb17 	bl	113d6 <emit4>
    3da8:	e7aa      	b.n	3d00 <emit_alu32_reg.constprop.14+0x34>
    if (is64 && !hi) { // subs.w
    3daa:	0201      	lsls	r1, r0, #8
    3dac:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    3db0:	4321      	orrs	r1, r4
        emit4(state, _thumb32_SUB_REG_T2(dst, dst, src, 0, SRTYPE_LSL, FLAG_S));
    3db2:	f041 416b 	orr.w	r1, r1, #3942645760	; 0xeb000000
    if (is64 && !hi) { // subs.w
    3db6:	f1b9 0f00 	cmp.w	r9, #0
    3dba:	d102      	bne.n	3dc2 <emit_alu32_reg.constprop.14+0xf6>
        emit4(state, _thumb32_SUB_REG_T2(dst, dst, src, 0, SRTYPE_LSL, FLAG_S));
    3dbc:	f441 0130 	orr.w	r1, r1, #11534336	; 0xb00000
    3dc0:	e7ef      	b.n	3da2 <emit_alu32_reg.constprop.14+0xd6>
        emit4(state, _thumb32_SBCW_T2(dst, dst, src, 0, SRTYPE_LSL, FLAG_NOS));
    3dc2:	f441 01c0 	orr.w	r1, r1, #6291456	; 0x600000
    3dc6:	e7ec      	b.n	3da2 <emit_alu32_reg.constprop.14+0xd6>
        return -1;
    }
    u32 imm3 = (shiftImm5 >> 2) & 0b111;
    u32 imm2 = shiftImm5 & 0b11; 
    u32 inst = (THUMB2_ORRW_REG) | (flagS << 20) | (Rn << 16) | (imm3 << 12)
             | (Rd << 8) | (imm2 << 6) | (srtype << 4) | (Rm); 
    3dc8:	0229      	lsls	r1, r5, #8
    3dca:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
    3dce:	4321      	orrs	r1, r4
        emit4(state, _thumb32_ORRW_REG_T2(dst, dst, src, 0, SRTYPE_ASL, FLAG_NOS));
    3dd0:	f041 416a 	orr.w	r1, r1, #3925868544	; 0xea000000
    3dd4:	e7e0      	b.n	3d98 <emit_alu32_reg.constprop.14+0xcc>
    if (dst < 8 && src < 8) {
    3dd6:	2807      	cmp	r0, #7
    3dd8:	dc07      	bgt.n	3dea <emit_alu32_reg.constprop.14+0x11e>
    3dda:	2c07      	cmp	r4, #7
    3ddc:	dc05      	bgt.n	3dea <emit_alu32_reg.constprop.14+0x11e>
    return (THUMB2_AND_REG_T1) | (Rm << 3) | (RDn);
    3dde:	ea40 01c4 	orr.w	r1, r0, r4, lsl #3
    3de2:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
            emit2(state, (0x4100) | (rn << 3) | (rd));
    3de6:	b289      	uxth	r1, r1
    3de8:	e7a2      	b.n	3d30 <emit_alu32_reg.constprop.14+0x64>
    return (THUMB2_AND_REG_T2) | (flagS << 20) | (Rn << 16) | (imm3 << 12) | (Rd << 8) | 
    3dea:	0229      	lsls	r1, r5, #8
    3dec:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
        (imm2 << 6) | (srtype << 4) | (Rm);
    3df0:	4321      	orrs	r1, r4
        emit4(state, _thumb32_AND_REG_T2(dst, dst, src, 0, SRTYPE_ASL, FLAG_NOS));
    3df2:	f041 416a 	orr.w	r1, r1, #3925868544	; 0xea000000
    3df6:	e7d4      	b.n	3da2 <emit_alu32_reg.constprop.14+0xd6>
        if (rn > 0 && rn < 8 && rd > 0 && rd < 8) {
    3df8:	1e63      	subs	r3, r4, #1
    3dfa:	b2db      	uxtb	r3, r3
    3dfc:	2b06      	cmp	r3, #6
    3dfe:	d80a      	bhi.n	3e16 <emit_alu32_reg.constprop.14+0x14a>
    3e00:	1e43      	subs	r3, r0, #1
    3e02:	b2db      	uxtb	r3, r3
    3e04:	2b06      	cmp	r3, #6
    3e06:	d806      	bhi.n	3e16 <emit_alu32_reg.constprop.14+0x14a>
            emit2(state, (0x4040) | (rn << 3) | (rd));
    3e08:	ea40 01c4 	orr.w	r1, r0, r4, lsl #3
    3e0c:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
            emit2(state, (0x40c0) | (rn << 3) | (rd));
    3e10:	f041 0140 	orr.w	r1, r1, #64	; 0x40
    3e14:	e7e7      	b.n	3de6 <emit_alu32_reg.constprop.14+0x11a>
             | (Rd << 8) | (imm2 << 6) | (srtype << 4) | (Rm); 
    3e16:	0229      	lsls	r1, r5, #8
    3e18:	ea41 4404 	orr.w	r4, r1, r4, lsl #16
            emit4(state, _thumb32_EOR_REG_T2(rd, rn, rd, 0, SRTYPE_ROR, FLAG_NOS));
    3e1c:	491c      	ldr	r1, [pc, #112]	; (3e90 <emit_alu32_reg.constprop.14+0x1c4>)
    3e1e:	432c      	orrs	r4, r5
            emit4(state, _thumb32_ASRW_REG_T2(rd, rd, rn, FLAG_NOS));
    3e20:	4321      	orrs	r1, r4
    3e22:	e7be      	b.n	3da2 <emit_alu32_reg.constprop.14+0xd6>
        if (rn > 0 && rn < 8 && rd > 0 && rd < 8) {
    3e24:	1e63      	subs	r3, r4, #1
    3e26:	b2db      	uxtb	r3, r3
    3e28:	2b06      	cmp	r3, #6
    3e2a:	d808      	bhi.n	3e3e <emit_alu32_reg.constprop.14+0x172>
    3e2c:	1e43      	subs	r3, r0, #1
    3e2e:	b2db      	uxtb	r3, r3
    3e30:	2b06      	cmp	r3, #6
    3e32:	d804      	bhi.n	3e3e <emit_alu32_reg.constprop.14+0x172>
            emit2(state, (0x4340) | (rn << 3) | (rd));
    3e34:	ea40 01c4 	orr.w	r1, r0, r4, lsl #3
    3e38:	f441 4186 	orr.w	r1, r1, #17152	; 0x4300
    3e3c:	e7e8      	b.n	3e10 <emit_alu32_reg.constprop.14+0x144>
    return (THUMB2_MUL_REG_T2) | (Rn << 16) | (Rd << 8) | (Rm);
    3e3e:	0229      	lsls	r1, r5, #8
    3e40:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
    3e44:	4329      	orrs	r1, r5
            emit4(state, _thumb32_MUL_REG_T2(rd, rn, rd));
    3e46:	f041 417b 	orr.w	r1, r1, #4211081216	; 0xfb000000
            emit4(state, _thumb32_LSLW_REG_T2(rd, rd, rn, FLAG_NOS));
    3e4a:	f441 4170 	orr.w	r1, r1, #61440	; 0xf000
    3e4e:	e7a8      	b.n	3da2 <emit_alu32_reg.constprop.14+0xd6>
    return (THUMB2_LSLW_REG_T2) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    3e50:	0229      	lsls	r1, r5, #8
    3e52:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
    3e56:	4321      	orrs	r1, r4
    3e58:	f041 417a 	orr.w	r1, r1, #4194304000	; 0xfa000000
    3e5c:	e7f5      	b.n	3e4a <emit_alu32_reg.constprop.14+0x17e>
        if (rn > 0 && rn < 8 && rd > 0 && rd < 8) {
    3e5e:	1e63      	subs	r3, r4, #1
    3e60:	b2db      	uxtb	r3, r3
    3e62:	2b06      	cmp	r3, #6
    3e64:	d808      	bhi.n	3e78 <emit_alu32_reg.constprop.14+0x1ac>
    3e66:	1e43      	subs	r3, r0, #1
    3e68:	b2db      	uxtb	r3, r3
    3e6a:	2b06      	cmp	r3, #6
    3e6c:	d804      	bhi.n	3e78 <emit_alu32_reg.constprop.14+0x1ac>
            emit2(state, (0x40c0) | (rn << 3) | (rd));
    3e6e:	ea40 01c4 	orr.w	r1, r0, r4, lsl #3
    3e72:	f441 4181 	orr.w	r1, r1, #16512	; 0x4080
    3e76:	e7cb      	b.n	3e10 <emit_alu32_reg.constprop.14+0x144>
    return (THUMB2_LSRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    3e78:	0229      	lsls	r1, r5, #8
    3e7a:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
    3e7e:	430c      	orrs	r4, r1
            emit4(state, _thumb32_LSRW_REG_T2(rd, rd, rn, FLAG_NOS));
    3e80:	4904      	ldr	r1, [pc, #16]	; (3e94 <emit_alu32_reg.constprop.14+0x1c8>)
    3e82:	e7cd      	b.n	3e20 <emit_alu32_reg.constprop.14+0x154>
    return (THUMB2_ASRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    3e84:	0229      	lsls	r1, r5, #8
    3e86:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
    3e8a:	430c      	orrs	r4, r1
            emit4(state, _thumb32_ASRW_REG_T2(rd, rd, rn, FLAG_NOS));
    3e8c:	4902      	ldr	r1, [pc, #8]	; (3e98 <emit_alu32_reg.constprop.14+0x1cc>)
    3e8e:	e7c7      	b.n	3e20 <emit_alu32_reg.constprop.14+0x154>
    3e90:	ea800030 	.word	0xea800030
    3e94:	fa20f000 	.word	0xfa20f000
    3e98:	fa40f000 	.word	0xfa40f000

00003e9c <build_prologue>:
 *
 * When popping registers off the stack at the end of a BPF function, we
 * reference them via the current ARM_FP register.
 */
// init eBPF stack and args
static void build_prologue(jit_state *state) {
    3e9c:	b510      	push	{r4, lr}
	const s8 *bpf_fp = bpf2a32[BPF_REG_FP];
    // 1. set stack SP to r10, USE SP
    // emit(ARM_PUSH(CALLEE_PUSH_MASK), ctx);
    // emit(ARM_MOV_R(ARM_FP, ARM_SP), ctx);
    // push {r4-r9, lr} , r4-r9, lr in used. aligned -> 8 reg
    emit4(state, _thumb32_PUSHW_T2(CALLEE_PUSH_MASK));
    3e9e:	4910      	ldr	r1, [pc, #64]	; (3ee0 <build_prologue+0x44>)
static void build_prologue(jit_state *state) {
    3ea0:	4604      	mov	r4, r0
    emit4(state, _thumb32_PUSHW_T2(CALLEE_PUSH_MASK));
    3ea2:	f00d fa98 	bl	113d6 <emit4>
    emit4(state, _thumb32_MOVW_REG_T3(dst, src, FLAG_NOS));
    3ea6:	490f      	ldr	r1, [pc, #60]	; (3ee4 <build_prologue+0x48>)
    3ea8:	f00d fa95 	bl	113d6 <emit4>
        emit2(state, inst);
    3eac:	f44f 510c 	mov.w	r1, #8960	; 0x2300
    3eb0:	f00d fa87 	bl	113c2 <emit2>
    emit4(state, _thumb32_SUBW_IMM_T4(dst, src, val, FLAG_NOS));
    3eb4:	490c      	ldr	r1, [pc, #48]	; (3ee8 <build_prologue+0x4c>)
    3eb6:	f00d fa8e 	bl	113d6 <emit4>
    3eba:	490c      	ldr	r1, [pc, #48]	; (3eec <build_prologue+0x50>)
    3ebc:	f00d fa8b 	bl	113d6 <emit4>
    if (!is64) {
    3ec0:	490b      	ldr	r1, [pc, #44]	; (3ef0 <build_prologue+0x54>)
    3ec2:	1c8a      	adds	r2, r1, #2
    3ec4:	3114      	adds	r1, #20
    3ec6:	f7ff fdaf 	bl	3a28 <emit_mov_reg64.part.7>
        emit2(state, _thumb16_MOV_REG_T1(dst, src));
    3eca:	f244 6102 	movw	r1, #17922	; 0x4602
    3ece:	4620      	mov	r0, r4
    3ed0:	f00d fa77 	bl	113c2 <emit2>
        emit2(state, inst);
    3ed4:	f44f 510c 	mov.w	r1, #8960	; 0x2300
	// emit_a32_mov_r64(state, true, bpf_fp, bpf_r1);
    emit_mov_reg64(state, true, bpf_fp, bpf_r1);
    // 3. mov arm_r0 to BPF_R1
    _emit_mov_reg(state, ARM_R0, bpf_r1[1]);
    emit_mov_imm(state, bpf_r1[0], 0);
}
    3ed8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        emit2(state, inst);
    3edc:	f00d ba71 	b.w	113c2 <emit2>
    3ee0:	e92d4bf0 	.word	0xe92d4bf0
    3ee4:	ea4f0b0d 	.word	0xea4f0b0d
    3ee8:	f2ad0250 	.word	0xf2ad0250
    3eec:	f2ad1d00 	.word	0xf2ad1d00
    3ef0:	000171f0 	.word	0x000171f0

00003ef4 <emit_str_reg>:
static void emit_str_reg(jit_state *state, const s8 dst, const s8 src[], s16 off, const u8 sz) {
    3ef4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3ef8:	4616      	mov	r6, r2
    s8 rd = arm_bpf_get_reg32(state, dst, tmp[1]);
    3efa:	2206      	movs	r2, #6
static void emit_str_reg(jit_state *state, const s8 dst, const s8 src[], s16 off, const u8 sz) {
    3efc:	461c      	mov	r4, r3
    3efe:	f89d 8018 	ldrb.w	r8, [sp, #24]
    3f02:	4605      	mov	r5, r0
    s8 rd = arm_bpf_get_reg32(state, dst, tmp[1]);
    3f04:	f00d fa71 	bl	113ea <arm_bpf_get_reg32>
    3f08:	4b2d      	ldr	r3, [pc, #180]	; (3fc0 <emit_str_reg+0xcc>)
    3f0a:	f933 3018 	ldrsh.w	r3, [r3, r8, lsl #1]
	return -off_max <= off && off <= off_max;
    3f0e:	425a      	negs	r2, r3
    3f10:	42a2      	cmp	r2, r4
    s8 rd = arm_bpf_get_reg32(state, dst, tmp[1]);
    3f12:	4607      	mov	r7, r0
	return -off_max <= off && off <= off_max;
    3f14:	dc01      	bgt.n	3f1a <emit_str_reg+0x26>
    if (!is_ldst_imm(off, sz)) {
    3f16:	429c      	cmp	r4, r3
    3f18:	dd0e      	ble.n	3f38 <emit_str_reg+0x44>
        emit_mov_imm(state, tmp[0], off);
    3f1a:	4622      	mov	r2, r4
    3f1c:	2107      	movs	r1, #7
    3f1e:	4628      	mov	r0, r5
    3f20:	f00d fb32 	bl	11588 <emit_mov_imm>
    return (THUMB2_ADD_REG_T2) | (DN << 7) | (Rm << 3) | (rdn);
    3f24:	f244 4107 	movw	r1, #17415	; 0x4407
    3f28:	ea41 01c7 	orr.w	r1, r1, r7, lsl #3
        emit2(state, _thumb16_ADD_REG_T2(dst, src));
    3f2c:	b289      	uxth	r1, r1
    3f2e:	4628      	mov	r0, r5
    3f30:	f00d fa47 	bl	113c2 <emit2>
        rd = tmp[0];
    3f34:	2707      	movs	r7, #7
        off = 0;
    3f36:	2400      	movs	r4, #0
    switch (sz) {
    3f38:	f1b8 0f08 	cmp.w	r8, #8
    3f3c:	d02b      	beq.n	3f96 <emit_str_reg+0xa2>
    3f3e:	d804      	bhi.n	3f4a <emit_str_reg+0x56>
    3f40:	f1b8 0f00 	cmp.w	r8, #0
    3f44:	d033      	beq.n	3fae <emit_str_reg+0xba>
}
    3f46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    switch (sz) {
    3f4a:	f1b8 0f10 	cmp.w	r8, #16
    3f4e:	d00f      	beq.n	3f70 <emit_str_reg+0x7c>
    3f50:	f1b8 0f18 	cmp.w	r8, #24
    3f54:	d1f7      	bne.n	3f46 <emit_str_reg+0x52>
        _emit_str_i(state, src_lo, rd, off);
    3f56:	4623      	mov	r3, r4
    3f58:	463a      	mov	r2, r7
    3f5a:	f996 1001 	ldrsb.w	r1, [r6, #1]
    3f5e:	4628      	mov	r0, r5
    3f60:	f00d fa4e 	bl	11400 <_emit_str_i>
        _emit_str_i(state, src_hi, rd, off + 4);
    3f64:	1d23      	adds	r3, r4, #4
    3f66:	b21b      	sxth	r3, r3
    3f68:	463a      	mov	r2, r7
    3f6a:	f996 1000 	ldrsb.w	r1, [r6]
    3f6e:	e022      	b.n	3fb6 <emit_str_reg+0xc2>
    u32 imm8 = offImm8 > 0 ? offImm8 : -offImm8;
    3f70:	ea84 71e4 	eor.w	r1, r4, r4, asr #31
    3f74:	eba1 71e4 	sub.w	r1, r1, r4, asr #31
    u32 inst = (THUMB2_STRB_IMM_T3) | (Rn << 16) | (Rt << 12) | (flag << 8) | (imm8);
    3f78:	f996 4001 	ldrsb.w	r4, [r6, #1]
    3f7c:	ea41 3107 	orr.w	r1, r1, r7, lsl #12
    3f80:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
        emit4(state, _thumb32_STRB_IMM_T3(src_lo, rd, off));
    3f84:	f041 4178 	orr.w	r1, r1, #4160749568	; 0xf8000000
    3f88:	f441 6170 	orr.w	r1, r1, #3840	; 0xf00
        emit4(state, _thumb32_STRH_IMM_T3(src_lo, rd, off));
    3f8c:	4628      	mov	r0, r5
}
    3f8e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        emit4(state, _thumb32_STRH_IMM_T3(src_lo, rd, off));
    3f92:	f00d ba20 	b.w	113d6 <emit4>
    u32 imm8 = offImm8 > 0 ? offImm8 : -offImm8;
    3f96:	2c00      	cmp	r4, #0
    u32 inst = (THUMB2_STRH_IMM_T3) | (Rn << 16) | (Rt << 12) | (flag << 8) | (imm8);
    3f98:	f996 1001 	ldrsb.w	r1, [r6, #1]
    u32 imm8 = offImm8 > 0 ? offImm8 : -offImm8;
    3f9c:	bfb8      	it	lt
    3f9e:	4264      	neglt	r4, r4
    u32 inst = (THUMB2_STRH_IMM_T3) | (Rn << 16) | (Rt << 12) | (flag << 8) | (imm8);
    3fa0:	ea44 3407 	orr.w	r4, r4, r7, lsl #12
    3fa4:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
    3fa8:	4906      	ldr	r1, [pc, #24]	; (3fc4 <emit_str_reg+0xd0>)
    3faa:	4321      	orrs	r1, r4
    3fac:	e7ee      	b.n	3f8c <emit_str_reg+0x98>
        _emit_str_i(state, src_lo, rd, off);
    3fae:	f996 1001 	ldrsb.w	r1, [r6, #1]
    3fb2:	4623      	mov	r3, r4
    3fb4:	463a      	mov	r2, r7
        _emit_str_i(state, src_hi, rd, off + 4);
    3fb6:	4628      	mov	r0, r5
}
    3fb8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        _emit_str_i(state, src_hi, rd, off + 4);
    3fbc:	f00d ba20 	b.w	11400 <_emit_str_i>
    3fc0:	0001683c 	.word	0x0001683c
    3fc4:	f8200f00 	.word	0xf8200f00

00003fc8 <jit_dump_inst>:
void jit_dump_inst(jit_state *state) {
    3fc8:	b570      	push	{r4, r5, r6, lr}
    3fca:	4605      	mov	r5, r0
    DEBUG_LOG("\nDecode:\n");
    3fcc:	4809      	ldr	r0, [pc, #36]	; (3ff4 <jit_dump_inst+0x2c>)
        DEBUG_LOG("%02x", state->jit_code[i]);
    3fce:	4e0a      	ldr	r6, [pc, #40]	; (3ff8 <jit_dump_inst+0x30>)
    DEBUG_LOG("\nDecode:\n");
    3fd0:	f00b ffbd 	bl	ff4e <debug_log>
    for (int i = 0; i < state->idx; i++) {
    3fd4:	2400      	movs	r4, #0
    3fd6:	692b      	ldr	r3, [r5, #16]
    3fd8:	42a3      	cmp	r3, r4
    3fda:	dc04      	bgt.n	3fe6 <jit_dump_inst+0x1e>
    DEBUG_LOG("\n");
    3fdc:	4807      	ldr	r0, [pc, #28]	; (3ffc <jit_dump_inst+0x34>)
}
    3fde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    DEBUG_LOG("\n");
    3fe2:	f00b bfb4 	b.w	ff4e <debug_log>
        DEBUG_LOG("%02x", state->jit_code[i]);
    3fe6:	68ab      	ldr	r3, [r5, #8]
    3fe8:	4630      	mov	r0, r6
    3fea:	5d19      	ldrb	r1, [r3, r4]
    3fec:	f00b ffaf 	bl	ff4e <debug_log>
    for (int i = 0; i < state->idx; i++) {
    3ff0:	3401      	adds	r4, #1
    3ff2:	e7f0      	b.n	3fd6 <jit_dump_inst+0xe>
    3ff4:	00017246 	.word	0x00017246
    3ff8:	00017250 	.word	0x00017250
    3ffc:	00017027 	.word	0x00017027

00004000 <emit_alu64_reg>:
void emit_alu64_reg(jit_state *state, bool is64, const s8 dst[], const s8 src[], const u8 op) {
    4000:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    4004:	4617      	mov	r7, r2
    4006:	4688      	mov	r8, r1
	const s8 *rd = arm_bpf_get_reg64(state, dst, tmp);
    4008:	4a1b      	ldr	r2, [pc, #108]	; (4078 <emit_alu64_reg+0x78>)
void emit_alu64_reg(jit_state *state, bool is64, const s8 dst[], const s8 src[], const u8 op) {
    400a:	f89d 6028 	ldrb.w	r6, [sp, #40]	; 0x28
	const s8 *rd = arm_bpf_get_reg64(state, dst, tmp);
    400e:	4639      	mov	r1, r7
void emit_alu64_reg(jit_state *state, bool is64, const s8 dst[], const s8 src[], const u8 op) {
    4010:	4604      	mov	r4, r0
    4012:	4699      	mov	r9, r3
	const s8 *rd = arm_bpf_get_reg64(state, dst, tmp);
    4014:	f00d fa54 	bl	114c0 <arm_bpf_get_reg64>
    4018:	4605      	mov	r5, r0
    if (is64) {
    401a:	f1b8 0f00 	cmp.w	r8, #0
    401e:	d01f      	beq.n	4060 <emit_alu64_reg+0x60>
        const s8 *rs = arm_bpf_get_reg64(state, src, tmp2);
    4020:	4a16      	ldr	r2, [pc, #88]	; (407c <emit_alu64_reg+0x7c>)
    4022:	4649      	mov	r1, r9
    4024:	4620      	mov	r0, r4
    4026:	f00d fa4b 	bl	114c0 <arm_bpf_get_reg64>
    402a:	4680      	mov	r8, r0
        emit_alu32_reg(state, rd[1], rs[1], true, false, op);
    402c:	f990 2001 	ldrsb.w	r2, [r0, #1]
    4030:	f995 1001 	ldrsb.w	r1, [r5, #1]
    4034:	9600      	str	r6, [sp, #0]
    4036:	2300      	movs	r3, #0
    4038:	4620      	mov	r0, r4
    403a:	f7ff fe47 	bl	3ccc <emit_alu32_reg.constprop.14>
        emit_alu32_reg(state, rd[0], rs[0], true, true, op);
    403e:	f998 2000 	ldrsb.w	r2, [r8]
    4042:	f995 1000 	ldrsb.w	r1, [r5]
    4046:	9600      	str	r6, [sp, #0]
    4048:	2301      	movs	r3, #1
        emit_alu32_reg(state, rd[1], rs, true, false, op);
    404a:	4620      	mov	r0, r4
    404c:	f7ff fe3e 	bl	3ccc <emit_alu32_reg.constprop.14>
    arm_bpf_put_reg64(state, dst, rd);
    4050:	462a      	mov	r2, r5
    4052:	4639      	mov	r1, r7
    4054:	4620      	mov	r0, r4
}
    4056:	b003      	add	sp, #12
    4058:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    arm_bpf_put_reg64(state, dst, rd);
    405c:	f00d ba75 	b.w	1154a <arm_bpf_put_reg64>
        s8 rs = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    4060:	2208      	movs	r2, #8
    4062:	f999 1001 	ldrsb.w	r1, [r9, #1]
    4066:	4620      	mov	r0, r4
    4068:	f00d f9bf 	bl	113ea <arm_bpf_get_reg32>
        emit_alu32_reg(state, rd[1], rs, true, false, op);
    406c:	f995 1001 	ldrsb.w	r1, [r5, #1]
    4070:	9600      	str	r6, [sp, #0]
    4072:	4643      	mov	r3, r8
    4074:	4602      	mov	r2, r0
    4076:	e7e8      	b.n	404a <emit_alu64_reg+0x4a>
    4078:	00017208 	.word	0x00017208
    407c:	0001720a 	.word	0x0001720a

00004080 <_emit_lsh64_reg>:
void _emit_lsh64_reg(jit_state *state, const s8 dst[], const s8 src[]) {
    4080:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4084:	460f      	mov	r7, r1
    rt = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    4086:	f992 1001 	ldrsb.w	r1, [r2, #1]
    inst = (THUMB2_LSLW_REG_T2) | (rd[0] << 16) | (tmp2[0] << 8) | (rt);
    408a:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 4138 <_emit_lsh64_reg+0xb8>
    emit4(state, inst);
    408e:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 413c <_emit_lsh64_reg+0xbc>
    rt = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    4092:	2208      	movs	r2, #8
void _emit_lsh64_reg(jit_state *state, const s8 dst[], const s8 src[]) {
    4094:	4604      	mov	r4, r0
    rt = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    4096:	f00d f9a8 	bl	113ea <arm_bpf_get_reg32>
    rd = arm_bpf_get_reg64(state, dst, tmp);
    409a:	4a22      	ldr	r2, [pc, #136]	; (4124 <_emit_lsh64_reg+0xa4>)
    rt = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    409c:	4605      	mov	r5, r0
    rd = arm_bpf_get_reg64(state, dst, tmp);
    409e:	4639      	mov	r1, r7
    40a0:	4620      	mov	r0, r4
    40a2:	f00d fa0d 	bl	114c0 <arm_bpf_get_reg64>
    emit4(state, inst);
    40a6:	4920      	ldr	r1, [pc, #128]	; (4128 <_emit_lsh64_reg+0xa8>)
    rd = arm_bpf_get_reg64(state, dst, tmp);
    40a8:	4606      	mov	r6, r0
    u32 inst = (0xf1a00000) | (i << 26) | (rt << 16) | (imm3 << 12) | (ARM_IP << 8) | imm8;
    40aa:	ea4f 4a05 	mov.w	sl, r5, lsl #16
    emit4(state, inst);
    40ae:	4620      	mov	r0, r4
    40b0:	ea4a 0101 	orr.w	r1, sl, r1
    40b4:	f00d f98f 	bl	113d6 <emit4>
    inst = (THUMB2_LSLW_REG_T2) | (rd[0] << 16) | (tmp2[0] << 8) | (rt);
    40b8:	f996 1000 	ldrsb.w	r1, [r6]
    40bc:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
    emit4(state, inst);
    40c0:	ea41 0108 	orr.w	r1, r1, r8
    40c4:	f00d f987 	bl	113d6 <emit4>
    emit4(state, inst);
    40c8:	4b18      	ldr	r3, [pc, #96]	; (412c <_emit_lsh64_reg+0xac>)
    inst = (THUMB2_LSLW_REG_T2) | (rd[1] << 16) | (ARM_IP << 8) | (ARM_IP);
    40ca:	f996 1001 	ldrsb.w	r1, [r6, #1]
    emit4(state, inst);
    40ce:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
    40d2:	f00d f980 	bl	113d6 <emit4>
    emit4(state, inst);
    40d6:	4649      	mov	r1, r9
    40d8:	f00d f97d 	bl	113d6 <emit4>
    emit4(state, inst);
    40dc:	4914      	ldr	r1, [pc, #80]	; (4130 <_emit_lsh64_reg+0xb0>)
    40de:	ea4a 0101 	orr.w	r1, sl, r1
    40e2:	f00d f978 	bl	113d6 <emit4>
    emit4(state, inst);
    40e6:	4b13      	ldr	r3, [pc, #76]	; (4134 <_emit_lsh64_reg+0xb4>)
    inst = (THUMB2_LSLW_REG_T2) | (rd[1] << 16) | (tmp2[0] << 8) | (tmp2[0]);
    40e8:	f996 1001 	ldrsb.w	r1, [r6, #1]
    emit4(state, inst);
    40ec:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
    40f0:	f00d f971 	bl	113d6 <emit4>
    emit4(state, inst);
    40f4:	4649      	mov	r1, r9
    40f6:	f00d f96e 	bl	113d6 <emit4>
    inst = (THUMB2_LSLW_REG_T2) | (rd[1] << 16) | (tmp2[0] << 8) | (rt);
    40fa:	f996 1001 	ldrsb.w	r1, [r6, #1]
    40fe:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
    emit4(state, inst);
    4102:	ea41 0108 	orr.w	r1, r1, r8
    4106:	f00d f966 	bl	113d6 <emit4>
	arm_bpf_put_reg32(state, dst_lo, tmp2[0]);
    410a:	f997 1001 	ldrsb.w	r1, [r7, #1]
    410e:	2209      	movs	r2, #9
    4110:	f00d f9fd 	bl	1150e <arm_bpf_put_reg32>
	arm_bpf_put_reg32(state, dst_hi, ARM_IP);
    4114:	f997 1000 	ldrsb.w	r1, [r7]
    4118:	4620      	mov	r0, r4
    411a:	220c      	movs	r2, #12
}
    411c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	arm_bpf_put_reg32(state, dst_hi, ARM_IP);
    4120:	f00d b9f5 	b.w	1150e <arm_bpf_put_reg32>
    4124:	00017208 	.word	0x00017208
    4128:	f1a00c20 	.word	0xf1a00c20
    412c:	fa00fc0c 	.word	0xfa00fc0c
    4130:	f1c00920 	.word	0xf1c00920
    4134:	fa00f909 	.word	0xfa00f909
    4138:	fa00f900 	.word	0xfa00f900
    413c:	ea490c0c 	.word	0xea490c0c

00004140 <_emit_lsh64_imm>:
void _emit_lsh64_imm(jit_state *state, const s8 dst[], const u16 val) {
    4140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4142:	4614      	mov	r4, r2
	rd = arm_bpf_get_reg64(state, dst, tmp);
    4144:	4a2a      	ldr	r2, [pc, #168]	; (41f0 <_emit_lsh64_imm+0xb0>)
void _emit_lsh64_imm(jit_state *state, const s8 dst[], const u16 val) {
    4146:	4605      	mov	r5, r0
    4148:	460f      	mov	r7, r1
	rd = arm_bpf_get_reg64(state, dst, tmp);
    414a:	f00d f9b9 	bl	114c0 <arm_bpf_get_reg64>
    if (val < 32) {
    414e:	2c1f      	cmp	r4, #31
	rd = arm_bpf_get_reg64(state, dst, tmp);
    4150:	4606      	mov	r6, r0
    if (val < 32) {
    4152:	f990 2000 	ldrsb.w	r2, [r0]
    4156:	d830      	bhi.n	41ba <_emit_lsh64_imm+0x7a>
        u32 inst = (0xea5f0000) | (imm3 << 12) | (tmp2[0] << 8) | (imm2 << 4) | (rd[0]);  
    4158:	f004 0103 	and.w	r1, r4, #3
        u16 imm3 = (val & 0b11100) >> 2;
    415c:	10a3      	asrs	r3, r4, #2
        u32 inst = (0xea5f0000) | (imm3 << 12) | (tmp2[0] << 8) | (imm2 << 4) | (rd[0]);  
    415e:	0109      	lsls	r1, r1, #4
    4160:	ea41 3103 	orr.w	r1, r1, r3, lsl #12
    4164:	430a      	orrs	r2, r1
        emit4(state, inst);
    4166:	4923      	ldr	r1, [pc, #140]	; (41f4 <_emit_lsh64_imm+0xb4>)
    4168:	4628      	mov	r0, r5
    416a:	4311      	orrs	r1, r2
    416c:	f00d f933 	bl	113d6 <emit4>
        imm2 = ((32 - val) & 0b11);
    4170:	4263      	negs	r3, r4
        inst = (0xea500010) | (tmp2[0] << 16) | (imm3 << 12) | (rd[0] << 8) | (imm2 << 6) | (rd[1]);
    4172:	f003 0203 	and.w	r2, r3, #3
    4176:	f996 3000 	ldrsb.w	r3, [r6]
        emit4(state, inst);
    417a:	491f      	ldr	r1, [pc, #124]	; (41f8 <_emit_lsh64_imm+0xb8>)
        inst = (0xea500010) | (tmp2[0] << 16) | (imm3 << 12) | (rd[0] << 8) | (imm2 << 6) | (rd[1]);
    417c:	021b      	lsls	r3, r3, #8
    417e:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
        imm3 = ((32 - val) & 0b11100) >> 2;
    4182:	f1c4 0220 	rsb	r2, r4, #32
        inst = (0xea500010) | (tmp2[0] << 16) | (imm3 << 12) | (rd[0] << 8) | (imm2 << 6) | (rd[1]);
    4186:	f3c2 0282 	ubfx	r2, r2, #2, #3
    418a:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
    418e:	f996 2001 	ldrsb.w	r2, [r6, #1]
    4192:	4313      	orrs	r3, r2
        emit4(state, inst);
    4194:	4319      	orrs	r1, r3
    4196:	f00d f91e 	bl	113d6 <emit4>
        emit2(state, (0x0000) | (val << 6) | (rd[1]<< 3) | (rd[1]));
    419a:	f996 1001 	ldrsb.w	r1, [r6, #1]
    419e:	ea41 1484 	orr.w	r4, r1, r4, lsl #6
    41a2:	ea44 01c1 	orr.w	r1, r4, r1, lsl #3
        emit2(state, (0x4040) | (rd[1] << 3) | (rd[1]));
    41a6:	b289      	uxth	r1, r1
    41a8:	4628      	mov	r0, r5
    41aa:	f00d f90a 	bl	113c2 <emit2>
    arm_bpf_put_reg64(state, dst, rd);
    41ae:	4632      	mov	r2, r6
    41b0:	4639      	mov	r1, r7
}
    41b2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    arm_bpf_put_reg64(state, dst, rd);
    41b6:	f00d b9c8 	b.w	1154a <arm_bpf_put_reg64>
        if (val == 32) { // 0
    41ba:	2c20      	cmp	r4, #32
    41bc:	f990 1001 	ldrsb.w	r1, [r0, #1]
    41c0:	d10b      	bne.n	41da <_emit_lsh64_imm+0x9a>
            _emit_mov_reg(state, rd[1], rd[0]);
    41c2:	4628      	mov	r0, r5
    41c4:	f00d f988 	bl	114d8 <_emit_mov_reg>
        emit2(state, (0x4040) | (rd[1] << 3) | (rd[1]));
    41c8:	f996 1001 	ldrsb.w	r1, [r6, #1]
    41cc:	ea41 01c1 	orr.w	r1, r1, r1, lsl #3
    41d0:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
    41d4:	f041 0140 	orr.w	r1, r1, #64	; 0x40
    41d8:	e7e5      	b.n	41a6 <_emit_lsh64_imm+0x66>
            emit2(state, (0x0000) | ((val - 32) << 6) | (rd[1] << 3) | (rd[0]));
    41da:	3c20      	subs	r4, #32
    41dc:	ea42 1484 	orr.w	r4, r2, r4, lsl #6
    41e0:	ea44 01c1 	orr.w	r1, r4, r1, lsl #3
    41e4:	b289      	uxth	r1, r1
    41e6:	4628      	mov	r0, r5
    41e8:	f00d f8eb 	bl	113c2 <emit2>
    41ec:	e7ec      	b.n	41c8 <_emit_lsh64_imm+0x88>
    41ee:	bf00      	nop
    41f0:	00017208 	.word	0x00017208
    41f4:	ea5f0900 	.word	0xea5f0900
    41f8:	ea590010 	.word	0xea590010

000041fc <emit_ldx_reg>:
{
    41fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4200:	461c      	mov	r4, r3
    4202:	f89d 9020 	ldrb.w	r9, [sp, #32]
    const s8 *rd = is_stacked(dst_lo) ? tmp : dst; //Rt
    4206:	f991 3001 	ldrsb.w	r3, [r1, #1]
    420a:	4f61      	ldr	r7, [pc, #388]	; (4390 <emit_ldx_reg+0x194>)
    420c:	ea17 0723 	ands.w	r7, r7, r3, asr #32
    4210:	bf38      	it	cc
    4212:	460f      	movcc	r7, r1
    4214:	f1b9 0f18 	cmp.w	r9, #24
    4218:	bf9a      	itte	ls
    421a:	4b5e      	ldrls	r3, [pc, #376]	; (4394 <emit_ldx_reg+0x198>)
    421c:	f933 3019 	ldrshls.w	r3, [r3, r9, lsl #1]
    4220:	2300      	movhi	r3, #0
{
    4222:	4615      	mov	r5, r2
	return -off_max <= off && off <= off_max;
    4224:	425a      	negs	r2, r3
    4226:	42a2      	cmp	r2, r4
{
    4228:	4606      	mov	r6, r0
    422a:	4688      	mov	r8, r1
	return -off_max <= off && off <= off_max;
    422c:	dc01      	bgt.n	4232 <emit_ldx_reg+0x36>
    if (!is_ldst_imm(off, sz)) {
    422e:	429c      	cmp	r4, r3
    4230:	dd1d      	ble.n	426e <emit_ldx_reg+0x72>
        emit_mov_imm(state, tmp[0], off);
    4232:	4622      	mov	r2, r4
    4234:	2107      	movs	r1, #7
    4236:	4630      	mov	r0, r6
    4238:	f00d f9a6 	bl	11588 <emit_mov_imm>
    return (THUMB2_ADD_REG_T2) | (DN << 7) | (Rm << 3) | (rdn);
    423c:	f244 4107 	movw	r1, #17415	; 0x4407
    4240:	ea41 01c5 	orr.w	r1, r1, r5, lsl #3
        emit2(state, _thumb16_ADD_REG_T2(dst, src));
    4244:	b289      	uxth	r1, r1
    4246:	4630      	mov	r0, r6
    4248:	f00d f8bb 	bl	113c2 <emit2>
        rm = tmp[0];
    424c:	2507      	movs	r5, #7
        off = 0;
    424e:	2400      	movs	r4, #0
    switch (sz) {
    4250:	f1b9 0f08 	cmp.w	r9, #8
    4254:	d064      	beq.n	4320 <emit_ldx_reg+0x124>
    4256:	d814      	bhi.n	4282 <emit_ldx_reg+0x86>
    4258:	f1b9 0f00 	cmp.w	r9, #0
    425c:	f000 808f 	beq.w	437e <emit_ldx_reg+0x182>
    arm_bpf_put_reg64(state, dst, rd);
    4260:	463a      	mov	r2, r7
    4262:	4641      	mov	r1, r8
    4264:	4630      	mov	r0, r6
}
    4266:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    arm_bpf_put_reg64(state, dst, rd);
    426a:	f00d b96e 	b.w	1154a <arm_bpf_put_reg64>
    } else if (rd[1] == rm) {
    426e:	f997 3001 	ldrsb.w	r3, [r7, #1]
    4272:	42ab      	cmp	r3, r5
    4274:	d1ec      	bne.n	4250 <emit_ldx_reg+0x54>
        emit_a32_mov_reg(state, rm, tmp[0]);
    4276:	4629      	mov	r1, r5
    4278:	2207      	movs	r2, #7
    427a:	f00d f959 	bl	11530 <emit_a32_mov_reg>
        rm = tmp[0];
    427e:	2507      	movs	r5, #7
    4280:	e7e6      	b.n	4250 <emit_ldx_reg+0x54>
    switch (sz) {
    4282:	f1b9 0f10 	cmp.w	r9, #16
    4286:	d00f      	beq.n	42a8 <emit_ldx_reg+0xac>
    4288:	f1b9 0f18 	cmp.w	r9, #24
    428c:	d1e8      	bne.n	4260 <emit_ldx_reg+0x64>
            _emit_ldr_i(state, rd[1], rm, off);
    428e:	4623      	mov	r3, r4
    4290:	462a      	mov	r2, r5
    4292:	f997 1001 	ldrsb.w	r1, [r7, #1]
    4296:	4630      	mov	r0, r6
    4298:	f7ff fba8 	bl	39ec <_emit_ldr_i>
            _emit_ldr_i(state, rd[0], rm, off + 4);
    429c:	1d23      	adds	r3, r4, #4
    429e:	b21b      	sxth	r3, r3
    42a0:	462a      	mov	r2, r5
    42a2:	f997 1000 	ldrsb.w	r1, [r7]
    42a6:	e06e      	b.n	4386 <emit_ldx_reg+0x18a>
    if (off <= imm5 && off >= -imm5) {
    42a8:	2c1f      	cmp	r4, #31
            _emit_ldrb_i(state, rd[1], rm, off);
    42aa:	f997 2001 	ldrsb.w	r2, [r7, #1]
    if (off <= imm5 && off >= -imm5) {
    42ae:	dc11      	bgt.n	42d4 <emit_ldx_reg+0xd8>
    42b0:	f114 0f1f 	cmn.w	r4, #31
    42b4:	db1e      	blt.n	42f4 <emit_ldx_reg+0xf8>
        if (Rt < 8 && Rn < 8) {
    42b6:	2a07      	cmp	r2, #7
    42b8:	dc0e      	bgt.n	42d8 <emit_ldx_reg+0xdc>
    42ba:	2d07      	cmp	r5, #7
    42bc:	dc0c      	bgt.n	42d8 <emit_ldx_reg+0xdc>
    return (THUMB2_LDRB_IMM_T1) | (offImm5 << 6) | (Rn << 3) | (Rt);
    42be:	00e9      	lsls	r1, r5, #3
    42c0:	ea41 1184 	orr.w	r1, r1, r4, lsl #6
    42c4:	4311      	orrs	r1, r2
    42c6:	f441 41f0 	orr.w	r1, r1, #30720	; 0x7800
        emit2(state, inst);
    42ca:	b289      	uxth	r1, r1
    42cc:	4630      	mov	r0, r6
    42ce:	f00d f878 	bl	113c2 <emit2>
    42d2:	e7c5      	b.n	4260 <emit_ldx_reg+0x64>
    if (off <= imm8 && off >= -imm8) {
    42d4:	2cff      	cmp	r4, #255	; 0xff
    42d6:	dc14      	bgt.n	4302 <emit_ldx_reg+0x106>
    u32 P = 1, U = offImm8 >= 0, W = 0; // p = 0 && w = 0 -> undefined
    42d8:	43e1      	mvns	r1, r4
    42da:	0fc9      	lsrs	r1, r1, #31
    u32 inst = (THUMB2_LDRB_IMM_T3) | (Rn << 16) | (Rt << 12) | (flag << 8) | (imm8);
    42dc:	0312      	lsls	r2, r2, #12
    42de:	ea42 2241 	orr.w	r2, r2, r1, lsl #9
    s32 imm8 = offImm8 > 0 ? offImm8 : -offImm8;
    42e2:	2c00      	cmp	r4, #0
    u32 inst = (THUMB2_LDRB_IMM_T3) | (Rn << 16) | (Rt << 12) | (flag << 8) | (imm8);
    42e4:	ea42 4505 	orr.w	r5, r2, r5, lsl #16
    s32 imm8 = offImm8 > 0 ? offImm8 : -offImm8;
    42e8:	bfb8      	it	lt
    42ea:	4264      	neglt	r4, r4
        emit4(state, _thumb32_LDRB_IMM_T3(Rt, Rn, off));
    42ec:	492a      	ldr	r1, [pc, #168]	; (4398 <emit_ldx_reg+0x19c>)
    u32 inst = (THUMB2_LDRB_IMM_T3) | (Rn << 16) | (Rt << 12) | (flag << 8) | (imm8);
    42ee:	432c      	orrs	r4, r5
        emit4(state, inst);
    42f0:	4321      	orrs	r1, r4
    42f2:	e011      	b.n	4318 <emit_ldx_reg+0x11c>
    if (off <= imm8 && off >= -imm8) {
    42f4:	f114 0fff 	cmn.w	r4, #255	; 0xff
    42f8:	daee      	bge.n	42d8 <emit_ldx_reg+0xdc>
    } else if (off <= imm12 && off >= -imm12) {
    42fa:	f514 5f80 	cmn.w	r4, #4096	; 0x1000
    42fe:	ddaf      	ble.n	4260 <emit_ldx_reg+0x64>
    4300:	e002      	b.n	4308 <emit_ldx_reg+0x10c>
    4302:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    4306:	daab      	bge.n	4260 <emit_ldx_reg+0x64>
        s32 inst = 0xf8900000 | (Rn << 16) | (Rt << 12) | off;
    4308:	0311      	lsls	r1, r2, #12
    430a:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
    430e:	4321      	orrs	r1, r4
        emit4(state, inst);
    4310:	f041 4178 	orr.w	r1, r1, #4160749568	; 0xf8000000
    4314:	f441 0110 	orr.w	r1, r1, #9437184	; 0x900000
        emit4(state, inst);
    4318:	4630      	mov	r0, r6
    431a:	f00d f85c 	bl	113d6 <emit4>
    431e:	e79f      	b.n	4260 <emit_ldx_reg+0x64>
    if (off <= imm5 && off >= -imm5) {
    4320:	2c1f      	cmp	r4, #31
            _emit_ldrh_i(state, rd[1], rm, off);
    4322:	f997 2001 	ldrsb.w	r2, [r7, #1]
    if (off <= imm5 && off >= -imm5) {
    4326:	dc0b      	bgt.n	4340 <emit_ldx_reg+0x144>
    4328:	f114 0f1f 	cmn.w	r4, #31
    432c:	db11      	blt.n	4352 <emit_ldx_reg+0x156>
        s16 inst = 0x8800 | ((off & imm5) << 6) | (Rn << 3) | (Rt);
    432e:	f004 011f 	and.w	r1, r4, #31
    4332:	ea42 1181 	orr.w	r1, r2, r1, lsl #6
    4336:	ea41 01c5 	orr.w	r1, r1, r5, lsl #3
    433a:	f441 4108 	orr.w	r1, r1, #34816	; 0x8800
    433e:	e7c4      	b.n	42ca <emit_ldx_reg+0xce>
    } else if (off <= imm8 && off >= -imm8) {
    4340:	2cff      	cmp	r4, #255	; 0xff
    4342:	dc0d      	bgt.n	4360 <emit_ldx_reg+0x164>
        s32 inst = 0xf8300000 | (Rn << 16) | (Rt << 12) | (0b1110 << 8) | (off & imm8);
    4344:	0312      	lsls	r2, r2, #12
    4346:	ea42 4505 	orr.w	r5, r2, r5, lsl #16
    434a:	b2e4      	uxtb	r4, r4
    434c:	432c      	orrs	r4, r5
        emit4(state, inst);
    434e:	4913      	ldr	r1, [pc, #76]	; (439c <emit_ldx_reg+0x1a0>)
    4350:	e7ce      	b.n	42f0 <emit_ldx_reg+0xf4>
    } else if (off <= imm8 && off >= -imm8) {
    4352:	f114 0fff 	cmn.w	r4, #255	; 0xff
    4356:	daf5      	bge.n	4344 <emit_ldx_reg+0x148>
    } else if (off <= imm12 && off >= -imm12) {
    4358:	f514 5f80 	cmn.w	r4, #4096	; 0x1000
    435c:	dd80      	ble.n	4260 <emit_ldx_reg+0x64>
    435e:	e003      	b.n	4368 <emit_ldx_reg+0x16c>
    4360:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    4364:	f6bf af7c 	bge.w	4260 <emit_ldx_reg+0x64>
        s32 inst = 0xf8b00000 | (Rn << 16) | (Rt << 12) | (off & imm12);
    4368:	0311      	lsls	r1, r2, #12
    436a:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
    436e:	f3c4 010b 	ubfx	r1, r4, #0, #12
    4372:	4329      	orrs	r1, r5
        emit4(state, inst);
    4374:	f041 4178 	orr.w	r1, r1, #4160749568	; 0xf8000000
    4378:	f441 0130 	orr.w	r1, r1, #11534336	; 0xb00000
    437c:	e7cc      	b.n	4318 <emit_ldx_reg+0x11c>
            _emit_ldr_i(state, rd[1], rm, off);
    437e:	f997 1001 	ldrsb.w	r1, [r7, #1]
    4382:	4623      	mov	r3, r4
    4384:	462a      	mov	r2, r5
            _emit_ldr_i(state, rd[0], rm, off + 4);
    4386:	4630      	mov	r0, r6
    4388:	f7ff fb30 	bl	39ec <_emit_ldr_i>
            break;
    438c:	e768      	b.n	4260 <emit_ldx_reg+0x64>
    438e:	bf00      	nop
    4390:	00017208 	.word	0x00017208
    4394:	0001683c 	.word	0x0001683c
    4398:	f8100c00 	.word	0xf8100c00
    439c:	f8300e00 	.word	0xf8300e00

000043a0 <build_body>:

static void build_body(jit_state *state) {
    43a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    43a4:	b089      	sub	sp, #36	; 0x24
    ebpf_inst *insts = state->insts;
    43a6:	6803      	ldr	r3, [r0, #0]
    43a8:	9305      	str	r3, [sp, #20]
    int inst_num = state->inst_num;
    43aa:	6843      	ldr	r3, [r0, #4]
    43ac:	9307      	str	r3, [sp, #28]
static void build_body(jit_state *state) {
    43ae:	4604      	mov	r4, r0
    // DEBUG_LOG("IMM val: 5=%d 6=%d\n", insts[5].imm, insts[6].imm);
    for (int i = 0; i < inst_num; i++) {
    43b0:	f04f 0b00 	mov.w	fp, #0
    43b4:	9b07      	ldr	r3, [sp, #28]
    43b6:	459b      	cmp	fp, r3
    43b8:	db02      	blt.n	43c0 <build_body+0x20>
        if (ret < 0) {
            DEBUG_LOG("ERROR: %d\n", ret);
            return;
        }
    }
}
    43ba:	b009      	add	sp, #36	; 0x24
    43bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ebpf_inst *inst = &insts[i];
    43c0:	9b05      	ldr	r3, [sp, #20]
    43c2:	eb03 00cb 	add.w	r0, r3, fp, lsl #3
    const int8_t *dst = bpf2a32[inst->dst];
    43c6:	4b82      	ldr	r3, [pc, #520]	; (45d0 <build_body+0x230>)
    43c8:	7841      	ldrb	r1, [r0, #1]
    const s16 off = inst->offset;
    43ca:	f9b0 9002 	ldrsh.w	r9, [r0, #2]
    const s32 imm = inst->imm;
    43ce:	6845      	ldr	r5, [r0, #4]
    const int8_t *dst = bpf2a32[inst->dst];
    43d0:	f001 020f 	and.w	r2, r1, #15
    43d4:	9204      	str	r2, [sp, #16]
    43d6:	eb03 0742 	add.w	r7, r3, r2, lsl #1
    int pc = inst - state->insts;
    43da:	6822      	ldr	r2, [r4, #0]
    43dc:	1a82      	subs	r2, r0, r2
    43de:	ea4f 0ae2 	mov.w	sl, r2, asr #3
    uint32_t target_pc = pc + inst->offset + 1;
    43e2:	eb09 020a 	add.w	r2, r9, sl
    43e6:	9206      	str	r2, [sp, #24]
    const u8 code = inst->opcode;
    43e8:	9a05      	ldr	r2, [sp, #20]
    43ea:	f812 603b 	ldrb.w	r6, [r2, fp, lsl #3]
    43ee:	f006 0207 	and.w	r2, r6, #7
    const bool is64 = (BPF_CLASS(code) == EBPF_CLS_ALU64);
    43f2:	f1a2 0c07 	sub.w	ip, r2, #7
    43f6:	9202      	str	r2, [sp, #8]
    43f8:	f1dc 0200 	rsbs	r2, ip, #0
    const int8_t *src = bpf2a32[inst->src];
    43fc:	ea4f 1111 	mov.w	r1, r1, lsr #4
    const bool is64 = (BPF_CLASS(code) == EBPF_CLS_ALU64);
    4400:	eb42 020c 	adc.w	r2, r2, ip
    const int8_t *src = bpf2a32[inst->src];
    4404:	eb03 0841 	add.w	r8, r3, r1, lsl #1
    const bool is64 = (BPF_CLASS(code) == EBPF_CLS_ALU64);
    4408:	9203      	str	r2, [sp, #12]
    switch (code) {
    440a:	2edd      	cmp	r6, #221	; 0xdd
    440c:	f200 84aa 	bhi.w	4d64 <build_body+0x9c4>
    4410:	e8df f016 	tbh	[pc, r6, lsl #1]
    4414:	04a800ed 	.word	0x04a800ed
    4418:	04a804a8 	.word	0x04a804a8
    441c:	04450107 	.word	0x04450107
    4420:	010704a8 	.word	0x010704a8
    4424:	04a804a8 	.word	0x04a804a8
    4428:	04a804a8 	.word	0x04a804a8
    442c:	04a80107 	.word	0x04a80107
    4430:	010704a8 	.word	0x010704a8
    4434:	04a804a8 	.word	0x04a804a8
    4438:	04a804a8 	.word	0x04a804a8
    443c:	038b0107 	.word	0x038b0107
    4440:	010704a8 	.word	0x010704a8
    4444:	04a80340 	.word	0x04a80340
    4448:	04a804a8 	.word	0x04a804a8
    444c:	038b0107 	.word	0x038b0107
    4450:	010704a8 	.word	0x010704a8
    4454:	04a804a8 	.word	0x04a804a8
    4458:	04a804a8 	.word	0x04a804a8
    445c:	038b0107 	.word	0x038b0107
    4460:	032604a8 	.word	0x032604a8
    4464:	04a804a8 	.word	0x04a804a8
    4468:	04a804a8 	.word	0x04a804a8
    446c:	038b0107 	.word	0x038b0107
    4470:	032604a8 	.word	0x032604a8
    4474:	04a804a8 	.word	0x04a804a8
    4478:	04a804a8 	.word	0x04a804a8
    447c:	038b0122 	.word	0x038b0122
    4480:	012204a8 	.word	0x012204a8
    4484:	04a804a8 	.word	0x04a804a8
    4488:	04a804a8 	.word	0x04a804a8
    448c:	038b0122 	.word	0x038b0122
    4490:	012204a8 	.word	0x012204a8
    4494:	04a804a8 	.word	0x04a804a8
    4498:	04a804a8 	.word	0x04a804a8
    449c:	038b0107 	.word	0x038b0107
    44a0:	010704a8 	.word	0x010704a8
    44a4:	04a804a8 	.word	0x04a804a8
    44a8:	04a804a8 	.word	0x04a804a8
    44ac:	038b0107 	.word	0x038b0107
    44b0:	010704a8 	.word	0x010704a8
    44b4:	04a804a8 	.word	0x04a804a8
    44b8:	04a804a8 	.word	0x04a804a8
    44bc:	038b0107 	.word	0x038b0107
    44c0:	010704a8 	.word	0x010704a8
    44c4:	04a804a8 	.word	0x04a804a8
    44c8:	04a804a8 	.word	0x04a804a8
    44cc:	038b0107 	.word	0x038b0107
    44d0:	010704a8 	.word	0x010704a8
    44d4:	035204a8 	.word	0x035204a8
    44d8:	03800362 	.word	0x03800362
    44dc:	038b015a 	.word	0x038b015a
    44e0:	018304a8 	.word	0x018304a8
    44e4:	035204a8 	.word	0x035204a8
    44e8:	03800362 	.word	0x03800362
    44ec:	038b0107 	.word	0x038b0107
    44f0:	017d04a8 	.word	0x017d04a8
    44f4:	035204a8 	.word	0x035204a8
    44f8:	03800362 	.word	0x03800362
    44fc:	038b015a 	.word	0x038b015a
    4500:	01e004a8 	.word	0x01e004a8
    4504:	035204a8 	.word	0x035204a8
    4508:	03800362 	.word	0x03800362
    450c:	038b0107 	.word	0x038b0107
    4510:	018904a8 	.word	0x018904a8
    4514:	04a804a8 	.word	0x04a804a8
    4518:	04a804a8 	.word	0x04a804a8
    451c:	04580309 	.word	0x04580309
    4520:	030c04a8 	.word	0x030c04a8
    4524:	04a804a8 	.word	0x04a804a8
    4528:	04a804a8 	.word	0x04a804a8
    452c:	04a804a8 	.word	0x04a804a8
    4530:	04a804a8 	.word	0x04a804a8
    4534:	04a804a8 	.word	0x04a804a8
    4538:	04a804a8 	.word	0x04a804a8
    453c:	049a0122 	.word	0x049a0122
    4540:	012204a8 	.word	0x012204a8
    4544:	04a804a8 	.word	0x04a804a8
    4548:	04a804a8 	.word	0x04a804a8
    454c:	04a80122 	.word	0x04a80122
    4550:	012204a8 	.word	0x012204a8
    4554:	04a804a8 	.word	0x04a804a8
    4558:	04a804a8 	.word	0x04a804a8
    455c:	038b0107 	.word	0x038b0107
    4560:	010704a8 	.word	0x010704a8
    4564:	04a804a8 	.word	0x04a804a8
    4568:	04a804a8 	.word	0x04a804a8
    456c:	038b0107 	.word	0x038b0107
    4570:	010704a8 	.word	0x010704a8
    4574:	04a804a8 	.word	0x04a804a8
    4578:	04a804a8 	.word	0x04a804a8
    457c:	038b00e0 	.word	0x038b00e0
    4580:	00e004a8 	.word	0x00e004a8
    4584:	04a804a8 	.word	0x04a804a8
    4588:	04a804a8 	.word	0x04a804a8
    458c:	038b00e0 	.word	0x038b00e0
    4590:	00e004a8 	.word	0x00e004a8
    4594:	04a804a8 	.word	0x04a804a8
    4598:	04a804a8 	.word	0x04a804a8
    459c:	038b015a 	.word	0x038b015a
    45a0:	028c04a8 	.word	0x028c04a8
    45a4:	04a804a8 	.word	0x04a804a8
    45a8:	04a804a8 	.word	0x04a804a8
    45ac:	038b0107 	.word	0x038b0107
    45b0:	024004a8 	.word	0x024004a8
    45b4:	04a804a8 	.word	0x04a804a8
    45b8:	04a804a8 	.word	0x04a804a8
    45bc:	038b033a 	.word	0x038b033a
    45c0:	04a804a8 	.word	0x04a804a8
    45c4:	04a804a8 	.word	0x04a804a8
    45c8:	04a804a8 	.word	0x04a804a8
    45cc:	038b033a 	.word	0x038b033a
    45d0:	000171f0 	.word	0x000171f0
        switch (BPF_SRC(code))
    45d4:	f016 0608 	ands.w	r6, r6, #8
    45d8:	d01c      	beq.n	4614 <build_body+0x274>
    45da:	b146      	cbz	r6, 45ee <build_body+0x24e>
            if (imm == 1) {
    45dc:	2d01      	cmp	r5, #1
    45de:	d108      	bne.n	45f2 <build_body+0x252>
                emit_mov_imm(state, dst_hi, 0);
    45e0:	9904      	ldr	r1, [sp, #16]
    45e2:	2200      	movs	r2, #0
    45e4:	f813 1011 	ldrb.w	r1, [r3, r1, lsl #1]
    45e8:	4620      	mov	r0, r4
    45ea:	f00c ffcd 	bl	11588 <emit_mov_imm>
    return 0;
    45ee:	2500      	movs	r5, #0
    45f0:	e071      	b.n	46d6 <build_body+0x336>
    if (!is64) {
    45f2:	9b02      	ldr	r3, [sp, #8]
    45f4:	2b07      	cmp	r3, #7
    45f6:	d007      	beq.n	4608 <build_body+0x268>
        emit_a32_mov_reg(state, src_lo, dst_lo);
    45f8:	f997 2001 	ldrsb.w	r2, [r7, #1]
    45fc:	f998 1001 	ldrsb.w	r1, [r8, #1]
    4600:	4620      	mov	r0, r4
    4602:	f00c ff95 	bl	11530 <emit_a32_mov_reg>
        if (ret > 0) { // load value, skip
    4606:	e7f2      	b.n	45ee <build_body+0x24e>
    4608:	4642      	mov	r2, r8
    460a:	4639      	mov	r1, r7
    460c:	4620      	mov	r0, r4
    460e:	f7ff fa0b 	bl	3a28 <emit_mov_reg64.part.7>
    4612:	e7ec      	b.n	45ee <build_body+0x24e>
            emit_mov_se_imm64(state, is64, dst, imm);
    4614:	462b      	mov	r3, r5
    4616:	463a      	mov	r2, r7
    4618:	9903      	ldr	r1, [sp, #12]
    461a:	4620      	mov	r0, r4
    461c:	f00c fffc 	bl	11618 <emit_mov_se_imm64>
        if (ret > 0) { // load value, skip
    4620:	e7e5      	b.n	45ee <build_body+0x24e>
        switch (BPF_SRC(code))
    4622:	f016 0908 	ands.w	r9, r6, #8
    4626:	d007      	beq.n	4638 <build_body+0x298>
    4628:	f1b9 0f00 	cmp.w	r9, #0
    462c:	d0df      	beq.n	45ee <build_body+0x24e>
            emit_alu64_reg(state, is64, dst, src, BPF_OP(code));
    462e:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
    4632:	9600      	str	r6, [sp, #0]
    4634:	4643      	mov	r3, r8
    4636:	e009      	b.n	464c <build_body+0x2ac>
            emit_mov_se_imm64(state, is64, tmp2, imm);
    4638:	462b      	mov	r3, r5
    463a:	4ad8      	ldr	r2, [pc, #864]	; (499c <build_body+0x5fc>)
    463c:	9903      	ldr	r1, [sp, #12]
    463e:	4620      	mov	r0, r4
    4640:	f00c ffea 	bl	11618 <emit_mov_se_imm64>
            emit_alu64_reg(state, is64, dst, tmp2, BPF_OP(code));
    4644:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
    4648:	4bd4      	ldr	r3, [pc, #848]	; (499c <build_body+0x5fc>)
    464a:	9600      	str	r6, [sp, #0]
            emit_alu64_reg(state, is64, dst, src, BPF_OP(code));
    464c:	463a      	mov	r2, r7
    464e:	9903      	ldr	r1, [sp, #12]
    4650:	4620      	mov	r0, r4
    4652:	f7ff fcd5 	bl	4000 <emit_alu64_reg>
        if (ret > 0) { // load value, skip
    4656:	e7ca      	b.n	45ee <build_body+0x24e>
    rd_lo = arm_bpf_get_reg32(state, dst_lo, tmp2[1]);
    4658:	2208      	movs	r2, #8
    465a:	f997 1001 	ldrsb.w	r1, [r7, #1]
    465e:	4620      	mov	r0, r4
    4660:	f00c fec3 	bl	113ea <arm_bpf_get_reg32>
    switch (BPF_SRC(code)) {
    4664:	f016 0308 	ands.w	r3, r6, #8
    rd_lo = arm_bpf_get_reg32(state, dst_lo, tmp2[1]);
    4668:	4681      	mov	r9, r0
    switch (BPF_SRC(code)) {
    466a:	d01c      	beq.n	46a6 <build_body+0x306>
    466c:	f998 1001 	ldrsb.w	r1, [r8, #1]
    4670:	b303      	cbz	r3, 46b4 <build_body+0x314>
        rt = arm_bpf_get_reg32(state, src_lo, tmp2[0]);
    4672:	2209      	movs	r2, #9
    4674:	4620      	mov	r0, r4
    4676:	f00c feb8 	bl	113ea <arm_bpf_get_reg32>
    if (BPF_OP(code) == EBPF_ALU_DIV) {
    467a:	ea4f 4109 	mov.w	r1, r9, lsl #16
    467e:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
    4682:	ea41 2509 	orr.w	r5, r1, r9, lsl #8
    4686:	2e30      	cmp	r6, #48	; 0x30
    4688:	ea45 0500 	orr.w	r5, r5, r0
    468c:	d114      	bne.n	46b8 <build_body+0x318>
        emit4(state, inst);
    468e:	49c4      	ldr	r1, [pc, #784]	; (49a0 <build_body+0x600>)
        emit4(state, inst);
    4690:	4329      	orrs	r1, r5
    4692:	4620      	mov	r0, r4
    4694:	f00c fe9f 	bl	113d6 <emit4>
    arm_bpf_put_reg32(state, dst_lo, rd_lo);
    4698:	f997 1001 	ldrsb.w	r1, [r7, #1]
    469c:	464a      	mov	r2, r9
    469e:	4620      	mov	r0, r4
    46a0:	f00c ff35 	bl	1150e <arm_bpf_put_reg32>
        if (ret > 0) { // load value, skip
    46a4:	e7a3      	b.n	45ee <build_body+0x24e>
        emit_mov_imm(state, rt, imm);
    46a6:	4620      	mov	r0, r4
    46a8:	b2aa      	uxth	r2, r5
    46aa:	2109      	movs	r1, #9
    46ac:	f00c ff6c 	bl	11588 <emit_mov_imm>
        rt = tmp2[0];
    46b0:	2009      	movs	r0, #9
    46b2:	e7e2      	b.n	467a <build_body+0x2da>
        rt = src_lo;
    46b4:	4608      	mov	r0, r1
        break;
    46b6:	e7e0      	b.n	467a <build_body+0x2da>
        u32 inst = (0xfbb0f0f0) | (rd_lo << 16) | (ARM_IP << 8) | (rt);
    46b8:	4308      	orrs	r0, r1
        emit4(state, inst);
    46ba:	49ba      	ldr	r1, [pc, #744]	; (49a4 <build_body+0x604>)
    46bc:	4301      	orrs	r1, r0
    46be:	4620      	mov	r0, r4
    46c0:	f00c fe89 	bl	113d6 <emit4>
        emit4(state, inst);
    46c4:	49b8      	ldr	r1, [pc, #736]	; (49a8 <build_body+0x608>)
    46c6:	e7e3      	b.n	4690 <build_body+0x2f0>
        if (imm > 31) {
    46c8:	2d1f      	cmp	r5, #31
    46ca:	dd15      	ble.n	46f8 <build_body+0x358>
            state->err_line = __LINE__;
    46cc:	f240 53ac 	movw	r3, #1452	; 0x5ac
    46d0:	61a3      	str	r3, [r4, #24]
        return -1;
    46d2:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
        if (!state->needGen) { // offset = end
    46d6:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    46da:	b91b      	cbnz	r3, 46e4 <build_body+0x344>
            state->offsets[i] = state->idx;
    46dc:	69e3      	ldr	r3, [r4, #28]
    46de:	6922      	ldr	r2, [r4, #16]
    46e0:	f843 202b 	str.w	r2, [r3, fp, lsl #2]
        if (ret < 0) {
    46e4:	1c6b      	adds	r3, r5, #1
    46e6:	f040 81e4 	bne.w	4ab2 <build_body+0x712>
            DEBUG_LOG("ERROR: %d\n", ret);
    46ea:	48b0      	ldr	r0, [pc, #704]	; (49ac <build_body+0x60c>)
    46ec:	4629      	mov	r1, r5
}
    46ee:	b009      	add	sp, #36	; 0x24
    46f0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            DEBUG_LOG("ERROR: %d\n", ret);
    46f4:	f00b bc2b 	b.w	ff4e <debug_log>
        if (imm) {
    46f8:	2d00      	cmp	r5, #0
    46fa:	d0ec      	beq.n	46d6 <build_body+0x336>
            emit_alu32_imm(state, dst_lo, imm, BPF_OP(code));
    46fc:	f006 03f0 	and.w	r3, r6, #240	; 0xf0
    4700:	b2aa      	uxth	r2, r5
        emit_alu32_imm(state, dst_lo, 0, BPF_OP(code));
    4702:	f997 1001 	ldrsb.w	r1, [r7, #1]
    4706:	4620      	mov	r0, r4
    4708:	f00c ff92 	bl	11630 <emit_alu32_imm>
        if (ret > 0) { // load value, skip
    470c:	e76f      	b.n	45ee <build_body+0x24e>
        _emit_lsh64_reg(state, dst, src);
    470e:	4642      	mov	r2, r8
    4710:	4639      	mov	r1, r7
    4712:	4620      	mov	r0, r4
    4714:	f7ff fcb4 	bl	4080 <_emit_lsh64_reg>
        if (ret > 0) { // load value, skip
    4718:	e769      	b.n	45ee <build_body+0x24e>
        _emit_lsh64_imm(state, dst, imm);
    471a:	b2aa      	uxth	r2, r5
    471c:	4639      	mov	r1, r7
    471e:	4620      	mov	r0, r4
    4720:	f7ff fd0e 	bl	4140 <_emit_lsh64_imm>
        if (ret > 0) { // load value, skip
    4724:	e763      	b.n	45ee <build_body+0x24e>
    rt = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    4726:	f998 1001 	ldrsb.w	r1, [r8, #1]
    472a:	2208      	movs	r2, #8
    472c:	4620      	mov	r0, r4
    472e:	f00c fe5c 	bl	113ea <arm_bpf_get_reg32>
    rd = arm_bpf_get_reg64(state, dst, tmp);
    4732:	4a9f      	ldr	r2, [pc, #636]	; (49b0 <build_body+0x610>)
    rt = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    4734:	4606      	mov	r6, r0
    rd = arm_bpf_get_reg64(state, dst, tmp);
    4736:	4639      	mov	r1, r7
    4738:	4620      	mov	r0, r4
    473a:	f00c fec1 	bl	114c0 <arm_bpf_get_reg64>
    emit4(state, _thumb32_RSBW_IMM_T2(ARM_IP, rt, 32, FLAG_S));
    473e:	499d      	ldr	r1, [pc, #628]	; (49b4 <build_body+0x614>)
    return (THUMB2_RSBW_IMM) | (i << 26) | (flagS << 20) | (Rn << 16) | (imm3 << 12) | (Rd << 8) | (imm8);
    4740:	ea4f 4806 	mov.w	r8, r6, lsl #16
    rd = arm_bpf_get_reg64(state, dst, tmp);
    4744:	4605      	mov	r5, r0
    emit4(state, _thumb32_RSBW_IMM_T2(ARM_IP, rt, 32, FLAG_S));
    4746:	ea48 0101 	orr.w	r1, r8, r1
    474a:	4620      	mov	r0, r4
    474c:	f00c fe43 	bl	113d6 <emit4>
    emit4(state, _thumb32_SUBW_IMM_T4(tmp2[0], rt, 32, FLAG_S));
    4750:	4999      	ldr	r1, [pc, #612]	; (49b8 <build_body+0x618>)
    4752:	ea48 0101 	orr.w	r1, r8, r1
    4756:	f00c fe3e 	bl	113d6 <emit4>
    return (THUMB2_LSRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    475a:	f995 2001 	ldrsb.w	r2, [r5, #1]
    emit4(state, _thumb32_LSRW_REG_T2(ARM_LR, rd[1], rt, FLAG_S));
    475e:	4997      	ldr	r1, [pc, #604]	; (49bc <build_body+0x61c>)
    u32 inst = (THUMB2_ORRW_REG) | (flagS << 20) | (Rn << 16) | (imm3 << 12)
    4760:	f8df 827c 	ldr.w	r8, [pc, #636]	; 49e0 <build_body+0x640>
    return (THUMB2_LSRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    4764:	ea46 4202 	orr.w	r2, r6, r2, lsl #16
    4768:	4311      	orrs	r1, r2
    476a:	f00c fe34 	bl	113d6 <emit4>
    return (THUMB2_LSLW_REG_T2) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    476e:	f995 1000 	ldrsb.w	r1, [r5]
    4772:	020a      	lsls	r2, r1, #8
    4774:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    emit4(state, _thumb32_LSLW_REG_T2(rd[0], rd[0], ARM_IP, FLAG_S));
    4778:	4991      	ldr	r1, [pc, #580]	; (49c0 <build_body+0x620>)
    477a:	4311      	orrs	r1, r2
    477c:	f00c fe2b 	bl	113d6 <emit4>
             | (Rd << 8) | (imm2 << 6) | (srtype << 4) | (Rm); 
    4780:	f995 1000 	ldrsb.w	r1, [r5]
    emit4(state, _thumb32_ORRW_REG_T2(ARM_LR, ARM_LR, rd[0], 0, SRTYPE_LSL, FLAG_S));
    4784:	ea41 0108 	orr.w	r1, r1, r8
    4788:	f00c fe25 	bl	113d6 <emit4>
    return (THUMB2_LSRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    478c:	f995 1000 	ldrsb.w	r1, [r5]
    4790:	020a      	lsls	r2, r1, #8
    4792:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    emit4(state, _thumb32_LSRW_REG_T2(rd[0], rd[0], tmp2[0], FLAG_S));
    4796:	498b      	ldr	r1, [pc, #556]	; (49c4 <build_body+0x624>)
    4798:	4311      	orrs	r1, r2
    479a:	f00c fe1c 	bl	113d6 <emit4>
             | (Rd << 8) | (imm2 << 6) | (srtype << 4) | (Rm); 
    479e:	f995 1000 	ldrsb.w	r1, [r5]
    emit4(state, _thumb32_ORRW_REG_T2(ARM_LR, ARM_LR, rd[0], 0, SRTYPE_LSL, FLAG_S));
    47a2:	ea41 0108 	orr.w	r1, r1, r8
    47a6:	f00c fe16 	bl	113d6 <emit4>
    return (THUMB2_LSRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    47aa:	f995 2000 	ldrsb.w	r2, [r5]
    emit4(state, _thumb32_LSRW_REG_T2(ARM_IP, rd[0], rt, FLAG_S));
    47ae:	4986      	ldr	r1, [pc, #536]	; (49c8 <build_body+0x628>)
    47b0:	ea46 4602 	orr.w	r6, r6, r2, lsl #16
    emit4(state, _thumb32_ASRW_REG_T2(ARM_IP, rd[0], rt, FLAG_S));
    47b4:	4331      	orrs	r1, r6
    47b6:	4620      	mov	r0, r4
    47b8:	f00c fe0d 	bl	113d6 <emit4>
    arm_bpf_put_reg32(state, dst_lo, ARM_LR);
    47bc:	220e      	movs	r2, #14
    47be:	f997 1001 	ldrsb.w	r1, [r7, #1]
    47c2:	f00c fea4 	bl	1150e <arm_bpf_put_reg32>
    arm_bpf_put_reg32(state, dst_hi, ARM_IP);
    47c6:	9b04      	ldr	r3, [sp, #16]
    47c8:	4619      	mov	r1, r3
    47ca:	4b80      	ldr	r3, [pc, #512]	; (49cc <build_body+0x62c>)
    47cc:	220c      	movs	r2, #12
    47ce:	f913 1011 	ldrsb.w	r1, [r3, r1, lsl #1]
    47d2:	e764      	b.n	469e <build_body+0x2fe>
    rd = arm_bpf_get_reg64(state, dst, tmp);
    47d4:	4a76      	ldr	r2, [pc, #472]	; (49b0 <build_body+0x610>)
    47d6:	4639      	mov	r1, r7
    47d8:	4620      	mov	r0, r4
    47da:	f00c fe71 	bl	114c0 <arm_bpf_get_reg64>
        emit_a32_rsh_i64(state, dst, imm);
    47de:	fa1f f885 	uxth.w	r8, r5
    rd = arm_bpf_get_reg64(state, dst, tmp);
    47e2:	4606      	mov	r6, r0
    if (val == 0) {
    47e4:	f1b8 0f00 	cmp.w	r8, #0
    47e8:	d044      	beq.n	4874 <build_body+0x4d4>
    } else if (val < 32) {
    47ea:	f1b8 0f1f 	cmp.w	r8, #31
    47ee:	f990 0001 	ldrsb.w	r0, [r0, #1]
    47f2:	d831      	bhi.n	4858 <build_body+0x4b8>
        emit4(state, _thumb32_LSRW_IMM_T2(tmp2[1], rd[1], val, FLAG_NOS));
    47f4:	2300      	movs	r3, #0
    47f6:	4642      	mov	r2, r8
    47f8:	4601      	mov	r1, r0
    47fa:	2008      	movs	r0, #8
    47fc:	f7ff f8e0 	bl	39c0 <_thumb32_LSRW_IMM_T2>
    4800:	4601      	mov	r1, r0
    4802:	4620      	mov	r0, r4
    4804:	f00c fde7 	bl	113d6 <emit4>
        emit4(state, _thumb32_ORRW_REG_T2(rd[1], tmp2[1], rd[0], 32 - val, SRTYPE_LSL, FLAG_NOS));
    4808:	f1c8 0320 	rsb	r3, r8, #32
    if (shiftImm5 < 0 || shiftImm5 > 0b11111) {
    480c:	2b1f      	cmp	r3, #31
    480e:	4645      	mov	r5, r8
    4810:	f996 0001 	ldrsb.w	r0, [r6, #1]
    4814:	f996 2000 	ldrsb.w	r2, [r6]
    4818:	d81b      	bhi.n	4852 <build_body+0x4b2>
    u32 imm3 = (shiftImm5 >> 2) & 0b111;
    481a:	ea4f 0ca3 	mov.w	ip, r3, asr #2
             | (Rd << 8) | (imm2 << 6) | (srtype << 4) | (Rm); 
    481e:	019b      	lsls	r3, r3, #6
    4820:	b2d9      	uxtb	r1, r3
    u32 inst = (THUMB2_ORRW_REG) | (flagS << 20) | (Rn << 16) | (imm3 << 12)
    4822:	ea41 310c 	orr.w	r1, r1, ip, lsl #12
    4826:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    482a:	4311      	orrs	r1, r2
    482c:	f041 416a 	orr.w	r1, r1, #3925868544	; 0xea000000
    4830:	f441 0190 	orr.w	r1, r1, #4718592	; 0x480000
    4834:	4620      	mov	r0, r4
    4836:	f00c fdce 	bl	113d6 <emit4>
        emit4(state, _thumb32_LSRW_IMM_T2(rd[0], rd[0], val, FLAG_NOS));
    483a:	f996 1000 	ldrsb.w	r1, [r6]
    483e:	2300      	movs	r3, #0
    4840:	4608      	mov	r0, r1
    4842:	462a      	mov	r2, r5
    4844:	f7ff f8bc 	bl	39c0 <_thumb32_LSRW_IMM_T2>
    4848:	4601      	mov	r1, r0
        emit4(state, _thumb32_ASRW_IMM_T2(rd[0], rd[0], 31, FLAG_S));
    484a:	4620      	mov	r0, r4
    484c:	f00c fdc3 	bl	113d6 <emit4>
    4850:	e010      	b.n	4874 <build_body+0x4d4>
        return -1;
    4852:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4856:	e7ed      	b.n	4834 <build_body+0x494>
    } else if (val == 32) {
    4858:	f1b8 0f20 	cmp.w	r8, #32
    485c:	f996 1000 	ldrsb.w	r1, [r6]
    4860:	d10e      	bne.n	4880 <build_body+0x4e0>
        _emit_mov_reg(state, rd[0], rd[1]);
    4862:	4602      	mov	r2, r0
    4864:	4620      	mov	r0, r4
    4866:	f00c fe37 	bl	114d8 <_emit_mov_reg>
        emit_mov_imm(state, rd[0], 0);
    486a:	2200      	movs	r2, #0
    486c:	7831      	ldrb	r1, [r6, #0]
    486e:	4620      	mov	r0, r4
    4870:	f00c fe8a 	bl	11588 <emit_mov_imm>
    arm_bpf_put_reg64(state, dst, rd);
    4874:	4632      	mov	r2, r6
    arm_bpf_put_reg64(state, dst, rd);
    4876:	4639      	mov	r1, r7
    4878:	4620      	mov	r0, r4
    487a:	f00c fe66 	bl	1154a <arm_bpf_put_reg64>
        if (ret > 0) { // load value, skip
    487e:	e6b6      	b.n	45ee <build_body+0x24e>
        emit4(state, _thumb32_LSRW_IMM_T2(rd[1], rd[0], val - 32, FLAG_NOS));
    4880:	b2aa      	uxth	r2, r5
    4882:	2300      	movs	r3, #0
    4884:	3a20      	subs	r2, #32
    4886:	f7ff f89b 	bl	39c0 <_thumb32_LSRW_IMM_T2>
    488a:	4601      	mov	r1, r0
    488c:	4620      	mov	r0, r4
    488e:	f00c fda2 	bl	113d6 <emit4>
    4892:	e7ea      	b.n	486a <build_body+0x4ca>
    rt = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    4894:	f998 1001 	ldrsb.w	r1, [r8, #1]
    4898:	2208      	movs	r2, #8
    489a:	4620      	mov	r0, r4
    489c:	f00c fda5 	bl	113ea <arm_bpf_get_reg32>
    rd = arm_bpf_get_reg64(state, dst, tmp);
    48a0:	4a43      	ldr	r2, [pc, #268]	; (49b0 <build_body+0x610>)
    rt = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    48a2:	4606      	mov	r6, r0
    rd = arm_bpf_get_reg64(state, dst, tmp);
    48a4:	4639      	mov	r1, r7
    48a6:	4620      	mov	r0, r4
    48a8:	f00c fe0a 	bl	114c0 <arm_bpf_get_reg64>
    emit4(state, _thumb32_RSBW_IMM_T2(ARM_IP, rt, 32, FLAG_S));
    48ac:	4941      	ldr	r1, [pc, #260]	; (49b4 <build_body+0x614>)
    return (THUMB2_RSBW_IMM) | (i << 26) | (flagS << 20) | (Rn << 16) | (imm3 << 12) | (Rd << 8) | (imm8);
    48ae:	ea4f 4806 	mov.w	r8, r6, lsl #16
    rd = arm_bpf_get_reg64(state, dst, tmp);
    48b2:	4605      	mov	r5, r0
    emit4(state, _thumb32_RSBW_IMM_T2(ARM_IP, rt, 32, FLAG_S));
    48b4:	ea48 0101 	orr.w	r1, r8, r1
    48b8:	4620      	mov	r0, r4
    48ba:	f00c fd8c 	bl	113d6 <emit4>
    emit4(state, _thumb32_SUBW_IMM_T4(tmp2[0], rt, 32, FLAG_S));
    48be:	493e      	ldr	r1, [pc, #248]	; (49b8 <build_body+0x618>)
    48c0:	ea48 0101 	orr.w	r1, r8, r1
    48c4:	f00c fd87 	bl	113d6 <emit4>
    return (THUMB2_LSRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    48c8:	f995 2001 	ldrsb.w	r2, [r5, #1]
    emit4(state, _thumb32_LSRW_REG_T2(ARM_LR, rd[1], rt, FLAG_S));
    48cc:	493b      	ldr	r1, [pc, #236]	; (49bc <build_body+0x61c>)
    u32 inst = (THUMB2_ORRW_REG) | (flagS << 20) | (Rn << 16) | (imm3 << 12)
    48ce:	f8df 8110 	ldr.w	r8, [pc, #272]	; 49e0 <build_body+0x640>
    return (THUMB2_LSRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    48d2:	ea46 4202 	orr.w	r2, r6, r2, lsl #16
    48d6:	4311      	orrs	r1, r2
    48d8:	f00c fd7d 	bl	113d6 <emit4>
    return (THUMB2_LSLW_REG_T2) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    48dc:	f995 1000 	ldrsb.w	r1, [r5]
    48e0:	020a      	lsls	r2, r1, #8
    48e2:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    emit4(state, _thumb32_LSLW_REG_T2(rd[0], rd[0], tmp2[0], FLAG_NOS));
    48e6:	493a      	ldr	r1, [pc, #232]	; (49d0 <build_body+0x630>)
    48e8:	4311      	orrs	r1, r2
    48ea:	f00c fd74 	bl	113d6 <emit4>
             | (Rd << 8) | (imm2 << 6) | (srtype << 4) | (Rm); 
    48ee:	f995 1000 	ldrsb.w	r1, [r5]
    emit4(state, _thumb32_ORRW_REG_T2(ARM_LR, ARM_LR, rd[0], 0, SRTYPE_LSL, FLAG_S));
    48f2:	ea41 0108 	orr.w	r1, r1, r8
    48f6:	f00c fd6e 	bl	113d6 <emit4>
    return (THUMB2_ASRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    48fa:	f995 1000 	ldrsb.w	r1, [r5]
    48fe:	020a      	lsls	r2, r1, #8
    4900:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    emit4(state, _thumb32_ASRW_REG_T2(rd[0], rd[0], tmp2[0], FLAG_NOS));
    4904:	4933      	ldr	r1, [pc, #204]	; (49d4 <build_body+0x634>)
    4906:	4311      	orrs	r1, r2
    4908:	f00c fd65 	bl	113d6 <emit4>
    emit2(state, _thumb16_IT_T1(COND_PL, IT_MASK_NONE));
    490c:	f64b 7158 	movw	r1, #48984	; 0xbf58
    4910:	f00c fd57 	bl	113c2 <emit2>
             | (Rd << 8) | (imm2 << 6) | (srtype << 4) | (Rm); 
    4914:	f995 1000 	ldrsb.w	r1, [r5]
    emit4(state, _thumb32_ORRW_REG_T2(ARM_LR, ARM_LR, rd[0], 0, SRTYPE_LSL, FLAG_S));
    4918:	ea41 0108 	orr.w	r1, r1, r8
    491c:	f00c fd5b 	bl	113d6 <emit4>
    return (THUMB2_ASRW_REG) | (flagS << 20) | (Rn << 16) | (Rd << 8) | (Rm);
    4920:	f995 2000 	ldrsb.w	r2, [r5]
    emit4(state, _thumb32_ASRW_REG_T2(ARM_IP, rd[0], rt, FLAG_S));
    4924:	492c      	ldr	r1, [pc, #176]	; (49d8 <build_body+0x638>)
    4926:	ea46 4602 	orr.w	r6, r6, r2, lsl #16
    492a:	e743      	b.n	47b4 <build_body+0x414>
    rd = arm_bpf_get_reg64(state, dst, tmp);
    492c:	4a20      	ldr	r2, [pc, #128]	; (49b0 <build_body+0x610>)
    492e:	4639      	mov	r1, r7
    4930:	4620      	mov	r0, r4
    4932:	f00c fdc5 	bl	114c0 <arm_bpf_get_reg64>
    4936:	4606      	mov	r6, r0
    if (val == 0) {
    4938:	2d00      	cmp	r5, #0
    493a:	d09b      	beq.n	4874 <build_body+0x4d4>
    } else if (val < 32) {
    493c:	2d1f      	cmp	r5, #31
    493e:	f990 c001 	ldrsb.w	ip, [r0, #1]
    4942:	d84f      	bhi.n	49e4 <build_body+0x644>
        emit4(state, _thumb32_LSRW_IMM_T2(tmp2[1], rd[1], val, FLAG_S));
    4944:	4661      	mov	r1, ip
    4946:	2301      	movs	r3, #1
    4948:	462a      	mov	r2, r5
    494a:	2008      	movs	r0, #8
    494c:	f7ff f838 	bl	39c0 <_thumb32_LSRW_IMM_T2>
    4950:	4601      	mov	r1, r0
    4952:	4620      	mov	r0, r4
    4954:	f00c fd3f 	bl	113d6 <emit4>
        emit4(state, _thumb32_ORRW_REG_T2(rd[1], tmp2[1], rd[0], 32 - val, SRTYPE_LSL, FLAG_S));
    4958:	f1c5 0320 	rsb	r3, r5, #32
             | (Rd << 8) | (imm2 << 6) | (srtype << 4) | (Rm); 
    495c:	f996 2001 	ldrsb.w	r2, [r6, #1]
    4960:	0199      	lsls	r1, r3, #6
    4962:	b2c9      	uxtb	r1, r1
    u32 inst = (THUMB2_ORRW_REG) | (flagS << 20) | (Rn << 16) | (imm3 << 12)
    4964:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
    u32 imm3 = (shiftImm5 >> 2) & 0b111;
    4968:	109b      	asrs	r3, r3, #2
    u32 inst = (THUMB2_ORRW_REG) | (flagS << 20) | (Rn << 16) | (imm3 << 12)
    496a:	ea41 3103 	orr.w	r1, r1, r3, lsl #12
             | (Rd << 8) | (imm2 << 6) | (srtype << 4) | (Rm); 
    496e:	f996 3000 	ldrsb.w	r3, [r6]
    u32 inst = (THUMB2_ORRW_REG) | (flagS << 20) | (Rn << 16) | (imm3 << 12)
    4972:	4319      	orrs	r1, r3
    4974:	f041 416a 	orr.w	r1, r1, #3925868544	; 0xea000000
    4978:	f441 01b0 	orr.w	r1, r1, #5767168	; 0x580000
    497c:	f00c fd2b 	bl	113d6 <emit4>
    return (THUMB2_ASRW_IMM) | (flagS << 20) | (imm3 << 12) | (Rd << 8) | (imm2 << 6) | (Rm);
    4980:	01ab      	lsls	r3, r5, #6
        emit4(state, _thumb32_ASRW_IMM_T2(rd[0], rd[0], val, FLAG_S));
    4982:	f996 2000 	ldrsb.w	r2, [r6]
    u32 imm3 = (imm5 >> 2) & 0b111;
    4986:	10a9      	asrs	r1, r5, #2
    return (THUMB2_ASRW_IMM) | (flagS << 20) | (imm3 << 12) | (Rd << 8) | (imm2 << 6) | (Rm);
    4988:	b2db      	uxtb	r3, r3
    498a:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
    498e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    4992:	4912      	ldr	r1, [pc, #72]	; (49dc <build_body+0x63c>)
    4994:	4313      	orrs	r3, r2
    4996:	4319      	orrs	r1, r3
    4998:	e757      	b.n	484a <build_body+0x4aa>
    499a:	bf00      	nop
    499c:	0001720a 	.word	0x0001720a
    49a0:	fbb0f0f0 	.word	0xfbb0f0f0
    49a4:	fbb0fcf0 	.word	0xfbb0fcf0
    49a8:	fb00c010 	.word	0xfb00c010
    49ac:	0001723b 	.word	0x0001723b
    49b0:	00017208 	.word	0x00017208
    49b4:	f1d00c20 	.word	0xf1d00c20
    49b8:	f2a00920 	.word	0xf2a00920
    49bc:	fa30fe00 	.word	0xfa30fe00
    49c0:	fa10f00c 	.word	0xfa10f00c
    49c4:	fa30f009 	.word	0xfa30f009
    49c8:	fa30fc00 	.word	0xfa30fc00
    49cc:	000171f0 	.word	0x000171f0
    49d0:	fa00f009 	.word	0xfa00f009
    49d4:	fa40f009 	.word	0xfa40f009
    49d8:	fa50fc00 	.word	0xfa50fc00
    49dc:	ea5f0020 	.word	0xea5f0020
    49e0:	ea5e0e00 	.word	0xea5e0e00
    } else if (val == 32) {
    49e4:	2d20      	cmp	r5, #32
    49e6:	f990 1000 	ldrsb.w	r1, [r0]
    49ea:	f8df 8358 	ldr.w	r8, [pc, #856]	; 4d44 <build_body+0x9a4>
    49ee:	d10a      	bne.n	4a06 <build_body+0x666>
        _emit_mov_reg(state, rd[0], rd[1]);
    49f0:	4662      	mov	r2, ip
    49f2:	4620      	mov	r0, r4
    49f4:	f00c fd70 	bl	114d8 <_emit_mov_reg>
        emit4(state, _thumb32_ASRW_IMM_T2(rd[0], rd[0], 31, FLAG_S));
    49f8:	f996 1000 	ldrsb.w	r1, [r6]
    49fc:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    4a00:	ea41 0108 	orr.w	r1, r1, r8
    4a04:	e721      	b.n	484a <build_body+0x4aa>
        emit4(state, _thumb32_ASRW_IMM_T2(rd[1], rd[0], val - 32, FLAG_S));
    4a06:	3d20      	subs	r5, #32
    4a08:	01a8      	lsls	r0, r5, #6
    4a0a:	b2c0      	uxtb	r0, r0
    4a0c:	02ad      	lsls	r5, r5, #10
    4a0e:	ea40 230c 	orr.w	r3, r0, ip, lsl #8
    4a12:	f405 45e0 	and.w	r5, r5, #28672	; 0x7000
    4a16:	432b      	orrs	r3, r5
    4a18:	430b      	orrs	r3, r1
    4a1a:	49be      	ldr	r1, [pc, #760]	; (4d14 <build_body+0x974>)
    4a1c:	4620      	mov	r0, r4
    4a1e:	4319      	orrs	r1, r3
    4a20:	f00c fcd9 	bl	113d6 <emit4>
    4a24:	e7e8      	b.n	49f8 <build_body+0x658>
        emit_alu32_imm(state, dst_lo, 0, BPF_OP(code));
    4a26:	2380      	movs	r3, #128	; 0x80
    4a28:	2200      	movs	r2, #0
    4a2a:	e66a      	b.n	4702 <build_body+0x362>
    rd = arm_bpf_get_reg64(state, dst, tmp);
    4a2c:	4aba      	ldr	r2, [pc, #744]	; (4d18 <build_body+0x978>)
    return (THUMB2_RSBW_IMM) | (i << 26) | (flagS << 20) | (Rn << 16) | (imm3 << 12) | (Rd << 8) | (imm8);
    4a2e:	4ebb      	ldr	r6, [pc, #748]	; (4d1c <build_body+0x97c>)
    4a30:	4639      	mov	r1, r7
    4a32:	4620      	mov	r0, r4
    4a34:	f00c fd44 	bl	114c0 <arm_bpf_get_reg64>
    4a38:	f990 3001 	ldrsb.w	r3, [r0, #1]
    4a3c:	0219      	lsls	r1, r3, #8
    4a3e:	4605      	mov	r5, r0
    4a40:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    emit4(state, _thumb32_RSBW_IMM_T2(rd[1], rd[1], 0, FLAG_S));
    4a44:	4331      	orrs	r1, r6
    4a46:	4620      	mov	r0, r4
    4a48:	f00c fcc5 	bl	113d6 <emit4>
    4a4c:	f995 3000 	ldrsb.w	r3, [r5]
    4a50:	0219      	lsls	r1, r3, #8
    4a52:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    emit4(state, _thumb32_RSBW_IMM_T2(rd[0], rd[0], 0, FLAG_S));
    4a56:	4331      	orrs	r1, r6
    4a58:	f00c fcbd 	bl	113d6 <emit4>
    arm_bpf_put_reg64(state, dst, rd);
    4a5c:	462a      	mov	r2, r5
    4a5e:	e70a      	b.n	4876 <build_body+0x4d6>
        switch (BPF_SRC(code)) {
    4a60:	f016 0608 	ands.w	r6, r6, #8
    4a64:	d004      	beq.n	4a70 <build_body+0x6d0>
    4a66:	2e00      	cmp	r6, #0
    4a68:	f43f adc1 	beq.w	45ee <build_body+0x24e>
            emit_a32_mul_r64(state, dst, src);
    4a6c:	4642      	mov	r2, r8
    4a6e:	e006      	b.n	4a7e <build_body+0x6de>
            emit_mov_se_imm64(state, is64, tmp2, imm);
    4a70:	4aab      	ldr	r2, [pc, #684]	; (4d20 <build_body+0x980>)
    4a72:	9903      	ldr	r1, [sp, #12]
    4a74:	462b      	mov	r3, r5
    4a76:	4620      	mov	r0, r4
    4a78:	f00c fdce 	bl	11618 <emit_mov_se_imm64>
            emit_a32_mul_r64(state, dst, tmp2);
    4a7c:	4aa8      	ldr	r2, [pc, #672]	; (4d20 <build_body+0x980>)
            emit_a32_mul_r64(state, dst, src);
    4a7e:	4639      	mov	r1, r7
    4a80:	4620      	mov	r0, r4
    4a82:	f7ff f81b 	bl	3abc <emit_a32_mul_r64>
        if (ret > 0) { // load value, skip
    4a86:	e5b2      	b.n	45ee <build_body+0x24e>
        DEBUG_LOG("TODO op: %x pc: %d\n", code, pc);
    4a88:	4652      	mov	r2, sl
    4a8a:	4631      	mov	r1, r6
    4a8c:	48a5      	ldr	r0, [pc, #660]	; (4d24 <build_body+0x984>)
    4a8e:	f00b fa5e 	bl	ff4e <debug_log>
    4a92:	e61e      	b.n	46d2 <build_body+0x332>
        emit_mov_i64(state, dst, val);
    4a94:	68c3      	ldr	r3, [r0, #12]
    4a96:	462a      	mov	r2, r5
    4a98:	4639      	mov	r1, r7
    4a9a:	4620      	mov	r0, r4
    4a9c:	f7fe fff2 	bl	3a84 <emit_mov_i64>
            if (!state->needGen) {
    4aa0:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
            i++;
    4aa4:	f10b 0b01 	add.w	fp, fp, #1
            if (!state->needGen) {
    4aa8:	b91b      	cbnz	r3, 4ab2 <build_body+0x712>
                state->offsets[i] = state->idx;
    4aaa:	69e3      	ldr	r3, [r4, #28]
    4aac:	6922      	ldr	r2, [r4, #16]
    4aae:	f843 202b 	str.w	r2, [r3, fp, lsl #2]
    for (int i = 0; i < inst_num; i++) {
    4ab2:	f10b 0b01 	add.w	fp, fp, #1
    4ab6:	e47d      	b.n	43b4 <build_body+0x14>
        rn = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    4ab8:	f998 1001 	ldrsb.w	r1, [r8, #1]
    4abc:	2208      	movs	r2, #8
    4abe:	4620      	mov	r0, r4
    4ac0:	f00c fc93 	bl	113ea <arm_bpf_get_reg32>
        emit_ldx_reg(state, dst, rn, off, BPF_SIZE(code));
    4ac4:	f006 0618 	and.w	r6, r6, #24
    4ac8:	4602      	mov	r2, r0
    4aca:	9600      	str	r6, [sp, #0]
    4acc:	464b      	mov	r3, r9
    4ace:	4639      	mov	r1, r7
    4ad0:	4620      	mov	r0, r4
    4ad2:	f7ff fb93 	bl	41fc <emit_ldx_reg>
        if (ret > 0) { // load value, skip
    4ad6:	e58a      	b.n	45ee <build_body+0x24e>
        switch (BPF_SIZE(code))
    4ad8:	f006 0618 	and.w	r6, r6, #24
    4adc:	2e08      	cmp	r6, #8
    4ade:	d001      	beq.n	4ae4 <build_body+0x744>
    4ae0:	d806      	bhi.n	4af0 <build_body+0x750>
    4ae2:	b976      	cbnz	r6, 4b02 <build_body+0x762>
            emit_mov_imm(state, tmp2[1], imm);
    4ae4:	462a      	mov	r2, r5
    4ae6:	2108      	movs	r1, #8
    4ae8:	4620      	mov	r0, r4
    4aea:	f00c fd4d 	bl	11588 <emit_mov_imm>
            break;
    4aee:	e008      	b.n	4b02 <build_body+0x762>
    4af0:	2e10      	cmp	r6, #16
    4af2:	d0f7      	beq.n	4ae4 <build_body+0x744>
    4af4:	2e18      	cmp	r6, #24
    4af6:	d104      	bne.n	4b02 <build_body+0x762>
    if (is64) {
    4af8:	462a      	mov	r2, r5
    4afa:	4989      	ldr	r1, [pc, #548]	; (4d20 <build_body+0x980>)
    4afc:	4620      	mov	r0, r4
    4afe:	f00c fd84 	bl	1160a <emit_mov_se_imm64.part.9>
        emit_str_reg(state, dst_lo, tmp2, off, BPF_SIZE(code));
    4b02:	4a87      	ldr	r2, [pc, #540]	; (4d20 <build_body+0x980>)
    4b04:	9600      	str	r6, [sp, #0]
    4b06:	464b      	mov	r3, r9
        emit_str_reg(state, dst_lo, rs, off, BPF_SIZE(code));
    4b08:	f997 1001 	ldrsb.w	r1, [r7, #1]
    4b0c:	4620      	mov	r0, r4
    4b0e:	f7ff f9f1 	bl	3ef4 <emit_str_reg>
        if (ret > 0) { // load value, skip
    4b12:	e56c      	b.n	45ee <build_body+0x24e>
        rs = arm_bpf_get_reg64(state, src, tmp2);
    4b14:	4a82      	ldr	r2, [pc, #520]	; (4d20 <build_body+0x980>)
    4b16:	4641      	mov	r1, r8
    4b18:	4620      	mov	r0, r4
    4b1a:	f00c fcd1 	bl	114c0 <arm_bpf_get_reg64>
        emit_str_reg(state, dst_lo, rs, off, BPF_SIZE(code));
    4b1e:	f006 0618 	and.w	r6, r6, #24
    4b22:	9600      	str	r6, [sp, #0]
    4b24:	464b      	mov	r3, r9
    4b26:	4602      	mov	r2, r0
    4b28:	e7ee      	b.n	4b08 <build_body+0x768>
        if (BPF_SRC(code) == EBPF_SRC_REG) {
    4b2a:	0732      	lsls	r2, r6, #28
    4b2c:	d531      	bpl.n	4b92 <build_body+0x7f2>
            rm = arm_bpf_get_reg32(state, src_hi, tmp2[0]);
    4b2e:	f913 1011 	ldrsb.w	r1, [r3, r1, lsl #1]
    4b32:	2209      	movs	r2, #9
    4b34:	4620      	mov	r0, r4
    4b36:	f00c fc58 	bl	113ea <arm_bpf_get_reg32>
            rn = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    4b3a:	f998 1001 	ldrsb.w	r1, [r8, #1]
            rm = arm_bpf_get_reg32(state, src_hi, tmp2[0]);
    4b3e:	4605      	mov	r5, r0
            rn = arm_bpf_get_reg32(state, src_lo, tmp2[1]);
    4b40:	2208      	movs	r2, #8
    4b42:	4620      	mov	r0, r4
    4b44:	f00c fc51 	bl	113ea <arm_bpf_get_reg32>
    4b48:	4680      	mov	r8, r0
        rd = arm_bpf_get_reg64(state, dst, tmp);
    4b4a:	4639      	mov	r1, r7
    4b4c:	4a72      	ldr	r2, [pc, #456]	; (4d18 <build_body+0x978>)
    4b4e:	4620      	mov	r0, r4
    4b50:	f00c fcb6 	bl	114c0 <arm_bpf_get_reg64>
        _emit_cmp_cond(state, rd[0], rd[1], rm, rn, BPF_OP(code), BPF_CLASS(code) == EBPF_CLS_JMP);
    4b54:	f026 060f 	bic.w	r6, r6, #15
    4b58:	b2f3      	uxtb	r3, r6
    switch (op)
    4b5a:	2b60      	cmp	r3, #96	; 0x60
        _emit_cmp_cond(state, rd[0], rd[1], rm, rn, BPF_OP(code), BPF_CLASS(code) == EBPF_CLS_JMP);
    4b5c:	f990 7000 	ldrsb.w	r7, [r0]
    4b60:	f990 9001 	ldrsb.w	r9, [r0, #1]
    switch (op)
    4b64:	d06d      	beq.n	4c42 <build_body+0x8a2>
    4b66:	d825      	bhi.n	4bb4 <build_body+0x814>
    4b68:	2b30      	cmp	r3, #48	; 0x30
    4b6a:	d004      	beq.n	4b76 <build_body+0x7d6>
    4b6c:	d81e      	bhi.n	4bac <build_body+0x80c>
    4b6e:	2b10      	cmp	r3, #16
    4b70:	d001      	beq.n	4b76 <build_body+0x7d6>
    4b72:	2b20      	cmp	r3, #32
    4b74:	d129      	bne.n	4bca <build_body+0x82a>
        if (is_jmp64) {
    4b76:	9b02      	ldr	r3, [sp, #8]
    4b78:	2b05      	cmp	r3, #5
    4b7a:	d104      	bne.n	4b86 <build_body+0x7e6>
            _emit_cmp_reg(state, rd, rm);
    4b7c:	462a      	mov	r2, r5
    4b7e:	4639      	mov	r1, r7
    4b80:	4620      	mov	r0, r4
    4b82:	f00c fd91 	bl	116a8 <_emit_cmp_reg>
             _emit_cmp_reg(state, rt, rn);
    4b86:	4642      	mov	r2, r8
    4b88:	4649      	mov	r1, r9
    4b8a:	4620      	mov	r0, r4
    4b8c:	f00c fd8c 	bl	116a8 <_emit_cmp_reg>
    4b90:	e01b      	b.n	4bca <build_body+0x82a>
            if (off == 0)
    4b92:	f1b9 0f00 	cmp.w	r9, #0
    4b96:	f43f ad2a 	beq.w	45ee <build_body+0x24e>
    if (is64) {
    4b9a:	462a      	mov	r2, r5
    4b9c:	4960      	ldr	r1, [pc, #384]	; (4d20 <build_body+0x980>)
    4b9e:	4620      	mov	r0, r4
    4ba0:	f00c fd33 	bl	1160a <emit_mov_se_imm64.part.9>
            rn = tmp2[1];
    4ba4:	f04f 0808 	mov.w	r8, #8
            rm = tmp2[0];
    4ba8:	2509      	movs	r5, #9
    4baa:	e7ce      	b.n	4b4a <build_body+0x7aa>
    switch (op)
    4bac:	2b40      	cmp	r3, #64	; 0x40
    4bae:	d02a      	beq.n	4c06 <build_body+0x866>
    4bb0:	2b50      	cmp	r3, #80	; 0x50
    4bb2:	e7df      	b.n	4b74 <build_body+0x7d4>
    4bb4:	2bb0      	cmp	r3, #176	; 0xb0
    4bb6:	d0de      	beq.n	4b76 <build_body+0x7d6>
    4bb8:	d803      	bhi.n	4bc2 <build_body+0x822>
    4bba:	2b70      	cmp	r3, #112	; 0x70
    4bbc:	d050      	beq.n	4c60 <build_body+0x8c0>
    4bbe:	2ba0      	cmp	r3, #160	; 0xa0
    4bc0:	e7d8      	b.n	4b74 <build_body+0x7d4>
    4bc2:	2bc0      	cmp	r3, #192	; 0xc0
    4bc4:	d04c      	beq.n	4c60 <build_body+0x8c0>
    4bc6:	2bd0      	cmp	r3, #208	; 0xd0
    4bc8:	d03b      	beq.n	4c42 <build_body+0x8a2>
        if (!_use_b4(state)) {
    4bca:	6863      	ldr	r3, [r4, #4]
    if (!state->needGen) {
    4bcc:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
            bsize = 2;
    4bd0:	2b14      	cmp	r3, #20
    4bd2:	bfcc      	ite	gt
    4bd4:	2004      	movgt	r0, #4
    4bd6:	2002      	movle	r0, #2
    if (!state->needGen) {
    4bd8:	b141      	cbz	r1, 4bec <build_body+0x84c>
    to = state->offsets[bpf_to];
    4bda:	69e2      	ldr	r2, [r4, #28]
    return to - from - 4;
    4bdc:	9b06      	ldr	r3, [sp, #24]
    4bde:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    from = state->offsets[bpf_from] - bsize;
    4be2:	f852 302a 	ldr.w	r3, [r2, sl, lsl #2]
    return to - from - 4;
    4be6:	3904      	subs	r1, #4
    from = state->offsets[bpf_from] - bsize;
    4be8:	1a1b      	subs	r3, r3, r0
    return to - from - 4;
    4bea:	1ac9      	subs	r1, r1, r3
        _emit_jump(state, jmp_offset, BPF_OP(code));
    4bec:	b276      	sxtb	r6, r6
    switch (op)
    4bee:	2e40      	cmp	r6, #64	; 0x40
    4bf0:	d048      	beq.n	4c84 <build_body+0x8e4>
    4bf2:	dc40      	bgt.n	4c76 <build_body+0x8d6>
    4bf4:	2e20      	cmp	r6, #32
    4bf6:	d04a      	beq.n	4c8e <build_body+0x8ee>
    4bf8:	2e30      	cmp	r6, #48	; 0x30
    4bfa:	d04a      	beq.n	4c92 <build_body+0x8f2>
    4bfc:	2e10      	cmp	r6, #16
    4bfe:	f47f acf6 	bne.w	45ee <build_body+0x24e>
        _emit_b_cond(state, jmp_off, COND_EQ);
    4c02:	2200      	movs	r2, #0
    4c04:	e03f      	b.n	4c86 <build_body+0x8e6>
        if (is_jmp64) {
    4c06:	9b02      	ldr	r3, [sp, #8]
    4c08:	ea48 4109 	orr.w	r1, r8, r9, lsl #16
    4c0c:	2b05      	cmp	r3, #5
            emit4(state, _thumb32_ADDW_REG_T3(ARM_IP, rt, rn, 0, SRTYPE_LSL, FLAG_NOS));
    4c0e:	f041 416b 	orr.w	r1, r1, #3942645760	; 0xeb000000
        if (is_jmp64) {
    4c12:	d111      	bne.n	4c38 <build_body+0x898>
            emit4(state, _thumb32_ADDW_REG_T3(ARM_IP, rt, rn, 0, SRTYPE_LSL, FLAG_NOS));
    4c14:	f441 6140 	orr.w	r1, r1, #3072	; 0xc00
    4c18:	4620      	mov	r0, r4
    4c1a:	f00c fbdc 	bl	113d6 <emit4>
        (imm2 << 6) | (srtype << 4) | (Rm);
    4c1e:	ea45 4107 	orr.w	r1, r5, r7, lsl #16
            emit4(state, _thumb32_ADDW_REG_T3(ARM_LR, rd, rm, 0, SRTYPE_LSL, FLAG_NOS));
    4c22:	f041 416b 	orr.w	r1, r1, #3942645760	; 0xeb000000
    4c26:	f441 6160 	orr.w	r1, r1, #3584	; 0xe00
    4c2a:	f00c fbd4 	bl	113d6 <emit4>
            emit4(state, _thumb32_ORRW_REG_T2(ARM_IP, ARM_LR, ARM_IP, 0, SRTYPE_LSL, FLAG_S));
    4c2e:	493e      	ldr	r1, [pc, #248]	; (4d28 <build_body+0x988>)
            emit4(state, _thumb32_SBCW_T2(ARM_IP, rd, rm, 0, SRTYPE_LSL, FLAG_S));
    4c30:	4620      	mov	r0, r4
    4c32:	f00c fbd0 	bl	113d6 <emit4>
    4c36:	e7c8      	b.n	4bca <build_body+0x82a>
            emit4(state, _thumb32_ADDW_REG_T3(ARM_IP, rt, rn, 0, SRTYPE_LSL, FLAG_S));
    4c38:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
            emit4(state, _thumb32_SBCW_T2(ARM_IP, rd, rm, 0, SRTYPE_LSL, FLAG_S));
    4c3c:	f441 6140 	orr.w	r1, r1, #3072	; 0xc00
    4c40:	e7f6      	b.n	4c30 <build_body+0x890>
        _emit_cmp_reg(state, rn, rt); // low cmp: rn - rt
    4c42:	464a      	mov	r2, r9
    4c44:	4641      	mov	r1, r8
    4c46:	4620      	mov	r0, r4
    4c48:	f00c fd2e 	bl	116a8 <_emit_cmp_reg>
        if (is_jmp64) { // subtract with carray b - a, rm - rd
    4c4c:	9b02      	ldr	r3, [sp, #8]
    4c4e:	2b05      	cmp	r3, #5
    4c50:	d1bb      	bne.n	4bca <build_body+0x82a>
         (imm2 << 6) | (srtype << 4) | (Rm);
    4c52:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
            emit4(state, _thumb32_SBCW_T2(ARM_IP, rd, rm, 0, SRTYPE_LSL, FLAG_S));
    4c56:	f041 416b 	orr.w	r1, r1, #3942645760	; 0xeb000000
    4c5a:	f441 01e0 	orr.w	r1, r1, #7340032	; 0x700000
    4c5e:	e7ed      	b.n	4c3c <build_body+0x89c>
        _emit_cmp_reg(state, rt, rn);
    4c60:	4642      	mov	r2, r8
    4c62:	4649      	mov	r1, r9
    4c64:	4620      	mov	r0, r4
    4c66:	f00c fd1f 	bl	116a8 <_emit_cmp_reg>
        if (is_jmp64) {
    4c6a:	9b02      	ldr	r3, [sp, #8]
    4c6c:	2b05      	cmp	r3, #5
    4c6e:	d1ac      	bne.n	4bca <build_body+0x82a>
    4c70:	ea45 4107 	orr.w	r1, r5, r7, lsl #16
    4c74:	e7ef      	b.n	4c56 <build_body+0x8b6>
    switch (op)
    4c76:	2e60      	cmp	r6, #96	; 0x60
    4c78:	d00d      	beq.n	4c96 <build_body+0x8f6>
    4c7a:	2e70      	cmp	r6, #112	; 0x70
    4c7c:	d00d      	beq.n	4c9a <build_body+0x8fa>
    4c7e:	2e50      	cmp	r6, #80	; 0x50
    4c80:	f47f acb5 	bne.w	45ee <build_body+0x24e>
        _emit_b_cond(state, jmp_off, COND_NE);
    4c84:	2201      	movs	r2, #1
        _emit_b_cond(state, jmp_off, COND_EQ);
    4c86:	4620      	mov	r0, r4
    4c88:	f7fe ff76 	bl	3b78 <_emit_b_cond>
        if (ret > 0) { // load value, skip
    4c8c:	e4af      	b.n	45ee <build_body+0x24e>
        _emit_b_cond(state, jmp_off, COND_HI);
    4c8e:	2208      	movs	r2, #8
    4c90:	e7f9      	b.n	4c86 <build_body+0x8e6>
        _emit_b_cond(state, jmp_off, COND_CS);
    4c92:	2202      	movs	r2, #2
    4c94:	e7f7      	b.n	4c86 <build_body+0x8e6>
        _emit_b_cond(state, jmp_off, COND_LT);
    4c96:	220b      	movs	r2, #11
    4c98:	e7f5      	b.n	4c86 <build_body+0x8e6>
        _emit_b_cond(state, jmp_off, COND_GE);
    4c9a:	220a      	movs	r2, #10
    4c9c:	e7f3      	b.n	4c86 <build_body+0x8e6>
        if (off == 0)
    4c9e:	f1b9 0f00 	cmp.w	r9, #0
    4ca2:	f43f aca4 	beq.w	45ee <build_body+0x24e>
    if (!state->needGen) {
    4ca6:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
    4caa:	b139      	cbz	r1, 4cbc <build_body+0x91c>
    to = state->offsets[bpf_to];
    4cac:	69e3      	ldr	r3, [r4, #28]
    return to - from - 4;
    4cae:	9a06      	ldr	r2, [sp, #24]
    4cb0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    from = state->offsets[bpf_from] - bsize;
    4cb4:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
    4cb8:	1ac9      	subs	r1, r1, r3
    return to - from - 4;
    4cba:	3902      	subs	r1, #2
        _emit_b(state, jmp_offset);
    4cbc:	4620      	mov	r0, r4
    4cbe:	f7fe ffcb 	bl	3c58 <_emit_b>
        if (ret > 0) { // load value, skip
    4cc2:	e494      	b.n	45ee <build_body+0x24e>
        const u32 func = *(u32 *) (state->__bpf_call_base + imm * 4);
    4cc4:	4a19      	ldr	r2, [pc, #100]	; (4d2c <build_body+0x98c>)
    4cc6:	6a23      	ldr	r3, [r4, #32]
    4cc8:	1e91      	subs	r1, r2, #2
    4cca:	4620      	mov	r0, r4
    4ccc:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
    if (!is64) {
    4cd0:	f7fe feaa 	bl	3a28 <emit_mov_reg64.part.7>
    4cd4:	4a16      	ldr	r2, [pc, #88]	; (4d30 <build_body+0x990>)
    4cd6:	4620      	mov	r0, r4
    4cd8:	1e91      	subs	r1, r2, #2
    4cda:	f7fe fea5 	bl	3a28 <emit_mov_reg64.part.7>
        emit_push_r64(state, r5);
    4cde:	4620      	mov	r0, r4
    4ce0:	4914      	ldr	r1, [pc, #80]	; (4d34 <build_body+0x994>)
    4ce2:	f7fe ff83 	bl	3bec <emit_push_r64>
        emit_push_r64(state, r4);
    4ce6:	4620      	mov	r0, r4
    4ce8:	4913      	ldr	r1, [pc, #76]	; (4d38 <build_body+0x998>)
    4cea:	f7fe ff7f 	bl	3bec <emit_push_r64>
        emit_push_r64(state, r3);
    4cee:	4620      	mov	r0, r4
    4cf0:	4912      	ldr	r1, [pc, #72]	; (4d3c <build_body+0x99c>)
    4cf2:	f7fe ff7b 	bl	3bec <emit_push_r64>
        emit_mov_imm(state, tmp[1], func);
    4cf6:	462a      	mov	r2, r5
    4cf8:	4620      	mov	r0, r4
    4cfa:	2106      	movs	r1, #6
    4cfc:	f00c fc44 	bl	11588 <emit_mov_imm>
        emit2(state, _thumb16_BLX_REG_T1(tmp[1]));
    4d00:	f244 71b0 	movw	r1, #18352	; 0x47b0
    4d04:	4620      	mov	r0, r4
    4d06:	f00c fb5c 	bl	113c2 <emit2>
        emit4(state, _thumb32_ADD_IMM_T4(dst, src, val));
    4d0a:	490d      	ldr	r1, [pc, #52]	; (4d40 <build_body+0x9a0>)
    4d0c:	f00c fb63 	bl	113d6 <emit4>
        if (ret > 0) { // load value, skip
    4d10:	e46d      	b.n	45ee <build_body+0x24e>
    4d12:	bf00      	nop
    4d14:	ea5f0020 	.word	0xea5f0020
    4d18:	00017208 	.word	0x00017208
    4d1c:	f1d00000 	.word	0xf1d00000
    4d20:	0001720a 	.word	0x0001720a
    4d24:	0001720e 	.word	0x0001720e
    4d28:	ea5e0c0c 	.word	0xea5e0c0c
    4d2c:	000171f2 	.word	0x000171f2
    4d30:	000171f4 	.word	0x000171f4
    4d34:	000171fa 	.word	0x000171fa
    4d38:	000171f8 	.word	0x000171f8
    4d3c:	000171f6 	.word	0x000171f6
    4d40:	f20d0d18 	.word	0xf20d0d18
    4d44:	ea5f70e0 	.word	0xea5f70e0
        if (pc == state->inst_num - 1) 
    4d48:	6863      	ldr	r3, [r4, #4]
    4d4a:	3b01      	subs	r3, #1
    4d4c:	459a      	cmp	sl, r3
    4d4e:	f43f ac4e 	beq.w	45ee <build_body+0x24e>
    if (!state->needGen) {
    4d52:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
    4d56:	2900      	cmp	r1, #0
    4d58:	d0b0      	beq.n	4cbc <build_body+0x91c>
    return to - from - 4;
    4d5a:	6961      	ldr	r1, [r4, #20]
    4d5c:	6923      	ldr	r3, [r4, #16]
    4d5e:	3904      	subs	r1, #4
    4d60:	1ac9      	subs	r1, r1, r3
    4d62:	e7ab      	b.n	4cbc <build_body+0x91c>
        DEBUG_LOG("Unsupport op: %x pc: %d\n", code, pc);
    4d64:	4652      	mov	r2, sl
    4d66:	4631      	mov	r1, r6
    4d68:	4801      	ldr	r0, [pc, #4]	; (4d70 <build_body+0x9d0>)
    4d6a:	f00b f8f0 	bl	ff4e <debug_log>
        if (ret > 0) { // load value, skip
    4d6e:	e43e      	b.n	45ee <build_body+0x24e>
    4d70:	00017222 	.word	0x00017222

00004d74 <jit_compile>:
    emit4(state, _thumb32_ORRW_REG_T2(0, 0, 1, 0, SRTYPE_LSL, FLAG_S));
    _emit_b_cond(state, 1, COND_NE);
    emit_mov_imm(state, 0, 2);
}

void jit_compile(jit_state *state) {
    4d74:	b538      	push	{r3, r4, r5, lr}
    // test_ldr(state);
    // test_alu(state);
    // return state;
    // PrePass: clac offset
	state->idx = 0;
    4d76:	2500      	movs	r5, #0
void jit_compile(jit_state *state) {
    4d78:	4604      	mov	r4, r0
	state->idx = 0;
    4d7a:	6105      	str	r5, [r0, #16]
    state->needGen = false;
    4d7c:	f880 5028 	strb.w	r5, [r0, #40]	; 0x28
    build_prologue(state);
    4d80:	f7ff f88c 	bl	3e9c <build_prologue>
    build_body(state);
    4d84:	4620      	mov	r0, r4
    4d86:	f7ff fb0b 	bl	43a0 <build_body>
    state->epilogue_offset = state->idx;
    4d8a:	6923      	ldr	r3, [r4, #16]
    // for (int i = 0; i < state->inst_num; i++) {
    //     DEBUG_LOG("build offset: i=%d %d\n", i, state->offsets[i]);
    // }
    // GenPass: generate jit code
    state->idx = 0;
    4d8c:	e9c4 5304 	strd	r5, r3, [r4, #16]
    state->needGen = true;
    4d90:	2301      	movs	r3, #1
    4d92:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    // DEBUG_LOG("epil: %d\n", epilogue_offset(state));
    build_prologue(state);
    4d96:	4620      	mov	r0, r4
    4d98:	f7ff f880 	bl	3e9c <build_prologue>

    // test_branch(state);
    build_body(state);
    4d9c:	4620      	mov	r0, r4
    4d9e:	f7ff faff 	bl	43a0 <build_body>
    emit4(state, _thumb32_MOVW_REG_T3(dst, src, FLAG_NOS));
    4da2:	4904      	ldr	r1, [pc, #16]	; (4db4 <jit_compile+0x40>)
    4da4:	4620      	mov	r0, r4
    4da6:	f00c fb16 	bl	113d6 <emit4>
    emit4(state, _thumb32_POPW_T2(CALLEE_POP_MASK));
    4daa:	4903      	ldr	r1, [pc, #12]	; (4db8 <jit_compile+0x44>)
    // DEBUG_LOG("epilogue_offset PASS1:%d PASS2:%d\n", state->epilogue_offset, state->idx);
    build_epilogue(state);

    // return state;
}
    4dac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    emit4(state, _thumb32_POPW_T2(CALLEE_POP_MASK));
    4db0:	f00c bb11 	b.w	113d6 <emit4>
    4db4:	ea4f0d0b 	.word	0xea4f0d0b
    4db8:	e8bd8bf0 	.word	0xe8bd8bf0

00004dbc <main>:

static void load_fixed_patch_0(void);
static void ebpf_test();
// extern void arm_core_mpu_disable();
void main(void)
{
    4dbc:	b508      	push	{r3, lr}
	#define USE_JIT
	#ifdef USE_JIT
	// disable mpu
	arm_core_mpu_disable();
    4dbe:	f005 f9dd 	bl	a17c <arm_core_mpu_disable>
	// https://lists.zephyrproject.org/g/users/topic/random_fault_exception/30793151?p=
	// CONFIG_NO_OPTIMIZATIONS=y
	#endif

	console_init();
    4dc2:	f002 fbdb 	bl	757c <console_init>

K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread)
    4dc6:	4809      	ldr	r0, [pc, #36]	; (4dec <main+0x30>)
    4dc8:	f00a fca8 	bl	f71c <z_impl_k_thread_start>
	//printk("Hello World! %s\n", CONFIG_BOARD);
	k_thread_start(cli_thread);

	//run_coap_server();
	profile_add_event("micro profile dynamic start");
    4dcc:	4808      	ldr	r0, [pc, #32]	; (4df0 <main+0x34>)
    4dce:	f7fe fcaf 	bl	3730 <profile_add_event>
	profile_add_event("micro profile fixed start");
    4dd2:	4808      	ldr	r0, [pc, #32]	; (4df4 <main+0x38>)
    4dd4:	f7fe fcac 	bl	3730 <profile_add_event>
	profile_add_event("uart print profile start");
    4dd8:	4807      	ldr	r0, [pc, #28]	; (4df8 <main+0x3c>)
    4dda:	f7fe fca9 	bl	3730 <profile_add_event>
	profile_add_event("eBPF exec time evaluation start");
    4dde:	4807      	ldr	r0, [pc, #28]	; (4dfc <main+0x40>)
    4de0:	f7fe fca6 	bl	3730 <profile_add_event>

	#ifdef DEV_MQTT
	run_mqtt_subscriber();
	#endif
}
    4de4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	run_mqtt_subscriber();
    4de8:	f000 b9ac 	b.w	5144 <run_mqtt_subscriber>
    4dec:	200021e4 	.word	0x200021e4
    4df0:	00017255 	.word	0x00017255
    4df4:	00017271 	.word	0x00017271
    4df8:	0001728b 	.word	0x0001728b
    4dfc:	000172a4 	.word	0x000172a4

00004e00 <wait>:
{
	nfds = 0;
}

static int wait(int timeout)
{
    4e00:	b538      	push	{r3, r4, r5, lr}
	int ret = 0;

	if (nfds > 0) {
    4e02:	4b10      	ldr	r3, [pc, #64]	; (4e44 <wait+0x44>)
    4e04:	6819      	ldr	r1, [r3, #0]
    4e06:	2900      	cmp	r1, #0
{
    4e08:	4602      	mov	r2, r0
	if (nfds > 0) {
    4e0a:	dd18      	ble.n	4e3e <wait+0x3e>

K_SYSCALL_DECLARE6(K_SYSCALL_ZSOCK_RECVFROM, zsock_recvfrom, ssize_t, int, sock, void *, buf, size_t, max_len, int, flags, struct sockaddr *, src_addr, socklen_t *, addrlen)

K_SYSCALL_DECLARE3(K_SYSCALL_ZSOCK_FCNTL, zsock_fcntl, int, int, sock, int, cmd, int, flags)

K_SYSCALL_DECLARE3(K_SYSCALL_ZSOCK_POLL, zsock_poll, int, struct zsock_pollfd *, fds, int, nfds, int, timeout)
    4e0c:	480e      	ldr	r0, [pc, #56]	; (4e48 <wait+0x48>)
    4e0e:	f002 fdb7 	bl	7980 <z_impl_zsock_poll>
		ret = zsock_poll(fds, nfds, timeout);
		if (ret < 0) {
    4e12:	1e05      	subs	r5, r0, #0
    4e14:	da11      	bge.n	4e3a <wait+0x3a>
			LOG_ERR("poll error: %d", errno);
    4e16:	2301      	movs	r3, #1
    4e18:	f04f 0400 	mov.w	r4, #0
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    4e1c:	4a0b      	ldr	r2, [pc, #44]	; (4e4c <wait+0x4c>)
    4e1e:	f363 0407 	bfi	r4, r3, #0, #8
    4e22:	4b0b      	ldr	r3, [pc, #44]	; (4e50 <wait+0x50>)
    4e24:	1a9b      	subs	r3, r3, r2
    4e26:	08db      	lsrs	r3, r3, #3
    4e28:	f363 148f 	bfi	r4, r3, #6, #10
    4e2c:	f00e f923 	bl	13076 <__errno>
    4e30:	4622      	mov	r2, r4
    4e32:	6801      	ldr	r1, [r0, #0]
    4e34:	4807      	ldr	r0, [pc, #28]	; (4e54 <wait+0x54>)
    4e36:	f00d f8aa 	bl	11f8e <log_1>
		}
	}

	return ret;
}
    4e3a:	4628      	mov	r0, r5
    4e3c:	bd38      	pop	{r3, r4, r5, pc}
	int ret = 0;
    4e3e:	2500      	movs	r5, #0
	return ret;
    4e40:	e7fb      	b.n	4e3a <wait+0x3a>
    4e42:	bf00      	nop
    4e44:	200022b8 	.word	0x200022b8
    4e48:	200022b0 	.word	0x200022b0
    4e4c:	00016344 	.word	0x00016344
    4e50:	000163cc 	.word	0x000163cc
    4e54:	000174d3 	.word	0x000174d3

00004e58 <mqtt_evt_handler>:

void mqtt_evt_handler(struct mqtt_client *const client,
		      const struct mqtt_evt *evt)
{
    4e58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t data[33];
	int len;
	int bytes_read;
	struct mqtt_puback_param puback;

	switch (evt->type) {
    4e5c:	780b      	ldrb	r3, [r1, #0]
{
    4e5e:	b08b      	sub	sp, #44	; 0x2c
    4e60:	4606      	mov	r6, r0
    4e62:	460c      	mov	r4, r1
	switch (evt->type) {
    4e64:	2b08      	cmp	r3, #8
    4e66:	d845      	bhi.n	4ef4 <mqtt_evt_handler+0x9c>
    4e68:	e8df f013 	tbh	[pc, r3, lsl #1]
    4e6c:	00470027 	.word	0x00470027
    4e70:	005c0074 	.word	0x005c0074
    4e74:	004400f6 	.word	0x004400f6
    4e78:	00090123 	.word	0x00090123
    4e7c:	0019      	.short	0x0019
	
	case MQTT_EVT_SUBACK:
		LOG_INF("SUBACK packet id: %u", evt->param.suback.message_id);
    4e7e:	2303      	movs	r3, #3
    4e80:	f04f 0200 	mov.w	r2, #0
    4e84:	f363 0207 	bfi	r2, r3, #0, #8
    4e88:	4996      	ldr	r1, [pc, #600]	; (50e4 <mqtt_evt_handler+0x28c>)
    4e8a:	4b97      	ldr	r3, [pc, #604]	; (50e8 <mqtt_evt_handler+0x290>)
    4e8c:	4897      	ldr	r0, [pc, #604]	; (50ec <mqtt_evt_handler+0x294>)
    4e8e:	1a5b      	subs	r3, r3, r1
    4e90:	08db      	lsrs	r3, r3, #3
    4e92:	88a1      	ldrh	r1, [r4, #4]
    4e94:	f363 128f 	bfi	r2, r3, #6, #10
		if (evt->result != 0) {
			LOG_ERR("MQTT PUBCOMP error %d", evt->result);
			break;
		}

		LOG_INF("PUBCOMP packet id: %u",
    4e98:	f00d f879 	bl	11f8e <log_1>
		break;

	default:
		break;
	}
}
    4e9c:	e02a      	b.n	4ef4 <mqtt_evt_handler+0x9c>
		LOG_INF("UNSUBACK packet id: %u", evt->param.suback.message_id);
    4e9e:	2303      	movs	r3, #3
    4ea0:	f04f 0200 	mov.w	r2, #0
    4ea4:	f363 0207 	bfi	r2, r3, #0, #8
    4ea8:	498e      	ldr	r1, [pc, #568]	; (50e4 <mqtt_evt_handler+0x28c>)
    4eaa:	4b8f      	ldr	r3, [pc, #572]	; (50e8 <mqtt_evt_handler+0x290>)
    4eac:	4890      	ldr	r0, [pc, #576]	; (50f0 <mqtt_evt_handler+0x298>)
    4eae:	1a5b      	subs	r3, r3, r1
    4eb0:	08db      	lsrs	r3, r3, #3
    4eb2:	f363 128f 	bfi	r2, r3, #6, #10
    4eb6:	88a1      	ldrh	r1, [r4, #4]
    4eb8:	e7ee      	b.n	4e98 <mqtt_evt_handler+0x40>
		if (evt->result != 0) {
    4eba:	4b8b      	ldr	r3, [pc, #556]	; (50e8 <mqtt_evt_handler+0x290>)
    4ebc:	4a89      	ldr	r2, [pc, #548]	; (50e4 <mqtt_evt_handler+0x28c>)
    4ebe:	69c9      	ldr	r1, [r1, #28]
    4ec0:	1a9b      	subs	r3, r3, r2
    4ec2:	f3c3 03c9 	ubfx	r3, r3, #3, #10
    4ec6:	b141      	cbz	r1, 4eda <mqtt_evt_handler+0x82>
			LOG_ERR("MQTT connect failed %d", evt->result);
    4ec8:	2001      	movs	r0, #1
    4eca:	f04f 0200 	mov.w	r2, #0
    4ece:	f360 0207 	bfi	r2, r0, #0, #8
    4ed2:	f363 128f 	bfi	r2, r3, #6, #10
    4ed6:	4887      	ldr	r0, [pc, #540]	; (50f4 <mqtt_evt_handler+0x29c>)
    4ed8:	e7de      	b.n	4e98 <mqtt_evt_handler+0x40>
		connected = true;
    4eda:	4a87      	ldr	r2, [pc, #540]	; (50f8 <mqtt_evt_handler+0x2a0>)
		LOG_INF("MQTT client connected!");
    4edc:	4887      	ldr	r0, [pc, #540]	; (50fc <mqtt_evt_handler+0x2a4>)
		connected = true;
    4ede:	2101      	movs	r1, #1
    4ee0:	7011      	strb	r1, [r2, #0]
		LOG_INF("MQTT client connected!");
    4ee2:	f04f 0100 	mov.w	r1, #0
    4ee6:	2203      	movs	r2, #3
    4ee8:	f362 0107 	bfi	r1, r2, #0, #8
    4eec:	f363 118f 	bfi	r1, r3, #6, #10
    4ef0:	f00d f840 	bl	11f74 <log_0>
}
    4ef4:	b00b      	add	sp, #44	; 0x2c
    4ef6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		LOG_INF("MQTT client disconnected %d", evt->result);
    4efa:	2303      	movs	r3, #3
    4efc:	f04f 0200 	mov.w	r2, #0
    4f00:	f363 0207 	bfi	r2, r3, #0, #8
    4f04:	4977      	ldr	r1, [pc, #476]	; (50e4 <mqtt_evt_handler+0x28c>)
    4f06:	4b78      	ldr	r3, [pc, #480]	; (50e8 <mqtt_evt_handler+0x290>)
    4f08:	487d      	ldr	r0, [pc, #500]	; (5100 <mqtt_evt_handler+0x2a8>)
    4f0a:	1a5b      	subs	r3, r3, r1
    4f0c:	08db      	lsrs	r3, r3, #3
    4f0e:	f363 128f 	bfi	r2, r3, #6, #10
    4f12:	69e1      	ldr	r1, [r4, #28]
    4f14:	f00d f83b 	bl	11f8e <log_1>
		connected = false;
    4f18:	4a77      	ldr	r2, [pc, #476]	; (50f8 <mqtt_evt_handler+0x2a0>)
    4f1a:	2300      	movs	r3, #0
    4f1c:	7013      	strb	r3, [r2, #0]
	nfds = 0;
    4f1e:	4a79      	ldr	r2, [pc, #484]	; (5104 <mqtt_evt_handler+0x2ac>)
    4f20:	6013      	str	r3, [r2, #0]
    4f22:	e7e7      	b.n	4ef4 <mqtt_evt_handler+0x9c>
		if (evt->result != 0) {
    4f24:	4a6f      	ldr	r2, [pc, #444]	; (50e4 <mqtt_evt_handler+0x28c>)
    4f26:	4b70      	ldr	r3, [pc, #448]	; (50e8 <mqtt_evt_handler+0x290>)
    4f28:	69c9      	ldr	r1, [r1, #28]
    4f2a:	1a9b      	subs	r3, r3, r2
    4f2c:	f3c3 03c9 	ubfx	r3, r3, #3, #10
			LOG_ERR("MQTT PUBACK error %d", evt->result);
    4f30:	f04f 0200 	mov.w	r2, #0
		if (evt->result != 0) {
    4f34:	b131      	cbz	r1, 4f44 <mqtt_evt_handler+0xec>
			LOG_ERR("MQTT PUBACK error %d", evt->result);
    4f36:	2001      	movs	r0, #1
    4f38:	f360 0207 	bfi	r2, r0, #0, #8
    4f3c:	f363 128f 	bfi	r2, r3, #6, #10
    4f40:	4871      	ldr	r0, [pc, #452]	; (5108 <mqtt_evt_handler+0x2b0>)
    4f42:	e7a9      	b.n	4e98 <mqtt_evt_handler+0x40>
		LOG_INF("PUBACK packet id: %u", evt->param.puback.message_id);
    4f44:	2103      	movs	r1, #3
    4f46:	f361 0207 	bfi	r2, r1, #0, #8
    4f4a:	f363 128f 	bfi	r2, r3, #6, #10
    4f4e:	88a1      	ldrh	r1, [r4, #4]
    4f50:	486e      	ldr	r0, [pc, #440]	; (510c <mqtt_evt_handler+0x2b4>)
    4f52:	e7a1      	b.n	4e98 <mqtt_evt_handler+0x40>
		LOG_INF("MQTT publish received %d, %d bytes", evt->result, len);
    4f54:	2203      	movs	r2, #3
    4f56:	f04f 0300 	mov.w	r3, #0
    4f5a:	f362 0307 	bfi	r3, r2, #0, #8
    4f5e:	4d62      	ldr	r5, [pc, #392]	; (50e8 <mqtt_evt_handler+0x290>)
    4f60:	4a60      	ldr	r2, [pc, #384]	; (50e4 <mqtt_evt_handler+0x28c>)
		len = evt->param.publish.message.payload.len;
    4f62:	694e      	ldr	r6, [r1, #20]
		LOG_INF("MQTT publish received %d, %d bytes", evt->result, len);
    4f64:	486a      	ldr	r0, [pc, #424]	; (5110 <mqtt_evt_handler+0x2b8>)
    4f66:	69c9      	ldr	r1, [r1, #28]
    4f68:	1aad      	subs	r5, r5, r2
    4f6a:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    4f6e:	f365 138f 	bfi	r3, r5, #6, #10
    4f72:	4632      	mov	r2, r6
    4f74:	f00d f81f 	bl	11fb6 <log_2>
		LOG_INF(" id: %d, qos: %d", evt->param.publish.message_id,
    4f78:	2203      	movs	r2, #3
    4f7a:	f04f 0300 	mov.w	r3, #0
    4f7e:	f362 0307 	bfi	r3, r2, #0, #8
    4f82:	f365 138f 	bfi	r3, r5, #6, #10
    4f86:	7b22      	ldrb	r2, [r4, #12]
    4f88:	8b21      	ldrh	r1, [r4, #24]
    4f8a:	4862      	ldr	r0, [pc, #392]	; (5114 <mqtt_evt_handler+0x2bc>)
    4f8c:	f00d f813 	bl	11fb6 <log_2>
		while (len) {
    4f90:	b31e      	cbz	r6, 4fda <mqtt_evt_handler+0x182>
			LOG_INF("ha---------->\n");
    4f92:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
    4f96:	f043 0303 	orr.w	r3, r3, #3
    4f9a:	f363 0707 	bfi	r7, r3, #0, #8
    4f9e:	f365 178f 	bfi	r7, r5, #6, #10
    4fa2:	4639      	mov	r1, r7
    4fa4:	485c      	ldr	r0, [pc, #368]	; (5118 <mqtt_evt_handler+0x2c0>)
    4fa6:	f00c ffe5 	bl	11f74 <log_0>
			bytes_read = mqtt_read_publish_payload(&client_ctx,
    4faa:	2e20      	cmp	r6, #32
    4fac:	4632      	mov	r2, r6
    4fae:	a901      	add	r1, sp, #4
    4fb0:	bf28      	it	cs
    4fb2:	2220      	movcs	r2, #32
    4fb4:	4859      	ldr	r0, [pc, #356]	; (511c <mqtt_evt_handler+0x2c4>)
    4fb6:	f010 fb8d 	bl	156d4 <mqtt_read_publish_payload>
			if (bytes_read < 0 && bytes_read != -EAGAIN) {
    4fba:	f1b0 0b00 	subs.w	fp, r0, #0
    4fbe:	da14      	bge.n	4fea <mqtt_evt_handler+0x192>
    4fc0:	f11b 0f0b 	cmn.w	fp, #11
    4fc4:	d011      	beq.n	4fea <mqtt_evt_handler+0x192>
				LOG_ERR("failure to read payload");
    4fc6:	f04f 0100 	mov.w	r1, #0
    4fca:	2301      	movs	r3, #1
    4fcc:	f363 0107 	bfi	r1, r3, #0, #8
    4fd0:	f365 118f 	bfi	r1, r5, #6, #10
    4fd4:	4852      	ldr	r0, [pc, #328]	; (5120 <mqtt_evt_handler+0x2c8>)
    4fd6:	f00c ffcd 	bl	11f74 <log_0>
		puback.message_id = evt->param.publish.message_id;
    4fda:	8b23      	ldrh	r3, [r4, #24]
		mqtt_publish_qos1_ack(&client_ctx, &puback);
    4fdc:	484f      	ldr	r0, [pc, #316]	; (511c <mqtt_evt_handler+0x2c4>)
		puback.message_id = evt->param.publish.message_id;
    4fde:	f8ad 3000 	strh.w	r3, [sp]
		mqtt_publish_qos1_ack(&client_ctx, &puback);
    4fe2:	4669      	mov	r1, sp
    4fe4:	f010 fac4 	bl	15570 <mqtt_publish_qos1_ack>
		break;
    4fe8:	e784      	b.n	4ef4 <mqtt_evt_handler+0x9c>
			data[bytes_read] = '\0';
    4fea:	ab0a      	add	r3, sp, #40	; 0x28
    4fec:	eb03 020b 	add.w	r2, r3, fp
    4ff0:	2100      	movs	r1, #0
    4ff2:	f802 1c24 	strb.w	r1, [r2, #-36]
			LOG_INF("   payload: %s", log_strdup(data));
    4ff6:	f028 023f 	bic.w	r2, r8, #63	; 0x3f
    4ffa:	f042 0203 	orr.w	r2, r2, #3
    4ffe:	a801      	add	r0, sp, #4
    5000:	f362 0807 	bfi	r8, r2, #0, #8
    5004:	f001 ffbc 	bl	6f80 <log_strdup>
    5008:	f365 188f 	bfi	r8, r5, #6, #10
    500c:	4642      	mov	r2, r8
    500e:	4601      	mov	r1, r0
    5010:	4844      	ldr	r0, [pc, #272]	; (5124 <mqtt_evt_handler+0x2cc>)
    5012:	f00c ffbc 	bl	11f8e <log_1>
			LOG_INF("len = %d", len);
    5016:	f029 023f 	bic.w	r2, r9, #63	; 0x3f
    501a:	f042 0203 	orr.w	r2, r2, #3
    501e:	f362 0907 	bfi	r9, r2, #0, #8
			len -= bytes_read;
    5022:	eba6 060b 	sub.w	r6, r6, fp
			LOG_INF("len = %d", len);
    5026:	f365 198f 	bfi	r9, r5, #6, #10
    502a:	464a      	mov	r2, r9
    502c:	4631      	mov	r1, r6
    502e:	483e      	ldr	r0, [pc, #248]	; (5128 <mqtt_evt_handler+0x2d0>)
    5030:	f00c ffad 	bl	11f8e <log_1>
			LOG_INF("bytes_read = %d", bytes_read);
    5034:	f02a 023f 	bic.w	r2, sl, #63	; 0x3f
    5038:	f042 0203 	orr.w	r2, r2, #3
    503c:	f362 0a07 	bfi	sl, r2, #0, #8
    5040:	f365 1a8f 	bfi	sl, r5, #6, #10
    5044:	4652      	mov	r2, sl
    5046:	4659      	mov	r1, fp
    5048:	4838      	ldr	r0, [pc, #224]	; (512c <mqtt_evt_handler+0x2d4>)
    504a:	f00c ffa0 	bl	11f8e <log_1>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
    504e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    5052:	f00a fa61 	bl	f518 <z_impl_k_sleep>
    5056:	e79b      	b.n	4f90 <mqtt_evt_handler+0x138>
		if (evt->result != 0) {
    5058:	4d23      	ldr	r5, [pc, #140]	; (50e8 <mqtt_evt_handler+0x290>)
    505a:	4b22      	ldr	r3, [pc, #136]	; (50e4 <mqtt_evt_handler+0x28c>)
    505c:	69c9      	ldr	r1, [r1, #28]
    505e:	1aed      	subs	r5, r5, r3
    5060:	f3c5 05c9 	ubfx	r5, r5, #3, #10
			LOG_ERR("MQTT PUBREC error %d", evt->result);
    5064:	f04f 0200 	mov.w	r2, #0
		if (evt->result != 0) {
    5068:	b131      	cbz	r1, 5078 <mqtt_evt_handler+0x220>
			LOG_ERR("MQTT PUBREC error %d", evt->result);
    506a:	2301      	movs	r3, #1
    506c:	f363 0207 	bfi	r2, r3, #0, #8
    5070:	f365 128f 	bfi	r2, r5, #6, #10
    5074:	482e      	ldr	r0, [pc, #184]	; (5130 <mqtt_evt_handler+0x2d8>)
    5076:	e70f      	b.n	4e98 <mqtt_evt_handler+0x40>
		LOG_INF("PUBREC packet id: %u", evt->param.pubrec.message_id);
    5078:	2303      	movs	r3, #3
    507a:	f363 0207 	bfi	r2, r3, #0, #8
    507e:	f365 128f 	bfi	r2, r5, #6, #10
    5082:	88a1      	ldrh	r1, [r4, #4]
    5084:	482b      	ldr	r0, [pc, #172]	; (5134 <mqtt_evt_handler+0x2dc>)
    5086:	f00c ff82 	bl	11f8e <log_1>
		const struct mqtt_pubrel_param rel_param = {
    508a:	88a3      	ldrh	r3, [r4, #4]
    508c:	f8ad 3004 	strh.w	r3, [sp, #4]
		err = mqtt_publish_qos2_release(client, &rel_param);
    5090:	a901      	add	r1, sp, #4
    5092:	4630      	mov	r0, r6
    5094:	f010 fa93 	bl	155be <mqtt_publish_qos2_release>
		if (err != 0) {
    5098:	4601      	mov	r1, r0
    509a:	2800      	cmp	r0, #0
    509c:	f43f af2a 	beq.w	4ef4 <mqtt_evt_handler+0x9c>
			LOG_ERR("Failed to send MQTT PUBREL: %d", err);
    50a0:	f04f 0200 	mov.w	r2, #0
    50a4:	2301      	movs	r3, #1
    50a6:	f363 0207 	bfi	r2, r3, #0, #8
    50aa:	f365 128f 	bfi	r2, r5, #6, #10
    50ae:	4822      	ldr	r0, [pc, #136]	; (5138 <mqtt_evt_handler+0x2e0>)
    50b0:	e6f2      	b.n	4e98 <mqtt_evt_handler+0x40>
		if (evt->result != 0) {
    50b2:	4a0c      	ldr	r2, [pc, #48]	; (50e4 <mqtt_evt_handler+0x28c>)
    50b4:	4b0c      	ldr	r3, [pc, #48]	; (50e8 <mqtt_evt_handler+0x290>)
    50b6:	69c9      	ldr	r1, [r1, #28]
    50b8:	1a9b      	subs	r3, r3, r2
    50ba:	f3c3 03c9 	ubfx	r3, r3, #3, #10
			LOG_ERR("MQTT PUBCOMP error %d", evt->result);
    50be:	f04f 0200 	mov.w	r2, #0
		if (evt->result != 0) {
    50c2:	b131      	cbz	r1, 50d2 <mqtt_evt_handler+0x27a>
			LOG_ERR("MQTT PUBCOMP error %d", evt->result);
    50c4:	2001      	movs	r0, #1
    50c6:	f360 0207 	bfi	r2, r0, #0, #8
    50ca:	f363 128f 	bfi	r2, r3, #6, #10
    50ce:	481b      	ldr	r0, [pc, #108]	; (513c <mqtt_evt_handler+0x2e4>)
    50d0:	e6e2      	b.n	4e98 <mqtt_evt_handler+0x40>
		LOG_INF("PUBCOMP packet id: %u",
    50d2:	2103      	movs	r1, #3
    50d4:	f361 0207 	bfi	r2, r1, #0, #8
    50d8:	f363 128f 	bfi	r2, r3, #6, #10
    50dc:	88a1      	ldrh	r1, [r4, #4]
    50de:	4818      	ldr	r0, [pc, #96]	; (5140 <mqtt_evt_handler+0x2e8>)
    50e0:	e6da      	b.n	4e98 <mqtt_evt_handler+0x40>
    50e2:	bf00      	nop
    50e4:	00016344 	.word	0x00016344
    50e8:	000163cc 	.word	0x000163cc
    50ec:	000172d1 	.word	0x000172d1
    50f0:	000172cf 	.word	0x000172cf
    50f4:	000172e6 	.word	0x000172e6
    50f8:	200057b4 	.word	0x200057b4
    50fc:	000172fd 	.word	0x000172fd
    5100:	00017314 	.word	0x00017314
    5104:	200022b8 	.word	0x200022b8
    5108:	00017330 	.word	0x00017330
    510c:	00017345 	.word	0x00017345
    5110:	0001735a 	.word	0x0001735a
    5114:	0001737d 	.word	0x0001737d
    5118:	0001738e 	.word	0x0001738e
    511c:	20002250 	.word	0x20002250
    5120:	0001739d 	.word	0x0001739d
    5124:	000173b5 	.word	0x000173b5
    5128:	000173c4 	.word	0x000173c4
    512c:	000173cd 	.word	0x000173cd
    5130:	000173dd 	.word	0x000173dd
    5134:	000173f2 	.word	0x000173f2
    5138:	00017407 	.word	0x00017407
    513c:	00017426 	.word	0x00017426
    5140:	0001743c 	.word	0x0001743c

00005144 <run_mqtt_subscriber>:
static K_MEM_POOL_DEFINE(app_mem_pool, sizeof(uintptr_t), 1024,
			 2, sizeof(uintptr_t));
#endif

void run_mqtt_subscriber(void)
{
    5144:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	LOG_INF("Start APP");
    5148:	2303      	movs	r3, #3
    514a:	f04f 0100 	mov.w	r1, #0
    514e:	f363 0107 	bfi	r1, r3, #0, #8
    5152:	4d5b      	ldr	r5, [pc, #364]	; (52c0 <run_mqtt_subscriber+0x17c>)
    5154:	4b5b      	ldr	r3, [pc, #364]	; (52c4 <run_mqtt_subscriber+0x180>)
    5156:	485c      	ldr	r0, [pc, #368]	; (52c8 <run_mqtt_subscriber+0x184>)
    5158:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 5314 <run_mqtt_subscriber+0x1d0>
	mqtt_client_init(client);
    515c:	4c5b      	ldr	r4, [pc, #364]	; (52cc <run_mqtt_subscriber+0x188>)
	LOG_INF("Start APP");
    515e:	1aed      	subs	r5, r5, r3
    5160:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    5164:	f365 118f 	bfi	r1, r5, #6, #10
    5168:	f00c ff04 	bl	11f74 <log_0>
static int try_to_connect(struct mqtt_client *client)
    516c:	f04f 090b 	mov.w	r9, #11
    5170:	46d8      	mov	r8, fp
	while (i++ < APP_CONNECT_TRIES && !connected) {
    5172:	f1b9 0901 	subs.w	r9, r9, #1
    5176:	f89b 6000 	ldrb.w	r6, [fp]
    517a:	f000 8090 	beq.w	529e <run_mqtt_subscriber+0x15a>
    517e:	2e00      	cmp	r6, #0
    5180:	d036      	beq.n	51f0 <run_mqtt_subscriber+0xac>
	subs_topic.topic.utf8 = topic;
    5182:	4c53      	ldr	r4, [pc, #332]	; (52d0 <run_mqtt_subscriber+0x18c>)
    5184:	4e53      	ldr	r6, [pc, #332]	; (52d4 <run_mqtt_subscriber+0x190>)
	subs_topic.topic.size = strlen(topic);
    5186:	4620      	mov	r0, r4
	subs_topic.topic.utf8 = topic;
    5188:	6034      	str	r4, [r6, #0]
	subs_topic.topic.size = strlen(topic);
    518a:	f7fd f84d 	bl	2228 <strlen>
	subs_list.list = &subs_topic;
    518e:	4952      	ldr	r1, [pc, #328]	; (52d8 <run_mqtt_subscriber+0x194>)
	subs_topic.topic.size = strlen(topic);
    5190:	6070      	str	r0, [r6, #4]
	subs_list.list_count = 1U;
    5192:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    5196:	604b      	str	r3, [r1, #4]
	err = mqtt_subscribe(client, &subs_list);
    5198:	484c      	ldr	r0, [pc, #304]	; (52cc <run_mqtt_subscriber+0x188>)
	subs_list.list = &subs_topic;
    519a:	600e      	str	r6, [r1, #0]
	err = mqtt_subscribe(client, &subs_list);
    519c:	f010 fa36 	bl	1560c <mqtt_subscribe>
	if (err) {
    51a0:	b150      	cbz	r0, 51b8 <run_mqtt_subscriber+0x74>
		LOG_ERR("Failed on topic %s", topic);
    51a2:	f04f 0200 	mov.w	r2, #0
    51a6:	2301      	movs	r3, #1
    51a8:	f363 0207 	bfi	r2, r3, #0, #8
    51ac:	f365 128f 	bfi	r2, r5, #6, #10
    51b0:	4621      	mov	r1, r4
    51b2:	484a      	ldr	r0, [pc, #296]	; (52dc <run_mqtt_subscriber+0x198>)
    51b4:	f00c feeb 	bl	11f8e <log_1>
		LOG_INF("poll");
    51b8:	2303      	movs	r3, #3
    51ba:	f04f 0100 	mov.w	r1, #0
    51be:	f363 0107 	bfi	r1, r3, #0, #8
    51c2:	f365 118f 	bfi	r1, r5, #6, #10
    51c6:	4846      	ldr	r0, [pc, #280]	; (52e0 <run_mqtt_subscriber+0x19c>)
			mqtt_input(&client_ctx);
    51c8:	4c40      	ldr	r4, [pc, #256]	; (52cc <run_mqtt_subscriber+0x188>)
		LOG_INF("poll");
    51ca:	f00c fed3 	bl	11f74 <log_0>
	while (connected) {
    51ce:	f898 3000 	ldrb.w	r3, [r8]
    51d2:	2b00      	cmp	r3, #0
    51d4:	d169      	bne.n	52aa <run_mqtt_subscriber+0x166>
	LOG_INF("not connected");
    51d6:	2303      	movs	r3, #3
    51d8:	f04f 0100 	mov.w	r1, #0
    51dc:	f363 0107 	bfi	r1, r3, #0, #8
    51e0:	4840      	ldr	r0, [pc, #256]	; (52e4 <run_mqtt_subscriber+0x1a0>)
    51e2:	f365 118f 	bfi	r1, r5, #6, #10
	k_thread_start(app_thread);
	k_thread_join(app_thread, K_FOREVER);
#else
	start_app();
#endif
}
    51e6:	b003      	add	sp, #12
    51e8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	LOG_INF("not connected");
    51ec:	f00c bec2 	b.w	11f74 <log_0>
	broker4->sin_family = AF_INET;
    51f0:	4f3d      	ldr	r7, [pc, #244]	; (52e8 <run_mqtt_subscriber+0x1a4>)
	mqtt_client_init(client);
    51f2:	4836      	ldr	r0, [pc, #216]	; (52cc <run_mqtt_subscriber+0x188>)
    51f4:	f010 f965 	bl	154c2 <mqtt_client_init>
	broker4->sin_port = htons(SERVER_PORT);
    51f8:	f645 3307 	movw	r3, #23303	; 0x5b07

K_SYSCALL_DECLARE2(K_SYSCALL_ZSOCK_GETHOSTNAME, zsock_gethostname, int, char *, buf, size_t, len)

K_SYSCALL_DECLARE3(K_SYSCALL_ZSOCK_INET_PTON, zsock_inet_pton, int, sa_family_t, family, const char *, src, void *, dst)
    51fc:	1d3a      	adds	r2, r7, #4
    51fe:	493b      	ldr	r1, [pc, #236]	; (52ec <run_mqtt_subscriber+0x1a8>)
    5200:	807b      	strh	r3, [r7, #2]
	broker4->sin_family = AF_INET;
    5202:	2001      	movs	r0, #1
    5204:	8038      	strh	r0, [r7, #0]
    5206:	f00d fe30 	bl	12e6a <z_impl_zsock_inet_pton>
	client->evt_cb = mqtt_evt_handler;
    520a:	4b39      	ldr	r3, [pc, #228]	; (52f0 <run_mqtt_subscriber+0x1ac>)
	client->client_id.utf8 = (uint8_t *)MQTT_CLIENTID;
    520c:	4839      	ldr	r0, [pc, #228]	; (52f4 <run_mqtt_subscriber+0x1b0>)
	client->evt_cb = mqtt_evt_handler;
    520e:	64a3      	str	r3, [r4, #72]	; 0x48
	client->broker = &broker;
    5210:	6367      	str	r7, [r4, #52]	; 0x34
	client->client_id.utf8 = (uint8_t *)MQTT_CLIENTID;
    5212:	62e0      	str	r0, [r4, #44]	; 0x2c
	client->client_id.size = strlen(MQTT_CLIENTID);
    5214:	f7fd f808 	bl	2228 <strlen>
	client->protocol_version = MQTT_VERSION_3_1_1;
    5218:	2304      	movs	r3, #4
	client->tx_buf = tx_buffer;
    521a:	4a37      	ldr	r2, [pc, #220]	; (52f8 <run_mqtt_subscriber+0x1b4>)
	client->protocol_version = MQTT_VERSION_3_1_1;
    521c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	client->rx_buf = rx_buffer;
    5220:	4b36      	ldr	r3, [pc, #216]	; (52fc <run_mqtt_subscriber+0x1b8>)
	client->client_id.size = strlen(MQTT_CLIENTID);
    5222:	6320      	str	r0, [r4, #48]	; 0x30
	client->rx_buf = rx_buffer;
    5224:	64e3      	str	r3, [r4, #76]	; 0x4c
		rc = mqtt_connect(client);
    5226:	4829      	ldr	r0, [pc, #164]	; (52cc <run_mqtt_subscriber+0x188>)
	client->transport.type = MQTT_TRANSPORT_NON_SECURE;
    5228:	f884 6024 	strb.w	r6, [r4, #36]	; 0x24
	client->rx_buf_size = sizeof(rx_buffer);
    522c:	2380      	movs	r3, #128	; 0x80
	client->tx_buf_size = sizeof(tx_buffer);
    522e:	e9c4 2315 	strd	r2, r3, [r4, #84]	; 0x54
	client->user_name = NULL;
    5232:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
	client->rx_buf_size = sizeof(rx_buffer);
    5236:	6523      	str	r3, [r4, #80]	; 0x50
		rc = mqtt_connect(client);
    5238:	f010 f958 	bl	154ec <mqtt_connect>
		if (rc != 0) {
    523c:	4602      	mov	r2, r0
    523e:	b198      	cbz	r0, 5268 <run_mqtt_subscriber+0x124>
			PRINT_RESULT("mqtt_connect", rc);
    5240:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
    5244:	f043 0303 	orr.w	r3, r3, #3
    5248:	f363 0a07 	bfi	sl, r3, #0, #8
    524c:	f365 1a8f 	bfi	sl, r5, #6, #10
    5250:	f8ad a000 	strh.w	sl, [sp]
    5254:	4b2a      	ldr	r3, [pc, #168]	; (5300 <run_mqtt_subscriber+0x1bc>)
    5256:	492b      	ldr	r1, [pc, #172]	; (5304 <run_mqtt_subscriber+0x1c0>)
    5258:	482b      	ldr	r0, [pc, #172]	; (5308 <run_mqtt_subscriber+0x1c4>)
    525a:	f00c fec4 	bl	11fe6 <log_3>
    525e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    5262:	f00a f959 	bl	f518 <z_impl_k_sleep>
    5266:	e784      	b.n	5172 <run_mqtt_subscriber+0x2e>
	if (client->transport.type == MQTT_TRANSPORT_NON_SECURE) {
    5268:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    526c:	4a27      	ldr	r2, [pc, #156]	; (530c <run_mqtt_subscriber+0x1c8>)
    526e:	b90b      	cbnz	r3, 5274 <run_mqtt_subscriber+0x130>
		fds[0].fd = client->transport.tcp.sock;
    5270:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    5272:	6013      	str	r3, [r2, #0]
	fds[0].events = ZSOCK_POLLIN;
    5274:	2301      	movs	r3, #1
    5276:	8093      	strh	r3, [r2, #4]
	nfds = 1;
    5278:	4a25      	ldr	r2, [pc, #148]	; (5310 <run_mqtt_subscriber+0x1cc>)
		if (wait(APP_CONNECT_TIMEOUT_MS)) {
    527a:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
	nfds = 1;
    527e:	6013      	str	r3, [r2, #0]
		if (wait(APP_CONNECT_TIMEOUT_MS)) {
    5280:	f7ff fdbe 	bl	4e00 <wait>
    5284:	b110      	cbz	r0, 528c <run_mqtt_subscriber+0x148>
			mqtt_input(client);
    5286:	4620      	mov	r0, r4
    5288:	f010 f9fb 	bl	15682 <mqtt_input>
		if (!connected) {
    528c:	f898 3000 	ldrb.w	r3, [r8]
    5290:	2b00      	cmp	r3, #0
    5292:	f47f af6e 	bne.w	5172 <run_mqtt_subscriber+0x2e>
			mqtt_abort(client);
    5296:	4620      	mov	r0, r4
    5298:	f010 f9df 	bl	1565a <mqtt_abort>
    529c:	e769      	b.n	5172 <run_mqtt_subscriber+0x2e>
	if (connected) {
    529e:	2e00      	cmp	r6, #0
    52a0:	f47f af6f 	bne.w	5182 <run_mqtt_subscriber+0x3e>
}
    52a4:	b003      	add	sp, #12
    52a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rc = wait(500); // Will this be too long?
    52aa:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    52ae:	f7ff fda7 	bl	4e00 <wait>
		if (rc > 0) {
    52b2:	2800      	cmp	r0, #0
    52b4:	dd8b      	ble.n	51ce <run_mqtt_subscriber+0x8a>
			mqtt_input(&client_ctx);
    52b6:	4620      	mov	r0, r4
    52b8:	f010 f9e3 	bl	15682 <mqtt_input>
    52bc:	e787      	b.n	51ce <run_mqtt_subscriber+0x8a>
    52be:	bf00      	nop
    52c0:	000163cc 	.word	0x000163cc
    52c4:	00016344 	.word	0x00016344
    52c8:	00017452 	.word	0x00017452
    52cc:	20002250 	.word	0x20002250
    52d0:	20011bf5 	.word	0x20011bf5
    52d4:	200022c4 	.word	0x200022c4
    52d8:	200022bc 	.word	0x200022bc
    52dc:	00017493 	.word	0x00017493
    52e0:	000174a6 	.word	0x000174a6
    52e4:	000174ab 	.word	0x000174ab
    52e8:	200056a0 	.word	0x200056a0
    52ec:	0001745c 	.word	0x0001745c
    52f0:	00004e59 	.word	0x00004e59
    52f4:	00017466 	.word	0x00017466
    52f8:	20005835 	.word	0x20005835
    52fc:	200057b5 	.word	0x200057b5
    5300:	00017474 	.word	0x00017474
    5304:	0001747a 	.word	0x0001747a
    5308:	00017487 	.word	0x00017487
    530c:	200022b0 	.word	0x200022b0
    5310:	200022b8 	.word	0x200022b8
    5314:	200057b4 	.word	0x200057b4

00005318 <_check_fd>:
	return -1;
}

static int _check_fd(int fd)
{
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
    5318:	2803      	cmp	r0, #3
{
    531a:	b508      	push	{r3, lr}
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
    531c:	d906      	bls.n	532c <_check_fd+0x14>
	}

	fd = k_array_index_sanitize(fd, ARRAY_SIZE(fdtable));

	if (fdtable[fd].obj == NULL) {
		errno = EBADF;
    531e:	f00d feaa 	bl	13076 <__errno>
    5322:	2309      	movs	r3, #9
    5324:	6003      	str	r3, [r0, #0]
    5326:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return -1;
	}

	return 0;
}
    532a:	bd08      	pop	{r3, pc}
	if (fdtable[fd].obj == NULL) {
    532c:	4b03      	ldr	r3, [pc, #12]	; (533c <_check_fd+0x24>)
    532e:	f853 3030 	ldr.w	r3, [r3, r0, lsl #3]
    5332:	2b00      	cmp	r3, #0
    5334:	d0f3      	beq.n	531e <_check_fd+0x6>
	return 0;
    5336:	2000      	movs	r0, #0
    5338:	e7f7      	b.n	532a <_check_fd+0x12>
    533a:	bf00      	nop
    533c:	200022d0 	.word	0x200022d0

00005340 <z_get_fd_obj_and_vtable>:

	return fd_entry->obj;
}

void *z_get_fd_obj_and_vtable(int fd, const struct fd_op_vtable **vtable)
{
    5340:	b538      	push	{r3, r4, r5, lr}
    5342:	4604      	mov	r4, r0
    5344:	460d      	mov	r5, r1
	struct fd_entry *fd_entry;

	if (_check_fd(fd) < 0) {
    5346:	f7ff ffe7 	bl	5318 <_check_fd>
    534a:	2800      	cmp	r0, #0
		return NULL;
	}

	fd_entry = &fdtable[fd];
	*vtable = fd_entry->vtable;
    534c:	bfa1      	itttt	ge
    534e:	4b05      	ldrge	r3, [pc, #20]	; (5364 <z_get_fd_obj_and_vtable+0x24>)
    5350:	eb03 02c4 	addge.w	r2, r3, r4, lsl #3

	return fd_entry->obj;
    5354:	f853 0034 	ldrge.w	r0, [r3, r4, lsl #3]
	*vtable = fd_entry->vtable;
    5358:	6852      	ldrge	r2, [r2, #4]
    535a:	bfac      	ite	ge
    535c:	602a      	strge	r2, [r5, #0]
		return NULL;
    535e:	2000      	movlt	r0, #0
}
    5360:	bd38      	pop	{r3, r4, r5, pc}
    5362:	bf00      	nop
    5364:	200022d0 	.word	0x200022d0

00005368 <z_reserve_fd>:

int z_reserve_fd(void)
{
    5368:	b510      	push	{r4, lr}

K_SYSCALL_DECLARE3(K_SYSCALL_K_STACK_POP, k_stack_pop, int, struct k_stack *, stack, u32_t *, data, s32_t, timeout)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_INIT, k_mutex_init, struct k_mutex *, mutex)

K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    536a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    536e:	480d      	ldr	r0, [pc, #52]	; (53a4 <z_reserve_fd+0x3c>)
    5370:	f009 fd7c 	bl	ee6c <z_impl_k_mutex_lock>
		if (fdtable[fd].obj == NULL) {
    5374:	4b0c      	ldr	r3, [pc, #48]	; (53a8 <z_reserve_fd+0x40>)
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
    5376:	2400      	movs	r4, #0
		if (fdtable[fd].obj == NULL) {
    5378:	f853 2034 	ldr.w	r2, [r3, r4, lsl #3]
    537c:	b16a      	cbz	r2, 539a <z_reserve_fd+0x32>
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
    537e:	3401      	adds	r4, #1
    5380:	2c04      	cmp	r4, #4
    5382:	d1f9      	bne.n	5378 <z_reserve_fd+0x10>
	errno = ENFILE;
    5384:	f00d fe77 	bl	13076 <__errno>
    5388:	2317      	movs	r3, #23
    538a:	6003      	str	r3, [r0, #0]
	return -1;
    538c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    5390:	4804      	ldr	r0, [pc, #16]	; (53a4 <z_reserve_fd+0x3c>)
    5392:	f009 fddb 	bl	ef4c <z_impl_k_mutex_unlock>
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
    5396:	4620      	mov	r0, r4
    5398:	bd10      	pop	{r4, pc}
		fdtable[fd].obj = FD_OBJ_RESERVED;
    539a:	2201      	movs	r2, #1
    539c:	f843 2034 	str.w	r2, [r3, r4, lsl #3]
    53a0:	e7f6      	b.n	5390 <z_reserve_fd+0x28>
    53a2:	bf00      	nop
    53a4:	20011dd8 	.word	0x20011dd8
    53a8:	200022d0 	.word	0x200022d0

000053ac <z_finalize_fd>:

void z_finalize_fd(int fd, void *obj, const struct fd_op_vtable *vtable)
{
	/* Assumes fd was already bounds-checked. */
	fdtable[fd].obj = obj;
    53ac:	4b03      	ldr	r3, [pc, #12]	; (53bc <z_finalize_fd+0x10>)
    53ae:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
	fdtable[fd].vtable = vtable;
    53b2:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    53b6:	605a      	str	r2, [r3, #4]
}
    53b8:	4770      	bx	lr
    53ba:	bf00      	nop
    53bc:	200022d0 	.word	0x200022d0

000053c0 <z_free_fd>:

void z_free_fd(int fd)
{
	/* Assumes fd was already bounds-checked. */
	fdtable[fd].obj = NULL;
    53c0:	4b02      	ldr	r3, [pc, #8]	; (53cc <z_free_fd+0xc>)
    53c2:	2200      	movs	r2, #0
    53c4:	f843 2030 	str.w	r2, [r3, r0, lsl #3]
}
    53c8:	4770      	bx	lr
    53ca:	bf00      	nop
    53cc:	200022d0 	.word	0x200022d0

000053d0 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    53d0:	680b      	ldr	r3, [r1, #0]
    53d2:	3301      	adds	r3, #1
    53d4:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    53d6:	4b01      	ldr	r3, [pc, #4]	; (53dc <char_out+0xc>)
    53d8:	681b      	ldr	r3, [r3, #0]
    53da:	4718      	bx	r3
    53dc:	20010cdc 	.word	0x20010cdc

000053e0 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    53e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    53e4:	b085      	sub	sp, #20
    53e6:	469b      	mov	fp, r3
    53e8:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    53ea:	f8df a090 	ldr.w	sl, [pc, #144]	; 547c <_printk_dec_ulong+0x9c>
    53ee:	2c01      	cmp	r4, #1
    53f0:	bfb8      	it	lt
    53f2:	2401      	movlt	r4, #1
    53f4:	2b01      	cmp	r3, #1
    53f6:	bf0c      	ite	eq
    53f8:	2330      	moveq	r3, #48	; 0x30
    53fa:	2320      	movne	r3, #32
    53fc:	4615      	mov	r5, r2
    53fe:	4680      	mov	r8, r0
    5400:	4689      	mov	r9, r1
    5402:	9401      	str	r4, [sp, #4]
    5404:	9302      	str	r3, [sp, #8]
    5406:	2601      	movs	r6, #1
    5408:	270a      	movs	r7, #10
    540a:	2200      	movs	r2, #0
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit != 0 || remainder > pos) {
    540c:	f10a 0401 	add.w	r4, sl, #1
    5410:	b90a      	cbnz	r2, 5416 <_printk_dec_ulong+0x36>
    5412:	45aa      	cmp	sl, r5
    5414:	d21f      	bcs.n	5456 <_printk_dec_ulong+0x76>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
    5416:	fbb5 f0f4 	udiv	r0, r5, r4
    541a:	4649      	mov	r1, r9
    541c:	3030      	adds	r0, #48	; 0x30
    541e:	47c0      	blx	r8
			digits++;
    5420:	3601      	adds	r6, #1
			found_largest_digit = 1;
    5422:	2201      	movs	r2, #1
		} else if (remaining <= min_width
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
    5424:	3f01      	subs	r7, #1
	while (pos >= 9) {
    5426:	2f01      	cmp	r7, #1
		remainder %= (pos + 1);
    5428:	fbb5 f1f4 	udiv	r1, r5, r4
		pos /= 10;
    542c:	f04f 030a 	mov.w	r3, #10
		remainder %= (pos + 1);
    5430:	fb04 5511 	mls	r5, r4, r1, r5
		pos /= 10;
    5434:	fbba faf3 	udiv	sl, sl, r3
	while (pos >= 9) {
    5438:	d1e8      	bne.n	540c <_printk_dec_ulong+0x2c>
	}
	out((int)(remainder + 48), ctx);
    543a:	4649      	mov	r1, r9
    543c:	f105 0030 	add.w	r0, r5, #48	; 0x30
    5440:	47c0      	blx	r8

	if (padding == PAD_SPACE_AFTER) {
    5442:	f1bb 0f03 	cmp.w	fp, #3
    5446:	d103      	bne.n	5450 <_printk_dec_ulong+0x70>
		remaining = min_width - digits;
    5448:	9b01      	ldr	r3, [sp, #4]
    544a:	1b9c      	subs	r4, r3, r6
		while (remaining-- > 0) {
    544c:	2c00      	cmp	r4, #0
    544e:	dc0f      	bgt.n	5470 <_printk_dec_ulong+0x90>
			out(' ', ctx);
		}
	}
}
    5450:	b005      	add	sp, #20
    5452:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
    5456:	9b01      	ldr	r3, [sp, #4]
    5458:	42bb      	cmp	r3, r7
    545a:	dbe3      	blt.n	5424 <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
    545c:	f1bb 0f02 	cmp.w	fp, #2
    5460:	d8e0      	bhi.n	5424 <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    5462:	4649      	mov	r1, r9
    5464:	9802      	ldr	r0, [sp, #8]
    5466:	9203      	str	r2, [sp, #12]
			digits++;
    5468:	3601      	adds	r6, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    546a:	47c0      	blx	r8
			digits++;
    546c:	9a03      	ldr	r2, [sp, #12]
    546e:	e7d9      	b.n	5424 <_printk_dec_ulong+0x44>
			out(' ', ctx);
    5470:	4649      	mov	r1, r9
    5472:	2020      	movs	r0, #32
    5474:	47c0      	blx	r8
    5476:	3c01      	subs	r4, #1
    5478:	e7e8      	b.n	544c <_printk_dec_ulong+0x6c>
    547a:	bf00      	nop
    547c:	3b9ac9ff 	.word	0x3b9ac9ff

00005480 <__printk_hook_install>:
	_char_out = fn;
    5480:	4b01      	ldr	r3, [pc, #4]	; (5488 <__printk_hook_install+0x8>)
    5482:	6018      	str	r0, [r3, #0]
}
    5484:	4770      	bx	lr
    5486:	bf00      	nop
    5488:	20010cdc 	.word	0x20010cdc

0000548c <vprintk>:
{
    548c:	b507      	push	{r0, r1, r2, lr}
	struct out_context ctx = { 0 };
    548e:	2300      	movs	r3, #0
    5490:	9301      	str	r3, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
    5492:	4602      	mov	r2, r0
    5494:	460b      	mov	r3, r1
    5496:	4803      	ldr	r0, [pc, #12]	; (54a4 <vprintk+0x18>)
    5498:	a901      	add	r1, sp, #4
    549a:	f00c fb60 	bl	11b5e <z_vprintk>
}
    549e:	b003      	add	sp, #12
    54a0:	f85d fb04 	ldr.w	pc, [sp], #4
    54a4:	000053d1 	.word	0x000053d1

000054a8 <nordicsemi_nrf52_init>:
	nrf_power_gpregret_set((uint8_t)type);
	NVIC_SystemReset();
}

static int nordicsemi_nrf52_init(struct device *arg)
{
    54a8:	b510      	push	{r4, lr}
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    54aa:	f04f 0320 	mov.w	r3, #32
    54ae:	f3ef 8411 	mrs	r4, BASEPRI
    54b2:	f383 8811 	msr	BASEPRI, r3
    54b6:	f3bf 8f6f 	isb	sy

	ARG_UNUSED(arg);

	key = irq_lock();

	SystemInit();
    54ba:	f000 f827 	bl	550c <SystemInit>

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    54be:	4a09      	ldr	r2, [pc, #36]	; (54e4 <nordicsemi_nrf52_init+0x3c>)
    54c0:	2301      	movs	r3, #1
    54c2:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
__STATIC_INLINE void nrf_power_dcdcen_set(bool enable)
{
    NRF_POWER->DCDCEN = (enable ?
    54c6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    54ca:	f8c2 3578 	str.w	r3, [r2, #1400]	; 0x578
static ALWAYS_INLINE void z_clearfaults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    54ce:	4b06      	ldr	r3, [pc, #24]	; (54e8 <nordicsemi_nrf52_init+0x40>)
    54d0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    54d4:	629a      	str	r2, [r3, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    54d6:	62da      	str	r2, [r3, #44]	; 0x2c
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    54d8:	f384 8811 	msr	BASEPRI, r4
    54dc:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    54e0:	2000      	movs	r0, #0
    54e2:	bd10      	pop	{r4, pc}
    54e4:	4001e000 	.word	0x4001e000
    54e8:	e000ed00 	.word	0xe000ed00

000054ec <errata_103>:
}


static bool errata_98(void)
{
    if (*(uint32_t *)0x10000130ul == 0x8ul){
    54ec:	4b05      	ldr	r3, [pc, #20]	; (5504 <errata_103+0x18>)
    54ee:	681b      	ldr	r3, [r3, #0]
    54f0:	2b08      	cmp	r3, #8
        if (*(uint32_t *)0x10000134ul == 0x0ul){
    54f2:	bf01      	itttt	eq
    54f4:	4b04      	ldreq	r3, [pc, #16]	; (5508 <errata_103+0x1c>)
    54f6:	6818      	ldreq	r0, [r3, #0]
    54f8:	fab0 f080 	clzeq	r0, r0
    54fc:	0940      	lsreq	r0, r0, #5
            return true;
        }
    }
    
    return false;
    54fe:	bf18      	it	ne
    5500:	2000      	movne	r0, #0
}
    5502:	4770      	bx	lr
    5504:	10000130 	.word	0x10000130
    5508:	10000134 	.word	0x10000134

0000550c <SystemInit>:
{
    550c:	b508      	push	{r3, lr}
        NRF_CLOCK->EVENTS_DONE = 0;
    550e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    5512:	2200      	movs	r2, #0
    5514:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
    5518:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
    551c:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    5520:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    5524:	f503 4340 	add.w	r3, r3, #49152	; 0xc000
    5528:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    552c:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    5530:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    5534:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    5538:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    553c:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    5540:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    5544:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    5548:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    554c:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    5550:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    5554:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    5558:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    555c:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    5560:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    5564:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    5568:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    556c:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    5570:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    5574:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    5578:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    557c:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    5580:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    5584:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    5588:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    558c:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    5590:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    5594:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    5598:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    559c:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    55a0:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    55a4:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    55a8:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    55ac:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    if (errata_98()){
    55b0:	f7ff ff9c 	bl	54ec <errata_103>
    55b4:	b110      	cbz	r0, 55bc <SystemInit+0xb0>
        *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
    55b6:	4b33      	ldr	r3, [pc, #204]	; (5684 <SystemInit+0x178>)
    55b8:	4a33      	ldr	r2, [pc, #204]	; (5688 <SystemInit+0x17c>)
    55ba:	601a      	str	r2, [r3, #0]
    if (errata_103()){
    55bc:	f7ff ff96 	bl	54ec <errata_103>
    55c0:	b118      	cbz	r0, 55ca <SystemInit+0xbe>
        NRF_CCM->MAXPACKETSIZE = 0xFBul;
    55c2:	4b32      	ldr	r3, [pc, #200]	; (568c <SystemInit+0x180>)
    55c4:	22fb      	movs	r2, #251	; 0xfb
    55c6:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    if (errata_115()){
    55ca:	f7ff ff8f 	bl	54ec <errata_103>
    55ce:	b148      	cbz	r0, 55e4 <SystemInit+0xd8>
        *(volatile uint32_t *)0x40000EE4 = (*(volatile uint32_t *)0x40000EE4 & 0xFFFFFFF0) | (*(uint32_t *)0x10000258 & 0x0000000F);
    55d0:	492f      	ldr	r1, [pc, #188]	; (5690 <SystemInit+0x184>)
    55d2:	4b30      	ldr	r3, [pc, #192]	; (5694 <SystemInit+0x188>)
    55d4:	680a      	ldr	r2, [r1, #0]
    55d6:	681b      	ldr	r3, [r3, #0]
    55d8:	f022 020f 	bic.w	r2, r2, #15
    55dc:	f003 030f 	and.w	r3, r3, #15
    55e0:	4313      	orrs	r3, r2
    55e2:	600b      	str	r3, [r1, #0]
    if (errata_120()){
    55e4:	f7ff ff82 	bl	54ec <errata_103>
    55e8:	b118      	cbz	r0, 55f2 <SystemInit+0xe6>
        *(volatile uint32_t *)0x40029640ul = 0x200ul;
    55ea:	4b2b      	ldr	r3, [pc, #172]	; (5698 <SystemInit+0x18c>)
    55ec:	f44f 7200 	mov.w	r2, #512	; 0x200
    55f0:	601a      	str	r2, [r3, #0]
        if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    55f2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    55f6:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    55fa:	07d2      	lsls	r2, r2, #31
            NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
    55fc:	bf44      	itt	mi
    55fe:	f06f 0201 	mvnmi.w	r2, #1
    5602:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    5606:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    560a:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    560e:	2a00      	cmp	r2, #0
    5610:	db03      	blt.n	561a <SystemInit+0x10e>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
    5612:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    5616:	2b00      	cmp	r3, #0
    5618:	da2f      	bge.n	567a <SystemInit+0x16e>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
    561a:	4b20      	ldr	r3, [pc, #128]	; (569c <SystemInit+0x190>)
    561c:	2201      	movs	r2, #1
    561e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    5622:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    5626:	2a00      	cmp	r2, #0
    5628:	d0fb      	beq.n	5622 <SystemInit+0x116>
            NRF_UICR->PSELRESET[0] = 18;
    562a:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
    562e:	2112      	movs	r1, #18
    5630:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    5634:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    5638:	2a00      	cmp	r2, #0
    563a:	d0fb      	beq.n	5634 <SystemInit+0x128>
            NRF_UICR->PSELRESET[1] = 18;
    563c:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    5640:	2212      	movs	r2, #18
    5642:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    5646:	4b15      	ldr	r3, [pc, #84]	; (569c <SystemInit+0x190>)
    5648:	461a      	mov	r2, r3
    564a:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
    564e:	2900      	cmp	r1, #0
    5650:	d0fb      	beq.n	564a <SystemInit+0x13e>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
    5652:	2100      	movs	r1, #0
    5654:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    5658:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    565c:	2b00      	cmp	r3, #0
    565e:	d0fb      	beq.n	5658 <SystemInit+0x14c>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    5660:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5664:	490e      	ldr	r1, [pc, #56]	; (56a0 <SystemInit+0x194>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5666:	4b0f      	ldr	r3, [pc, #60]	; (56a4 <SystemInit+0x198>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5668:	68ca      	ldr	r2, [r1, #12]
    566a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    566e:	4313      	orrs	r3, r2
    5670:	60cb      	str	r3, [r1, #12]
    5672:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    5676:	bf00      	nop
    5678:	e7fd      	b.n	5676 <SystemInit+0x16a>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    567a:	4b0b      	ldr	r3, [pc, #44]	; (56a8 <SystemInit+0x19c>)
    567c:	4a0b      	ldr	r2, [pc, #44]	; (56ac <SystemInit+0x1a0>)
    567e:	601a      	str	r2, [r3, #0]
}
    5680:	bd08      	pop	{r3, pc}
    5682:	bf00      	nop
    5684:	4000568c 	.word	0x4000568c
    5688:	00038148 	.word	0x00038148
    568c:	4000f000 	.word	0x4000f000
    5690:	40000ee4 	.word	0x40000ee4
    5694:	10000258 	.word	0x10000258
    5698:	40029640 	.word	0x40029640
    569c:	4001e000 	.word	0x4001e000
    56a0:	e000ed00 	.word	0xe000ed00
    56a4:	05fa0004 	.word	0x05fa0004
    56a8:	20010ce0 	.word	0x20010ce0
    56ac:	03d09000 	.word	0x03d09000

000056b0 <nrfx_systick_delay_ticks>:
    return (diff >= nrfx_systick_us_tick(us));
}

void nrfx_systick_delay_ticks(uint32_t ticks)
{
    NRFX_ASSERT(ticks <= NRFX_SYSTICK_TICKS_MAX);
    56b0:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
{
    56b4:	b508      	push	{r3, lr}
    NRFX_ASSERT(ticks <= NRFX_SYSTICK_TICKS_MAX);
    56b6:	d305      	bcc.n	56c4 <nrfx_systick_delay_ticks+0x14>
    56b8:	4b07      	ldr	r3, [pc, #28]	; (56d8 <nrfx_systick_delay_ticks+0x28>)
    56ba:	4a08      	ldr	r2, [pc, #32]	; (56dc <nrfx_systick_delay_ticks+0x2c>)
    56bc:	4808      	ldr	r0, [pc, #32]	; (56e0 <nrfx_systick_delay_ticks+0x30>)
    56be:	2187      	movs	r1, #135	; 0x87
    56c0:	f7fb f85c 	bl	77c <__assert_func>
    SysTick->LOAD = val;
}

__STATIC_INLINE uint32_t nrf_systick_val_get(void)
{
    return SysTick->VAL;
    56c4:	4a07      	ldr	r2, [pc, #28]	; (56e4 <nrfx_systick_delay_ticks+0x34>)
    56c6:	6891      	ldr	r1, [r2, #8]
    56c8:	6893      	ldr	r3, [r2, #8]

    const uint32_t start = nrf_systick_val_get();
    while ((NRF_SYSTICK_VAL_MASK & (start - nrf_systick_val_get())) < ticks)
    56ca:	1acb      	subs	r3, r1, r3
    56cc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    56d0:	4283      	cmp	r3, r0
    56d2:	d3f9      	bcc.n	56c8 <nrfx_systick_delay_ticks+0x18>
    {
        /* Nothing to do */
    }
}
    56d4:	bd08      	pop	{r3, pc}
    56d6:	bf00      	nop
    56d8:	00017524 	.word	0x00017524
    56dc:	000174f5 	.word	0x000174f5
    56e0:	0001758d 	.word	0x0001758d
    56e4:	e000e010 	.word	0xe000e010

000056e8 <nrfx_systick_delay_us>:

void nrfx_systick_delay_us(uint32_t us)
{
    56e8:	b508      	push	{r3, lr}
    NRFX_SYSTICK_ASSERT_TIMEOUT(us);
    56ea:	4b0a      	ldr	r3, [pc, #40]	; (5714 <nrfx_systick_delay_us+0x2c>)
    56ec:	4a0a      	ldr	r2, [pc, #40]	; (5718 <nrfx_systick_delay_us+0x30>)
    56ee:	681b      	ldr	r3, [r3, #0]
    56f0:	fbb3 f3f2 	udiv	r3, r3, r2
    56f4:	4a09      	ldr	r2, [pc, #36]	; (571c <nrfx_systick_delay_us+0x34>)
    56f6:	fbb2 f2f3 	udiv	r2, r2, r3
    56fa:	4282      	cmp	r2, r0
    56fc:	d205      	bcs.n	570a <nrfx_systick_delay_us+0x22>
    56fe:	4b08      	ldr	r3, [pc, #32]	; (5720 <nrfx_systick_delay_us+0x38>)
    5700:	4a08      	ldr	r2, [pc, #32]	; (5724 <nrfx_systick_delay_us+0x3c>)
    5702:	4809      	ldr	r0, [pc, #36]	; (5728 <nrfx_systick_delay_us+0x40>)
    5704:	2192      	movs	r1, #146	; 0x92
    5706:	f7fb f839 	bl	77c <__assert_func>
    nrfx_systick_delay_ticks(nrfx_systick_us_tick(us));
    570a:	4358      	muls	r0, r3
}
    570c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_systick_delay_ticks(nrfx_systick_us_tick(us));
    5710:	f7ff bfce 	b.w	56b0 <nrfx_systick_delay_ticks>
    5714:	20010ce0 	.word	0x20010ce0
    5718:	000f4240 	.word	0x000f4240
    571c:	007fffff 	.word	0x007fffff
    5720:	00017543 	.word	0x00017543
    5724:	0001750e 	.word	0x0001750e
    5728:	0001758d 	.word	0x0001758d

0000572c <nrfx_usbd_errata_type_52840_eng_b>:
#define NRFX_USBD_ERRATA_ENABLE 1
#endif

static inline bool nrfx_usbd_errata_type_52840(void)
{
    return (*(uint32_t *)0x10000130UL == 0x8UL);
    572c:	4b05      	ldr	r3, [pc, #20]	; (5744 <nrfx_usbd_errata_type_52840_eng_b+0x18>)
    return nrfx_usbd_errata_type_52840();
}

static inline bool nrfx_usbd_errata_type_52840_eng_b(void)
{
    return (nrfx_usbd_errata_type_52840() && (*(uint32_t *)0x10000134UL >= 0x1UL));
    572e:	681b      	ldr	r3, [r3, #0]
    5730:	2b08      	cmp	r3, #8
    5732:	d105      	bne.n	5740 <nrfx_usbd_errata_type_52840_eng_b+0x14>
    5734:	4b04      	ldr	r3, [pc, #16]	; (5748 <nrfx_usbd_errata_type_52840_eng_b+0x1c>)
    5736:	6818      	ldr	r0, [r3, #0]
    5738:	3000      	adds	r0, #0
    573a:	bf18      	it	ne
    573c:	2001      	movne	r0, #1
    573e:	4770      	bx	lr
    5740:	2000      	movs	r0, #0
}
    5742:	4770      	bx	lr
    5744:	10000130 	.word	0x10000130
    5748:	10000134 	.word	0x10000134

0000574c <usbd_dma_pending_clear>:
 */
static inline void usbd_dma_pending_clear(void)
{
    if (nrfx_usbd_errata_199())
    {
        *((volatile uint32_t *)0x40027C1C) = 0x00000000;
    574c:	4a02      	ldr	r2, [pc, #8]	; (5758 <usbd_dma_pending_clear+0xc>)
    574e:	2300      	movs	r3, #0
    5750:	6013      	str	r3, [r2, #0]
    }
    m_dma_pending = false;
    5752:	4a02      	ldr	r2, [pc, #8]	; (575c <usbd_dma_pending_clear+0x10>)
    5754:	7013      	strb	r3, [r2, #0]
}
    5756:	4770      	bx	lr
    5758:	40027c1c 	.word	0x40027c1c
    575c:	200058b6 	.word	0x200058b6

00005760 <ev_usbreset_handler>:
 * Interrupt runtimes that would be vectorized using @ref m_isr.
 * @{
 */

static void ev_usbreset_handler(void)
{
    5760:	b507      	push	{r0, r1, r2, lr}
    m_bus_suspend = false;
    5762:	4a08      	ldr	r2, [pc, #32]	; (5784 <ev_usbreset_handler+0x24>)
    5764:	2300      	movs	r3, #0
    5766:	7013      	strb	r3, [r2, #0]
    m_last_setup_dir = NRFX_USBD_EPOUT0;
    5768:	4a07      	ldr	r2, [pc, #28]	; (5788 <ev_usbreset_handler+0x28>)

    const nrfx_usbd_evt_t evt = {
    576a:	9301      	str	r3, [sp, #4]
    m_last_setup_dir = NRFX_USBD_EPOUT0;
    576c:	7013      	strb	r3, [r2, #0]
    const nrfx_usbd_evt_t evt = {
    576e:	2301      	movs	r3, #1
    5770:	f88d 3004 	strb.w	r3, [sp, #4]
            .type = NRFX_USBD_EVT_RESET
    };

    m_event_handler(&evt);
    5774:	4b05      	ldr	r3, [pc, #20]	; (578c <ev_usbreset_handler+0x2c>)
    5776:	a801      	add	r0, sp, #4
    5778:	681b      	ldr	r3, [r3, #0]
    577a:	4798      	blx	r3
}
    577c:	b003      	add	sp, #12
    577e:	f85d fb04 	ldr.w	pc, [sp], #4
    5782:	bf00      	nop
    5784:	200058b5 	.word	0x200058b5
    5788:	200058b8 	.word	0x200058b8
    578c:	200024f0 	.word	0x200024f0

00005790 <task_start_ep>:
{
    5790:	b508      	push	{r3, lr}
    5792:	f000 030f 	and.w	r3, r0, #15
    NRFX_USBD_ASSERT_EP_VALID(ep);
    5796:	2b08      	cmp	r3, #8
    5798:	d906      	bls.n	57a8 <task_start_ep+0x18>
    579a:	4b07      	ldr	r3, [pc, #28]	; (57b8 <task_start_ep+0x28>)
    579c:	4a07      	ldr	r2, [pc, #28]	; (57bc <task_start_ep+0x2c>)
    579e:	4808      	ldr	r0, [pc, #32]	; (57c0 <task_start_ep+0x30>)
    57a0:	f240 2192 	movw	r1, #658	; 0x292
    57a4:	f7fa ffea 	bl	77c <__assert_func>
    return (nrf_usbd_task_t)(
    57a8:	f010 0f80 	tst.w	r0, #128	; 0x80
    57ac:	bf14      	ite	ne
    57ae:	2004      	movne	r0, #4
    57b0:	2028      	moveq	r0, #40	; 0x28
}
    57b2:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    57b6:	bd08      	pop	{r3, pc}
    57b8:	00017bbe 	.word	0x00017bbe
    57bc:	000176fc 	.word	0x000176fc
    57c0:	00017c80 	.word	0x00017c80

000057c4 <usbd_ep_data_handler>:
 * Auxiliary internal function.
 * @param ep     Endpoint number.
 * @param bitpos Bit position for selected endpoint number.
 */
static void usbd_ep_data_handler(nrfx_usbd_ep_t ep, uint8_t bitpos)
{
    57c4:	b513      	push	{r0, r1, r4, lr}
    NRFX_LOG_DEBUG("USBD event: EndpointData: %x", ep);
    /* Mark endpoint ready for next DMA access */
    m_ep_ready |= (1U << bitpos);
    57c6:	4c12      	ldr	r4, [pc, #72]	; (5810 <usbd_ep_data_handler+0x4c>)
    57c8:	2201      	movs	r2, #1
    57ca:	6823      	ldr	r3, [r4, #0]
    57cc:	fa02 f101 	lsl.w	r1, r2, r1
    57d0:	430b      	orrs	r3, r1
    57d2:	6023      	str	r3, [r4, #0]

    if (NRF_USBD_EPIN_CHECK(ep))
    57d4:	4b0f      	ldr	r3, [pc, #60]	; (5814 <usbd_ep_data_handler+0x50>)
    57d6:	681b      	ldr	r3, [r3, #0]
    57d8:	4019      	ands	r1, r3
    57da:	0603      	lsls	r3, r0, #24
    57dc:	d50d      	bpl.n	57fa <usbd_ep_data_handler+0x36>
    {
        /* IN endpoint (Device -> Host) */
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
    57de:	b951      	cbnz	r1, 57f6 <usbd_ep_data_handler+0x32>
        {
            NRFX_LOG_DEBUG("USBD event: EndpointData: In finished");
            /* No more data to be send - transmission finished */
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    57e0:	2306      	movs	r3, #6
    57e2:	f88d 3004 	strb.w	r3, [sp, #4]
    57e6:	f88d 0006 	strb.w	r0, [sp, #6]
    57ea:	f88d 1007 	strb.w	r1, [sp, #7]
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
        {
            NRFX_LOG_DEBUG("USBD event: EndpointData: Out waiting");
            /* No buffer prepared - send event to the application */
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_WAITING);
            m_event_handler(&evt);
    57ee:	4b0a      	ldr	r3, [pc, #40]	; (5818 <usbd_ep_data_handler+0x54>)
    57f0:	a801      	add	r0, sp, #4
    57f2:	681b      	ldr	r3, [r3, #0]
    57f4:	4798      	blx	r3
        }
    }
}
    57f6:	b002      	add	sp, #8
    57f8:	bd10      	pop	{r4, pc}
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
    57fa:	2900      	cmp	r1, #0
    57fc:	d1fb      	bne.n	57f6 <usbd_ep_data_handler+0x32>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_WAITING);
    57fe:	2306      	movs	r3, #6
    5800:	f88d 3004 	strb.w	r3, [sp, #4]
    5804:	f88d 0006 	strb.w	r0, [sp, #6]
    5808:	f88d 2007 	strb.w	r2, [sp, #7]
    580c:	e7ef      	b.n	57ee <usbd_ep_data_handler+0x2a>
    580e:	bf00      	nop
    5810:	200023cc 	.word	0x200023cc
    5814:	2000235c 	.word	0x2000235c
    5818:	200024f0 	.word	0x200024f0

0000581c <nrfx_usbd_consumer>:
    NRFX_ASSERT(ep_size >= data_size);
    581c:	429a      	cmp	r2, r3
{
    581e:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(ep_size >= data_size);
    5820:	d206      	bcs.n	5830 <nrfx_usbd_consumer+0x14>
    5822:	4b15      	ldr	r3, [pc, #84]	; (5878 <nrfx_usbd_consumer+0x5c>)
    5824:	4a15      	ldr	r2, [pc, #84]	; (587c <nrfx_usbd_consumer+0x60>)
    5826:	f44f 71e9 	mov.w	r1, #466	; 0x1d2
    NRFX_ASSERT((p_transfer->p_data.rx == NULL) ||
    582a:	4815      	ldr	r0, [pc, #84]	; (5880 <nrfx_usbd_consumer+0x64>)
    582c:	f7fa ffa6 	bl	77c <__assert_func>
    5830:	680c      	ldr	r4, [r1, #0]
    5832:	b14c      	cbz	r4, 5848 <nrfx_usbd_consumer+0x2c>

#ifndef SUPPRESS_INLINE_IMPLEMENTATION

__STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
    5834:	f004 4460 	and.w	r4, r4, #3758096384	; 0xe0000000
    5838:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
    583c:	d004      	beq.n	5848 <nrfx_usbd_consumer+0x2c>
    583e:	4b11      	ldr	r3, [pc, #68]	; (5884 <nrfx_usbd_consumer+0x68>)
    5840:	4a0e      	ldr	r2, [pc, #56]	; (587c <nrfx_usbd_consumer+0x60>)
    5842:	f44f 71ea 	mov.w	r1, #468	; 0x1d4
    5846:	e7f0      	b.n	582a <nrfx_usbd_consumer+0xe>
    size_t size = p_transfer->size;
    5848:	684c      	ldr	r4, [r1, #4]
    if (size < data_size)
    584a:	680d      	ldr	r5, [r1, #0]
    584c:	42a3      	cmp	r3, r4
        p_next->p_data = p_transfer->p_data;
    584e:	bf9b      	ittet	ls
    5850:	e9c0 5300 	strdls	r5, r3, [r0]
        p_transfer->p_data.addr += data_size;
    5854:	6808      	ldrls	r0, [r1, #0]
        p_next->size = 0;
    5856:	2100      	movhi	r1, #0
        size -= data_size;
    5858:	1ae4      	subls	r4, r4, r3
        p_transfer->p_data.addr += data_size;
    585a:	bf97      	itett	ls
    585c:	18c0      	addls	r0, r0, r3
        p_next->p_data = p_transfer->p_data;
    585e:	e9c0 5100 	strdhi	r5, r1, [r0]
        p_transfer->size = size;
    5862:	604c      	strls	r4, [r1, #4]
        p_transfer->p_data.addr += data_size;
    5864:	6008      	strls	r0, [r1, #0]
    return (ep_size == data_size) && (size != 0);
    5866:	429a      	cmp	r2, r3
    5868:	d103      	bne.n	5872 <nrfx_usbd_consumer+0x56>
    586a:	1c20      	adds	r0, r4, #0
    586c:	bf18      	it	ne
    586e:	2001      	movne	r0, #1
}
    5870:	bd38      	pop	{r3, r4, r5, pc}
    return (ep_size == data_size) && (size != 0);
    5872:	2000      	movs	r0, #0
    5874:	e7fc      	b.n	5870 <nrfx_usbd_consumer+0x54>
    5876:	bf00      	nop
    5878:	00017914 	.word	0x00017914
    587c:	0001767f 	.word	0x0001767f
    5880:	00017c80 	.word	0x00017c80
    5884:	00017929 	.word	0x00017929

00005888 <nrfx_usbd_feeder_ram>:
{
    5888:	b510      	push	{r4, lr}
    588a:	680c      	ldr	r4, [r1, #0]
    588c:	f004 4360 	and.w	r3, r4, #3758096384	; 0xe0000000
    NRFX_ASSERT(nrfx_is_in_ram(p_transfer->p_data.tx));
    5890:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    5894:	d006      	beq.n	58a4 <nrfx_usbd_feeder_ram+0x1c>
    5896:	4b0a      	ldr	r3, [pc, #40]	; (58c0 <nrfx_usbd_feeder_ram+0x38>)
    5898:	4a0a      	ldr	r2, [pc, #40]	; (58c4 <nrfx_usbd_feeder_ram+0x3c>)
    589a:	480b      	ldr	r0, [pc, #44]	; (58c8 <nrfx_usbd_feeder_ram+0x40>)
    589c:	f240 11f9 	movw	r1, #505	; 0x1f9
    58a0:	f7fa ff6c 	bl	77c <__assert_func>
    size_t tx_size = p_transfer->size;
    58a4:	684b      	ldr	r3, [r1, #4]
    if (tx_size > ep_size)
    58a6:	429a      	cmp	r2, r3
    58a8:	bf28      	it	cs
    58aa:	461a      	movcs	r2, r3
    p_next->size = tx_size;
    58ac:	e9c0 4200 	strd	r4, r2, [r0]
    p_transfer->size -= tx_size;
    58b0:	1a98      	subs	r0, r3, r2
    58b2:	6048      	str	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
    58b4:	4414      	add	r4, r2
}
    58b6:	3000      	adds	r0, #0
    p_transfer->p_data.addr += tx_size;
    58b8:	600c      	str	r4, [r1, #0]
}
    58ba:	bf18      	it	ne
    58bc:	2001      	movne	r0, #1
    58be:	bd10      	pop	{r4, pc}
    58c0:	00017b29 	.word	0x00017b29
    58c4:	00017692 	.word	0x00017692
    58c8:	00017c80 	.word	0x00017c80

000058cc <nrfx_usbd_feeder_ram_zlp>:
{
    58cc:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(nrfx_is_in_ram(p_transfer->p_data.tx));
    58ce:	680b      	ldr	r3, [r1, #0]
    58d0:	f003 4460 	and.w	r4, r3, #3758096384	; 0xe0000000
    58d4:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
    58d8:	461d      	mov	r5, r3
    58da:	d006      	beq.n	58ea <nrfx_usbd_feeder_ram_zlp+0x1e>
    58dc:	4b0c      	ldr	r3, [pc, #48]	; (5910 <nrfx_usbd_feeder_ram_zlp+0x44>)
    58de:	4a0d      	ldr	r2, [pc, #52]	; (5914 <nrfx_usbd_feeder_ram_zlp+0x48>)
    58e0:	480d      	ldr	r0, [pc, #52]	; (5918 <nrfx_usbd_feeder_ram_zlp+0x4c>)
    58e2:	f240 211a 	movw	r1, #538	; 0x21a
    58e6:	f7fa ff49 	bl	77c <__assert_func>
    size_t tx_size = p_transfer->size;
    58ea:	684c      	ldr	r4, [r1, #4]
    if (tx_size > ep_size)
    58ec:	42a2      	cmp	r2, r4
    58ee:	bf28      	it	cs
    58f0:	4622      	movcs	r2, r4
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
    58f2:	2a00      	cmp	r2, #0
    58f4:	bf08      	it	eq
    58f6:	2300      	moveq	r3, #0
    p_next->size = tx_size;
    58f8:	e9c0 3200 	strd	r3, r2, [r0]
    p_transfer->size -= tx_size;
    58fc:	eba4 0402 	sub.w	r4, r4, r2
    p_transfer->p_data.addr += tx_size;
    5900:	442a      	add	r2, r5
    p_transfer->size -= tx_size;
    5902:	604c      	str	r4, [r1, #4]
    p_transfer->p_data.addr += tx_size;
    5904:	600a      	str	r2, [r1, #0]
}
    5906:	bf14      	ite	ne
    5908:	2001      	movne	r0, #1
    590a:	2000      	moveq	r0, #0
    590c:	bd38      	pop	{r3, r4, r5, pc}
    590e:	bf00      	nop
    5910:	00017b29 	.word	0x00017b29
    5914:	000176a7 	.word	0x000176a7
    5918:	00017c80 	.word	0x00017c80

0000591c <ep_state_access.part.5>:
static inline usbd_ep_state_t* ep_state_access(nrfx_usbd_ep_t ep)
    591c:	b508      	push	{r3, lr}
    NRFX_USBD_ASSERT_EP_VALID(ep);
    591e:	4a03      	ldr	r2, [pc, #12]	; (592c <ep_state_access.part.5+0x10>)
    5920:	4b03      	ldr	r3, [pc, #12]	; (5930 <ep_state_access.part.5+0x14>)
    5922:	4804      	ldr	r0, [pc, #16]	; (5934 <ep_state_access.part.5+0x18>)
    5924:	f240 21a2 	movw	r1, #674	; 0x2a2
    5928:	f7fa ff28 	bl	77c <__assert_func>
    592c:	0001770a 	.word	0x0001770a
    5930:	00017bbe 	.word	0x00017bbe
    5934:	00017c80 	.word	0x00017c80

00005938 <ep_state_access>:
    5938:	f000 020f 	and.w	r2, r0, #15
    593c:	2a08      	cmp	r2, #8
{
    593e:	b508      	push	{r3, lr}
    NRFX_USBD_ASSERT_EP_VALID(ep);
    5940:	d901      	bls.n	5946 <ep_state_access+0xe>
    5942:	f7ff ffeb 	bl	591c <ep_state_access.part.5>
    return ((NRF_USBD_EPIN_CHECK(ep) ? m_ep_state.ep_in : m_ep_state.ep_out) +
    5946:	4b05      	ldr	r3, [pc, #20]	; (595c <ep_state_access+0x24>)
    5948:	f010 0f80 	tst.w	r0, #128	; 0x80
    594c:	f1a3 0090 	sub.w	r0, r3, #144	; 0x90
    5950:	bf18      	it	ne
    5952:	4618      	movne	r0, r3
}
    5954:	eb00 1002 	add.w	r0, r0, r2, lsl #4
    5958:	bd08      	pop	{r3, pc}
    595a:	bf00      	nop
    595c:	20002460 	.word	0x20002460

00005960 <ep2bit.part.6>:
static inline uint8_t ep2bit(nrfx_usbd_ep_t ep)
    5960:	b508      	push	{r3, lr}
    NRFX_USBD_ASSERT_EP_VALID(ep);
    5962:	4a03      	ldr	r2, [pc, #12]	; (5970 <ep2bit.part.6+0x10>)
    5964:	4b03      	ldr	r3, [pc, #12]	; (5974 <ep2bit.part.6+0x14>)
    5966:	4804      	ldr	r0, [pc, #16]	; (5978 <ep2bit.part.6+0x18>)
    5968:	f240 21b5 	movw	r1, #693	; 0x2b5
    596c:	f7fa ff06 	bl	77c <__assert_func>
    5970:	0001771a 	.word	0x0001771a
    5974:	00017bbe 	.word	0x00017bbe
    5978:	00017c80 	.word	0x00017c80

0000597c <ev_setup_data_handler>:

static void ev_setup_data_handler(void)
{
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
    597c:	4b05      	ldr	r3, [pc, #20]	; (5994 <ev_setup_data_handler+0x18>)
{
    597e:	b510      	push	{r4, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
    5980:	781c      	ldrb	r4, [r3, #0]
    5982:	4620      	mov	r0, r4
    5984:	f00c fa57 	bl	11e36 <ep2bit>
    5988:	4601      	mov	r1, r0
    598a:	4620      	mov	r0, r4
}
    598c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
    5990:	f7ff bf18 	b.w	57c4 <usbd_ep_data_handler>
    5994:	200058b8 	.word	0x200058b8

00005998 <nrfx_usbd_ep_to_endevent.part.8>:
static inline nrf_usbd_event_t nrfx_usbd_ep_to_endevent(nrfx_usbd_ep_t ep)
    5998:	b508      	push	{r3, lr}
    NRFX_USBD_ASSERT_EP_VALID(ep);
    599a:	4a03      	ldr	r2, [pc, #12]	; (59a8 <nrfx_usbd_ep_to_endevent.part.8+0x10>)
    599c:	4b03      	ldr	r3, [pc, #12]	; (59ac <nrfx_usbd_ep_to_endevent.part.8+0x14>)
    599e:	4804      	ldr	r0, [pc, #16]	; (59b0 <nrfx_usbd_ep_to_endevent.part.8+0x18>)
    59a0:	f44f 71b9 	mov.w	r1, #370	; 0x172
    59a4:	f7fa feea 	bl	77c <__assert_func>
    59a8:	00017652 	.word	0x00017652
    59ac:	00017bbe 	.word	0x00017bbe
    59b0:	00017c80 	.word	0x00017c80

000059b4 <ep_to_hal.part.9>:
static inline uint8_t ep_to_hal(nrfx_usbd_ep_t ep)
    59b4:	b508      	push	{r3, lr}
    NRFX_USBD_ASSERT_EP_VALID(ep);
    59b6:	4a03      	ldr	r2, [pc, #12]	; (59c4 <ep_to_hal.part.9+0x10>)
    59b8:	4b03      	ldr	r3, [pc, #12]	; (59c8 <ep_to_hal.part.9+0x14>)
    59ba:	4804      	ldr	r0, [pc, #16]	; (59cc <ep_to_hal.part.9+0x18>)
    59bc:	f240 2185 	movw	r1, #645	; 0x285
    59c0:	f7fa fedc 	bl	77c <__assert_func>
    59c4:	000176f2 	.word	0x000176f2
    59c8:	00017bbe 	.word	0x00017bbe
    59cc:	00017c80 	.word	0x00017c80

000059d0 <nrf_usbd_ep_enable_check>:
    retval = ((NRF_USBD->DTOGGLE) & USBD_DTOGGLE_VALUE_Msk) >> USBD_DTOGGLE_VALUE_Pos;
    return (nrf_usbd_dtoggle_t)retval;
}

bool nrf_usbd_ep_enable_check(uint8_t ep)
{
    59d0:	b508      	push	{r3, lr}
    59d2:	f000 030f 	and.w	r3, r0, #15
    NRFX_ASSERT(NRF_USBD_EP_VALIDATE(ep));
    59d6:	2b08      	cmp	r3, #8
    59d8:	d906      	bls.n	59e8 <nrf_usbd_ep_enable_check+0x18>
    59da:	4b09      	ldr	r3, [pc, #36]	; (5a00 <nrf_usbd_ep_enable_check+0x30>)
    59dc:	4a09      	ldr	r2, [pc, #36]	; (5a04 <nrf_usbd_ep_enable_check+0x34>)
    59de:	480a      	ldr	r0, [pc, #40]	; (5a08 <nrf_usbd_ep_enable_check+0x38>)
    59e0:	f44f 6199 	mov.w	r1, #1224	; 0x4c8
    59e4:	f7fa feca 	bl	77c <__assert_func>
    uint8_t epnr = NRF_USBD_EP_NR_GET(ep);

    if (NRF_USBD_EPIN_CHECK(ep))
    59e8:	4a08      	ldr	r2, [pc, #32]	; (5a0c <nrf_usbd_ep_enable_check+0x3c>)
    59ea:	f010 0f80 	tst.w	r0, #128	; 0x80
    {
        return 0 != (NRF_USBD->EPINEN & (1UL << epnr));
    59ee:	bf14      	ite	ne
    59f0:	f8d2 0510 	ldrne.w	r0, [r2, #1296]	; 0x510
    }
    else
    {
        return 0 != (NRF_USBD->EPOUTEN & (1UL << epnr));
    59f4:	f8d2 0514 	ldreq.w	r0, [r2, #1300]	; 0x514
    59f8:	40d8      	lsrs	r0, r3
    59fa:	f000 0001 	and.w	r0, r0, #1
    }
}
    59fe:	bd08      	pop	{r3, pc}
    5a00:	0001782b 	.word	0x0001782b
    5a04:	00017613 	.word	0x00017613
    5a08:	000178ee 	.word	0x000178ee
    5a0c:	40027000 	.word	0x40027000

00005a10 <nrfx_usbd_ep_to_int.part.11>:
static inline uint32_t nrfx_usbd_ep_to_int(nrfx_usbd_ep_t ep)
    5a10:	b508      	push	{r3, lr}
    NRFX_USBD_ASSERT_EP_VALID(ep);
    5a12:	4a03      	ldr	r2, [pc, #12]	; (5a20 <nrfx_usbd_ep_to_int.part.11+0x10>)
    5a14:	4b03      	ldr	r3, [pc, #12]	; (5a24 <nrfx_usbd_ep_to_int.part.11+0x14>)
    5a16:	4804      	ldr	r0, [pc, #16]	; (5a28 <nrfx_usbd_ep_to_int.part.11+0x18>)
    5a18:	f240 119b 	movw	r1, #411	; 0x19b
    5a1c:	f7fa feae 	bl	77c <__assert_func>
    5a20:	0001766b 	.word	0x0001766b
    5a24:	00017bbe 	.word	0x00017bbe
    5a28:	00017c80 	.word	0x00017c80

00005a2c <nrfx_usbd_feeder_flash>:
{
    5a2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5a2e:	460d      	mov	r5, r1
    NRFX_ASSERT(!nrfx_is_in_ram(p_transfer->p_data.tx));
    5a30:	6809      	ldr	r1, [r1, #0]
    5a32:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
    5a36:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
{
    5a3a:	4606      	mov	r6, r0
    NRFX_ASSERT(!nrfx_is_in_ram(p_transfer->p_data.tx));
    5a3c:	d106      	bne.n	5a4c <nrfx_usbd_feeder_flash+0x20>
    5a3e:	4b12      	ldr	r3, [pc, #72]	; (5a88 <nrfx_usbd_feeder_flash+0x5c>)
    5a40:	4a12      	ldr	r2, [pc, #72]	; (5a8c <nrfx_usbd_feeder_flash+0x60>)
    5a42:	f44f 710e 	mov.w	r1, #568	; 0x238
    NRFX_ASSERT(tx_size <= NRFX_USBD_FEEDER_BUFFER_SIZE);
    5a46:	4812      	ldr	r0, [pc, #72]	; (5a90 <nrfx_usbd_feeder_flash+0x64>)
    5a48:	f7fa fe98 	bl	77c <__assert_func>
    size_t tx_size  = p_transfer->size;
    5a4c:	686c      	ldr	r4, [r5, #4]
    if (tx_size > ep_size)
    5a4e:	4294      	cmp	r4, r2
    5a50:	bf28      	it	cs
    5a52:	4614      	movcs	r4, r2
    NRFX_ASSERT(tx_size <= NRFX_USBD_FEEDER_BUFFER_SIZE);
    5a54:	2c40      	cmp	r4, #64	; 0x40
    5a56:	d904      	bls.n	5a62 <nrfx_usbd_feeder_flash+0x36>
    5a58:	4b0e      	ldr	r3, [pc, #56]	; (5a94 <nrfx_usbd_feeder_flash+0x68>)
    5a5a:	4a0c      	ldr	r2, [pc, #48]	; (5a8c <nrfx_usbd_feeder_flash+0x60>)
    5a5c:	f240 2142 	movw	r1, #578	; 0x242
    5a60:	e7f1      	b.n	5a46 <nrfx_usbd_feeder_flash+0x1a>
    memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
    5a62:	4f0d      	ldr	r7, [pc, #52]	; (5a98 <nrfx_usbd_feeder_flash+0x6c>)
    5a64:	4622      	mov	r2, r4
    5a66:	2340      	movs	r3, #64	; 0x40
    5a68:	4638      	mov	r0, r7
    5a6a:	f7fc fb91 	bl	2190 <__memcpy_chk>
    p_transfer->size -= tx_size;
    5a6e:	6868      	ldr	r0, [r5, #4]
    p_transfer->p_data.addr += tx_size;
    5a70:	682a      	ldr	r2, [r5, #0]
    p_transfer->size -= tx_size;
    5a72:	1b00      	subs	r0, r0, r4
    p_next->size = tx_size;
    5a74:	e9c6 7400 	strd	r7, r4, [r6]
    p_transfer->p_data.addr += tx_size;
    5a78:	4422      	add	r2, r4
    p_transfer->size -= tx_size;
    5a7a:	6068      	str	r0, [r5, #4]
}
    5a7c:	3000      	adds	r0, #0
    p_transfer->p_data.addr += tx_size;
    5a7e:	602a      	str	r2, [r5, #0]
}
    5a80:	bf18      	it	ne
    5a82:	2001      	movne	r0, #1
    5a84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5a86:	bf00      	nop
    5a88:	00017b28 	.word	0x00017b28
    5a8c:	000176c0 	.word	0x000176c0
    5a90:	00017c80 	.word	0x00017c80
    5a94:	00017b4f 	.word	0x00017b4f
    5a98:	200024f8 	.word	0x200024f8

00005a9c <nrfx_usbd_feeder_flash_zlp>:
{
    5a9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5a9e:	460d      	mov	r5, r1
    NRFX_ASSERT(!nrfx_is_in_ram(p_transfer->p_data.tx));
    5aa0:	6809      	ldr	r1, [r1, #0]
    5aa2:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
    5aa6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
{
    5aaa:	4606      	mov	r6, r0
    NRFX_ASSERT(!nrfx_is_in_ram(p_transfer->p_data.tx));
    5aac:	d106      	bne.n	5abc <nrfx_usbd_feeder_flash_zlp+0x20>
    5aae:	4b13      	ldr	r3, [pc, #76]	; (5afc <nrfx_usbd_feeder_flash_zlp+0x60>)
    5ab0:	4a13      	ldr	r2, [pc, #76]	; (5b00 <nrfx_usbd_feeder_flash_zlp+0x64>)
    5ab2:	f240 215b 	movw	r1, #603	; 0x25b
    NRFX_ASSERT(tx_size <= NRFX_USBD_FEEDER_BUFFER_SIZE);
    5ab6:	4813      	ldr	r0, [pc, #76]	; (5b04 <nrfx_usbd_feeder_flash_zlp+0x68>)
    5ab8:	f7fa fe60 	bl	77c <__assert_func>
    size_t tx_size  = p_transfer->size;
    5abc:	686c      	ldr	r4, [r5, #4]
    if (tx_size > ep_size)
    5abe:	4294      	cmp	r4, r2
    5ac0:	bf28      	it	cs
    5ac2:	4614      	movcs	r4, r2
    NRFX_ASSERT(tx_size <= NRFX_USBD_FEEDER_BUFFER_SIZE);
    5ac4:	2c40      	cmp	r4, #64	; 0x40
    5ac6:	d904      	bls.n	5ad2 <nrfx_usbd_feeder_flash_zlp+0x36>
    5ac8:	4b0f      	ldr	r3, [pc, #60]	; (5b08 <nrfx_usbd_feeder_flash_zlp+0x6c>)
    5aca:	4a0d      	ldr	r2, [pc, #52]	; (5b00 <nrfx_usbd_feeder_flash_zlp+0x64>)
    5acc:	f240 2165 	movw	r1, #613	; 0x265
    5ad0:	e7f1      	b.n	5ab6 <nrfx_usbd_feeder_flash_zlp+0x1a>
    if (tx_size != 0)
    5ad2:	b18c      	cbz	r4, 5af8 <nrfx_usbd_feeder_flash_zlp+0x5c>
        memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
    5ad4:	4f0d      	ldr	r7, [pc, #52]	; (5b0c <nrfx_usbd_feeder_flash_zlp+0x70>)
    5ad6:	2340      	movs	r3, #64	; 0x40
    5ad8:	4622      	mov	r2, r4
    5ada:	4638      	mov	r0, r7
    5adc:	f7fc fb58 	bl	2190 <__memcpy_chk>
        p_next->p_data.tx = p_buffer;
    5ae0:	6037      	str	r7, [r6, #0]
    p_transfer->size -= tx_size;
    5ae2:	686b      	ldr	r3, [r5, #4]
    p_next->size = tx_size;
    5ae4:	6074      	str	r4, [r6, #4]
    p_transfer->size -= tx_size;
    5ae6:	1b1b      	subs	r3, r3, r4
    5ae8:	606b      	str	r3, [r5, #4]
    p_transfer->p_data.addr += tx_size;
    5aea:	682b      	ldr	r3, [r5, #0]
}
    5aec:	1c20      	adds	r0, r4, #0
    p_transfer->p_data.addr += tx_size;
    5aee:	4423      	add	r3, r4
    5af0:	602b      	str	r3, [r5, #0]
}
    5af2:	bf18      	it	ne
    5af4:	2001      	movne	r0, #1
    5af6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        p_next->p_data.tx = NULL;
    5af8:	6004      	str	r4, [r0, #0]
    5afa:	e7f2      	b.n	5ae2 <nrfx_usbd_feeder_flash_zlp+0x46>
    5afc:	00017b28 	.word	0x00017b28
    5b00:	000176d7 	.word	0x000176d7
    5b04:	00017c80 	.word	0x00017c80
    5b08:	00017b4f 	.word	0x00017b4f
    5b0c:	200024f8 	.word	0x200024f8

00005b10 <ev_sof_handler>:
{
    5b10:	b507      	push	{r0, r1, r2, lr}
    nrfx_usbd_evt_t evt =  {
    5b12:	2300      	movs	r3, #0
    5b14:	f88d 3004 	strb.w	r3, [sp, #4]
        (((NRF_USBD->ISOSPLIT) & USBD_ISOSPLIT_SPLIT_Msk) >> USBD_ISOSPLIT_SPLIT_Pos);
}

uint32_t nrf_usbd_framecntr_get(void)
{
    return NRF_USBD->FRAMECNTR;
    5b18:	4b0b      	ldr	r3, [pc, #44]	; (5b48 <ev_sof_handler+0x38>)
    5b1a:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
    5b1e:	f8ad 2006 	strh.w	r2, [sp, #6]
    size_t size_isoout = NRF_USBD->SIZE.ISOOUT;
    5b22:	f8d3 34c0 	ldr.w	r3, [r3, #1216]	; 0x4c0
    m_ep_ready |= iso_ready_mask;
    5b26:	4a09      	ldr	r2, [pc, #36]	; (5b4c <ev_sof_handler+0x3c>)
    if (size_isoout == 0)
    5b28:	2b00      	cmp	r3, #0
    5b2a:	6813      	ldr	r3, [r2, #0]
        iso_ready_mask |= (1U << ep2bit(NRFX_USBD_EPOUT8));
    5b2c:	bf0c      	ite	eq
    5b2e:	f44f 7180 	moveq.w	r1, #256	; 0x100
    5b32:	f04f 2101 	movne.w	r1, #16777472	; 0x1000100
    m_ep_ready |= iso_ready_mask;
    5b36:	430b      	orrs	r3, r1
    5b38:	6013      	str	r3, [r2, #0]
    m_event_handler(&evt);
    5b3a:	4b05      	ldr	r3, [pc, #20]	; (5b50 <ev_sof_handler+0x40>)
    5b3c:	a801      	add	r0, sp, #4
    5b3e:	681b      	ldr	r3, [r3, #0]
    5b40:	4798      	blx	r3
}
    5b42:	b003      	add	sp, #12
    5b44:	f85d fb04 	ldr.w	pc, [sp], #4
    5b48:	40027000 	.word	0x40027000
    5b4c:	200023cc 	.word	0x200023cc
    5b50:	200024f0 	.word	0x200024f0

00005b54 <atomic_and.constprop.25>:
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    5b54:	4b07      	ldr	r3, [pc, #28]	; (5b74 <atomic_and.constprop.25+0x20>)
}
    5b56:	f3bf 8f5b 	dmb	ish
    5b5a:	4602      	mov	r2, r0
    5b5c:	e853 0f00 	ldrex	r0, [r3]
    5b60:	ea00 0102 	and.w	r1, r0, r2
    5b64:	e843 1c00 	strex	ip, r1, [r3]
    5b68:	f1bc 0f00 	cmp.w	ip, #0
    5b6c:	d1f6      	bne.n	5b5c <atomic_and.constprop.25+0x8>
    5b6e:	f3bf 8f5b 	dmb	ish
    5b72:	4770      	bx	lr
    5b74:	2000235c 	.word	0x2000235c

00005b78 <ev_dma_epin0_handler>:
static void ev_dma_epin0_handler(void)  { nrf_usbd_ep0in_dma_handler(); }
    5b78:	b508      	push	{r3, lr}
    usbd_dma_pending_clear();
    5b7a:	f7ff fde7 	bl	574c <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    5b7e:	4b08      	ldr	r3, [pc, #32]	; (5ba0 <ev_dma_epin0_handler+0x28>)
    5b80:	f893 209e 	ldrb.w	r2, [r3, #158]	; 0x9e
    5b84:	2a03      	cmp	r2, #3
    5b86:	d105      	bne.n	5b94 <ev_dma_epin0_handler+0x1c>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    5b88:	f06f 0001 	mvn.w	r0, #1
static void ev_dma_epin0_handler(void)  { nrf_usbd_ep0in_dma_handler(); }
    5b8c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    5b90:	f7ff bfe0 	b.w	5b54 <atomic_and.constprop.25>
    else if (p_state->handler.feeder == NULL)
    5b94:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    5b98:	2b00      	cmp	r3, #0
    5b9a:	d0f5      	beq.n	5b88 <ev_dma_epin0_handler+0x10>
static void ev_dma_epin0_handler(void)  { nrf_usbd_ep0in_dma_handler(); }
    5b9c:	bd08      	pop	{r3, pc}
    5b9e:	bf00      	nop
    5ba0:	200023d0 	.word	0x200023d0

00005ba4 <ev_dma_epout8_handler>:
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
    5ba4:	b507      	push	{r0, r1, r2, lr}
    usbd_dma_pending_clear();
    5ba6:	f7ff fdd1 	bl	574c <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    5baa:	4b0c      	ldr	r3, [pc, #48]	; (5bdc <ev_dma_epout8_handler+0x38>)
    5bac:	f893 208e 	ldrb.w	r2, [r3, #142]	; 0x8e
    5bb0:	2a03      	cmp	r2, #3
    5bb2:	d010      	beq.n	5bd6 <ev_dma_epout8_handler+0x32>
    else if (p_state->handler.consumer == NULL)
    5bb4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    5bb8:	b96b      	cbnz	r3, 5bd6 <ev_dma_epout8_handler+0x32>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    5bba:	f06f 7080 	mvn.w	r0, #16777216	; 0x1000000
    5bbe:	f7ff ffc9 	bl	5b54 <atomic_and.constprop.25>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    5bc2:	2306      	movs	r3, #6
    5bc4:	f88d 3004 	strb.w	r3, [sp, #4]
    5bc8:	2308      	movs	r3, #8
    5bca:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
    5bce:	4b04      	ldr	r3, [pc, #16]	; (5be0 <ev_dma_epout8_handler+0x3c>)
    5bd0:	a801      	add	r0, sp, #4
    5bd2:	681b      	ldr	r3, [r3, #0]
    5bd4:	4798      	blx	r3
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
    5bd6:	b003      	add	sp, #12
    5bd8:	f85d fb04 	ldr.w	pc, [sp], #4
    5bdc:	200023d0 	.word	0x200023d0
    5be0:	200024f0 	.word	0x200024f0

00005be4 <ev_dma_epin8_handler>:
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
    5be4:	b507      	push	{r0, r1, r2, lr}
    usbd_dma_pending_clear();
    5be6:	f7ff fdb1 	bl	574c <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    5bea:	4b0f      	ldr	r3, [pc, #60]	; (5c28 <ev_dma_epin8_handler+0x44>)
    5bec:	f893 211e 	ldrb.w	r2, [r3, #286]	; 0x11e
    5bf0:	2a03      	cmp	r2, #3
    5bf2:	d106      	bne.n	5c02 <ev_dma_epin8_handler+0x1e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    5bf4:	f46f 7080 	mvn.w	r0, #256	; 0x100
    5bf8:	f7ff ffac 	bl	5b54 <atomic_and.constprop.25>
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
    5bfc:	b003      	add	sp, #12
    5bfe:	f85d fb04 	ldr.w	pc, [sp], #4
    else if (p_state->handler.feeder == NULL)
    5c02:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
    5c06:	2b00      	cmp	r3, #0
    5c08:	d1f8      	bne.n	5bfc <ev_dma_epin8_handler+0x18>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    5c0a:	f46f 7080 	mvn.w	r0, #256	; 0x100
    5c0e:	f7ff ffa1 	bl	5b54 <atomic_and.constprop.25>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    5c12:	2306      	movs	r3, #6
    5c14:	f88d 3004 	strb.w	r3, [sp, #4]
    5c18:	2388      	movs	r3, #136	; 0x88
    5c1a:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
    5c1e:	4b03      	ldr	r3, [pc, #12]	; (5c2c <ev_dma_epin8_handler+0x48>)
    5c20:	a801      	add	r0, sp, #4
    5c22:	681b      	ldr	r3, [r3, #0]
    5c24:	4798      	blx	r3
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
    5c26:	e7e9      	b.n	5bfc <ev_dma_epin8_handler+0x18>
    5c28:	200023d0 	.word	0x200023d0
    5c2c:	200024f0 	.word	0x200024f0

00005c30 <ev_usbevent_handler>:
    return NRF_USBD->EVENTCAUSE;
    5c30:	4b24      	ldr	r3, [pc, #144]	; (5cc4 <ev_usbevent_handler+0x94>)
    };
    m_event_handler(&evt);
}

static void ev_usbevent_handler(void)
{
    5c32:	b513      	push	{r0, r1, r4, lr}
    5c34:	f8d3 4400 	ldr.w	r4, [r3, #1024]	; 0x400
    NRF_USBD->EVENTCAUSE = flags;
    5c38:	f8c3 4400 	str.w	r4, [r3, #1024]	; 0x400
  __ASM volatile ("isb 0xF":::"memory");
    5c3c:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    5c40:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    5c44:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    5c48:	f3bf 8f4f 	dsb	sy
    if (event & NRF_USBD_EVENTCAUSE_ISOOUTCRC_MASK)
    {
        NRFX_LOG_DEBUG("USBD event: ISOOUTCRC");
        /* Currently no support */
    }
    if (event & NRF_USBD_EVENTCAUSE_SUSPEND_MASK)
    5c4c:	05e1      	lsls	r1, r4, #23
    5c4e:	d50b      	bpl.n	5c68 <ev_usbevent_handler+0x38>
    {
        NRFX_LOG_DEBUG("USBD event: SUSPEND");
        m_bus_suspend = true;
    5c50:	4b1d      	ldr	r3, [pc, #116]	; (5cc8 <ev_usbevent_handler+0x98>)
    5c52:	2201      	movs	r2, #1
    5c54:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
    5c56:	2300      	movs	r3, #0
    5c58:	9301      	str	r3, [sp, #4]
    5c5a:	2302      	movs	r3, #2
    5c5c:	f88d 3004 	strb.w	r3, [sp, #4]
                .type = NRFX_USBD_EVT_SUSPEND
        };
        m_event_handler(&evt);
    5c60:	4b1a      	ldr	r3, [pc, #104]	; (5ccc <ev_usbevent_handler+0x9c>)
    5c62:	a801      	add	r0, sp, #4
    5c64:	681b      	ldr	r3, [r3, #0]
    5c66:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_RESUME_MASK)
    5c68:	05a2      	lsls	r2, r4, #22
    5c6a:	d50a      	bpl.n	5c82 <ev_usbevent_handler+0x52>
    {
        NRFX_LOG_DEBUG("USBD event: RESUME");
        m_bus_suspend = false;
    5c6c:	4a16      	ldr	r2, [pc, #88]	; (5cc8 <ev_usbevent_handler+0x98>)
    5c6e:	2300      	movs	r3, #0
        const nrfx_usbd_evt_t evt = {
    5c70:	9301      	str	r3, [sp, #4]
        m_bus_suspend = false;
    5c72:	7013      	strb	r3, [r2, #0]
        const nrfx_usbd_evt_t evt = {
    5c74:	2303      	movs	r3, #3
    5c76:	f88d 3004 	strb.w	r3, [sp, #4]
                .type = NRFX_USBD_EVT_RESUME
        };
        m_event_handler(&evt);
    5c7a:	4b14      	ldr	r3, [pc, #80]	; (5ccc <ev_usbevent_handler+0x9c>)
    5c7c:	a801      	add	r0, sp, #4
    5c7e:	681b      	ldr	r3, [r3, #0]
    5c80:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_WUREQ_MASK)
    5c82:	0563      	lsls	r3, r4, #21
    5c84:	d51c      	bpl.n	5cc0 <ev_usbevent_handler+0x90>
    {
        NRFX_LOG_DEBUG("USBD event: WUREQ (%s)", m_bus_suspend ? "In Suspend" : "Active");
        if (m_bus_suspend)
    5c86:	4910      	ldr	r1, [pc, #64]	; (5cc8 <ev_usbevent_handler+0x98>)
    5c88:	780b      	ldrb	r3, [r1, #0]
    5c8a:	b1cb      	cbz	r3, 5cc0 <ev_usbevent_handler+0x90>
    NRF_USBD->LOWPOWER = USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos;
}

bool nrf_usbd_lowpower_check(void)
{
    return (NRF_USBD->LOWPOWER != (USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos));
    5c8c:	4b0d      	ldr	r3, [pc, #52]	; (5cc4 <ev_usbevent_handler+0x94>)
    5c8e:	f8d3 252c 	ldr.w	r2, [r3, #1324]	; 0x52c
        {
            NRFX_ASSERT(!nrf_usbd_lowpower_check());
    5c92:	b132      	cbz	r2, 5ca2 <ev_usbevent_handler+0x72>
    5c94:	4b0e      	ldr	r3, [pc, #56]	; (5cd0 <ev_usbevent_handler+0xa0>)
    5c96:	4a0f      	ldr	r2, [pc, #60]	; (5cd4 <ev_usbevent_handler+0xa4>)
    5c98:	480f      	ldr	r0, [pc, #60]	; (5cd8 <ev_usbevent_handler+0xa8>)
    5c9a:	f240 41e2 	movw	r1, #1250	; 0x4e2
    5c9e:	f7fa fd6d 	bl	77c <__assert_func>
            m_bus_suspend = false;
    5ca2:	700a      	strb	r2, [r1, #0]
    NRF_USBD->DPDMVALUE = ((uint32_t)val) << USBD_DPDMVALUE_STATE_Pos;
    5ca4:	2101      	movs	r1, #1
    5ca6:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508

            nrf_usbd_dpdmvalue_set(NRF_USBD_DPDMVALUE_RESUME);
            nrf_usbd_task_trigger(NRF_USBD_TASK_DRIVEDPDM);
    5caa:	2058      	movs	r0, #88	; 0x58
    5cac:	f00c f8b7 	bl	11e1e <nrf_usbd_task_trigger>

            const nrfx_usbd_evt_t evt = {
    5cb0:	2304      	movs	r3, #4
    5cb2:	9201      	str	r2, [sp, #4]
    5cb4:	f88d 3004 	strb.w	r3, [sp, #4]
                    .type = NRFX_USBD_EVT_WUREQ
            };
            m_event_handler(&evt);
    5cb8:	4b04      	ldr	r3, [pc, #16]	; (5ccc <ev_usbevent_handler+0x9c>)
    5cba:	a801      	add	r0, sp, #4
    5cbc:	681b      	ldr	r3, [r3, #0]
    5cbe:	4798      	blx	r3
        }
    }
}
    5cc0:	b002      	add	sp, #8
    5cc2:	bd10      	pop	{r4, pc}
    5cc4:	40027000 	.word	0x40027000
    5cc8:	200058b5 	.word	0x200058b5
    5ccc:	200024f0 	.word	0x200024f0
    5cd0:	00017810 	.word	0x00017810
    5cd4:	00017721 	.word	0x00017721
    5cd8:	00017c80 	.word	0x00017c80

00005cdc <nrfx_usbd_uninit>:

    return NRFX_SUCCESS;
}

void nrfx_usbd_uninit(void)
{
    5cdc:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_INITIALIZED);
    5cde:	4b08      	ldr	r3, [pc, #32]	; (5d00 <nrfx_usbd_uninit+0x24>)
    5ce0:	781a      	ldrb	r2, [r3, #0]
    5ce2:	2a01      	cmp	r2, #1
    5ce4:	d006      	beq.n	5cf4 <nrfx_usbd_uninit+0x18>
    5ce6:	4b07      	ldr	r3, [pc, #28]	; (5d04 <nrfx_usbd_uninit+0x28>)
    5ce8:	4a07      	ldr	r2, [pc, #28]	; (5d08 <nrfx_usbd_uninit+0x2c>)
    5cea:	4808      	ldr	r0, [pc, #32]	; (5d0c <nrfx_usbd_uninit+0x30>)
    5cec:	f240 61a3 	movw	r1, #1699	; 0x6a3
    5cf0:	f7fa fd44 	bl	77c <__assert_func>

    m_event_handler = NULL;
    5cf4:	4906      	ldr	r1, [pc, #24]	; (5d10 <nrfx_usbd_uninit+0x34>)
    5cf6:	2200      	movs	r2, #0
    5cf8:	600a      	str	r2, [r1, #0]
    m_drv_state = NRFX_DRV_STATE_UNINITIALIZED;
    5cfa:	701a      	strb	r2, [r3, #0]
    return;
}
    5cfc:	bd08      	pop	{r3, pc}
    5cfe:	bf00      	nop
    5d00:	200058b7 	.word	0x200058b7
    5d04:	00017b94 	.word	0x00017b94
    5d08:	00017758 	.word	0x00017758
    5d0c:	00017c80 	.word	0x00017c80
    5d10:	200024f0 	.word	0x200024f0

00005d14 <nrfx_usbd_enable>:

void nrfx_usbd_enable(void)
{
    5d14:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_INITIALIZED);
    5d16:	4d56      	ldr	r5, [pc, #344]	; (5e70 <nrfx_usbd_enable+0x15c>)
    5d18:	782b      	ldrb	r3, [r5, #0]
    5d1a:	2b01      	cmp	r3, #1
    5d1c:	d006      	beq.n	5d2c <nrfx_usbd_enable+0x18>
    5d1e:	4b55      	ldr	r3, [pc, #340]	; (5e74 <nrfx_usbd_enable+0x160>)
    5d20:	4a55      	ldr	r2, [pc, #340]	; (5e78 <nrfx_usbd_enable+0x164>)
    5d22:	4856      	ldr	r0, [pc, #344]	; (5e7c <nrfx_usbd_enable+0x168>)
    5d24:	f240 61ac 	movw	r1, #1708	; 0x6ac
    5d28:	f7fa fd28 	bl	77c <__assert_func>
    NRF_USBD->EVENTCAUSE = flags;
    5d2c:	4b54      	ldr	r3, [pc, #336]	; (5e80 <nrfx_usbd_enable+0x16c>)
    5d2e:	f44f 6200 	mov.w	r2, #2048	; 0x800
    5d32:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
  __ASM volatile ("isb 0xF":::"memory");
    5d36:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    5d3a:	f3bf 8f4f 	dsb	sy
}

/* Errata: USB cannot be enabled. */
static inline bool nrfx_usbd_errata_187(void)
{
    return (NRFX_USBD_ERRATA_ENABLE && nrfx_usbd_errata_type_52840_eng_b());
    5d3e:	f7ff fcf5 	bl	572c <nrfx_usbd_errata_type_52840_eng_b>
    5d42:	4950      	ldr	r1, [pc, #320]	; (5e84 <nrfx_usbd_enable+0x170>)

    /* Prepare for READY event receiving */
    nrf_usbd_eventcause_clear(NRF_USBD_EVENTCAUSE_READY_MASK);

    if (nrfx_usbd_errata_187())
    5d44:	b1a8      	cbz	r0, 5d72 <nrfx_usbd_enable+0x5e>
	__asm__ volatile(
    5d46:	f04f 0320 	mov.w	r3, #32
    5d4a:	f3ef 8411 	mrs	r4, BASEPRI
    5d4e:	f383 8811 	msr	BASEPRI, r3
    5d52:	f3bf 8f6f 	isb	sy
    {
        NRFX_CRITICAL_SECTION_ENTER();
        if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
    5d56:	6808      	ldr	r0, [r1, #0]
    5d58:	4b4b      	ldr	r3, [pc, #300]	; (5e88 <nrfx_usbd_enable+0x174>)
    5d5a:	2203      	movs	r2, #3
    5d5c:	2800      	cmp	r0, #0
    5d5e:	d17d      	bne.n	5e5c <nrfx_usbd_enable+0x148>
        {
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5d60:	f249 3075 	movw	r0, #37749	; 0x9375
    5d64:	6008      	str	r0, [r1, #0]
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
    5d66:	601a      	str	r2, [r3, #0]
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5d68:	6008      	str	r0, [r1, #0]
	__asm__ volatile(
    5d6a:	f384 8811 	msr	BASEPRI, r4
    5d6e:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
    5d72:	f04f 0320 	mov.w	r3, #32
    5d76:	f3ef 8411 	mrs	r4, BASEPRI
    5d7a:	f383 8811 	msr	BASEPRI, r3
    5d7e:	f3bf 8f6f 	isb	sy
    }
    
    if (nrfx_usbd_errata_171())
    {
        NRFX_CRITICAL_SECTION_ENTER();
        if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
    5d82:	6808      	ldr	r0, [r1, #0]
    5d84:	4a41      	ldr	r2, [pc, #260]	; (5e8c <nrfx_usbd_enable+0x178>)
    5d86:	23c0      	movs	r3, #192	; 0xc0
    5d88:	2800      	cmp	r0, #0
    5d8a:	d169      	bne.n	5e60 <nrfx_usbd_enable+0x14c>
        {
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5d8c:	f249 3075 	movw	r0, #37749	; 0x9375
    5d90:	6008      	str	r0, [r1, #0]
            *((volatile uint32_t *)(0x4006EC14)) = 0x000000C0;
    5d92:	6013      	str	r3, [r2, #0]
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5d94:	6008      	str	r0, [r1, #0]
	__asm__ volatile(
    5d96:	f384 8811 	msr	BASEPRI, r4
    5d9a:	f3bf 8f6f 	isb	sy
    NRF_USBD->ENABLE = USBD_ENABLE_ENABLE_Enabled << USBD_ENABLE_ENABLE_Pos;
    5d9e:	4b38      	ldr	r3, [pc, #224]	; (5e80 <nrfx_usbd_enable+0x16c>)
    5da0:	2001      	movs	r0, #1
    5da2:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
  __ASM volatile ("isb 0xF":::"memory");
    5da6:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    5daa:	f3bf 8f4f 	dsb	sy
    return NRF_USBD->EVENTCAUSE;
    5dae:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
    }

    /* Enable the peripheral */
    nrf_usbd_enable();
    /* Waiting for peripheral to enable, this should take a few us */
    while (0 == (NRF_USBD_EVENTCAUSE_READY_MASK & nrf_usbd_eventcause_get()))
    5db2:	0500      	lsls	r0, r0, #20
    5db4:	d5fb      	bpl.n	5dae <nrfx_usbd_enable+0x9a>
    NRF_USBD->EVENTCAUSE = flags;
    5db6:	f44f 6000 	mov.w	r0, #2048	; 0x800
    5dba:	f8c3 0400 	str.w	r0, [r3, #1024]	; 0x400
  __ASM volatile ("isb 0xF":::"memory");
    5dbe:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    5dc2:	f3bf 8f4f 	dsb	sy
	__asm__ volatile(
    5dc6:	f04f 0320 	mov.w	r3, #32
    5dca:	f3ef 8411 	mrs	r4, BASEPRI
    5dce:	f383 8811 	msr	BASEPRI, r3
    5dd2:	f3bf 8f6f 	isb	sy
    nrf_usbd_eventcause_clear(NRF_USBD_EVENTCAUSE_READY_MASK);
    
    if (nrfx_usbd_errata_171())
    {
        NRFX_CRITICAL_SECTION_ENTER();
        if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
    5dd6:	6808      	ldr	r0, [r1, #0]
    5dd8:	2800      	cmp	r0, #0
    5dda:	d143      	bne.n	5e64 <nrfx_usbd_enable+0x150>
        {
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5ddc:	f249 3375 	movw	r3, #37749	; 0x9375
    5de0:	600b      	str	r3, [r1, #0]
            *((volatile uint32_t *)(0x4006EC14)) = 0x00000000;
    5de2:	6010      	str	r0, [r2, #0]
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5de4:	600b      	str	r3, [r1, #0]
	__asm__ volatile(
    5de6:	f384 8811 	msr	BASEPRI, r4
    5dea:	f3bf 8f6f 	isb	sy
        NRFX_CRITICAL_SECTION_EXIT();
    }

    if (nrfx_usbd_errata_166())
    {
        *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7E3;
    5dee:	4b28      	ldr	r3, [pc, #160]	; (5e90 <nrfx_usbd_enable+0x17c>)
    5df0:	f240 72e3 	movw	r2, #2019	; 0x7e3
    5df4:	601a      	str	r2, [r3, #0]
        *((volatile uint32_t *)(NRF_USBD_BASE + 0x804)) = 0x40;
    5df6:	3304      	adds	r3, #4
    5df8:	2240      	movs	r2, #64	; 0x40
    5dfa:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
    5dfc:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    5e00:	f3bf 8f4f 	dsb	sy
    NRF_USBD->ISOSPLIT = split << USBD_ISOSPLIT_SPLIT_Pos;
    5e04:	f6a3 0304 	subw	r3, r3, #2052	; 0x804
}

void nrf_usbd_isoinconfig_set(nrf_usbd_isoinconfig_t config)
{
    NRF_USBD->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
    5e08:	2400      	movs	r4, #0
    NRF_USBD->ISOSPLIT = split << USBD_ISOSPLIT_SPLIT_Pos;
    5e0a:	2280      	movs	r2, #128	; 0x80
    5e0c:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
    NRF_USBD->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
    5e10:	f8c3 4530 	str.w	r4, [r3, #1328]	; 0x530
    else
    {
        nrfx_usbd_isoinconfig_set(NRF_USBD_ISOINCONFIG_NORESP);
    }

    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
    5e14:	4b1f      	ldr	r3, [pc, #124]	; (5e94 <nrfx_usbd_enable+0x180>)
    5e16:	f240 12ff 	movw	r2, #511	; 0x1ff
    5e1a:	601a      	str	r2, [r3, #0]
    m_ep_dma_waiting = 0;
    5e1c:	4b1e      	ldr	r3, [pc, #120]	; (5e98 <nrfx_usbd_enable+0x184>)
    5e1e:	601c      	str	r4, [r3, #0]
    usbd_dma_pending_clear();
    5e20:	f7ff fc94 	bl	574c <usbd_dma_pending_clear>
    m_last_setup_dir = NRFX_USBD_EPOUT0;
    5e24:	4b1d      	ldr	r3, [pc, #116]	; (5e9c <nrfx_usbd_enable+0x188>)
    5e26:	701c      	strb	r4, [r3, #0]

    m_drv_state = NRFX_DRV_STATE_POWERED_ON;
    5e28:	2302      	movs	r3, #2
    5e2a:	702b      	strb	r3, [r5, #0]
    5e2c:	f7ff fc7e 	bl	572c <nrfx_usbd_errata_type_52840_eng_b>

    if (nrfx_usbd_errata_187())
    5e30:	b198      	cbz	r0, 5e5a <nrfx_usbd_enable+0x146>
	__asm__ volatile(
    5e32:	f04f 0320 	mov.w	r3, #32
    5e36:	f3ef 8511 	mrs	r5, BASEPRI
    5e3a:	f383 8811 	msr	BASEPRI, r3
    5e3e:	f3bf 8f6f 	isb	sy
    {
        NRFX_CRITICAL_SECTION_ENTER();
        if (*((volatile uint32_t *)(0x4006EC00)) == 0x00000000)
    5e42:	6808      	ldr	r0, [r1, #0]
    5e44:	4b10      	ldr	r3, [pc, #64]	; (5e88 <nrfx_usbd_enable+0x174>)
    5e46:	b980      	cbnz	r0, 5e6a <nrfx_usbd_enable+0x156>
        {
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5e48:	f249 3275 	movw	r2, #37749	; 0x9375
    5e4c:	600a      	str	r2, [r1, #0]
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
    5e4e:	6018      	str	r0, [r3, #0]
            *((volatile uint32_t *)(0x4006EC00)) = 0x00009375;
    5e50:	600a      	str	r2, [r1, #0]
	__asm__ volatile(
    5e52:	f385 8811 	msr	BASEPRI, r5
    5e56:	f3bf 8f6f 	isb	sy
        {
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
        }
        NRFX_CRITICAL_SECTION_EXIT();
    }
}
    5e5a:	bd38      	pop	{r3, r4, r5, pc}
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000003;
    5e5c:	601a      	str	r2, [r3, #0]
    5e5e:	e784      	b.n	5d6a <nrfx_usbd_enable+0x56>
            *((volatile uint32_t *)(0x4006EC14)) = 0x000000C0;
    5e60:	6013      	str	r3, [r2, #0]
    5e62:	e798      	b.n	5d96 <nrfx_usbd_enable+0x82>
            *((volatile uint32_t *)(0x4006EC14)) = 0x00000000;
    5e64:	2300      	movs	r3, #0
    5e66:	6013      	str	r3, [r2, #0]
    5e68:	e7bd      	b.n	5de6 <nrfx_usbd_enable+0xd2>
            *((volatile uint32_t *)(0x4006ED14)) = 0x00000000;
    5e6a:	601c      	str	r4, [r3, #0]
    5e6c:	e7f1      	b.n	5e52 <nrfx_usbd_enable+0x13e>
    5e6e:	bf00      	nop
    5e70:	200058b7 	.word	0x200058b7
    5e74:	00017b94 	.word	0x00017b94
    5e78:	00017769 	.word	0x00017769
    5e7c:	00017c80 	.word	0x00017c80
    5e80:	40027000 	.word	0x40027000
    5e84:	4006ec00 	.word	0x4006ec00
    5e88:	4006ed14 	.word	0x4006ed14
    5e8c:	4006ec14 	.word	0x4006ec14
    5e90:	40027800 	.word	0x40027800
    5e94:	200023cc 	.word	0x200023cc
    5e98:	2000235c 	.word	0x2000235c
    5e9c:	200058b8 	.word	0x200058b8

00005ea0 <nrfx_usbd_start>:
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
}

void nrfx_usbd_start(bool enable_sof)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_POWERED_ON);
    5ea0:	4b13      	ldr	r3, [pc, #76]	; (5ef0 <nrfx_usbd_start+0x50>)
    5ea2:	781b      	ldrb	r3, [r3, #0]
    5ea4:	2b02      	cmp	r3, #2
{
    5ea6:	b510      	push	{r4, lr}
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_POWERED_ON);
    5ea8:	d006      	beq.n	5eb8 <nrfx_usbd_start+0x18>
    5eaa:	4b12      	ldr	r3, [pc, #72]	; (5ef4 <nrfx_usbd_start+0x54>)
    5eac:	4a12      	ldr	r2, [pc, #72]	; (5ef8 <nrfx_usbd_start+0x58>)
    5eae:	4813      	ldr	r0, [pc, #76]	; (5efc <nrfx_usbd_start+0x5c>)
    5eb0:	f240 7126 	movw	r1, #1830	; 0x726
    5eb4:	f7fa fc62 	bl	77c <__assert_func>
    m_bus_suspend = false;
    5eb8:	4b11      	ldr	r3, [pc, #68]	; (5f00 <nrfx_usbd_start+0x60>)
    5eba:	2200      	movs	r2, #0
    5ebc:	701a      	strb	r2, [r3, #0]
       NRF_USBD_INT_ENDEPOUT0_MASK    |
       NRF_USBD_INT_USBEVENT_MASK     |
       NRF_USBD_INT_EP0SETUP_MASK     |
       NRF_USBD_INT_DATAEP_MASK;

   if (enable_sof || nrfx_usbd_errata_104())
    5ebe:	b9a8      	cbnz	r0, 5eec <nrfx_usbd_start+0x4c>
    return (NRFX_USBD_ERRATA_ENABLE && (!nrfx_usbd_errata_type_52840_eng_b()));
    5ec0:	f7ff fc34 	bl	572c <nrfx_usbd_errata_type_52840_eng_b>
    uint32_t ints_to_enable =
    5ec4:	4b0f      	ldr	r3, [pc, #60]	; (5f04 <nrfx_usbd_start+0x64>)
    5ec6:	4a10      	ldr	r2, [pc, #64]	; (5f08 <nrfx_usbd_start+0x68>)
    5ec8:	2800      	cmp	r0, #0
    5eca:	bf0c      	ite	eq
    5ecc:	4618      	moveq	r0, r3
    5ece:	4610      	movne	r0, r2
    NRF_USBD->INTENSET = int_mask;
    5ed0:	4c0e      	ldr	r4, [pc, #56]	; (5f0c <nrfx_usbd_start+0x6c>)
    5ed2:	f8c4 0304 	str.w	r0, [r4, #772]	; 0x304
   /* Enable all required interrupts */
   nrf_usbd_int_enable(ints_to_enable);

   /* Enable interrupt globally */
   NRFX_IRQ_PRIORITY_SET(USBD_IRQn, NRFX_USBD_CONFIG_IRQ_PRIORITY);
   NRFX_IRQ_ENABLE(USBD_IRQn);
    5ed6:	2027      	movs	r0, #39	; 0x27
    5ed8:	f003 ff58 	bl	9d8c <z_arch_irq_enable>
    NRF_USBD->USBPULLUP = USBD_USBPULLUP_CONNECT_Enabled << USBD_USBPULLUP_CONNECT_Pos;
    5edc:	2301      	movs	r3, #1
    5ede:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
  __ASM volatile ("isb 0xF":::"memory");
    5ee2:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    5ee6:	f3bf 8f4f 	dsb	sy

   /* Enable pullups */
   nrf_usbd_pullup_enable();
}
    5eea:	bd10      	pop	{r4, pc}
       ints_to_enable |= NRF_USBD_INT_SOF_MASK;
    5eec:	4805      	ldr	r0, [pc, #20]	; (5f04 <nrfx_usbd_start+0x64>)
    5eee:	e7ef      	b.n	5ed0 <nrfx_usbd_start+0x30>
    5ef0:	200058b7 	.word	0x200058b7
    5ef4:	00017b6b 	.word	0x00017b6b
    5ef8:	0001778c 	.word	0x0001778c
    5efc:	00017c80 	.word	0x00017c80
    5f00:	200058b5 	.word	0x200058b5
    5f04:	01e01407 	.word	0x01e01407
    5f08:	01c01407 	.word	0x01c01407
    5f0c:	40027000 	.word	0x40027000

00005f10 <nrfx_usbd_is_enabled>:
    return (m_drv_state >= NRFX_DRV_STATE_INITIALIZED);
}

bool nrfx_usbd_is_enabled(void)
{
    return (m_drv_state >= NRFX_DRV_STATE_POWERED_ON);
    5f10:	4b03      	ldr	r3, [pc, #12]	; (5f20 <nrfx_usbd_is_enabled+0x10>)
    5f12:	7818      	ldrb	r0, [r3, #0]
}
    5f14:	2801      	cmp	r0, #1
    5f16:	bf94      	ite	ls
    5f18:	2000      	movls	r0, #0
    5f1a:	2001      	movhi	r0, #1
    5f1c:	4770      	bx	lr
    5f1e:	bf00      	nop
    5f20:	200058b7 	.word	0x200058b7

00005f24 <nrfx_usbd_ep_max_packet_size_set>:
{
    m_bus_suspend = false;
}

void nrfx_usbd_ep_max_packet_size_set(nrfx_usbd_ep_t ep, uint16_t size)
{
    5f24:	b510      	push	{r4, lr}
    /* Only power of 2 size allowed */
    NRFX_ASSERT((size != 0) && (size & (size - 1)) == 0);
    5f26:	460c      	mov	r4, r1
    5f28:	b111      	cbz	r1, 5f30 <nrfx_usbd_ep_max_packet_size_set+0xc>
    5f2a:	1e4b      	subs	r3, r1, #1
    5f2c:	420b      	tst	r3, r1
    5f2e:	d006      	beq.n	5f3e <nrfx_usbd_ep_max_packet_size_set+0x1a>
    5f30:	4b0f      	ldr	r3, [pc, #60]	; (5f70 <nrfx_usbd_ep_max_packet_size_set+0x4c>)
    5f32:	4a10      	ldr	r2, [pc, #64]	; (5f74 <nrfx_usbd_ep_max_packet_size_set+0x50>)
    5f34:	f240 71be 	movw	r1, #1982	; 0x7be
    /* Packet size cannot be higher than maximum buffer size */
    NRFX_ASSERT((NRF_USBD_EPISO_CHECK(ep) && (size <= usbd_ep_iso_capacity(ep))) ||
    5f38:	480f      	ldr	r0, [pc, #60]	; (5f78 <nrfx_usbd_ep_max_packet_size_set+0x54>)
    5f3a:	f7fa fc1f 	bl	77c <__assert_func>
    5f3e:	0703      	lsls	r3, r0, #28
    5f40:	d514      	bpl.n	5f6c <nrfx_usbd_ep_max_packet_size_set+0x48>
        (((NRF_USBD->ISOSPLIT) & USBD_ISOSPLIT_SPLIT_Msk) >> USBD_ISOSPLIT_SPLIT_Pos);
    5f42:	4b0e      	ldr	r3, [pc, #56]	; (5f7c <nrfx_usbd_ep_max_packet_size_set+0x58>)
    5f44:	f8d3 351c 	ldr.w	r3, [r3, #1308]	; 0x51c
    if (NRF_USBD_ISOSPLIT_HALF == split)
    5f48:	b2db      	uxtb	r3, r3
        return NRFX_USBD_ISOSIZE / 2;
    5f4a:	2b80      	cmp	r3, #128	; 0x80
    5f4c:	bf14      	ite	ne
    5f4e:	f44f 6380 	movne.w	r3, #1024	; 0x400
    5f52:	f44f 7300 	moveq.w	r3, #512	; 0x200
    NRFX_ASSERT((NRF_USBD_EPISO_CHECK(ep) && (size <= usbd_ep_iso_capacity(ep))) ||
    5f56:	4299      	cmp	r1, r3
    5f58:	d904      	bls.n	5f64 <nrfx_usbd_ep_max_packet_size_set+0x40>
    5f5a:	4b09      	ldr	r3, [pc, #36]	; (5f80 <nrfx_usbd_ep_max_packet_size_set+0x5c>)
    5f5c:	4a05      	ldr	r2, [pc, #20]	; (5f74 <nrfx_usbd_ep_max_packet_size_set+0x50>)
    5f5e:	f240 71c1 	movw	r1, #1985	; 0x7c1
    5f62:	e7e9      	b.n	5f38 <nrfx_usbd_ep_max_packet_size_set+0x14>
                (!NRF_USBD_EPISO_CHECK(ep) && (size <= NRFX_USBD_EPSIZE)));

    usbd_ep_state_t * p_state = ep_state_access(ep);
    5f64:	f7ff fce8 	bl	5938 <ep_state_access>
    p_state->max_packet_size = size;
    5f68:	8184      	strh	r4, [r0, #12]
}
    5f6a:	bd10      	pop	{r4, pc}
    NRFX_ASSERT((NRF_USBD_EPISO_CHECK(ep) && (size <= usbd_ep_iso_capacity(ep))) ||
    5f6c:	2940      	cmp	r1, #64	; 0x40
    5f6e:	e7f3      	b.n	5f58 <nrfx_usbd_ep_max_packet_size_set+0x34>
    5f70:	000179a5 	.word	0x000179a5
    5f74:	000177ab 	.word	0x000177ab
    5f78:	00017c80 	.word	0x00017c80
    5f7c:	40027000 	.word	0x40027000
    5f80:	000179cd 	.word	0x000179cd

00005f84 <nrfx_usbd_init>:
{
    5f84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    NRFX_ASSERT(event_handler);
    5f86:	b930      	cbnz	r0, 5f96 <nrfx_usbd_init+0x12>
    5f88:	4b1f      	ldr	r3, [pc, #124]	; (6008 <nrfx_usbd_init+0x84>)
    5f8a:	4a20      	ldr	r2, [pc, #128]	; (600c <nrfx_usbd_init+0x88>)
    5f8c:	4820      	ldr	r0, [pc, #128]	; (6010 <nrfx_usbd_init+0x8c>)
    5f8e:	f240 617e 	movw	r1, #1662	; 0x67e
    5f92:	f7fa fbf3 	bl	77c <__assert_func>
    if (m_drv_state != NRFX_DRV_STATE_UNINITIALIZED)
    5f96:	4b1f      	ldr	r3, [pc, #124]	; (6014 <nrfx_usbd_init+0x90>)
    5f98:	781c      	ldrb	r4, [r3, #0]
    5f9a:	bb94      	cbnz	r4, 6002 <nrfx_usbd_init+0x7e>
    m_event_handler = event_handler;
    5f9c:	4a1e      	ldr	r2, [pc, #120]	; (6018 <nrfx_usbd_init+0x94>)
    5f9e:	6010      	str	r0, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
    5fa0:	2201      	movs	r2, #1
    5fa2:	701a      	strb	r2, [r3, #0]
    5fa4:	4625      	mov	r5, r4
        p_state->status = NRFX_USBD_EP_OK;
    5fa6:	4626      	mov	r6, r4
    5fa8:	b2eb      	uxtb	r3, r5
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    5faa:	f013 0f08 	tst.w	r3, #8
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
    5fae:	f043 0780 	orr.w	r7, r3, #128	; 0x80
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    5fb2:	bf0c      	ite	eq
    5fb4:	2140      	moveq	r1, #64	; 0x40
    5fb6:	f44f 7100 	movne.w	r1, #512	; 0x200
    5fba:	4638      	mov	r0, r7
    5fbc:	f7ff ffb2 	bl	5f24 <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
    5fc0:	4638      	mov	r0, r7
    5fc2:	f7ff fcb9 	bl	5938 <ep_state_access>
        p_state->status = NRFX_USBD_EP_OK;
    5fc6:	3501      	adds	r5, #1
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
    5fc8:	2d09      	cmp	r5, #9
        p_state->status = NRFX_USBD_EP_OK;
    5fca:	7386      	strb	r6, [r0, #14]
        p_state->handler.feeder = NULL;
    5fcc:	6006      	str	r6, [r0, #0]
        p_state->transfer_cnt = 0;
    5fce:	6086      	str	r6, [r0, #8]
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
    5fd0:	d1ea      	bne.n	5fa8 <nrfx_usbd_init+0x24>
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    5fd2:	2140      	movs	r1, #64	; 0x40
        p_state->status = NRFX_USBD_EP_OK;
    5fd4:	2500      	movs	r5, #0
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    5fd6:	4620      	mov	r0, r4
    5fd8:	f7ff ffa4 	bl	5f24 <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
    5fdc:	4620      	mov	r0, r4
    5fde:	f7ff fcab 	bl	5938 <ep_state_access>
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
    5fe2:	3401      	adds	r4, #1
    5fe4:	b2e4      	uxtb	r4, r4
    5fe6:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
    5fe8:	7385      	strb	r5, [r0, #14]
        p_state->handler.consumer = NULL;
    5fea:	6005      	str	r5, [r0, #0]
        p_state->transfer_cnt = 0;
    5fec:	6085      	str	r5, [r0, #8]
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
    5fee:	d101      	bne.n	5ff4 <nrfx_usbd_init+0x70>
    return NRFX_SUCCESS;
    5ff0:	480a      	ldr	r0, [pc, #40]	; (601c <nrfx_usbd_init+0x98>)
}
    5ff2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
    5ff4:	f014 0f08 	tst.w	r4, #8
    5ff8:	bf14      	ite	ne
    5ffa:	f44f 7100 	movne.w	r1, #512	; 0x200
    5ffe:	2140      	moveq	r1, #64	; 0x40
    6000:	e7e9      	b.n	5fd6 <nrfx_usbd_init+0x52>
        return NRFX_ERROR_INVALID_STATE;
    6002:	4807      	ldr	r0, [pc, #28]	; (6020 <nrfx_usbd_init+0x9c>)
    6004:	e7f5      	b.n	5ff2 <nrfx_usbd_init+0x6e>
    6006:	bf00      	nop
    6008:	00017b5d 	.word	0x00017b5d
    600c:	00017749 	.word	0x00017749
    6010:	00017c80 	.word	0x00017c80
    6014:	200058b7 	.word	0x200058b7
    6018:	200024f0 	.word	0x200024f0
    601c:	0bad0000 	.word	0x0bad0000
    6020:	0bad0005 	.word	0x0bad0005

00006024 <nrfx_usbd_ep_transfer>:
}

nrfx_err_t nrfx_usbd_ep_transfer(
    nrfx_usbd_ep_t               ep,
    nrfx_usbd_transfer_t const * p_transfer)
{
    6024:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6028:	4689      	mov	r9, r1
    602a:	4682      	mov	sl, r0
    nrfx_err_t ret;
    const uint8_t ep_bitpos = ep2bit(ep);
    602c:	f00b ff03 	bl	11e36 <ep2bit>
    NRFX_ASSERT(NULL != p_transfer);
    6030:	f1b9 0f00 	cmp.w	r9, #0
    6034:	d106      	bne.n	6044 <nrfx_usbd_ep_transfer+0x20>
    6036:	4b36      	ldr	r3, [pc, #216]	; (6110 <nrfx_usbd_ep_transfer+0xec>)
    6038:	4a36      	ldr	r2, [pc, #216]	; (6114 <nrfx_usbd_ep_transfer+0xf0>)
    603a:	f640 010b 	movw	r1, #2059	; 0x80b
            }
        }
        else
        {
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT((p_transfer->p_data.rx == NULL) || (nrfx_is_in_ram(p_transfer->p_data.rx)));
    603e:	4836      	ldr	r0, [pc, #216]	; (6118 <nrfx_usbd_ep_transfer+0xf4>)
    6040:	f7fa fb9c 	bl	77c <__assert_func>
	__asm__ volatile(
    6044:	f04f 0320 	mov.w	r3, #32
    6048:	f3ef 8711 	mrs	r7, BASEPRI
    604c:	f383 8811 	msr	BASEPRI, r3
    6050:	f3bf 8f6f 	isb	sy
    if ((NRF_USBD_EP_NR_GET(ep) == 0) && (ep != m_last_setup_dir))
    6054:	f01a 0b0f 	ands.w	fp, sl, #15
    6058:	d103      	bne.n	6062 <nrfx_usbd_ep_transfer+0x3e>
    605a:	4b30      	ldr	r3, [pc, #192]	; (611c <nrfx_usbd_ep_transfer+0xf8>)
    605c:	781b      	ldrb	r3, [r3, #0]
    605e:	4553      	cmp	r3, sl
    6060:	d151      	bne.n	6106 <nrfx_usbd_ep_transfer+0xe2>
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
    6062:	4a2f      	ldr	r2, [pc, #188]	; (6120 <nrfx_usbd_ep_transfer+0xfc>)
    6064:	4b2f      	ldr	r3, [pc, #188]	; (6124 <nrfx_usbd_ep_transfer+0x100>)
    6066:	6812      	ldr	r2, [r2, #0]
    6068:	681d      	ldr	r5, [r3, #0]
    606a:	43d2      	mvns	r2, r2
    606c:	2601      	movs	r6, #1
    606e:	b292      	uxth	r2, r2
    6070:	4086      	lsls	r6, r0
    6072:	432a      	orrs	r2, r5
    6074:	4232      	tst	r2, r6
    6076:	4698      	mov	r8, r3
    6078:	d147      	bne.n	610a <nrfx_usbd_ep_transfer+0xe6>
        usbd_ep_state_t * p_state =  ep_state_access(ep);
    607a:	4650      	mov	r0, sl
    607c:	f7ff fc5c 	bl	5938 <ep_state_access>
    6080:	230c      	movs	r3, #12
        if (NRF_USBD_EPIN_CHECK(ep))
    6082:	f01a 0f80 	tst.w	sl, #128	; 0x80
        usbd_ep_state_t * p_state =  ep_state_access(ep);
    6086:	4604      	mov	r4, r0
        if (NRF_USBD_EPIN_CHECK(ep))
    6088:	fb03 f30b 	mul.w	r3, r3, fp
    608c:	f8d9 2000 	ldr.w	r2, [r9]
    6090:	d02a      	beq.n	60e8 <nrfx_usbd_ep_transfer+0xc4>
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
    6092:	4925      	ldr	r1, [pc, #148]	; (6128 <nrfx_usbd_ep_transfer+0x104>)
    6094:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
    6098:	440b      	add	r3, r1
    609a:	f8d9 1008 	ldr.w	r1, [r9, #8]
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
    609e:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    60a2:	f001 0101 	and.w	r1, r1, #1
    60a6:	d11a      	bne.n	60de <nrfx_usbd_ep_transfer+0xba>
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
    60a8:	b9b9      	cbnz	r1, 60da <nrfx_usbd_ep_transfer+0xb6>
                    p_state->handler.feeder = nrfx_usbd_feeder_ram;
    60aa:	4a20      	ldr	r2, [pc, #128]	; (612c <nrfx_usbd_ep_transfer+0x108>)
            p_state->handler.consumer = nrfx_usbd_consumer;
    60ac:	6022      	str	r2, [r4, #0]
        }
        *p_context = *p_transfer;
    60ae:	e899 0007 	ldmia.w	r9, {r0, r1, r2}
    60b2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        p_state->p_context = p_context;
    60b6:	6063      	str	r3, [r4, #4]

        p_state->transfer_cnt = 0;
    60b8:	2300      	movs	r3, #0
    60ba:	60a3      	str	r3, [r4, #8]
        p_state->status    =  NRFX_USBD_EP_OK;
    60bc:	73a3      	strb	r3, [r4, #14]
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    60be:	4b1c      	ldr	r3, [pc, #112]	; (6130 <nrfx_usbd_ep_transfer+0x10c>)
        m_ep_dma_waiting   |= 1U << ep_bitpos;
        ret = NRFX_SUCCESS;
    60c0:	481c      	ldr	r0, [pc, #112]	; (6134 <nrfx_usbd_ep_transfer+0x110>)
        m_ep_dma_waiting   |= 1U << ep_bitpos;
    60c2:	4335      	orrs	r5, r6
    60c4:	2280      	movs	r2, #128	; 0x80
    60c6:	f8c8 5000 	str.w	r5, [r8]
    60ca:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	__asm__ volatile(
    60ce:	f387 8811 	msr	BASEPRI, r7
    60d2:	f3bf 8f6f 	isb	sy
        usbd_int_rise();
    }
    NRFX_CRITICAL_SECTION_EXIT();
    return ret;
}
    60d6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    p_state->handler.feeder = nrfx_usbd_feeder_ram_zlp;
    60da:	4a17      	ldr	r2, [pc, #92]	; (6138 <nrfx_usbd_ep_transfer+0x114>)
    60dc:	e7e6      	b.n	60ac <nrfx_usbd_ep_transfer+0x88>
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
    60de:	b909      	cbnz	r1, 60e4 <nrfx_usbd_ep_transfer+0xc0>
                    p_state->handler.feeder = nrfx_usbd_feeder_flash;
    60e0:	4a16      	ldr	r2, [pc, #88]	; (613c <nrfx_usbd_ep_transfer+0x118>)
    60e2:	e7e3      	b.n	60ac <nrfx_usbd_ep_transfer+0x88>
                    p_state->handler.feeder = nrfx_usbd_feeder_flash_zlp;
    60e4:	4a16      	ldr	r2, [pc, #88]	; (6140 <nrfx_usbd_ep_transfer+0x11c>)
    60e6:	e7e1      	b.n	60ac <nrfx_usbd_ep_transfer+0x88>
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
    60e8:	4916      	ldr	r1, [pc, #88]	; (6144 <nrfx_usbd_ep_transfer+0x120>)
    60ea:	440b      	add	r3, r1
            NRFX_ASSERT((p_transfer->p_data.rx == NULL) || (nrfx_is_in_ram(p_transfer->p_data.rx)));
    60ec:	b14a      	cbz	r2, 6102 <nrfx_usbd_ep_transfer+0xde>
    60ee:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
    60f2:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
    60f6:	d004      	beq.n	6102 <nrfx_usbd_ep_transfer+0xde>
    60f8:	4b13      	ldr	r3, [pc, #76]	; (6148 <nrfx_usbd_ep_transfer+0x124>)
    60fa:	4a06      	ldr	r2, [pc, #24]	; (6114 <nrfx_usbd_ep_transfer+0xf0>)
    60fc:	f640 0165 	movw	r1, #2149	; 0x865
    6100:	e79d      	b.n	603e <nrfx_usbd_ep_transfer+0x1a>
            p_state->handler.consumer = nrfx_usbd_consumer;
    6102:	4a12      	ldr	r2, [pc, #72]	; (614c <nrfx_usbd_ep_transfer+0x128>)
    6104:	e7d2      	b.n	60ac <nrfx_usbd_ep_transfer+0x88>
        ret = NRFX_ERROR_INVALID_ADDR;
    6106:	4812      	ldr	r0, [pc, #72]	; (6150 <nrfx_usbd_ep_transfer+0x12c>)
    6108:	e7e1      	b.n	60ce <nrfx_usbd_ep_transfer+0xaa>
        ret = NRFX_ERROR_BUSY;
    610a:	4812      	ldr	r0, [pc, #72]	; (6154 <nrfx_usbd_ep_transfer+0x130>)
    610c:	e7df      	b.n	60ce <nrfx_usbd_ep_transfer+0xaa>
    610e:	bf00      	nop
    6110:	00017a8d 	.word	0x00017a8d
    6114:	000177cc 	.word	0x000177cc
    6118:	00017c80 	.word	0x00017c80
    611c:	200058b8 	.word	0x200058b8
    6120:	200023cc 	.word	0x200023cc
    6124:	2000235c 	.word	0x2000235c
    6128:	20002360 	.word	0x20002360
    612c:	00005889 	.word	0x00005889
    6130:	e000e100 	.word	0xe000e100
    6134:	0bad0000 	.word	0x0bad0000
    6138:	000058cd 	.word	0x000058cd
    613c:	00005a2d 	.word	0x00005a2d
    6140:	00005a9d 	.word	0x00005a9d
    6144:	200022f0 	.word	0x200022f0
    6148:	00017aa7 	.word	0x00017aa7
    614c:	0000581d 	.word	0x0000581d
    6150:	0bad000a 	.word	0x0bad000a
    6154:	0bad000b 	.word	0x0bad000b

00006158 <nrfx_usbd_epout_size_get>:
    NRFX_CRITICAL_SECTION_EXIT();
    return ret;
}

size_t nrfx_usbd_epout_size_get(nrfx_usbd_ep_t ep)
{
    6158:	b508      	push	{r3, lr}
    615a:	f000 030f 	and.w	r3, r0, #15
    NRFX_USBD_ASSERT_EP_VALID(ep);
    615e:	2b08      	cmp	r3, #8
    6160:	d901      	bls.n	6166 <nrfx_usbd_epout_size_get+0xe>
    6162:	f7ff fc27 	bl	59b4 <ep_to_hal.part.9>
    NRFX_ASSERT(NRF_USBD_EPOUT_CHECK(ep));
    6166:	0602      	lsls	r2, r0, #24
    6168:	d506      	bpl.n	6178 <nrfx_usbd_epout_size_get+0x20>
    616a:	4b0b      	ldr	r3, [pc, #44]	; (6198 <nrfx_usbd_epout_size_get+0x40>)
    616c:	4a0b      	ldr	r2, [pc, #44]	; (619c <nrfx_usbd_epout_size_get+0x44>)
    616e:	480c      	ldr	r0, [pc, #48]	; (61a0 <nrfx_usbd_epout_size_get+0x48>)
    6170:	f240 4171 	movw	r1, #1137	; 0x471
    6174:	f7fa fb02 	bl	77c <__assert_func>
    if (NRF_USBD_EPISO_CHECK(ep))
    6178:	f010 0f08 	tst.w	r0, #8
    617c:	4a09      	ldr	r2, [pc, #36]	; (61a4 <nrfx_usbd_epout_size_get+0x4c>)
    617e:	d006      	beq.n	618e <nrfx_usbd_epout_size_get+0x36>
        size_t size_isoout = NRF_USBD->SIZE.ISOOUT;
    6180:	f8d2 04c0 	ldr.w	r0, [r2, #1216]	; 0x4c0
        if ((size_isoout & USBD_SIZE_ISOOUT_ZERO_Msk) == (USBD_SIZE_ISOOUT_ZERO_ZeroData << USBD_SIZE_ISOOUT_ZERO_Pos))
    6184:	f410 3f80 	tst.w	r0, #65536	; 0x10000
            size_isoout = 0;
    6188:	bf18      	it	ne
    618a:	2000      	movne	r0, #0
    return nrf_usbd_epout_size_get(ep_to_hal(ep));
}
    618c:	bd08      	pop	{r3, pc}
    return NRF_USBD->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
    618e:	f503 7394 	add.w	r3, r3, #296	; 0x128
    6192:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    return nrf_usbd_epout_size_get(ep_to_hal(ep));
    6196:	e7f9      	b.n	618c <nrfx_usbd_epout_size_get+0x34>
    6198:	00017af9 	.word	0x00017af9
    619c:	000175fb 	.word	0x000175fb
    61a0:	000178ee 	.word	0x000178ee
    61a4:	40027000 	.word	0x40027000

000061a8 <usbd_dmareq_process>:
{
    61a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (!m_dma_pending)
    61ac:	4b79      	ldr	r3, [pc, #484]	; (6394 <usbd_dmareq_process+0x1ec>)
{
    61ae:	b087      	sub	sp, #28
    if (!m_dma_pending)
    61b0:	781a      	ldrb	r2, [r3, #0]
    61b2:	9301      	str	r3, [sp, #4]
    61b4:	2a00      	cmp	r2, #0
    61b6:	f040 80d4 	bne.w	6362 <usbd_dmareq_process+0x1ba>
        while (0 != (req = m_ep_dma_waiting & m_ep_ready))
    61ba:	f8df 9208 	ldr.w	r9, [pc, #520]	; 63c4 <usbd_dmareq_process+0x21c>
    61be:	46ca      	mov	sl, r9
    61c0:	4b75      	ldr	r3, [pc, #468]	; (6398 <usbd_dmareq_process+0x1f0>)
    61c2:	f8d9 4000 	ldr.w	r4, [r9]
    61c6:	6818      	ldr	r0, [r3, #0]
    61c8:	4020      	ands	r0, r4
    61ca:	f000 80ca 	beq.w	6362 <usbd_dmareq_process+0x1ba>
            if (NRFX_USBD_CONFIG_DMASCHEDULER_ISO_BOOST && ((req & USBD_EPISO_BIT_MASK) != 0))
    61ce:	f010 2401 	ands.w	r4, r0, #16777472	; 0x1000100
    61d2:	d017      	beq.n	6204 <usbd_dmareq_process+0x5c>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    61d4:	fa94 f4a4 	rbit	r4, r4
    return __CLZ(__RBIT(req));
    61d8:	fab4 f484 	clz	r4, r4
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    61dc:	2c0f      	cmp	r4, #15
        NRF_USBD_EPOUT(bitpos - NRFX_USBD_EPOUT_BITPOS_0) : NRF_USBD_EPIN(bitpos));
    61de:	bf86      	itte	hi
    61e0:	f1a4 0510 	subhi.w	r5, r4, #16
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    61e4:	b2ed      	uxtbhi	r5, r5
    61e6:	f044 0580 	orrls.w	r5, r4, #128	; 0x80
            usbd_ep_state_t * p_state = ep_state_access(ep);
    61ea:	4628      	mov	r0, r5
    61ec:	f7ff fba4 	bl	5938 <ep_state_access>
            NRFX_ASSERT((p_state->handler.feeder) != NULL);
    61f0:	6803      	ldr	r3, [r0, #0]
            usbd_ep_state_t * p_state = ep_state_access(ep);
    61f2:	4606      	mov	r6, r0
            NRFX_ASSERT((p_state->handler.feeder) != NULL);
    61f4:	b95b      	cbnz	r3, 620e <usbd_dmareq_process+0x66>
    61f6:	4b69      	ldr	r3, [pc, #420]	; (639c <usbd_dmareq_process+0x1f4>)
    61f8:	4a69      	ldr	r2, [pc, #420]	; (63a0 <usbd_dmareq_process+0x1f8>)
    61fa:	f240 5155 	movw	r1, #1365	; 0x555
                    NRFX_ASSERT(transfer.size == 0);
    61fe:	4869      	ldr	r0, [pc, #420]	; (63a4 <usbd_dmareq_process+0x1fc>)
    6200:	f7fa fabc 	bl	77c <__assert_func>
    6204:	fa90 f0a0 	rbit	r0, r0
    return __CLZ(__RBIT(req));
    6208:	fab0 f480 	clz	r4, r0
    620c:	e7e6      	b.n	61dc <usbd_dmareq_process+0x34>
            if (NRF_USBD_EPIN_CHECK(ep))
    620e:	fa4f f885 	sxtb.w	r8, r5
    6212:	f1b8 0f00 	cmp.w	r8, #0
    6216:	da54      	bge.n	62c2 <usbd_dmareq_process+0x11a>
                continue_transfer = p_state->handler.feeder(
    6218:	8982      	ldrh	r2, [r0, #12]
    621a:	6841      	ldr	r1, [r0, #4]
    621c:	a804      	add	r0, sp, #16
    621e:	4798      	blx	r3
                if (!continue_transfer)
    6220:	b900      	cbnz	r0, 6224 <usbd_dmareq_process+0x7c>
                    p_state->handler.consumer = NULL;
    6222:	6030      	str	r0, [r6, #0]
        *((volatile uint32_t *)0x40027C1C) = 0x00000082;
    6224:	4b60      	ldr	r3, [pc, #384]	; (63a8 <usbd_dmareq_process+0x200>)
    6226:	2282      	movs	r2, #130	; 0x82
    6228:	601a      	str	r2, [r3, #0]
    m_dma_pending = true;
    622a:	9b01      	ldr	r3, [sp, #4]
            p_state->transfer_cnt += transfer.size;
    622c:	9a05      	ldr	r2, [sp, #20]
    m_dma_pending = true;
    622e:	2001      	movs	r0, #1
    6230:	7018      	strb	r0, [r3, #0]
            p_state->transfer_cnt += transfer.size;
    6232:	68b3      	ldr	r3, [r6, #8]
            m_ep_ready &= ~(1U << pos);
    6234:	40a0      	lsls	r0, r4
    6236:	f8da 4000 	ldr.w	r4, [sl]
            p_state->transfer_cnt += transfer.size;
    623a:	4413      	add	r3, r2
            m_ep_ready &= ~(1U << pos);
    623c:	ea24 0000 	bic.w	r0, r4, r0
        (((NRF_USBD->ISOINCONFIG) & USBD_ISOINCONFIG_RESPONSE_Msk) >> USBD_ISOINCONFIG_RESPONSE_Pos);
}

void nrf_usbd_ep_easydma_set(uint8_t ep, uint32_t ptr, uint32_t maxcnt)
{
    if (NRF_USBD_EPIN_CHECK(ep))
    6240:	f1b8 0f00 	cmp.w	r8, #0
            p_state->transfer_cnt += transfer.size;
    6244:	60b3      	str	r3, [r6, #8]
            m_ep_ready &= ~(1U << pos);
    6246:	f8ca 0000 	str.w	r0, [sl]
            nrf_usbd_ep_easydma_set(ep, transfer.p_data.addr, (uint32_t)transfer.size);
    624a:	f005 0108 	and.w	r1, r5, #8
    624e:	9804      	ldr	r0, [sp, #16]
    6250:	4b56      	ldr	r3, [pc, #344]	; (63ac <usbd_dmareq_process+0x204>)
    6252:	f005 060f 	and.w	r6, r5, #15
    6256:	da6b      	bge.n	6330 <usbd_dmareq_process+0x188>
    {
        if (NRF_USBD_EPISO_CHECK(ep))
    6258:	2900      	cmp	r1, #0
    625a:	d061      	beq.n	6320 <usbd_dmareq_process+0x178>
        {
            NRF_USBD->ISOIN.PTR    = ptr;
    625c:	f8c3 06a0 	str.w	r0, [r3, #1696]	; 0x6a0
            NRF_USBD->ISOIN.MAXCNT = maxcnt;
    6260:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
    6264:	f7ff fa62 	bl	572c <nrfx_usbd_errata_type_52840_eng_b>
    6268:	0077      	lsls	r7, r6, #1
    626a:	4c51      	ldr	r4, [pc, #324]	; (63b0 <usbd_dmareq_process+0x208>)
    626c:	f8df 9158 	ldr.w	r9, [pc, #344]	; 63c8 <usbd_dmareq_process+0x220>
            if (nrfx_usbd_errata_104())
    6270:	2800      	cmp	r0, #0
    6272:	d179      	bne.n	6368 <usbd_dmareq_process+0x1c0>
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
    6274:	ea14 0828 	ands.w	r8, r4, r8, asr #32
    6278:	bf38      	it	cc
    627a:	46c8      	movcc	r8, r9
    627c:	44b8      	add	r8, r7
                    while (0 == (0x20 & *((volatile uint32_t *)(NRF_USBD_BASE + 0x474))))
    627e:	f8df 914c 	ldr.w	r9, [pc, #332]	; 63cc <usbd_dmareq_process+0x224>
    *(nrf_usbd_getRegPtr((uint32_t)event)) = 0UL;
    6282:	4f4c      	ldr	r7, [pc, #304]	; (63b4 <usbd_dmareq_process+0x20c>)
    6284:	4604      	mov	r4, r0
    6286:	603c      	str	r4, [r7, #0]
  __ASM volatile ("isb 0xF":::"memory");
    6288:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    628c:	f3bf 8f4f 	dsb	sy
    nrf_usbd_task_trigger(task_start_ep(ep));
    6290:	4628      	mov	r0, r5
    6292:	f7ff fa7d 	bl	5790 <task_start_ep>
    6296:	f00b fdc2 	bl	11e1e <nrf_usbd_task_trigger>
                        nrfx_systick_delay_us(2);
    629a:	2002      	movs	r0, #2
    629c:	f7ff fa24 	bl	56e8 <nrfx_systick_delay_us>
    return (bool)*nrf_usbd_getRegPtr_c((uint32_t)event);
    62a0:	683b      	ldr	r3, [r7, #0]
                    }while (!nrf_usbd_event_check(NRF_USBD_EVENT_STARTED));
    62a2:	2b00      	cmp	r3, #0
    62a4:	d0ef      	beq.n	6286 <usbd_dmareq_process+0xde>
                    nrfx_systick_delay_us(30);
    62a6:	201e      	movs	r0, #30
                        nrfx_systick_delay_us(2);
    62a8:	f7ff fa1e 	bl	56e8 <nrfx_systick_delay_us>
                    while (0 == (0x20 & *((volatile uint32_t *)(NRF_USBD_BASE + 0x474))))
    62ac:	f8d9 3000 	ldr.w	r3, [r9]
    62b0:	069b      	lsls	r3, r3, #26
    62b2:	d54b      	bpl.n	634c <usbd_dmareq_process+0x1a4>
                    nrfx_systick_delay_us(1);
    62b4:	2001      	movs	r0, #1
    62b6:	f7ff fa17 	bl	56e8 <nrfx_systick_delay_us>
    NRFX_USBD_ASSERT_EP_VALID(ep);
    62ba:	2e08      	cmp	r6, #8
    62bc:	d948      	bls.n	6350 <usbd_dmareq_process+0x1a8>
    62be:	f7ff fb6b 	bl	5998 <nrfx_usbd_ep_to_endevent.part.8>
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
    62c2:	4628      	mov	r0, r5
    62c4:	f7ff ff48 	bl	6158 <nrfx_usbd_epout_size_get>
                continue_transfer = p_state->handler.consumer(
    62c8:	89b2      	ldrh	r2, [r6, #12]
    62ca:	6837      	ldr	r7, [r6, #0]
    62cc:	6871      	ldr	r1, [r6, #4]
    62ce:	4603      	mov	r3, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
    62d0:	4683      	mov	fp, r0
                continue_transfer = p_state->handler.consumer(
    62d2:	a804      	add	r0, sp, #16
    62d4:	47b8      	blx	r7
                if (transfer.p_data.rx == NULL)
    62d6:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    62da:	b932      	cbnz	r2, 62ea <usbd_dmareq_process+0x142>
                    NRFX_ASSERT(transfer.size == 0);
    62dc:	2b00      	cmp	r3, #0
    62de:	d09f      	beq.n	6220 <usbd_dmareq_process+0x78>
    62e0:	4b35      	ldr	r3, [pc, #212]	; (63b8 <usbd_dmareq_process+0x210>)
    62e2:	4a2f      	ldr	r2, [pc, #188]	; (63a0 <usbd_dmareq_process+0x1f8>)
    62e4:	f240 5171 	movw	r1, #1393	; 0x571
    62e8:	e789      	b.n	61fe <usbd_dmareq_process+0x56>
                else if (transfer.size < rx_size)
    62ea:	459b      	cmp	fp, r3
    62ec:	d912      	bls.n	6314 <usbd_dmareq_process+0x16c>
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
    62ee:	2001      	movs	r0, #1
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
    62f0:	2702      	movs	r7, #2
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
    62f2:	40a0      	lsls	r0, r4
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
    62f4:	73b7      	strb	r7, [r6, #14]
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
    62f6:	43c0      	mvns	r0, r0
    62f8:	f7ff fc2c 	bl	5b54 <atomic_and.constprop.25>
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
    62fc:	2306      	movs	r3, #6
    62fe:	f88d 300c 	strb.w	r3, [sp, #12]
                    m_event_handler(&evt);
    6302:	4b2e      	ldr	r3, [pc, #184]	; (63bc <usbd_dmareq_process+0x214>)
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
    6304:	f88d 500e 	strb.w	r5, [sp, #14]
    6308:	f88d 700f 	strb.w	r7, [sp, #15]
                    m_event_handler(&evt);
    630c:	681b      	ldr	r3, [r3, #0]
    630e:	a803      	add	r0, sp, #12
    6310:	4798      	blx	r3
                    continue;
    6312:	e755      	b.n	61c0 <usbd_dmareq_process+0x18>
                    NRFX_ASSERT(transfer.size == rx_size);
    6314:	d084      	beq.n	6220 <usbd_dmareq_process+0x78>
    6316:	4b2a      	ldr	r3, [pc, #168]	; (63c0 <usbd_dmareq_process+0x218>)
    6318:	4a21      	ldr	r2, [pc, #132]	; (63a0 <usbd_dmareq_process+0x1f8>)
    631a:	f44f 61b0 	mov.w	r1, #1408	; 0x580
    631e:	e76e      	b.n	61fe <usbd_dmareq_process+0x56>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT(epnr < NRFX_ARRAY_SIZE(NRF_USBD->EPIN));
            NRF_USBD->EPIN[epnr].PTR    = ptr;
    6320:	2114      	movs	r1, #20
    6322:	fb01 3306 	mla	r3, r1, r6, r3
    6326:	f8c3 0600 	str.w	r0, [r3, #1536]	; 0x600
            NRF_USBD->EPIN[epnr].MAXCNT = maxcnt;
    632a:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
    632e:	e799      	b.n	6264 <usbd_dmareq_process+0xbc>
        }
    }
    else
    {
        if (NRF_USBD_EPISO_CHECK(ep))
    6330:	b121      	cbz	r1, 633c <usbd_dmareq_process+0x194>
        {
            NRF_USBD->ISOOUT.PTR    = ptr;
    6332:	f8c3 07a0 	str.w	r0, [r3, #1952]	; 0x7a0
            NRF_USBD->ISOOUT.MAXCNT = maxcnt;
    6336:	f8c3 27a4 	str.w	r2, [r3, #1956]	; 0x7a4
    633a:	e793      	b.n	6264 <usbd_dmareq_process+0xbc>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT(epnr < NRFX_ARRAY_SIZE(NRF_USBD->EPOUT));
            NRF_USBD->EPOUT[epnr].PTR    = ptr;
    633c:	2114      	movs	r1, #20
    633e:	fb01 3306 	mla	r3, r1, r6, r3
    6342:	f8c3 0700 	str.w	r0, [r3, #1792]	; 0x700
            NRF_USBD->EPOUT[epnr].MAXCNT = maxcnt;
    6346:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
    634a:	e78b      	b.n	6264 <usbd_dmareq_process+0xbc>
                        nrfx_systick_delay_us(2);
    634c:	2002      	movs	r0, #2
    634e:	e7ab      	b.n	62a8 <usbd_dmareq_process+0x100>
    return (bool)*nrf_usbd_getRegPtr_c((uint32_t)event);
    6350:	f8b8 3000 	ldrh.w	r3, [r8]
    return (volatile const uint32_t*)(((uint8_t *)NRF_USBD) + (uint32_t)offset);
    6354:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    6358:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    return (bool)*nrf_usbd_getRegPtr_c((uint32_t)event);
    635c:	681b      	ldr	r3, [r3, #0]
                } while (!nrf_usbd_event_check(nrfx_usbd_ep_to_endevent(ep)));
    635e:	2b00      	cmp	r3, #0
    6360:	d091      	beq.n	6286 <usbd_dmareq_process+0xde>
}
    6362:	b007      	add	sp, #28
    6364:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    nrf_usbd_task_trigger(task_start_ep(ep));
    6368:	4628      	mov	r0, r5
    636a:	f7ff fa11 	bl	5790 <task_start_ep>
    636e:	f00b fd56 	bl	11e1e <nrf_usbd_task_trigger>
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
    6372:	ea14 0828 	ands.w	r8, r4, r8, asr #32
    6376:	bf38      	it	cc
    6378:	46c8      	movcc	r8, r9
    637a:	44b8      	add	r8, r7
    NRFX_USBD_ASSERT_EP_VALID(ep);
    637c:	2e08      	cmp	r6, #8
    637e:	d89e      	bhi.n	62be <usbd_dmareq_process+0x116>
    6380:	f8b8 3000 	ldrh.w	r3, [r8]
    return (volatile const uint32_t*)(((uint8_t *)NRF_USBD) + (uint32_t)offset);
    6384:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    6388:	f503 331c 	add.w	r3, r3, #159744	; 0x27000
    return (bool)*nrf_usbd_getRegPtr_c((uint32_t)event);
    638c:	681b      	ldr	r3, [r3, #0]
                while (!nrf_usbd_event_check(nrfx_usbd_ep_to_endevent(ep)))
    638e:	2b00      	cmp	r3, #0
    6390:	d0f4      	beq.n	637c <usbd_dmareq_process+0x1d4>
    6392:	e7e6      	b.n	6362 <usbd_dmareq_process+0x1ba>
    6394:	200058b6 	.word	0x200058b6
    6398:	2000235c 	.word	0x2000235c
    639c:	00017ceb 	.word	0x00017ceb
    63a0:	00017735 	.word	0x00017735
    63a4:	00017c80 	.word	0x00017c80
    63a8:	40027c1c 	.word	0x40027c1c
    63ac:	40027000 	.word	0x40027000
    63b0:	0001686e 	.word	0x0001686e
    63b4:	40027104 	.word	0x40027104
    63b8:	00017d14 	.word	0x00017d14
    63bc:	200024f0 	.word	0x200024f0
    63c0:	00017d27 	.word	0x00017d27
    63c4:	200023cc 	.word	0x200023cc
    63c8:	00016880 	.word	0x00016880
    63cc:	40027474 	.word	0x40027474

000063d0 <ev_epdata_handler>:
{
    63d0:	b538      	push	{r3, r4, r5, lr}
    return NRF_USBD->EPDATASTATUS;
    63d2:	4b17      	ldr	r3, [pc, #92]	; (6430 <ev_epdata_handler+0x60>)
    63d4:	f8d3 446c 	ldr.w	r4, [r3, #1132]	; 0x46c
    NRF_USBD->EPDATASTATUS = flags;
    63d8:	f8c3 446c 	str.w	r4, [r3, #1132]	; 0x46c
  __ASM volatile ("isb 0xF":::"memory");
    63dc:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    63e0:	f3bf 8f4f 	dsb	sy
    63e4:	f7ff f9a2 	bl	572c <nrfx_usbd_errata_type_52840_eng_b>
    if (nrfx_usbd_errata_104())
    63e8:	b938      	cbnz	r0, 63fa <ev_epdata_handler+0x2a>
        dataepstatus |= (m_simulated_dataepstatus &
    63ea:	4a12      	ldr	r2, [pc, #72]	; (6434 <ev_epdata_handler+0x64>)
    63ec:	6813      	ldr	r3, [r2, #0]
    63ee:	f023 1101 	bic.w	r1, r3, #65537	; 0x10001
        m_simulated_dataepstatus &=
    63f2:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
        dataepstatus |= (m_simulated_dataepstatus &
    63f6:	430c      	orrs	r4, r1
        m_simulated_dataepstatus &=
    63f8:	6013      	str	r3, [r2, #0]
        dataepstatus &= ~(1UL << bitpos);
    63fa:	2501      	movs	r5, #1
    while (dataepstatus)
    63fc:	b91c      	cbnz	r4, 6406 <ev_epdata_handler+0x36>
}
    63fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        usbd_dmareq_process();
    6402:	f7ff bed1 	b.w	61a8 <usbd_dmareq_process>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    6406:	fa94 f3a4 	rbit	r3, r4
        uint8_t bitpos    = __CLZ(__RBIT(dataepstatus));
    640a:	fab3 f383 	clz	r3, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    640e:	2b0f      	cmp	r3, #15
        uint8_t bitpos    = __CLZ(__RBIT(dataepstatus));
    6410:	b2d9      	uxtb	r1, r3
        NRF_USBD_EPOUT(bitpos - NRFX_USBD_EPOUT_BITPOS_0) : NRF_USBD_EPIN(bitpos));
    6412:	bfc4      	itt	gt
    6414:	f1a3 0010 	subgt.w	r0, r3, #16
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    6418:	b2c0      	uxtbgt	r0, r0
        dataepstatus &= ~(1UL << bitpos);
    641a:	fa05 f303 	lsl.w	r3, r5, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    641e:	bfd8      	it	le
    6420:	f041 0080 	orrle.w	r0, r1, #128	; 0x80
        dataepstatus &= ~(1UL << bitpos);
    6424:	ea24 0403 	bic.w	r4, r4, r3
        (void)(usbd_ep_data_handler(ep, bitpos));
    6428:	f7ff f9cc 	bl	57c4 <usbd_ep_data_handler>
    642c:	e7e6      	b.n	63fc <ev_epdata_handler+0x2c>
    642e:	bf00      	nop
    6430:	40027000 	.word	0x40027000
    6434:	200024f4 	.word	0x200024f4

00006438 <nrf_usbd_epout_dma_handler>:
{
    6438:	b537      	push	{r0, r1, r2, r4, r5, lr}
    643a:	4604      	mov	r4, r0
    usbd_dma_pending_clear();
    643c:	f7ff f986 	bl	574c <usbd_dma_pending_clear>
    usbd_ep_state_t * p_state = ep_state_access(ep);
    6440:	f7ff fa7a 	bl	5938 <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    6444:	7b83      	ldrb	r3, [r0, #14]
    6446:	2b03      	cmp	r3, #3
    6448:	d10c      	bne.n	6464 <nrf_usbd_epout_dma_handler+0x2c>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    644a:	4620      	mov	r0, r4
    644c:	f00b fcf3 	bl	11e36 <ep2bit>
    6450:	2301      	movs	r3, #1
    6452:	fa03 f000 	lsl.w	r0, r3, r0
    6456:	43c0      	mvns	r0, r0
    6458:	f7ff fb7c 	bl	5b54 <atomic_and.constprop.25>
    usbd_dmareq_process();
    645c:	f7ff fea4 	bl	61a8 <usbd_dmareq_process>
}
    6460:	b003      	add	sp, #12
    6462:	bd30      	pop	{r4, r5, pc}
    else if (p_state->handler.consumer == NULL)
    6464:	6805      	ldr	r5, [r0, #0]
    6466:	2d00      	cmp	r5, #0
    6468:	d1f8      	bne.n	645c <nrf_usbd_epout_dma_handler+0x24>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    646a:	4620      	mov	r0, r4
    646c:	f00b fce3 	bl	11e36 <ep2bit>
    6470:	2301      	movs	r3, #1
    6472:	fa03 f000 	lsl.w	r0, r3, r0
    6476:	43c0      	mvns	r0, r0
    6478:	f7ff fb6c 	bl	5b54 <atomic_and.constprop.25>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    647c:	2306      	movs	r3, #6
    647e:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
    6482:	4b04      	ldr	r3, [pc, #16]	; (6494 <nrf_usbd_epout_dma_handler+0x5c>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    6484:	f88d 4006 	strb.w	r4, [sp, #6]
    6488:	f88d 5007 	strb.w	r5, [sp, #7]
        m_event_handler(&evt);
    648c:	681b      	ldr	r3, [r3, #0]
    648e:	a801      	add	r0, sp, #4
    6490:	4798      	blx	r3
    6492:	e7e3      	b.n	645c <nrf_usbd_epout_dma_handler+0x24>
    6494:	200024f0 	.word	0x200024f0

00006498 <nrfx_usbd_ep_stall>:
{
    return (0 != ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep2bit(ep))));
}

void nrfx_usbd_ep_stall(nrfx_usbd_ep_t ep)
{
    6498:	b508      	push	{r3, lr}
    NRFX_USBD_ASSERT_EP_VALID(ep);
    649a:	f000 030f 	and.w	r3, r0, #15
    649e:	2b08      	cmp	r3, #8
    64a0:	d901      	bls.n	64a6 <nrfx_usbd_ep_stall+0xe>
    64a2:	f7ff fa87 	bl	59b4 <ep_to_hal.part.9>
    NRFX_ASSERT(!NRF_USBD_EPISO_CHECK(ep));
    64a6:	0703      	lsls	r3, r0, #28
    64a8:	d506      	bpl.n	64b8 <nrfx_usbd_ep_stall+0x20>
    64aa:	4b08      	ldr	r3, [pc, #32]	; (64cc <nrfx_usbd_ep_stall+0x34>)
    64ac:	4a08      	ldr	r2, [pc, #32]	; (64d0 <nrfx_usbd_ep_stall+0x38>)
    64ae:	4809      	ldr	r0, [pc, #36]	; (64d4 <nrfx_usbd_ep_stall+0x3c>)
    64b0:	f240 5101 	movw	r1, #1281	; 0x501
    64b4:	f7fa f962 	bl	77c <__assert_func>
    NRF_USBD->EPSTALL = (USBD_EPSTALL_STALL_Stall << USBD_EPSTALL_STALL_Pos) | ep;
    64b8:	4b07      	ldr	r3, [pc, #28]	; (64d8 <nrfx_usbd_ep_stall+0x40>)
    64ba:	f440 7080 	orr.w	r0, r0, #256	; 0x100
    64be:	f8c3 0518 	str.w	r0, [r3, #1304]	; 0x518
  __ASM volatile ("isb 0xF":::"memory");
    64c2:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    64c6:	f3bf 8f4f 	dsb	sy
    NRFX_LOG_DEBUG("USB: EP %x stalled.", ep);
    nrf_usbd_ep_stall(ep_to_hal(ep));
}
    64ca:	bd08      	pop	{r3, pc}
    64cc:	00017a61 	.word	0x00017a61
    64d0:	0001762c 	.word	0x0001762c
    64d4:	000178ee 	.word	0x000178ee
    64d8:	40027000 	.word	0x40027000

000064dc <nrfx_usbd_ep_stall_check>:
    }
    nrf_usbd_ep_unstall(ep_to_hal(ep));
}

bool nrfx_usbd_ep_stall_check(nrfx_usbd_ep_t ep)
{
    64dc:	b508      	push	{r3, lr}
    64de:	f000 030f 	and.w	r3, r0, #15
    NRFX_USBD_ASSERT_EP_VALID(ep);
    64e2:	2b08      	cmp	r3, #8
    64e4:	d901      	bls.n	64ea <nrfx_usbd_ep_stall_check+0xe>
    64e6:	f7ff fa65 	bl	59b4 <ep_to_hal.part.9>
    if (NRF_USBD_EPISO_CHECK(ep))
    64ea:	0702      	lsls	r2, r0, #28
    64ec:	d411      	bmi.n	6512 <nrfx_usbd_ep_stall_check+0x36>
    if (NRF_USBD_EPIN_CHECK(ep))
    64ee:	f010 0f80 	tst.w	r0, #128	; 0x80
    64f2:	4a09      	ldr	r2, [pc, #36]	; (6518 <nrfx_usbd_ep_stall_check+0x3c>)
        return NRF_USBD->HALTED.EPOUT[epnr];
    64f4:	bf0b      	itete	eq
    64f6:	f503 7388 	addeq.w	r3, r3, #272	; 0x110
        return NRF_USBD->HALTED.EPIN[epnr];
    64fa:	f503 7384 	addne.w	r3, r3, #264	; 0x108
        return NRF_USBD->HALTED.EPOUT[epnr];
    64fe:	eb02 0383 	addeq.w	r3, r2, r3, lsl #2
        return NRF_USBD->HALTED.EPIN[epnr];
    6502:	f852 0023 	ldrne.w	r0, [r2, r3, lsl #2]
        return NRF_USBD->HALTED.EPOUT[epnr];
    6506:	bf08      	it	eq
    6508:	6858      	ldreq	r0, [r3, #4]
    return USBD_HALTED_EPOUT_GETSTATUS_Halted == nrf_usbd_haltedep(ep);
    650a:	1e43      	subs	r3, r0, #1
    650c:	4258      	negs	r0, r3
    650e:	4158      	adcs	r0, r3
    return nrf_usbd_ep_is_stall(ep_to_hal(ep));
}
    6510:	bd08      	pop	{r3, pc}
        return false;
    6512:	2000      	movs	r0, #0
    6514:	e7fc      	b.n	6510 <nrfx_usbd_ep_stall_check+0x34>
    6516:	bf00      	nop
    6518:	40027000 	.word	0x40027000

0000651c <nrfx_usbd_setup_get>:
__ssp_bos_icheck3(memmove, void *, const void *)
__ssp_bos_icheck3_restrict(mempcpy, void *, const void *)
__ssp_bos_icheck3(memset, void *, int)
    651c:	2300      	movs	r3, #0
    651e:	6003      	str	r3, [r0, #0]
    6520:	6043      	str	r3, [r0, #4]
    return (uint8_t)(NRF_USBD->BMREQUESTTYPE);
    6522:	4b0e      	ldr	r3, [pc, #56]	; (655c <nrfx_usbd_setup_get+0x40>)
    6524:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
    6528:	7002      	strb	r2, [r0, #0]
    return (uint8_t)(NRF_USBD->BREQUEST);
    652a:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
    652e:	7042      	strb	r2, [r0, #1]
    const uint16_t val = NRF_USBD->WVALUEL;
    6530:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((NRF_USBD->WVALUEH) << 8));
    6534:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
    6538:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
void nrfx_usbd_setup_get(nrfx_usbd_setup_t * p_setup)
{
    memset(p_setup, 0, sizeof(nrfx_usbd_setup_t));
    p_setup->bmRequestType = nrf_usbd_setup_bmrequesttype_get();
    p_setup->bRequest      = nrf_usbd_setup_brequest_get();
    p_setup->wValue        = nrf_usbd_setup_wvalue_get();
    653c:	8042      	strh	r2, [r0, #2]
    const uint16_t val = NRF_USBD->WINDEXL;
    653e:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((NRF_USBD->WINDEXH) << 8));
    6542:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
    6546:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->wIndex        = nrf_usbd_setup_windex_get();
    654a:	8082      	strh	r2, [r0, #4]
    const uint16_t val = NRF_USBD->WLENGTHL;
    654c:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((NRF_USBD->WLENGTHH) << 8));
    6550:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
    6554:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    p_setup->wLength       = nrf_usbd_setup_wlength_get();
    6558:	80c3      	strh	r3, [r0, #6]
}
    655a:	4770      	bx	lr
    655c:	40027000 	.word	0x40027000

00006560 <ev_dma_epout0_handler>:
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
    6560:	b513      	push	{r0, r1, r4, lr}
    usbd_dma_pending_clear();
    6562:	f7ff f8f3 	bl	574c <usbd_dma_pending_clear>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
    6566:	4b0e      	ldr	r3, [pc, #56]	; (65a0 <ev_dma_epout0_handler+0x40>)
    6568:	7b9a      	ldrb	r2, [r3, #14]
    656a:	2a03      	cmp	r2, #3
    656c:	d105      	bne.n	657a <ev_dma_epout0_handler+0x1a>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    656e:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
    6572:	f7ff faef 	bl	5b54 <atomic_and.constprop.25>
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
    6576:	b002      	add	sp, #8
    6578:	bd10      	pop	{r4, pc}
    else if (p_state->handler.consumer == NULL)
    657a:	681c      	ldr	r4, [r3, #0]
    657c:	b96c      	cbnz	r4, 659a <ev_dma_epout0_handler+0x3a>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
    657e:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
    6582:	f7ff fae7 	bl	5b54 <atomic_and.constprop.25>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    6586:	2306      	movs	r3, #6
    6588:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
    658c:	4b05      	ldr	r3, [pc, #20]	; (65a4 <ev_dma_epout0_handler+0x44>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
    658e:	f8ad 4006 	strh.w	r4, [sp, #6]
        m_event_handler(&evt);
    6592:	681b      	ldr	r3, [r3, #0]
    6594:	a801      	add	r0, sp, #4
    6596:	4798      	blx	r3
    6598:	e7ed      	b.n	6576 <ev_dma_epout0_handler+0x16>
        nrfx_usbd_setup_data_clear();
    659a:	f00b fcb6 	bl	11f0a <nrfx_usbd_setup_data_clear>
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
    659e:	e7ea      	b.n	6576 <ev_dma_epout0_handler+0x16>
    65a0:	200023d0 	.word	0x200023d0
    65a4:	200024f0 	.word	0x200024f0

000065a8 <nrfx_usbd_last_setup_dir_get>:
}

nrfx_usbd_ep_t nrfx_usbd_last_setup_dir_get(void)
{
    return m_last_setup_dir;
}
    65a8:	4b01      	ldr	r3, [pc, #4]	; (65b0 <nrfx_usbd_last_setup_dir_get+0x8>)
    65aa:	7818      	ldrb	r0, [r3, #0]
    65ac:	4770      	bx	lr
    65ae:	bf00      	nop
    65b0:	200058b8 	.word	0x200058b8

000065b4 <nrfx_usbd_transfer_out_drop>:

void nrfx_usbd_transfer_out_drop(nrfx_usbd_ep_t ep)
{
    65b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    NRFX_ASSERT(NRF_USBD_EPOUT_CHECK(ep));
    65b6:	0603      	lsls	r3, r0, #24
{
    65b8:	4604      	mov	r4, r0
    NRFX_ASSERT(NRF_USBD_EPOUT_CHECK(ep));
    65ba:	d506      	bpl.n	65ca <nrfx_usbd_transfer_out_drop+0x16>
    65bc:	4b28      	ldr	r3, [pc, #160]	; (6660 <nrfx_usbd_transfer_out_drop+0xac>)
    65be:	4a29      	ldr	r2, [pc, #164]	; (6664 <nrfx_usbd_transfer_out_drop+0xb0>)
    65c0:	4829      	ldr	r0, [pc, #164]	; (6668 <nrfx_usbd_transfer_out_drop+0xb4>)
    65c2:	f640 110a 	movw	r1, #2314	; 0x90a
    65c6:	f7fa f8d9 	bl	77c <__assert_func>
    65ca:	f7ff f8af 	bl	572c <nrfx_usbd_errata_type_52840_eng_b>
    65ce:	4d27      	ldr	r5, [pc, #156]	; (666c <nrfx_usbd_transfer_out_drop+0xb8>)

    if (nrfx_usbd_errata_200())
    65d0:	4606      	mov	r6, r0
    65d2:	bb00      	cbnz	r0, 6616 <nrfx_usbd_transfer_out_drop+0x62>
	__asm__ volatile(
    65d4:	f04f 0320 	mov.w	r3, #32
    65d8:	f3ef 8711 	mrs	r7, BASEPRI
    65dc:	f383 8811 	msr	BASEPRI, r3
    65e0:	f3bf 8f6f 	isb	sy
    {
        NRFX_CRITICAL_SECTION_ENTER();
        m_ep_ready &= ~(1U << ep2bit(ep));
    65e4:	4620      	mov	r0, r4
    65e6:	f00b fc26 	bl	11e36 <ep2bit>
    65ea:	2301      	movs	r3, #1
    65ec:	fa03 f000 	lsl.w	r0, r3, r0
    65f0:	682b      	ldr	r3, [r5, #0]
        *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7C5 + (2u * NRF_USBD_EP_NR_GET(ep));
    65f2:	f004 040f 	and.w	r4, r4, #15
        m_ep_ready &= ~(1U << ep2bit(ep));
    65f6:	ea23 0300 	bic.w	r3, r3, r0
    65fa:	602b      	str	r3, [r5, #0]
        *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7C5 + (2u * NRF_USBD_EP_NR_GET(ep));
    65fc:	0064      	lsls	r4, r4, #1
    65fe:	4b1c      	ldr	r3, [pc, #112]	; (6670 <nrfx_usbd_transfer_out_drop+0xbc>)
    6600:	f204 74c5 	addw	r4, r4, #1989	; 0x7c5
    6604:	601c      	str	r4, [r3, #0]
        *((volatile uint32_t *)(NRF_USBD_BASE + 0x804)) = 0;
    6606:	605e      	str	r6, [r3, #4]
    6608:	3304      	adds	r3, #4
        (void)(*((volatile uint32_t *)(NRF_USBD_BASE + 0x804)));
    660a:	681b      	ldr	r3, [r3, #0]
	__asm__ volatile(
    660c:	f387 8811 	msr	BASEPRI, r7
    6610:	f3bf 8f6f 	isb	sy
        {
            nrf_usbd_epout_clear(ep);
        }
        NRFX_CRITICAL_SECTION_EXIT();
    }
}
    6614:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__asm__ volatile(
    6616:	f04f 0320 	mov.w	r3, #32
    661a:	f3ef 8611 	mrs	r6, BASEPRI
    661e:	f383 8811 	msr	BASEPRI, r3
    6622:	f3bf 8f6f 	isb	sy
        m_ep_ready &= ~(1U << ep2bit(ep));
    6626:	4620      	mov	r0, r4
    6628:	f00b fc05 	bl	11e36 <ep2bit>
    662c:	2301      	movs	r3, #1
    662e:	fa03 f000 	lsl.w	r0, r3, r0
    6632:	682b      	ldr	r3, [r5, #0]
        if (!NRF_USBD_EPISO_CHECK(ep))
    6634:	f014 0208 	ands.w	r2, r4, #8
        m_ep_ready &= ~(1U << ep2bit(ep));
    6638:	ea23 0300 	bic.w	r3, r3, r0
    663c:	602b      	str	r3, [r5, #0]
        if (!NRF_USBD_EPISO_CHECK(ep))
    663e:	d10a      	bne.n	6656 <nrfx_usbd_transfer_out_drop+0xa2>
    NRF_USBD->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)] = 0;
    6640:	f004 040f 	and.w	r4, r4, #15
    6644:	f504 7494 	add.w	r4, r4, #296	; 0x128
    6648:	4b0a      	ldr	r3, [pc, #40]	; (6674 <nrfx_usbd_transfer_out_drop+0xc0>)
    664a:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  __ASM volatile ("isb 0xF":::"memory");
    664e:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    6652:	f3bf 8f4f 	dsb	sy
	__asm__ volatile(
    6656:	f386 8811 	msr	BASEPRI, r6
    665a:	f3bf 8f6f 	isb	sy
}
    665e:	e7d9      	b.n	6614 <nrfx_usbd_transfer_out_drop+0x60>
    6660:	00017af9 	.word	0x00017af9
    6664:	000177e2 	.word	0x000177e2
    6668:	00017c80 	.word	0x00017c80
    666c:	200023cc 	.word	0x200023cc
    6670:	40027800 	.word	0x40027800
    6674:	40027000 	.word	0x40027000

00006678 <usbd_ep_abort>:
{
    6678:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    667c:	4604      	mov	r4, r0
    667e:	b085      	sub	sp, #20
	__asm__ volatile(
    6680:	f04f 0320 	mov.w	r3, #32
    6684:	f3ef 8711 	mrs	r7, BASEPRI
    6688:	f383 8811 	msr	BASEPRI, r3
    668c:	f3bf 8f6f 	isb	sy
    usbd_ep_state_t * p_state = ep_state_access(ep);
    6690:	f7ff f952 	bl	5938 <ep_state_access>
    if (NRF_USBD_EPOUT_CHECK(ep))
    6694:	f014 0f80 	tst.w	r4, #128	; 0x80
    usbd_ep_state_t * p_state = ep_state_access(ep);
    6698:	4605      	mov	r5, r0
    if (NRF_USBD_EPOUT_CHECK(ep))
    669a:	4e3d      	ldr	r6, [pc, #244]	; (6790 <usbd_ep_abort+0x118>)
    669c:	d12b      	bne.n	66f6 <usbd_ep_abort+0x7e>
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
    669e:	4620      	mov	r0, r4
    66a0:	f00b fbc9 	bl	11e36 <ep2bit>
    66a4:	f8d6 9000 	ldr.w	r9, [r6]
    66a8:	f04f 0801 	mov.w	r8, #1
    66ac:	fa08 f000 	lsl.w	r0, r8, r0
    66b0:	ea30 0009 	bics.w	r0, r0, r9
    66b4:	d00b      	beq.n	66ce <usbd_ep_abort+0x56>
            nrfx_usbd_transfer_out_drop(ep);
    66b6:	4620      	mov	r0, r4
    66b8:	f7ff ff7c 	bl	65b4 <nrfx_usbd_transfer_out_drop>
        p_state->status = NRFX_USBD_EP_ABORTED;
    66bc:	2303      	movs	r3, #3
    66be:	73ab      	strb	r3, [r5, #14]
	__asm__ volatile(
    66c0:	f387 8811 	msr	BASEPRI, r7
    66c4:	f3bf 8f6f 	isb	sy
}
    66c8:	b005      	add	sp, #20
    66ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            p_state->handler.consumer = NULL;
    66ce:	6028      	str	r0, [r5, #0]
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
    66d0:	4620      	mov	r0, r4
    66d2:	f00b fbb0 	bl	11e36 <ep2bit>
    66d6:	fa08 f000 	lsl.w	r0, r8, r0
    66da:	ea29 0000 	bic.w	r0, r9, r0
    66de:	6030      	str	r0, [r6, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
    66e0:	4620      	mov	r0, r4
    66e2:	f00b fba8 	bl	11e36 <ep2bit>
    66e6:	4a2b      	ldr	r2, [pc, #172]	; (6794 <usbd_ep_abort+0x11c>)
    66e8:	6813      	ldr	r3, [r2, #0]
    66ea:	fa08 f000 	lsl.w	r0, r8, r0
    66ee:	ea23 0000 	bic.w	r0, r3, r0
    66f2:	6010      	str	r0, [r2, #0]
    66f4:	e7e2      	b.n	66bc <usbd_ep_abort+0x44>
        if(!NRF_USBD_EPISO_CHECK(ep))
    66f6:	0723      	lsls	r3, r4, #28
    66f8:	d411      	bmi.n	671e <usbd_ep_abort+0xa6>
            if(ep != NRFX_USBD_EPIN0)
    66fa:	2c80      	cmp	r4, #128	; 0x80
    66fc:	4926      	ldr	r1, [pc, #152]	; (6798 <usbd_ep_abort+0x120>)
    66fe:	4b27      	ldr	r3, [pc, #156]	; (679c <usbd_ep_abort+0x124>)
    6700:	d03c      	beq.n	677c <usbd_ep_abort+0x104>
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7B6 + (2u * (NRF_USBD_EP_NR_GET(ep) - 1));
    6702:	f004 020f 	and.w	r2, r4, #15
    6706:	0052      	lsls	r2, r2, #1
    6708:	f202 72b4 	addw	r2, r2, #1972	; 0x7b4
    670c:	600a      	str	r2, [r1, #0]
                uint8_t temp = *((volatile uint32_t *)(NRF_USBD_BASE + 0x804));
    670e:	681a      	ldr	r2, [r3, #0]
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x804)) |= temp;
    6710:	6819      	ldr	r1, [r3, #0]
                uint8_t temp = *((volatile uint32_t *)(NRF_USBD_BASE + 0x804));
    6712:	b2d2      	uxtb	r2, r2
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x804)) |= temp;
    6714:	f042 0202 	orr.w	r2, r2, #2
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x804)) |= temp;
    6718:	430a      	orrs	r2, r1
    671a:	601a      	str	r2, [r3, #0]
                (void)(*((volatile uint32_t *)(NRF_USBD_BASE + 0x804)));
    671c:	681b      	ldr	r3, [r3, #0]
        if ((m_ep_dma_waiting | (~m_ep_ready)) & (1U << ep2bit(ep)))
    671e:	f8df 9074 	ldr.w	r9, [pc, #116]	; 6794 <usbd_ep_abort+0x11c>
    6722:	f8d6 b000 	ldr.w	fp, [r6]
    6726:	f8d9 a000 	ldr.w	sl, [r9]
    672a:	4620      	mov	r0, r4
    672c:	ea6b 030a 	orn	r3, fp, sl
    6730:	9301      	str	r3, [sp, #4]
    6732:	f00b fb80 	bl	11e36 <ep2bit>
    6736:	f04f 0801 	mov.w	r8, #1
    673a:	9b01      	ldr	r3, [sp, #4]
    673c:	fa08 f000 	lsl.w	r0, r8, r0
    6740:	4203      	tst	r3, r0
    6742:	d0bd      	beq.n	66c0 <usbd_ep_abort+0x48>
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
    6744:	ea2b 0000 	bic.w	r0, fp, r0
    6748:	6030      	str	r0, [r6, #0]
            m_ep_ready       |=   1U << ep2bit(ep) ;
    674a:	4620      	mov	r0, r4
    674c:	f00b fb73 	bl	11e36 <ep2bit>
            p_state->handler.feeder = NULL;
    6750:	2300      	movs	r3, #0
    6752:	602b      	str	r3, [r5, #0]
            p_state->status = NRFX_USBD_EP_ABORTED;
    6754:	2303      	movs	r3, #3
            m_ep_ready       |=   1U << ep2bit(ep) ;
    6756:	fa08 f000 	lsl.w	r0, r8, r0
            p_state->status = NRFX_USBD_EP_ABORTED;
    675a:	73ab      	strb	r3, [r5, #14]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
    675c:	f88d 300f 	strb.w	r3, [sp, #15]
            m_event_handler(&evt);
    6760:	4b0f      	ldr	r3, [pc, #60]	; (67a0 <usbd_ep_abort+0x128>)
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
    6762:	f88d 400e 	strb.w	r4, [sp, #14]
            m_ep_ready       |=   1U << ep2bit(ep) ;
    6766:	ea40 000a 	orr.w	r0, r0, sl
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
    676a:	2206      	movs	r2, #6
            m_ep_ready       |=   1U << ep2bit(ep) ;
    676c:	f8c9 0000 	str.w	r0, [r9]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
    6770:	f88d 200c 	strb.w	r2, [sp, #12]
            m_event_handler(&evt);
    6774:	681b      	ldr	r3, [r3, #0]
    6776:	a803      	add	r0, sp, #12
    6778:	4798      	blx	r3
    677a:	e7a1      	b.n	66c0 <usbd_ep_abort+0x48>
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7B4;
    677c:	f240 72b4 	movw	r2, #1972	; 0x7b4
    6780:	600a      	str	r2, [r1, #0]
                uint8_t temp = *((volatile uint32_t *)(NRF_USBD_BASE + 0x804));
    6782:	681a      	ldr	r2, [r3, #0]
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x804)) |= temp;
    6784:	6819      	ldr	r1, [r3, #0]
                uint8_t temp = *((volatile uint32_t *)(NRF_USBD_BASE + 0x804));
    6786:	b2d2      	uxtb	r2, r2
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x804)) |= temp;
    6788:	f042 0204 	orr.w	r2, r2, #4
    678c:	e7c4      	b.n	6718 <usbd_ep_abort+0xa0>
    678e:	bf00      	nop
    6790:	2000235c 	.word	0x2000235c
    6794:	200023cc 	.word	0x200023cc
    6798:	40027800 	.word	0x40027800
    679c:	40027804 	.word	0x40027804
    67a0:	200024f0 	.word	0x200024f0

000067a4 <ev_setup_handler>:
{
    67a4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    return (uint8_t)(NRF_USBD->BMREQUESTTYPE);
    67a8:	4b17      	ldr	r3, [pc, #92]	; (6808 <ev_setup_handler+0x64>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
    67aa:	4d18      	ldr	r5, [pc, #96]	; (680c <ev_setup_handler+0x68>)
    67ac:	f8d3 7480 	ldr.w	r7, [r3, #1152]	; 0x480
    67b0:	682b      	ldr	r3, [r5, #0]
        & (1U <<ep2bit(m_last_setup_dir)))
    67b2:	4e17      	ldr	r6, [pc, #92]	; (6810 <ev_setup_handler+0x6c>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
    67b4:	43dc      	mvns	r4, r3
    67b6:	4b17      	ldr	r3, [pc, #92]	; (6814 <ev_setup_handler+0x70>)
        & (1U <<ep2bit(m_last_setup_dir)))
    67b8:	f896 8000 	ldrb.w	r8, [r6]
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
    67bc:	681b      	ldr	r3, [r3, #0]
    67be:	b2a4      	uxth	r4, r4
        & (1U <<ep2bit(m_last_setup_dir)))
    67c0:	4640      	mov	r0, r8
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
    67c2:	431c      	orrs	r4, r3
        & (1U <<ep2bit(m_last_setup_dir)))
    67c4:	f00b fb37 	bl	11e36 <ep2bit>
    67c8:	2301      	movs	r3, #1
    67ca:	fa03 f000 	lsl.w	r0, r3, r0
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
    67ce:	4220      	tst	r0, r4
    67d0:	d002      	beq.n	67d8 <ev_setup_handler+0x34>
        usbd_ep_abort(m_last_setup_dir);
    67d2:	4640      	mov	r0, r8
    67d4:	f7ff ff50 	bl	6678 <usbd_ep_abort>
        NRFX_USBD_EPOUT0 : NRFX_USBD_EPIN0;
    67d8:	f007 0780 	and.w	r7, r7, #128	; 0x80
    (void)(NRFX_ATOMIC_FETCH_AND(
    67dc:	f06f 1001 	mvn.w	r0, #65537	; 0x10001
    m_last_setup_dir =
    67e0:	7037      	strb	r7, [r6, #0]
    (void)(NRFX_ATOMIC_FETCH_AND(
    67e2:	f7ff f9b7 	bl	5b54 <atomic_and.constprop.25>
    m_ep_ready |= 1U << ep2bit(NRFX_USBD_EPIN0);
    67e6:	682b      	ldr	r3, [r5, #0]
    67e8:	f043 0301 	orr.w	r3, r3, #1
    67ec:	602b      	str	r3, [r5, #0]
    const nrfx_usbd_evt_t evt = {
    67ee:	2300      	movs	r3, #0
    67f0:	9301      	str	r3, [sp, #4]
    67f2:	2305      	movs	r3, #5
    67f4:	f88d 3004 	strb.w	r3, [sp, #4]
    m_event_handler(&evt);
    67f8:	4b07      	ldr	r3, [pc, #28]	; (6818 <ev_setup_handler+0x74>)
    67fa:	a801      	add	r0, sp, #4
    67fc:	681b      	ldr	r3, [r3, #0]
    67fe:	4798      	blx	r3
}
    6800:	b002      	add	sp, #8
    6802:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6806:	bf00      	nop
    6808:	40027000 	.word	0x40027000
    680c:	200023cc 	.word	0x200023cc
    6810:	200058b8 	.word	0x200058b8
    6814:	2000235c 	.word	0x2000235c
    6818:	200024f0 	.word	0x200024f0

0000681c <nrfx_usbd_irq_handler>:
    return NRF_USBD->INTENSET;
    681c:	4b55      	ldr	r3, [pc, #340]	; (6974 <nrfx_usbd_irq_handler+0x158>)
{
    681e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6822:	f8d3 5304 	ldr.w	r5, [r3, #772]	; 0x304
    uint32_t active = 0;
    6826:	2200      	movs	r2, #0
    uint32_t to_process = enabled;
    6828:	4629      	mov	r1, r5
    *(nrf_usbd_getRegPtr((uint32_t)event)) = 0UL;
    682a:	4616      	mov	r6, r2
            active |= 1UL << event_nr;
    682c:	2401      	movs	r4, #1
    while (to_process)
    682e:	2900      	cmp	r1, #0
    6830:	d17c      	bne.n	692c <nrfx_usbd_irq_handler+0x110>
    6832:	f7fe ff7b 	bl	572c <nrfx_usbd_errata_type_52840_eng_b>
    if (nrfx_usbd_errata_104())
    6836:	2800      	cmp	r0, #0
    6838:	d169      	bne.n	690e <nrfx_usbd_irq_handler+0xf2>
        if ((!m_dma_pending) && (0 != (active & (USBD_INTEN_SOF_Msk))))
    683a:	4b4f      	ldr	r3, [pc, #316]	; (6978 <nrfx_usbd_irq_handler+0x15c>)
    683c:	781b      	ldrb	r3, [r3, #0]
    683e:	2b00      	cmp	r3, #0
    6840:	d165      	bne.n	690e <nrfx_usbd_irq_handler+0xf2>
    6842:	0296      	lsls	r6, r2, #10
    6844:	d563      	bpl.n	690e <nrfx_usbd_irq_handler+0xf2>
            *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7A9;
    6846:	494d      	ldr	r1, [pc, #308]	; (697c <nrfx_usbd_irq_handler+0x160>)
            *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7AB;
    6848:	4e4c      	ldr	r6, [pc, #304]	; (697c <nrfx_usbd_irq_handler+0x160>)
            *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7A9;
    684a:	f240 73a9 	movw	r3, #1961	; 0x7a9
    684e:	600b      	str	r3, [r1, #0]
            uii = (uint8_t)(*((volatile uint32_t *)(NRF_USBD_BASE + 0x804)));
    6850:	4b4b      	ldr	r3, [pc, #300]	; (6980 <nrfx_usbd_irq_handler+0x164>)
    6852:	681c      	ldr	r4, [r3, #0]
            if (0 != uii)
    6854:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
                uii &= (uint8_t)(*((volatile uint32_t *)(NRF_USBD_BASE + 0x804)));
    6858:	bf1c      	itt	ne
    685a:	6818      	ldrne	r0, [r3, #0]
    685c:	4004      	andne	r4, r0
            *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7AA;
    685e:	f240 70aa 	movw	r0, #1962	; 0x7aa
    6862:	6008      	str	r0, [r1, #0]
            uoi = (uint8_t)(*((volatile uint32_t *)(NRF_USBD_BASE + 0x804)));
    6864:	6818      	ldr	r0, [r3, #0]
            if (0 != uoi)
    6866:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
                uoi &= (uint8_t)(*((volatile uint32_t *)(NRF_USBD_BASE + 0x804)));
    686a:	bf1c      	itt	ne
    686c:	6819      	ldrne	r1, [r3, #0]
    686e:	4008      	andne	r0, r1
            *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7AB;
    6870:	f240 71ab 	movw	r1, #1963	; 0x7ab
    6874:	6031      	str	r1, [r6, #0]
            usbi = (uint8_t)(*((volatile uint32_t *)(NRF_USBD_BASE + 0x804)));
    6876:	6819      	ldr	r1, [r3, #0]
            if (0 != usbi)
    6878:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
    687c:	46b4      	mov	ip, r6
                usbi &= (uint8_t)(*((volatile uint32_t *)(NRF_USBD_BASE + 0x804)));
    687e:	bf1c      	itt	ne
    6880:	681e      	ldrne	r6, [r3, #0]
    6882:	4031      	andne	r1, r6
            *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7AC;
    6884:	f240 76ac 	movw	r6, #1964	; 0x7ac
    6888:	f8cc 6000 	str.w	r6, [ip]
            uii &= (uint8_t)*((volatile uint32_t *)(NRF_USBD_BASE + 0x804));
    688c:	681e      	ldr	r6, [r3, #0]
            if (0 != uii)
    688e:	4034      	ands	r4, r6
    6890:	4e3c      	ldr	r6, [pc, #240]	; (6984 <nrfx_usbd_irq_handler+0x168>)
    6892:	d008      	beq.n	68a6 <nrfx_usbd_irq_handler+0x8a>
                m_simulated_dataepstatus |= ((uint32_t)uii) << NRFX_USBD_EPIN_BITPOS_0;
    6894:	6837      	ldr	r7, [r6, #0]
    6896:	4327      	orrs	r7, r4
    6898:	6037      	str	r7, [r6, #0]
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7A9;
    689a:	f240 77a9 	movw	r7, #1961	; 0x7a9
    689e:	f8cc 7000 	str.w	r7, [ip]
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x804)) = uii;
    68a2:	601c      	str	r4, [r3, #0]
                rb = (uint8_t)*((volatile uint32_t *)(NRF_USBD_BASE + 0x804));
    68a4:	681c      	ldr	r4, [r3, #0]
            *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7AD;
    68a6:	4f35      	ldr	r7, [pc, #212]	; (697c <nrfx_usbd_irq_handler+0x160>)
    68a8:	f240 74ad 	movw	r4, #1965	; 0x7ad
    68ac:	603c      	str	r4, [r7, #0]
            uoi &= (uint8_t)*((volatile uint32_t *)(NRF_USBD_BASE + 0x804));
    68ae:	681c      	ldr	r4, [r3, #0]
            if (0 != uoi)
    68b0:	4020      	ands	r0, r4
    68b2:	d008      	beq.n	68c6 <nrfx_usbd_irq_handler+0xaa>
                m_simulated_dataepstatus |= ((uint32_t)uoi) << NRFX_USBD_EPOUT_BITPOS_0;
    68b4:	6834      	ldr	r4, [r6, #0]
    68b6:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
    68ba:	6034      	str	r4, [r6, #0]
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7AA;
    68bc:	f240 74aa 	movw	r4, #1962	; 0x7aa
    68c0:	603c      	str	r4, [r7, #0]
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x804)) = uoi;
    68c2:	6018      	str	r0, [r3, #0]
                rb = (uint8_t)*((volatile uint32_t *)(NRF_USBD_BASE + 0x804));
    68c4:	6818      	ldr	r0, [r3, #0]
            *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7AE;
    68c6:	482d      	ldr	r0, [pc, #180]	; (697c <nrfx_usbd_irq_handler+0x160>)
    68c8:	f240 74ae 	movw	r4, #1966	; 0x7ae
    68cc:	6004      	str	r4, [r0, #0]
            usbi &= (uint8_t)*((volatile uint32_t *)(NRF_USBD_BASE + 0x804));
    68ce:	6818      	ldr	r0, [r3, #0]
            if (0 != usbi)
    68d0:	4001      	ands	r1, r0
    68d2:	d00d      	beq.n	68f0 <nrfx_usbd_irq_handler+0xd4>
                if (usbi & 0x01)
    68d4:	07cc      	lsls	r4, r1, #31
                    active |= USBD_INTEN_EP0SETUP_Msk;
    68d6:	bf48      	it	mi
    68d8:	f442 0200 	orrmi.w	r2, r2, #8388608	; 0x800000
                if (usbi & 0x10)
    68dc:	06c8      	lsls	r0, r1, #27
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x800)) = 0x7AB;
    68de:	4827      	ldr	r0, [pc, #156]	; (697c <nrfx_usbd_irq_handler+0x160>)
    68e0:	f240 74ab 	movw	r4, #1963	; 0x7ab
    68e4:	6004      	str	r4, [r0, #0]
                *((volatile uint32_t *)(NRF_USBD_BASE + 0x804)) = usbi;
    68e6:	6019      	str	r1, [r3, #0]
                rb = (uint8_t)*((volatile uint32_t *)(NRF_USBD_BASE + 0x804));
    68e8:	681b      	ldr	r3, [r3, #0]
                    active |= USBD_INTEN_USBRESET_Msk;
    68ea:	bf48      	it	mi
    68ec:	f042 0201 	orrmi.w	r2, r2, #1
            if (0 != (m_simulated_dataepstatus &
    68f0:	6833      	ldr	r3, [r6, #0]
    68f2:	f033 1101 	bics.w	r1, r3, #65537	; 0x10001
                active |= enabled & NRF_USBD_INT_DATAEP_MASK;
    68f6:	bf1c      	itt	ne
    68f8:	f005 7080 	andne.w	r0, r5, #16777216	; 0x1000000
    68fc:	4302      	orrne	r2, r0
            if (0 != (m_simulated_dataepstatus &
    68fe:	f013 1f01 	tst.w	r3, #65537	; 0x10001
    6902:	d004      	beq.n	690e <nrfx_usbd_irq_handler+0xf2>
                if (0 != (enabled & NRF_USBD_INT_EP0DATADONE_MASK))
    6904:	056b      	lsls	r3, r5, #21
                    m_simulated_dataepstatus &=
    6906:	bf44      	itt	mi
    6908:	6031      	strmi	r1, [r6, #0]
                    active |= NRF_USBD_INT_EP0DATADONE_MASK;
    690a:	f442 6280 	orrmi.w	r2, r2, #1024	; 0x400
        m_isr[event_nr]();
    690e:	4f1e      	ldr	r7, [pc, #120]	; (6988 <nrfx_usbd_irq_handler+0x16c>)
    bool setup_active = 0 != (active & NRF_USBD_INT_EP0SETUP_MASK);
    6910:	f402 0600 	and.w	r6, r2, #8388608	; 0x800000
    active &= ~NRF_USBD_INT_EP0SETUP_MASK;
    6914:	f422 0400 	bic.w	r4, r2, #8388608	; 0x800000
        active &= ~(1UL << event_nr);
    6918:	f04f 0801 	mov.w	r8, #1
    while (active)
    691c:	b9e4      	cbnz	r4, 6958 <nrfx_usbd_irq_handler+0x13c>
    usbd_dmareq_process();
    691e:	f7ff fc43 	bl	61a8 <usbd_dmareq_process>
    if (setup_active)
    6922:	b32e      	cbz	r6, 6970 <nrfx_usbd_irq_handler+0x154>
}
    6924:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        m_isr[USBD_INTEN_EP0SETUP_Pos]();
    6928:	f7ff bf3c 	b.w	67a4 <ev_setup_handler>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    692c:	fa91 f3a1 	rbit	r3, r1
    return (volatile const uint32_t*)(((uint8_t *)NRF_USBD) + (uint32_t)offset);
    6930:	4816      	ldr	r0, [pc, #88]	; (698c <nrfx_usbd_irq_handler+0x170>)
        uint8_t event_nr = __CLZ(__RBIT(to_process));
    6932:	fab3 f383 	clz	r3, r3
}

__STATIC_INLINE uint32_t nrfx_bitpos_to_event(uint32_t bit)
{
    static const uint32_t event_reg_offset = 0x100u;
    return event_reg_offset + (bit * sizeof(uint32_t));
    6936:	009f      	lsls	r7, r3, #2
    6938:	4438      	add	r0, r7
    return (bool)*nrf_usbd_getRegPtr_c((uint32_t)event);
    693a:	6807      	ldr	r7, [r0, #0]
    if (ret)
    693c:	b13f      	cbz	r7, 694e <nrfx_usbd_irq_handler+0x132>
    *(nrf_usbd_getRegPtr((uint32_t)event)) = 0UL;
    693e:	6006      	str	r6, [r0, #0]
  __ASM volatile ("isb 0xF":::"memory");
    6940:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    6944:	f3bf 8f4f 	dsb	sy
            active |= 1UL << event_nr;
    6948:	fa04 f003 	lsl.w	r0, r4, r3
    694c:	4302      	orrs	r2, r0
        to_process &= ~(1UL << event_nr);
    694e:	fa04 f303 	lsl.w	r3, r4, r3
    6952:	ea21 0103 	bic.w	r1, r1, r3
    6956:	e76a      	b.n	682e <nrfx_usbd_irq_handler+0x12>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    6958:	fa94 f5a4 	rbit	r5, r4
        uint8_t event_nr = __CLZ(__RBIT(active));
    695c:	fab5 f585 	clz	r5, r5
        m_isr[event_nr]();
    6960:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
        active &= ~(1UL << event_nr);
    6964:	fa08 f505 	lsl.w	r5, r8, r5
        m_isr[event_nr]();
    6968:	4798      	blx	r3
        active &= ~(1UL << event_nr);
    696a:	ea24 0405 	bic.w	r4, r4, r5
    696e:	e7d5      	b.n	691c <nrfx_usbd_irq_handler+0x100>
}
    6970:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6974:	40027000 	.word	0x40027000
    6978:	200058b6 	.word	0x200058b6
    697c:	40027800 	.word	0x40027800
    6980:	40027804 	.word	0x40027804
    6984:	200024f4 	.word	0x200024f4
    6988:	00016638 	.word	0x00016638
    698c:	40027100 	.word	0x40027100

00006990 <usbd_ep_abort_all>:
{
    6990:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint32_t ep_waiting = m_ep_dma_waiting | (m_ep_ready & NRFX_USBD_EPOUT_BIT_MASK);
    6992:	4e10      	ldr	r6, [pc, #64]	; (69d4 <usbd_ep_abort_all+0x44>)
    6994:	4a10      	ldr	r2, [pc, #64]	; (69d8 <usbd_ep_abort_all+0x48>)
    6996:	6834      	ldr	r4, [r6, #0]
    6998:	6812      	ldr	r2, [r2, #0]
    699a:	0c24      	lsrs	r4, r4, #16
    699c:	0424      	lsls	r4, r4, #16
    699e:	4314      	orrs	r4, r2
        ep_waiting &= ~(1U << bitpos);
    69a0:	2701      	movs	r7, #1
    while (0 != ep_waiting)
    69a2:	b91c      	cbnz	r4, 69ac <usbd_ep_abort_all+0x1c>
    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
    69a4:	f240 13ff 	movw	r3, #511	; 0x1ff
    69a8:	6033      	str	r3, [r6, #0]
}
    69aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    69ac:	fa94 f5a4 	rbit	r5, r4
        uint8_t bitpos = __CLZ(__RBIT(ep_waiting));
    69b0:	fab5 f585 	clz	r5, r5
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    69b4:	2d0f      	cmp	r5, #15
        NRF_USBD_EPOUT(bitpos - NRFX_USBD_EPOUT_BITPOS_0) : NRF_USBD_EPIN(bitpos));
    69b6:	bfc6      	itte	gt
    69b8:	f1a5 0010 	subgt.w	r0, r5, #16
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
    69bc:	b2c0      	uxtbgt	r0, r0
    69be:	f045 0080 	orrle.w	r0, r5, #128	; 0x80
        if (!NRF_USBD_EPISO_CHECK(bit2ep(bitpos)))
    69c2:	0703      	lsls	r3, r0, #28
    69c4:	d401      	bmi.n	69ca <usbd_ep_abort_all+0x3a>
            usbd_ep_abort(bit2ep(bitpos));
    69c6:	f7ff fe57 	bl	6678 <usbd_ep_abort>
        ep_waiting &= ~(1U << bitpos);
    69ca:	fa07 f505 	lsl.w	r5, r7, r5
    69ce:	ea24 0405 	bic.w	r4, r4, r5
    69d2:	e7e6      	b.n	69a2 <usbd_ep_abort_all+0x12>
    69d4:	200023cc 	.word	0x200023cc
    69d8:	2000235c 	.word	0x2000235c

000069dc <nrfx_usbd_stop>:
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_POWERED_ON);
    69dc:	4b12      	ldr	r3, [pc, #72]	; (6a28 <nrfx_usbd_stop+0x4c>)
    69de:	781b      	ldrb	r3, [r3, #0]
    69e0:	2b02      	cmp	r3, #2
{
    69e2:	b510      	push	{r4, lr}
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_POWERED_ON);
    69e4:	d006      	beq.n	69f4 <nrfx_usbd_stop+0x18>
    69e6:	4b11      	ldr	r3, [pc, #68]	; (6a2c <nrfx_usbd_stop+0x50>)
    69e8:	4a11      	ldr	r2, [pc, #68]	; (6a30 <nrfx_usbd_stop+0x54>)
    69ea:	4812      	ldr	r0, [pc, #72]	; (6a34 <nrfx_usbd_stop+0x58>)
    69ec:	f240 7145 	movw	r1, #1861	; 0x745
    69f0:	f7f9 fec4 	bl	77c <__assert_func>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    69f4:	4b10      	ldr	r3, [pc, #64]	; (6a38 <nrfx_usbd_stop+0x5c>)
    69f6:	2280      	movs	r2, #128	; 0x80
    69f8:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    if (NRFX_IRQ_IS_ENABLED(USBD_IRQn))
    69fc:	2027      	movs	r0, #39	; 0x27
    69fe:	f003 f9e9 	bl	9dd4 <z_arch_irq_is_enabled>
    6a02:	b180      	cbz	r0, 6a26 <nrfx_usbd_stop+0x4a>
    NRF_USBD->USBPULLUP = USBD_USBPULLUP_CONNECT_Disabled << USBD_USBPULLUP_CONNECT_Pos;
    6a04:	4c0d      	ldr	r4, [pc, #52]	; (6a3c <nrfx_usbd_stop+0x60>)
        usbd_ep_abort_all();
    6a06:	f7ff ffc3 	bl	6990 <usbd_ep_abort_all>
    6a0a:	2300      	movs	r3, #0
    6a0c:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
  __ASM volatile ("isb 0xF":::"memory");
    6a10:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    6a14:	f3bf 8f4f 	dsb	sy
        NRFX_IRQ_DISABLE(USBD_IRQn);
    6a18:	2027      	movs	r0, #39	; 0x27
    6a1a:	f003 f9c7 	bl	9dac <z_arch_irq_disable>
    NRF_USBD->INTENCLR = int_mask;
    6a1e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6a22:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
}
    6a26:	bd10      	pop	{r4, pc}
    6a28:	200058b7 	.word	0x200058b7
    6a2c:	00017b6b 	.word	0x00017b6b
    6a30:	0001779c 	.word	0x0001779c
    6a34:	00017c80 	.word	0x00017c80
    6a38:	e000e100 	.word	0xe000e100
    6a3c:	40027000 	.word	0x40027000

00006a40 <nrfx_usbd_disable>:
{
    6a40:	b510      	push	{r4, lr}
    NRFX_ASSERT(m_drv_state != NRFX_DRV_STATE_UNINITIALIZED);
    6a42:	4c0e      	ldr	r4, [pc, #56]	; (6a7c <nrfx_usbd_disable+0x3c>)
    6a44:	7823      	ldrb	r3, [r4, #0]
    6a46:	b933      	cbnz	r3, 6a56 <nrfx_usbd_disable+0x16>
    6a48:	4b0d      	ldr	r3, [pc, #52]	; (6a80 <nrfx_usbd_disable+0x40>)
    6a4a:	4a0e      	ldr	r2, [pc, #56]	; (6a84 <nrfx_usbd_disable+0x44>)
    6a4c:	480e      	ldr	r0, [pc, #56]	; (6a88 <nrfx_usbd_disable+0x48>)
    6a4e:	f44f 61e3 	mov.w	r1, #1816	; 0x718
    6a52:	f7f9 fe93 	bl	77c <__assert_func>
    nrfx_usbd_stop();
    6a56:	f7ff ffc1 	bl	69dc <nrfx_usbd_stop>
    return NRF_USBD->INTENSET;
    6a5a:	4b0c      	ldr	r3, [pc, #48]	; (6a8c <nrfx_usbd_disable+0x4c>)
    6a5c:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
    NRF_USBD->INTENCLR = int_mask;
    6a60:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    NRF_USBD->ENABLE = USBD_ENABLE_ENABLE_Disabled << USBD_ENABLE_ENABLE_Pos;
    6a64:	2200      	movs	r2, #0
    6a66:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("isb 0xF":::"memory");
    6a6a:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    6a6e:	f3bf 8f4f 	dsb	sy
    usbd_dma_pending_clear();
    6a72:	f7fe fe6b 	bl	574c <usbd_dma_pending_clear>
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
    6a76:	2301      	movs	r3, #1
    6a78:	7023      	strb	r3, [r4, #0]
}
    6a7a:	bd10      	pop	{r4, pc}
    6a7c:	200058b7 	.word	0x200058b7
    6a80:	00017979 	.word	0x00017979
    6a84:	0001777a 	.word	0x0001777a
    6a88:	00017c80 	.word	0x00017c80
    6a8c:	40027000 	.word	0x40027000

00006a90 <nrfx_usbd_suspend>:
{
    6a90:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    6a92:	f04f 0320 	mov.w	r3, #32
    6a96:	f3ef 8511 	mrs	r5, BASEPRI
    6a9a:	f383 8811 	msr	BASEPRI, r3
    6a9e:	f3bf 8f6f 	isb	sy
    if (m_bus_suspend)
    6aa2:	4b0f      	ldr	r3, [pc, #60]	; (6ae0 <nrfx_usbd_suspend+0x50>)
    6aa4:	781b      	ldrb	r3, [r3, #0]
    6aa6:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    6aaa:	b933      	cbnz	r3, 6aba <nrfx_usbd_suspend+0x2a>
    bool suspended = false;
    6aac:	2400      	movs	r4, #0
	__asm__ volatile(
    6aae:	f385 8811 	msr	BASEPRI, r5
    6ab2:	f3bf 8f6f 	isb	sy
}
    6ab6:	4620      	mov	r0, r4
    6ab8:	bd38      	pop	{r3, r4, r5, pc}
        usbd_ep_abort_all();
    6aba:	f7ff ff69 	bl	6990 <usbd_ep_abort_all>
    return NRF_USBD->EVENTCAUSE;
    6abe:	4a09      	ldr	r2, [pc, #36]	; (6ae4 <nrfx_usbd_suspend+0x54>)
    6ac0:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
        if (!(nrf_usbd_eventcause_get() & NRF_USBD_EVENTCAUSE_RESUME_MASK))
    6ac4:	f413 7300 	ands.w	r3, r3, #512	; 0x200
    6ac8:	d1f0      	bne.n	6aac <nrfx_usbd_suspend+0x1c>
    NRF_USBD->LOWPOWER = USBD_LOWPOWER_LOWPOWER_LowPower << USBD_LOWPOWER_LOWPOWER_Pos;
    6aca:	2101      	movs	r1, #1
    6acc:	f8c2 152c 	str.w	r1, [r2, #1324]	; 0x52c
    return NRF_USBD->EVENTCAUSE;
    6ad0:	f8d2 1400 	ldr.w	r1, [r2, #1024]	; 0x400
            if (nrf_usbd_eventcause_get() & NRF_USBD_EVENTCAUSE_RESUME_MASK)
    6ad4:	0589      	lsls	r1, r1, #22
    NRF_USBD->LOWPOWER = USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos;
    6ad6:	bf44      	itt	mi
    6ad8:	f8c2 352c 	strmi.w	r3, [r2, #1324]	; 0x52c
    bool suspended = false;
    6adc:	461c      	movmi	r4, r3
    6ade:	e7e6      	b.n	6aae <nrfx_usbd_suspend+0x1e>
    6ae0:	200058b5 	.word	0x200058b5
    6ae4:	40027000 	.word	0x40027000

00006ae8 <nrfx_usbd_ep_enable>:
{
    6ae8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6aec:	f000 070f 	and.w	r7, r0, #15
    NRFX_USBD_ASSERT_EP_VALID(ep);
    6af0:	2f08      	cmp	r7, #8
{
    6af2:	4604      	mov	r4, r0
    NRFX_USBD_ASSERT_EP_VALID(ep);
    6af4:	d901      	bls.n	6afa <nrfx_usbd_ep_enable+0x12>
    6af6:	f7fe ff8b 	bl	5a10 <nrfx_usbd_ep_to_int.part.11>
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
    6afa:	4b24      	ldr	r3, [pc, #144]	; (6b8c <nrfx_usbd_ep_enable+0xa4>)
    6afc:	4a24      	ldr	r2, [pc, #144]	; (6b90 <nrfx_usbd_ep_enable+0xa8>)
    NRF_USBD->INTENSET = int_mask;
    6afe:	4d25      	ldr	r5, [pc, #148]	; (6b94 <nrfx_usbd_ep_enable+0xac>)
    6b00:	fa4f f880 	sxtb.w	r8, r0
    6b04:	ea13 0328 	ands.w	r3, r3, r8, asr #32
    6b08:	bf38      	it	cc
    6b0a:	4613      	movcc	r3, r2
    6b0c:	2601      	movs	r6, #1
    6b0e:	5ddb      	ldrb	r3, [r3, r7]
    6b10:	fa06 f303 	lsl.w	r3, r6, r3
    6b14:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    if (nrf_usbd_ep_enable_check(ep))
    6b18:	f7fe ff5a 	bl	59d0 <nrf_usbd_ep_enable_check>
    6b1c:	2800      	cmp	r0, #0
    6b1e:	d133      	bne.n	6b88 <nrfx_usbd_ep_enable+0xa0>
    if (NRF_USBD_EPIN_CHECK(ep))
    6b20:	f1b8 0f00 	cmp.w	r8, #0
        NRF_USBD->EPINEN |= 1UL << epnr;
    6b24:	bfb4      	ite	lt
    6b26:	f8d5 3510 	ldrlt.w	r3, [r5, #1296]	; 0x510
        NRF_USBD->EPOUTEN |= 1UL << epnr;
    6b2a:	f8d5 3514 	ldrge.w	r3, [r5, #1300]	; 0x514
    6b2e:	fa06 f607 	lsl.w	r6, r6, r7
        NRF_USBD->EPINEN |= 1UL << epnr;
    6b32:	bfb5      	itete	lt
    6b34:	431e      	orrlt	r6, r3
        NRF_USBD->EPOUTEN |= 1UL << epnr;
    6b36:	431e      	orrge	r6, r3
        NRF_USBD->EPINEN |= 1UL << epnr;
    6b38:	f8c5 6510 	strlt.w	r6, [r5, #1296]	; 0x510
        NRF_USBD->EPOUTEN |= 1UL << epnr;
    6b3c:	f8c5 6514 	strge.w	r6, [r5, #1300]	; 0x514
  __ASM volatile ("isb 0xF":::"memory");
    6b40:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    6b44:	f3bf 8f4f 	dsb	sy
    if ((NRF_USBD_EP_NR_GET(ep) != 0) &&
    6b48:	b1f7      	cbz	r7, 6b88 <nrfx_usbd_ep_enable+0xa0>
    6b4a:	f1b8 0f00 	cmp.w	r8, #0
    6b4e:	db1b      	blt.n	6b88 <nrfx_usbd_ep_enable+0xa0>
        NRF_USBD_EPOUT_CHECK(ep) &&
    6b50:	0723      	lsls	r3, r4, #28
    6b52:	d419      	bmi.n	6b88 <nrfx_usbd_ep_enable+0xa0>
	__asm__ volatile(
    6b54:	f04f 0320 	mov.w	r3, #32
    6b58:	f3ef 8511 	mrs	r5, BASEPRI
    6b5c:	f383 8811 	msr	BASEPRI, r3
    6b60:	f3bf 8f6f 	isb	sy
        nrfx_usbd_transfer_out_drop(ep);
    6b64:	4620      	mov	r0, r4
    6b66:	f7ff fd25 	bl	65b4 <nrfx_usbd_transfer_out_drop>
        m_ep_dma_waiting &= ~(1U << ep2bit(ep));
    6b6a:	4620      	mov	r0, r4
    6b6c:	f00b f963 	bl	11e36 <ep2bit>
    6b70:	4a09      	ldr	r2, [pc, #36]	; (6b98 <nrfx_usbd_ep_enable+0xb0>)
    6b72:	2301      	movs	r3, #1
    6b74:	fa03 f000 	lsl.w	r0, r3, r0
    6b78:	6813      	ldr	r3, [r2, #0]
    6b7a:	ea23 0300 	bic.w	r3, r3, r0
    6b7e:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
    6b80:	f385 8811 	msr	BASEPRI, r5
    6b84:	f3bf 8f6f 	isb	sy
}
    6b88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6b8c:	000177fe 	.word	0x000177fe
    6b90:	00017807 	.word	0x00017807
    6b94:	40027000 	.word	0x40027000
    6b98:	2000235c 	.word	0x2000235c

00006b9c <nrfx_usbd_ep_stall_clear>:
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
    6b9c:	0602      	lsls	r2, r0, #24
{
    6b9e:	b510      	push	{r4, lr}
    6ba0:	4604      	mov	r4, r0
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
    6ba2:	d405      	bmi.n	6bb0 <nrfx_usbd_ep_stall_clear+0x14>
    6ba4:	f7ff fc9a 	bl	64dc <nrfx_usbd_ep_stall_check>
    6ba8:	b110      	cbz	r0, 6bb0 <nrfx_usbd_ep_stall_clear+0x14>
        nrfx_usbd_transfer_out_drop(ep);
    6baa:	4620      	mov	r0, r4
    6bac:	f7ff fd02 	bl	65b4 <nrfx_usbd_transfer_out_drop>
    NRFX_USBD_ASSERT_EP_VALID(ep);
    6bb0:	f004 030f 	and.w	r3, r4, #15
    6bb4:	2b08      	cmp	r3, #8
    6bb6:	d901      	bls.n	6bbc <nrfx_usbd_ep_stall_clear+0x20>
    6bb8:	f7fe fefc 	bl	59b4 <ep_to_hal.part.9>
    NRFX_ASSERT(!NRF_USBD_EPISO_CHECK(ep));
    6bbc:	0723      	lsls	r3, r4, #28
    6bbe:	d506      	bpl.n	6bce <nrfx_usbd_ep_stall_clear+0x32>
    6bc0:	4b07      	ldr	r3, [pc, #28]	; (6be0 <nrfx_usbd_ep_stall_clear+0x44>)
    6bc2:	4a08      	ldr	r2, [pc, #32]	; (6be4 <nrfx_usbd_ep_stall_clear+0x48>)
    6bc4:	4808      	ldr	r0, [pc, #32]	; (6be8 <nrfx_usbd_ep_stall_clear+0x4c>)
    6bc6:	f240 5109 	movw	r1, #1289	; 0x509
    6bca:	f7f9 fdd7 	bl	77c <__assert_func>
    NRF_USBD->EPSTALL = (USBD_EPSTALL_STALL_UnStall << USBD_EPSTALL_STALL_Pos) | ep;
    6bce:	4b07      	ldr	r3, [pc, #28]	; (6bec <nrfx_usbd_ep_stall_clear+0x50>)
    6bd0:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
  __ASM volatile ("isb 0xF":::"memory");
    6bd4:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
    6bd8:	f3bf 8f4f 	dsb	sy
}
    6bdc:	bd10      	pop	{r4, pc}
    6bde:	bf00      	nop
    6be0:	00017a61 	.word	0x00017a61
    6be4:	0001763e 	.word	0x0001763e
    6be8:	000178ee 	.word	0x000178ee
    6bec:	40027000 	.word	0x40027000

00006bf0 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
    6bf0:	b507      	push	{r0, r1, r2, lr}
	union log_msg_chunk *msg = NULL;
    6bf2:	2200      	movs	r2, #0
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg, K_NO_WAIT);
    6bf4:	a901      	add	r1, sp, #4
    6bf6:	4808      	ldr	r0, [pc, #32]	; (6c18 <z_log_msg_std_alloc+0x28>)
	union log_msg_chunk *msg = NULL;
    6bf8:	9201      	str	r2, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg, K_NO_WAIT);
    6bfa:	f008 f829 	bl	ec50 <k_mem_slab_alloc>
	if (err != 0) {
    6bfe:	b110      	cbz	r0, 6c06 <z_log_msg_std_alloc+0x16>
		msg = log_msg_no_space_handle();
    6c00:	f000 fa1c 	bl	703c <log_msg_no_space_handle>
    6c04:	9001      	str	r0, [sp, #4]
	return msg;
    6c06:	9801      	ldr	r0, [sp, #4]
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();

	if (msg != NULL) {
    6c08:	b118      	cbz	r0, 6c12 <z_log_msg_std_alloc+0x22>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    6c0a:	2301      	movs	r3, #1
    6c0c:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    6c0e:	2300      	movs	r3, #0
    6c10:	8103      	strh	r3, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
    6c12:	b003      	add	sp, #12
    6c14:	f85d fb04 	ldr.w	pc, [sp], #4
    6c18:	200025d8 	.word	0x200025d8

00006c1c <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
    6c1c:	b530      	push	{r4, r5, lr}
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
    6c1e:	4d0c      	ldr	r5, [pc, #48]	; (6c50 <enable_logger+0x34>)
    6c20:	490c      	ldr	r1, [pc, #48]	; (6c54 <enable_logger+0x38>)
    6c22:	b087      	sub	sp, #28
    6c24:	2400      	movs	r4, #0
    6c26:	230e      	movs	r3, #14
    6c28:	e9cd 4302 	strd	r4, r3, [sp, #8]
    6c2c:	f44f 7240 	mov.w	r2, #768	; 0x300
    6c30:	4b09      	ldr	r3, [pc, #36]	; (6c58 <enable_logger+0x3c>)
    6c32:	e9cd 4404 	strd	r4, r4, [sp, #16]
    6c36:	e9cd 4400 	strd	r4, r4, [sp]
    6c3a:	4628      	mov	r0, r5
    6c3c:	f008 fdaa 	bl	f794 <z_impl_k_thread_create>
K_SYSCALL_DECLARE2(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, int, k_tid_t, thread_id, const char *, value)
    6c40:	4906      	ldr	r1, [pc, #24]	; (6c5c <enable_logger+0x40>)
    6c42:	4628      	mov	r0, r5
    6c44:	f00f f8be 	bl	15dc4 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    6c48:	4620      	mov	r0, r4
    6c4a:	b007      	add	sp, #28
    6c4c:	bd30      	pop	{r4, r5, pc}
    6c4e:	bf00      	nop
    6c50:	20002568 	.word	0x20002568
    6c54:	20006c88 	.word	0x20006c88
    6c58:	00006f49 	.word	0x00006f49
    6c5c:	00017d49 	.word	0x00017d49

00006c60 <log_core_init>:
{
    6c60:	b508      	push	{r3, lr}
		log_msg_pool_init();
    6c62:	f000 f9e1 	bl	7028 <log_msg_pool_init>
		log_list_init(&list);
    6c66:	4809      	ldr	r0, [pc, #36]	; (6c8c <log_core_init+0x2c>)
    6c68:	f00b f96a 	bl	11f40 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    6c6c:	2304      	movs	r3, #4
    6c6e:	2234      	movs	r2, #52	; 0x34
    6c70:	4807      	ldr	r0, [pc, #28]	; (6c90 <log_core_init+0x30>)
    6c72:	4908      	ldr	r1, [pc, #32]	; (6c94 <log_core_init+0x34>)
    6c74:	f00e fe7c 	bl	15970 <k_mem_slab_init>
	timestamp_func = timestamp_get;
    6c78:	4b07      	ldr	r3, [pc, #28]	; (6c98 <log_core_init+0x38>)
    6c7a:	4a08      	ldr	r2, [pc, #32]	; (6c9c <log_core_init+0x3c>)
    6c7c:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
    6c7e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
}
    6c82:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	log_output_timestamp_freq_set(freq);
    6c86:	f000 bbf3 	b.w	7470 <log_output_timestamp_freq_set>
    6c8a:	bf00      	nop
    6c8c:	20002544 	.word	0x20002544
    6c90:	2000254c 	.word	0x2000254c
    6c94:	2000ae58 	.word	0x2000ae58
    6c98:	20010ce4 	.word	0x20010ce4
    6c9c:	00011f71 	.word	0x00011f71

00006ca0 <dropped_notify>:
{
    6ca0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    6ca2:	4b0f      	ldr	r3, [pc, #60]	; (6ce0 <dropped_notify+0x40>)
    6ca4:	f3bf 8f5b 	dmb	ish
    6ca8:	2500      	movs	r5, #0
    6caa:	e853 7f00 	ldrex	r7, [r3]
    6cae:	e843 5200 	strex	r2, r5, [r3]
    6cb2:	2a00      	cmp	r2, #0
    6cb4:	d1f9      	bne.n	6caa <dropped_notify+0xa>
    6cb6:	f3bf 8f5b 	dmb	ish
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    6cba:	4c0a      	ldr	r4, [pc, #40]	; (6ce4 <dropped_notify+0x44>)
    6cbc:	4e0a      	ldr	r6, [pc, #40]	; (6ce8 <dropped_notify+0x48>)
    6cbe:	1b36      	subs	r6, r6, r4
    6cc0:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    6cc2:	42b5      	cmp	r5, r6
    6cc4:	db00      	blt.n	6cc8 <dropped_notify+0x28>
}
    6cc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    6cc8:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    6cca:	795b      	ldrb	r3, [r3, #5]
    6ccc:	b12b      	cbz	r3, 6cda <dropped_notify+0x3a>
	if (backend->api->dropped != NULL) {
    6cce:	6823      	ldr	r3, [r4, #0]
    6cd0:	68db      	ldr	r3, [r3, #12]
    6cd2:	b113      	cbz	r3, 6cda <dropped_notify+0x3a>
		backend->api->dropped(backend, cnt);
    6cd4:	4639      	mov	r1, r7
    6cd6:	4620      	mov	r0, r4
    6cd8:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    6cda:	3501      	adds	r5, #1
    6cdc:	3410      	adds	r4, #16
    6cde:	e7f0      	b.n	6cc2 <dropped_notify+0x22>
    6ce0:	2000253c 	.word	0x2000253c
    6ce4:	0001645c 	.word	0x0001645c
    6ce8:	0001646c 	.word	0x0001646c

00006cec <z_impl_log_process>:
	if (!backend_attached && !bypass) {
    6cec:	4b24      	ldr	r3, [pc, #144]	; (6d80 <z_impl_log_process+0x94>)
    6cee:	781b      	ldrb	r3, [r3, #0]
{
    6cf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6cf4:	4605      	mov	r5, r0
	if (!backend_attached && !bypass) {
    6cf6:	b903      	cbnz	r3, 6cfa <z_impl_log_process+0xe>
    6cf8:	b360      	cbz	r0, 6d54 <z_impl_log_process+0x68>
	__asm__ volatile(
    6cfa:	f04f 0320 	mov.w	r3, #32
    6cfe:	f3ef 8411 	mrs	r4, BASEPRI
    6d02:	f383 8811 	msr	BASEPRI, r3
    6d06:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
    6d0a:	481e      	ldr	r0, [pc, #120]	; (6d84 <z_impl_log_process+0x98>)
    6d0c:	f00b f928 	bl	11f60 <log_list_head_get>
    6d10:	4607      	mov	r7, r0
	__asm__ volatile(
    6d12:	f384 8811 	msr	BASEPRI, r4
    6d16:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
    6d1a:	b178      	cbz	r0, 6d3c <z_impl_log_process+0x50>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    6d1c:	f3bf 8f5b 	dmb	ish
    6d20:	4b19      	ldr	r3, [pc, #100]	; (6d88 <z_impl_log_process+0x9c>)
    6d22:	e853 2f00 	ldrex	r2, [r3]
    6d26:	3a01      	subs	r2, #1
    6d28:	e843 2100 	strex	r1, r2, [r3]
    6d2c:	2900      	cmp	r1, #0
    6d2e:	d1f8      	bne.n	6d22 <z_impl_log_process+0x36>
    6d30:	f3bf 8f5b 	dmb	ish
	if (!bypass) {
    6d34:	b18d      	cbz	r5, 6d5a <z_impl_log_process+0x6e>
	log_msg_put(msg);
    6d36:	4638      	mov	r0, r7
    6d38:	f00b f9fa 	bl	12130 <log_msg_put>
	if (!bypass && dropped_cnt) {
    6d3c:	b925      	cbnz	r5, 6d48 <z_impl_log_process+0x5c>
    6d3e:	4b13      	ldr	r3, [pc, #76]	; (6d8c <z_impl_log_process+0xa0>)
    6d40:	681b      	ldr	r3, [r3, #0]
    6d42:	b10b      	cbz	r3, 6d48 <z_impl_log_process+0x5c>
		dropped_notify();
    6d44:	f7ff ffac 	bl	6ca0 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
    6d48:	480e      	ldr	r0, [pc, #56]	; (6d84 <z_impl_log_process+0x98>)
    6d4a:	f00b f907 	bl	11f5c <log_list_head_peek>
    6d4e:	1c05      	adds	r5, r0, #0
    6d50:	bf18      	it	ne
    6d52:	2501      	movne	r5, #1
}
    6d54:	4628      	mov	r0, r5
    6d56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return __log_backends_end - __log_backends_start;
    6d5a:	4c0d      	ldr	r4, [pc, #52]	; (6d90 <z_impl_log_process+0xa4>)
    6d5c:	4e0d      	ldr	r6, [pc, #52]	; (6d94 <z_impl_log_process+0xa8>)
    6d5e:	1b36      	subs	r6, r6, r4
    6d60:	1136      	asrs	r6, r6, #4
		for (int i = 0; i < log_backend_count_get(); i++) {
    6d62:	46a8      	mov	r8, r5
    6d64:	45b0      	cmp	r8, r6
    6d66:	dae6      	bge.n	6d36 <z_impl_log_process+0x4a>
	return backend->cb->active;
    6d68:	6863      	ldr	r3, [r4, #4]
			if (log_backend_is_active(backend) &&
    6d6a:	795b      	ldrb	r3, [r3, #5]
    6d6c:	b123      	cbz	r3, 6d78 <z_impl_log_process+0x8c>
	backend->api->put(backend, msg);
    6d6e:	6823      	ldr	r3, [r4, #0]
    6d70:	4639      	mov	r1, r7
    6d72:	681b      	ldr	r3, [r3, #0]
    6d74:	4620      	mov	r0, r4
    6d76:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
    6d78:	f108 0801 	add.w	r8, r8, #1
    6d7c:	3410      	adds	r4, #16
    6d7e:	e7f1      	b.n	6d64 <z_impl_log_process+0x78>
    6d80:	200058b9 	.word	0x200058b9
    6d84:	20002544 	.word	0x20002544
    6d88:	20002538 	.word	0x20002538
    6d8c:	2000253c 	.word	0x2000253c
    6d90:	0001645c 	.word	0x0001645c
    6d94:	0001646c 	.word	0x0001646c

00006d98 <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
    6d98:	4b20      	ldr	r3, [pc, #128]	; (6e1c <msg_finalize+0x84>)
{
    6d9a:	b570      	push	{r4, r5, r6, lr}
	msg->hdr.timestamp = timestamp_func();
    6d9c:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
    6d9e:	8141      	strh	r1, [r0, #10]
{
    6da0:	4605      	mov	r5, r0
	msg->hdr.timestamp = timestamp_func();
    6da2:	4798      	blx	r3
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    6da4:	4c1e      	ldr	r4, [pc, #120]	; (6e20 <msg_finalize+0x88>)
    6da6:	60e8      	str	r0, [r5, #12]
    6da8:	f3bf 8f5b 	dmb	ish
    6dac:	e854 3f00 	ldrex	r3, [r4]
    6db0:	3301      	adds	r3, #1
    6db2:	e844 3200 	strex	r2, r3, [r4]
    6db6:	2a00      	cmp	r2, #0
    6db8:	d1f8      	bne.n	6dac <msg_finalize+0x14>
    6dba:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
    6dbe:	f04f 0320 	mov.w	r3, #32
    6dc2:	f3ef 8611 	mrs	r6, BASEPRI
    6dc6:	f383 8811 	msr	BASEPRI, r3
    6dca:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    6dce:	4815      	ldr	r0, [pc, #84]	; (6e24 <msg_finalize+0x8c>)
    6dd0:	4629      	mov	r1, r5
    6dd2:	f00b f8b9 	bl	11f48 <log_list_add_tail>
	__asm__ volatile(
    6dd6:	f386 8811 	msr	BASEPRI, r6
    6dda:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
    6dde:	4b12      	ldr	r3, [pc, #72]	; (6e28 <msg_finalize+0x90>)
    6de0:	781b      	ldrb	r3, [r3, #0]
    6de2:	b17b      	cbz	r3, 6e04 <msg_finalize+0x6c>
	__asm__ volatile(
    6de4:	f04f 0320 	mov.w	r3, #32
    6de8:	f3ef 8411 	mrs	r4, BASEPRI
    6dec:	f383 8811 	msr	BASEPRI, r3
    6df0:	f3bf 8f6f 	isb	sy
extern "C" {
#endif

K_SYSCALL_DECLARE0_VOID(K_SYSCALL_LOG_PANIC, log_panic)

K_SYSCALL_DECLARE1(K_SYSCALL_LOG_PROCESS, log_process, bool, bool, bypass)
    6df4:	2000      	movs	r0, #0
    6df6:	f7ff ff79 	bl	6cec <z_impl_log_process>
	__asm__ volatile(
    6dfa:	f384 8811 	msr	BASEPRI, r4
    6dfe:	f3bf 8f6f 	isb	sy
}
    6e02:	bd70      	pop	{r4, r5, r6, pc}
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    6e04:	6823      	ldr	r3, [r4, #0]
    6e06:	2b0a      	cmp	r3, #10
    6e08:	d1fb      	bne.n	6e02 <msg_finalize+0x6a>
		    (proc_tid != NULL)) {
    6e0a:	4b08      	ldr	r3, [pc, #32]	; (6e2c <msg_finalize+0x94>)
    6e0c:	6818      	ldr	r0, [r3, #0]
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    6e0e:	2800      	cmp	r0, #0
    6e10:	d0f7      	beq.n	6e02 <msg_finalize+0x6a>
}
    6e12:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_WAKEUP, k_wakeup, k_tid_t, thread)
    6e16:	f008 bbcb 	b.w	f5b0 <z_impl_k_wakeup>
    6e1a:	bf00      	nop
    6e1c:	20010ce4 	.word	0x20010ce4
    6e20:	20002538 	.word	0x20002538
    6e24:	20002544 	.word	0x20002544
    6e28:	200058ba 	.word	0x200058ba
    6e2c:	200025d4 	.word	0x200025d4

00006e30 <log_dropped>:
    6e30:	4b06      	ldr	r3, [pc, #24]	; (6e4c <log_dropped+0x1c>)
    6e32:	f3bf 8f5b 	dmb	ish
    6e36:	e853 2f00 	ldrex	r2, [r3]
    6e3a:	3201      	adds	r2, #1
    6e3c:	e843 2100 	strex	r1, r2, [r3]
    6e40:	2900      	cmp	r1, #0
    6e42:	d1f8      	bne.n	6e36 <log_dropped+0x6>
    6e44:	f3bf 8f5b 	dmb	ish
}
    6e48:	4770      	bx	lr
    6e4a:	bf00      	nop
    6e4c:	2000253c 	.word	0x2000253c

00006e50 <log_source_name_get>:
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    6e50:	4a04      	ldr	r2, [pc, #16]	; (6e64 <log_source_name_get+0x14>)
    6e52:	4b05      	ldr	r3, [pc, #20]	; (6e68 <log_source_name_get+0x18>)
    6e54:	1a9b      	subs	r3, r3, r2
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
    6e56:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
    6e5a:	bf34      	ite	cc
    6e5c:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
    6e60:	2000      	movcs	r0, #0
}
    6e62:	4770      	bx	lr
    6e64:	00016344 	.word	0x00016344
    6e68:	0001645c 	.word	0x0001645c

00006e6c <log_backend_enable>:
	id += backend - log_backend_get(0);
    6e6c:	4b06      	ldr	r3, [pc, #24]	; (6e88 <log_backend_enable+0x1c>)
	log_backend_id_set(backend, id);
    6e6e:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
    6e70:	1ac3      	subs	r3, r0, r3
    6e72:	111b      	asrs	r3, r3, #4
    6e74:	3301      	adds	r3, #1
	log_backend_id_set(backend, id);
    6e76:	7113      	strb	r3, [r2, #4]
	log_backend_activate(backend, ctx);
    6e78:	6842      	ldr	r2, [r0, #4]
	backend->cb->active = true;
    6e7a:	2301      	movs	r3, #1
	backend->cb->ctx = ctx;
    6e7c:	6011      	str	r1, [r2, #0]
	backend->cb->active = true;
    6e7e:	7153      	strb	r3, [r2, #5]
	backend_attached = true;
    6e80:	4a02      	ldr	r2, [pc, #8]	; (6e8c <log_backend_enable+0x20>)
    6e82:	7013      	strb	r3, [r2, #0]
}
    6e84:	4770      	bx	lr
    6e86:	bf00      	nop
    6e88:	0001645c 	.word	0x0001645c
    6e8c:	200058b9 	.word	0x200058b9

00006e90 <log_init>:
{
    6e90:	b570      	push	{r4, r5, r6, lr}
	return __log_backends_end - __log_backends_start;
    6e92:	4b15      	ldr	r3, [pc, #84]	; (6ee8 <log_init+0x58>)
    6e94:	4c15      	ldr	r4, [pc, #84]	; (6eec <log_init+0x5c>)
    6e96:	1b1b      	subs	r3, r3, r4
	assert(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
    6e98:	2b90      	cmp	r3, #144	; 0x90
    6e9a:	dd06      	ble.n	6eaa <log_init+0x1a>
    6e9c:	4b14      	ldr	r3, [pc, #80]	; (6ef0 <log_init+0x60>)
    6e9e:	4a15      	ldr	r2, [pc, #84]	; (6ef4 <log_init+0x64>)
    6ea0:	4815      	ldr	r0, [pc, #84]	; (6ef8 <log_init+0x68>)
    6ea2:	f44f 71af 	mov.w	r1, #350	; 0x15e
    6ea6:	f7f9 fc69 	bl	77c <__assert_func>
    6eaa:	4a14      	ldr	r2, [pc, #80]	; (6efc <log_init+0x6c>)
    6eac:	f3bf 8f5b 	dmb	ish
    6eb0:	e852 6f00 	ldrex	r6, [r2]
    6eb4:	1c71      	adds	r1, r6, #1
    6eb6:	e842 1000 	strex	r0, r1, [r2]
    6eba:	2800      	cmp	r0, #0
    6ebc:	d1f8      	bne.n	6eb0 <log_init+0x20>
    6ebe:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
    6ec2:	b916      	cbnz	r6, 6eca <log_init+0x3a>
    6ec4:	111d      	asrs	r5, r3, #4
	for (i = 0; i < log_backend_count_get(); i++) {
    6ec6:	42ae      	cmp	r6, r5
    6ec8:	db00      	blt.n	6ecc <log_init+0x3c>
}
    6eca:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
    6ecc:	7b23      	ldrb	r3, [r4, #12]
    6ece:	b143      	cbz	r3, 6ee2 <log_init+0x52>
			if (backend->api->init != NULL) {
    6ed0:	6823      	ldr	r3, [r4, #0]
    6ed2:	695b      	ldr	r3, [r3, #20]
    6ed4:	b103      	cbz	r3, 6ed8 <log_init+0x48>
				backend->api->init();
    6ed6:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
    6ed8:	2204      	movs	r2, #4
    6eda:	2100      	movs	r1, #0
    6edc:	4620      	mov	r0, r4
    6ede:	f7ff ffc5 	bl	6e6c <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    6ee2:	3601      	adds	r6, #1
    6ee4:	3410      	adds	r4, #16
    6ee6:	e7ee      	b.n	6ec6 <log_init+0x36>
    6ee8:	0001646c 	.word	0x0001646c
    6eec:	0001645c 	.word	0x0001645c
    6ef0:	00017d51 	.word	0x00017d51
    6ef4:	00017d40 	.word	0x00017d40
    6ef8:	00017d9e 	.word	0x00017d9e
    6efc:	20002540 	.word	0x20002540

00006f00 <z_impl_log_panic>:
{
    6f00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
    6f02:	4f0e      	ldr	r7, [pc, #56]	; (6f3c <z_impl_log_panic+0x3c>)
    6f04:	783d      	ldrb	r5, [r7, #0]
    6f06:	b975      	cbnz	r5, 6f26 <z_impl_log_panic+0x26>
    6f08:	4c0d      	ldr	r4, [pc, #52]	; (6f40 <z_impl_log_panic+0x40>)
    6f0a:	4e0e      	ldr	r6, [pc, #56]	; (6f44 <z_impl_log_panic+0x44>)
	log_init();
    6f0c:	f7ff ffc0 	bl	6e90 <log_init>
    6f10:	1b36      	subs	r6, r6, r4
    6f12:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
    6f14:	42b5      	cmp	r5, r6
    6f16:	db07      	blt.n	6f28 <z_impl_log_panic+0x28>
    6f18:	2000      	movs	r0, #0
    6f1a:	f7ff fee7 	bl	6cec <z_impl_log_process>
		while (log_process(false) == true) {
    6f1e:	2800      	cmp	r0, #0
    6f20:	d1fa      	bne.n	6f18 <z_impl_log_panic+0x18>
	panic_mode = true;
    6f22:	2301      	movs	r3, #1
    6f24:	703b      	strb	r3, [r7, #0]
}
    6f26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
    6f28:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
    6f2a:	795b      	ldrb	r3, [r3, #5]
    6f2c:	b11b      	cbz	r3, 6f36 <z_impl_log_panic+0x36>
	backend->api->panic(backend);
    6f2e:	6823      	ldr	r3, [r4, #0]
    6f30:	4620      	mov	r0, r4
    6f32:	691b      	ldr	r3, [r3, #16]
    6f34:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
    6f36:	3501      	adds	r5, #1
    6f38:	3410      	adds	r4, #16
    6f3a:	e7eb      	b.n	6f14 <z_impl_log_panic+0x14>
    6f3c:	200058ba 	.word	0x200058ba
    6f40:	0001645c 	.word	0x0001645c
    6f44:	0001646c 	.word	0x0001646c

00006f48 <log_process_thread_func>:
{
    6f48:	b508      	push	{r3, lr}
	log_init();
    6f4a:	f7ff ffa1 	bl	6e90 <log_init>
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
    6f4e:	f008 fb55 	bl	f5fc <z_impl_k_current_get>
	proc_tid = process_tid;
    6f52:	4a09      	ldr	r2, [pc, #36]	; (6f78 <log_process_thread_func+0x30>)
    6f54:	6010      	str	r0, [r2, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    6f56:	b128      	cbz	r0, 6f64 <log_process_thread_func+0x1c>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    6f58:	4b08      	ldr	r3, [pc, #32]	; (6f7c <log_process_thread_func+0x34>)
	    process_tid &&
    6f5a:	681b      	ldr	r3, [r3, #0]
    6f5c:	2b09      	cmp	r3, #9
    6f5e:	dd01      	ble.n	6f64 <log_process_thread_func+0x1c>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_WAKEUP, k_wakeup, k_tid_t, thread)
    6f60:	f008 fb26 	bl	f5b0 <z_impl_k_wakeup>
    6f64:	2000      	movs	r0, #0
    6f66:	f7ff fec1 	bl	6cec <z_impl_log_process>
		if (log_process(false) == false) {
    6f6a:	2800      	cmp	r0, #0
    6f6c:	d1fa      	bne.n	6f64 <log_process_thread_func+0x1c>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
    6f6e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    6f72:	f008 fad1 	bl	f518 <z_impl_k_sleep>
    6f76:	e7f5      	b.n	6f64 <log_process_thread_func+0x1c>
    6f78:	200025d4 	.word	0x200025d4
    6f7c:	20002538 	.word	0x20002538

00006f80 <log_strdup>:
{
    6f80:	b573      	push	{r0, r1, r4, r5, r6, lr}
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    6f82:	2200      	movs	r2, #0
{
    6f84:	4606      	mov	r6, r0
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    6f86:	a901      	add	r1, sp, #4
    6f88:	4811      	ldr	r0, [pc, #68]	; (6fd0 <log_strdup+0x50>)
    6f8a:	f007 fe61 	bl	ec50 <k_mem_slab_alloc>
	if (err != 0) {
    6f8e:	4605      	mov	r5, r0
    6f90:	b9d8      	cbnz	r0, 6fca <log_strdup+0x4a>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    6f92:	2201      	movs	r2, #1
    6f94:	9b01      	ldr	r3, [sp, #4]
    6f96:	f3bf 8f5b 	dmb	ish
    6f9a:	e853 1f00 	ldrex	r1, [r3]
    6f9e:	e843 2000 	strex	r0, r2, [r3]
    6fa2:	2800      	cmp	r0, #0
    6fa4:	d1f9      	bne.n	6f9a <log_strdup+0x1a>
    6fa6:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    6faa:	9c01      	ldr	r4, [sp, #4]
    6fac:	1d23      	adds	r3, r4, #4
#if __GNUC_PREREQ__(4,8) || defined(__clang__)
__ssp_bos_icheck3_restrict(stpncpy, char *, const char *)
#endif
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
__ssp_bos_icheck2_restrict(strcat, char *, const char *)
__ssp_bos_icheck3_restrict(strncpy, char *, const char *)
    6fae:	222d      	movs	r2, #45	; 0x2d
    6fb0:	4618      	mov	r0, r3
    6fb2:	4631      	mov	r1, r6
    6fb4:	f7fb f940 	bl	2238 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    6fb8:	227e      	movs	r2, #126	; 0x7e
    6fba:	4603      	mov	r3, r0
    6fbc:	f884 2031 	strb.w	r2, [r4, #49]	; 0x31
	dup->buf[sizeof(dup->buf) - 1] = '\0';
    6fc0:	f884 5032 	strb.w	r5, [r4, #50]	; 0x32
}
    6fc4:	4618      	mov	r0, r3
    6fc6:	b002      	add	sp, #8
    6fc8:	bd70      	pop	{r4, r5, r6, pc}
		return (char *)log_strdup_fail_msg;
    6fca:	4b02      	ldr	r3, [pc, #8]	; (6fd4 <log_strdup+0x54>)
    6fcc:	e7fa      	b.n	6fc4 <log_strdup+0x44>
    6fce:	bf00      	nop
    6fd0:	2000254c 	.word	0x2000254c
    6fd4:	00017d84 	.word	0x00017d84

00006fd8 <log_is_strdup>:
	return ((char *)buf >= pool_first->buf) &&
    6fd8:	4b05      	ldr	r3, [pc, #20]	; (6ff0 <log_is_strdup+0x18>)
    6fda:	4298      	cmp	r0, r3
    6fdc:	d305      	bcc.n	6fea <log_is_strdup+0x12>
    6fde:	339c      	adds	r3, #156	; 0x9c
    6fe0:	4298      	cmp	r0, r3
    6fe2:	bf8c      	ite	hi
    6fe4:	2000      	movhi	r0, #0
    6fe6:	2001      	movls	r0, #1
    6fe8:	4770      	bx	lr
    6fea:	2000      	movs	r0, #0
}
    6fec:	4770      	bx	lr
    6fee:	bf00      	nop
    6ff0:	2000ae5c 	.word	0x2000ae5c

00006ff4 <log_free>:
{
    6ff4:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    6ff6:	3804      	subs	r0, #4
    6ff8:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    6ffa:	f3bf 8f5b 	dmb	ish
    6ffe:	e850 3f00 	ldrex	r3, [r0]
    7002:	1e5a      	subs	r2, r3, #1
    7004:	e840 2100 	strex	r1, r2, [r0]
    7008:	2900      	cmp	r1, #0
    700a:	d1f8      	bne.n	6ffe <log_free+0xa>
    700c:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
    7010:	2b01      	cmp	r3, #1
    7012:	d103      	bne.n	701c <log_free+0x28>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    7014:	a901      	add	r1, sp, #4
    7016:	4803      	ldr	r0, [pc, #12]	; (7024 <log_free+0x30>)
    7018:	f007 fe46 	bl	eca8 <k_mem_slab_free>
}
    701c:	b003      	add	sp, #12
    701e:	f85d fb04 	ldr.w	pc, [sp], #4
    7022:	bf00      	nop
    7024:	2000254c 	.word	0x2000254c

00007028 <log_msg_pool_init>:
static u8_t __noinit __aligned(sizeof(u32_t))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    7028:	2320      	movs	r3, #32
    702a:	461a      	mov	r2, r3
    702c:	4901      	ldr	r1, [pc, #4]	; (7034 <log_msg_pool_init+0xc>)
    702e:	4802      	ldr	r0, [pc, #8]	; (7038 <log_msg_pool_init+0x10>)
    7030:	f00e bc9e 	b.w	15970 <k_mem_slab_init>
    7034:	2000af28 	.word	0x2000af28
    7038:	200025d8 	.word	0x200025d8

0000703c <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
    703c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	union log_msg_chunk *msg = NULL;
    703e:	2300      	movs	r3, #0

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
    7040:	4d09      	ldr	r5, [pc, #36]	; (7068 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
    7042:	9301      	str	r3, [sp, #4]
    7044:	2001      	movs	r0, #1
    7046:	f7ff fe51 	bl	6cec <z_impl_log_process>
    704a:	4604      	mov	r4, r0
			log_dropped();
    704c:	f7ff fef0 	bl	6e30 <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    7050:	2200      	movs	r2, #0
    7052:	a901      	add	r1, sp, #4
    7054:	4628      	mov	r0, r5
    7056:	f007 fdfb 	bl	ec50 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
    705a:	b108      	cbz	r0, 7060 <log_msg_no_space_handle+0x24>
    705c:	2c00      	cmp	r4, #0
    705e:	d1f1      	bne.n	7044 <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
    7060:	9801      	ldr	r0, [sp, #4]
    7062:	b003      	add	sp, #12
    7064:	bd30      	pop	{r4, r5, pc}
    7066:	bf00      	nop
    7068:	200025d8 	.word	0x200025d8

0000706c <log_msg_chunk_alloc>:
{
    706c:	b507      	push	{r0, r1, r2, lr}
	union log_msg_chunk *msg = NULL;
    706e:	2200      	movs	r2, #0
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg, K_NO_WAIT);
    7070:	a901      	add	r1, sp, #4
    7072:	4806      	ldr	r0, [pc, #24]	; (708c <log_msg_chunk_alloc+0x20>)
	union log_msg_chunk *msg = NULL;
    7074:	9201      	str	r2, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg, K_NO_WAIT);
    7076:	f007 fdeb 	bl	ec50 <k_mem_slab_alloc>
	if (err != 0) {
    707a:	b110      	cbz	r0, 7082 <log_msg_chunk_alloc+0x16>
		msg = log_msg_no_space_handle();
    707c:	f7ff ffde 	bl	703c <log_msg_no_space_handle>
    7080:	9001      	str	r0, [sp, #4]
}
    7082:	9801      	ldr	r0, [sp, #4]
    7084:	b003      	add	sp, #12
    7086:	f85d fb04 	ldr.w	pc, [sp], #4
    708a:	bf00      	nop
    708c:	200025d8 	.word	0x200025d8

00007090 <msg_free>:
{
    7090:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    7092:	7a04      	ldrb	r4, [r0, #8]
	u32_t nargs = msg->hdr.params.std.nargs;
    7094:	7a45      	ldrb	r5, [r0, #9]
{
    7096:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
    7098:	f014 0401 	ands.w	r4, r4, #1
	u32_t nargs = msg->hdr.params.std.nargs;
    709c:	ea4f 1515 	mov.w	r5, r5, lsr #4
	if (log_msg_is_std(msg) && nargs) {
    70a0:	d00e      	beq.n	70c0 <msg_free+0x30>
	if (msg->hdr.params.generic.ext == 1) {
    70a2:	9b01      	ldr	r3, [sp, #4]
    70a4:	7a1a      	ldrb	r2, [r3, #8]
    70a6:	0792      	lsls	r2, r2, #30
    70a8:	d504      	bpl.n	70b4 <msg_free+0x24>
		cont_free(msg->payload.ext.next);
    70aa:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    70ac:	4c10      	ldr	r4, [pc, #64]	; (70f0 <msg_free+0x60>)
    70ae:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
    70b0:	9b03      	ldr	r3, [sp, #12]
    70b2:	b9b3      	cbnz	r3, 70e2 <msg_free+0x52>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    70b4:	a901      	add	r1, sp, #4
    70b6:	480e      	ldr	r0, [pc, #56]	; (70f0 <msg_free+0x60>)
    70b8:	f007 fdf6 	bl	eca8 <k_mem_slab_free>
}
    70bc:	b004      	add	sp, #16
    70be:	bd70      	pop	{r4, r5, r6, pc}
	if (log_msg_is_std(msg) && nargs) {
    70c0:	2d00      	cmp	r5, #0
    70c2:	d0ee      	beq.n	70a2 <msg_free+0x12>
		for (i = 0; i < nargs; i++) {
    70c4:	42a5      	cmp	r5, r4
    70c6:	9801      	ldr	r0, [sp, #4]
    70c8:	d9eb      	bls.n	70a2 <msg_free+0x12>
			void *buf = (void *)log_msg_arg_get(msg, i);
    70ca:	4621      	mov	r1, r4
    70cc:	f00b f813 	bl	120f6 <log_msg_arg_get>
    70d0:	4606      	mov	r6, r0
			if (log_is_strdup(buf)) {
    70d2:	f7ff ff81 	bl	6fd8 <log_is_strdup>
    70d6:	b110      	cbz	r0, 70de <msg_free+0x4e>
				log_free(buf);
    70d8:	4630      	mov	r0, r6
    70da:	f7ff ff8b 	bl	6ff4 <log_free>
		for (i = 0; i < nargs; i++) {
    70de:	3401      	adds	r4, #1
    70e0:	e7f0      	b.n	70c4 <msg_free+0x34>
		next = cont->next;
    70e2:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    70e4:	a903      	add	r1, sp, #12
    70e6:	4620      	mov	r0, r4
    70e8:	f007 fdde 	bl	eca8 <k_mem_slab_free>
		cont = next;
    70ec:	9503      	str	r5, [sp, #12]
    70ee:	e7df      	b.n	70b0 <msg_free+0x20>
    70f0:	200025d8 	.word	0x200025d8

000070f4 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
    70f4:	b40e      	push	{r1, r2, r3}
    70f6:	b503      	push	{r0, r1, lr}
    70f8:	ab03      	add	r3, sp, #12
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
    70fa:	4601      	mov	r1, r0
{
    70fc:	f853 2b04 	ldr.w	r2, [r3], #4
	z_vprintk(out_func, (void *)log_output, fmt, args);
    7100:	4804      	ldr	r0, [pc, #16]	; (7114 <print_formatted+0x20>)
	va_start(args, fmt);
    7102:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
    7104:	f00a fd2b 	bl	11b5e <z_vprintk>
#endif
	va_end(args);

	return length;
}
    7108:	2000      	movs	r0, #0
    710a:	b002      	add	sp, #8
    710c:	f85d eb04 	ldr.w	lr, [sp], #4
    7110:	b003      	add	sp, #12
    7112:	4770      	bx	lr
    7114:	000124ff 	.word	0x000124ff

00007118 <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
    7118:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    711c:	b085      	sub	sp, #20
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
    711e:	f011 0402 	ands.w	r4, r1, #2
{
    7122:	4606      	mov	r6, r0
    7124:	4690      	mov	r8, r2
    7126:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    712a:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    712e:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
    7132:	d007      	beq.n	7144 <prefix_print+0x2c>
	if (!format) {
    7134:	f011 0f44 	tst.w	r1, #68	; 0x44
    7138:	d137      	bne.n	71aa <prefix_print+0x92>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
    713a:	461a      	mov	r2, r3
    713c:	4932      	ldr	r1, [pc, #200]	; (7208 <prefix_print+0xf0>)
    713e:	f7ff ffd9 	bl	70f4 <print_formatted>
		length += timestamp_print(log_output, flags, timestamp);
    7142:	4604      	mov	r4, r0
	if (color) {
    7144:	f1b9 0f00 	cmp.w	r9, #0
    7148:	d00a      	beq.n	7160 <prefix_print+0x48>
		const char *color = start && (colors[level] != NULL) ?
    714a:	4b30      	ldr	r3, [pc, #192]	; (720c <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
    714c:	4930      	ldr	r1, [pc, #192]	; (7210 <prefix_print+0xf8>)
		const char *color = start && (colors[level] != NULL) ?
    714e:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
    7152:	4b30      	ldr	r3, [pc, #192]	; (7214 <prefix_print+0xfc>)
    7154:	4630      	mov	r0, r6
    7156:	2a00      	cmp	r2, #0
    7158:	bf08      	it	eq
    715a:	461a      	moveq	r2, r3
    715c:	f7ff ffca 	bl	70f4 <print_formatted>
	if (level_on) {
    7160:	b13d      	cbz	r5, 7172 <prefix_print+0x5a>
		total += print_formatted(log_output, "<%s> ", severity[level]);
    7162:	4b2d      	ldr	r3, [pc, #180]	; (7218 <prefix_print+0x100>)
    7164:	492d      	ldr	r1, [pc, #180]	; (721c <prefix_print+0x104>)
    7166:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
    716a:	4630      	mov	r0, r6
    716c:	f7ff ffc2 	bl	70f4 <print_formatted>
    7170:	4605      	mov	r5, r0
	total += print_formatted(log_output,
    7172:	f1b8 0f00 	cmp.w	r8, #0
    7176:	d044      	beq.n	7202 <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    7178:	2301      	movs	r3, #1
    717a:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
    717e:	4b28      	ldr	r3, [pc, #160]	; (7220 <prefix_print+0x108>)
    7180:	f017 0f10 	tst.w	r7, #16
    7184:	4f27      	ldr	r7, [pc, #156]	; (7224 <prefix_print+0x10c>)
    7186:	bf18      	it	ne
    7188:	461f      	movne	r7, r3
    718a:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
    718e:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
    7192:	f7ff fe5d 	bl	6e50 <log_source_name_get>
    7196:	4639      	mov	r1, r7
    7198:	4602      	mov	r2, r0
    719a:	4630      	mov	r0, r6
    719c:	f7ff ffaa 	bl	70f4 <print_formatted>
    71a0:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
    71a2:	4420      	add	r0, r4
    71a4:	b005      	add	sp, #20
    71a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
    71aa:	4a1f      	ldr	r2, [pc, #124]	; (7228 <prefix_print+0x110>)
    71ac:	6811      	ldr	r1, [r2, #0]
    71ae:	b331      	cbz	r1, 71fe <prefix_print+0xe6>
		timestamp /= timestamp_div;
    71b0:	4a1e      	ldr	r2, [pc, #120]	; (722c <prefix_print+0x114>)
    71b2:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
    71b6:	6814      	ldr	r4, [r2, #0]
    71b8:	fbb3 f3f4 	udiv	r3, r3, r4
		ms = (remainder * 1000U) / freq;
    71bc:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		seconds = timestamp / freq;
    71c0:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
    71c4:	fbb4 f2fe 	udiv	r2, r4, lr
    71c8:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
    71cc:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
    71d0:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
    71d4:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    71d8:	fbb4 fbf1 	udiv	fp, r4, r1
    71dc:	fb01 441b 	mls	r4, r1, fp, r4
		mins = seconds / 60U;
    71e0:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    71e4:	fb0c f404 	mul.w	r4, ip, r4
    71e8:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
    71ec:	e9cd b101 	strd	fp, r1, [sp, #4]
    71f0:	fb0a e113 	mls	r1, sl, r3, lr
    71f4:	9100      	str	r1, [sp, #0]
    71f6:	490e      	ldr	r1, [pc, #56]	; (7230 <prefix_print+0x118>)
    71f8:	f7ff ff7c 	bl	70f4 <print_formatted>
    71fc:	e7a1      	b.n	7142 <prefix_print+0x2a>
		length = 0;
    71fe:	4608      	mov	r0, r1
    7200:	e79f      	b.n	7142 <prefix_print+0x2a>
	total += print_formatted(log_output,
    7202:	4f08      	ldr	r7, [pc, #32]	; (7224 <prefix_print+0x10c>)
    7204:	e7c1      	b.n	718a <prefix_print+0x72>
    7206:	bf00      	nop
    7208:	00017e41 	.word	0x00017e41
    720c:	0001669c 	.word	0x0001669c
    7210:	000173c1 	.word	0x000173c1
    7214:	00017e33 	.word	0x00017e33
    7218:	000166b0 	.word	0x000166b0
    721c:	00017e66 	.word	0x00017e66
    7220:	00017e3d 	.word	0x00017e3d
    7224:	00017e38 	.word	0x00017e38
    7228:	200025f4 	.word	0x200025f4
    722c:	200025f8 	.word	0x200025f8
    7230:	00017e4a 	.word	0x00017e4a

00007234 <hexdump_line_print>:
{
    7234:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7238:	4698      	mov	r8, r3
    723a:	9b08      	ldr	r3, [sp, #32]
    723c:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    723e:	06da      	lsls	r2, r3, #27
{
    7240:	4604      	mov	r4, r0
    7242:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    7244:	d405      	bmi.n	7252 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    7246:	069b      	lsls	r3, r3, #26
		print_formatted(ctx, "\n");
    7248:	bf4c      	ite	mi
    724a:	4922      	ldrmi	r1, [pc, #136]	; (72d4 <hexdump_line_print+0xa0>)
		print_formatted(ctx, "\r\n");
    724c:	4922      	ldrpl	r1, [pc, #136]	; (72d8 <hexdump_line_print+0xa4>)
    724e:	f7ff ff51 	bl	70f4 <print_formatted>
		print_formatted(log_output, " ");
    7252:	f8df 908c 	ldr.w	r9, [pc, #140]	; 72e0 <hexdump_line_print+0xac>
{
    7256:	2500      	movs	r5, #0
	for (int i = 0; i < prefix_offset; i++) {
    7258:	4545      	cmp	r5, r8
    725a:	db2b      	blt.n	72b4 <hexdump_line_print+0x80>
			print_formatted(log_output, "   ");
    725c:	f8df 8084 	ldr.w	r8, [pc, #132]	; 72e4 <hexdump_line_print+0xb0>
			print_formatted(log_output, "%02x ", data[i]);
    7260:	f8df 9084 	ldr.w	r9, [pc, #132]	; 72e8 <hexdump_line_print+0xb4>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    7264:	2500      	movs	r5, #0
		if (i < length) {
    7266:	42af      	cmp	r7, r5
    7268:	d92a      	bls.n	72c0 <hexdump_line_print+0x8c>
			print_formatted(log_output, "%02x ", data[i]);
    726a:	5d72      	ldrb	r2, [r6, r5]
    726c:	4649      	mov	r1, r9
    726e:	4620      	mov	r0, r4
    7270:	f7ff ff40 	bl	70f4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    7274:	3501      	adds	r5, #1
    7276:	2d08      	cmp	r5, #8
    7278:	d1f5      	bne.n	7266 <hexdump_line_print+0x32>
	print_formatted(log_output, "|");
    727a:	4918      	ldr	r1, [pc, #96]	; (72dc <hexdump_line_print+0xa8>)
			print_formatted(log_output, " ");
    727c:	f8df 8060 	ldr.w	r8, [pc, #96]	; 72e0 <hexdump_line_print+0xac>
			      isprint((int)c) ? c : '.');
    7280:	f8df 9068 	ldr.w	r9, [pc, #104]	; 72ec <hexdump_line_print+0xb8>
			print_formatted(log_output, "%c",
    7284:	f8df a068 	ldr.w	sl, [pc, #104]	; 72f0 <hexdump_line_print+0xbc>
	print_formatted(log_output, "|");
    7288:	4620      	mov	r0, r4
    728a:	f7ff ff33 	bl	70f4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    728e:	2500      	movs	r5, #0
		if (i < length) {
    7290:	42af      	cmp	r7, r5
    7292:	d91a      	bls.n	72ca <hexdump_line_print+0x96>
			char c = (char)data[i];
    7294:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(log_output, "%c",
    7296:	f812 3009 	ldrb.w	r3, [r2, r9]
    729a:	f013 0f97 	tst.w	r3, #151	; 0x97
    729e:	bf08      	it	eq
    72a0:	222e      	moveq	r2, #46	; 0x2e
    72a2:	4651      	mov	r1, sl
    72a4:	4620      	mov	r0, r4
    72a6:	f7ff ff25 	bl	70f4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    72aa:	3501      	adds	r5, #1
    72ac:	2d08      	cmp	r5, #8
    72ae:	d1ef      	bne.n	7290 <hexdump_line_print+0x5c>
}
    72b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
    72b4:	4649      	mov	r1, r9
    72b6:	4620      	mov	r0, r4
    72b8:	f7ff ff1c 	bl	70f4 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    72bc:	3501      	adds	r5, #1
    72be:	e7cb      	b.n	7258 <hexdump_line_print+0x24>
			print_formatted(log_output, "   ");
    72c0:	4641      	mov	r1, r8
    72c2:	4620      	mov	r0, r4
    72c4:	f7ff ff16 	bl	70f4 <print_formatted>
    72c8:	e7d4      	b.n	7274 <hexdump_line_print+0x40>
			print_formatted(log_output, " ");
    72ca:	4641      	mov	r1, r8
    72cc:	4620      	mov	r0, r4
    72ce:	f7ff ff11 	bl	70f4 <print_formatted>
    72d2:	e7ea      	b.n	72aa <hexdump_line_print+0x76>
    72d4:	00017027 	.word	0x00017027
    72d8:	00017df7 	.word	0x00017df7
    72dc:	00017e04 	.word	0x00017e04
    72e0:	00017e02 	.word	0x00017e02
    72e4:	00017e00 	.word	0x00017e00
    72e8:	00017dfa 	.word	0x00017dfa
    72ec:	0001649f 	.word	0x0001649f
    72f0:	00017e06 	.word	0x00017e06

000072f4 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
    72f4:	b538      	push	{r3, r4, r5, lr}
    72f6:	460c      	mov	r4, r1
	if (color) {
    72f8:	07e1      	lsls	r1, r4, #31
{
    72fa:	4605      	mov	r5, r0
	if (color) {
    72fc:	d503      	bpl.n	7306 <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
    72fe:	4a08      	ldr	r2, [pc, #32]	; (7320 <postfix_print+0x2c>)
    7300:	4908      	ldr	r1, [pc, #32]	; (7324 <postfix_print+0x30>)
    7302:	f7ff fef7 	bl	70f4 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    7306:	06e2      	lsls	r2, r4, #27
    7308:	d408      	bmi.n	731c <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    730a:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
    730c:	4628      	mov	r0, r5
		print_formatted(ctx, "\n");
    730e:	bf4c      	ite	mi
    7310:	4905      	ldrmi	r1, [pc, #20]	; (7328 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
    7312:	4906      	ldrpl	r1, [pc, #24]	; (732c <postfix_print+0x38>)
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
    7314:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\r\n");
    7318:	f7ff beec 	b.w	70f4 <print_formatted>
}
    731c:	bd38      	pop	{r3, r4, r5, pc}
    731e:	bf00      	nop
    7320:	00017e33 	.word	0x00017e33
    7324:	000173c1 	.word	0x000173c1
    7328:	00017027 	.word	0x00017027
    732c:	00017df7 	.word	0x00017df7

00007330 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    u32_t flags)
{
    7330:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
    7334:	7a8b      	ldrb	r3, [r1, #10]
	u16_t source_id = (u16_t)log_msg_source_id_get(msg);
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	int prefix_offset;

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    7336:	f013 0407 	ands.w	r4, r3, #7
{
    733a:	4617      	mov	r7, r2
    733c:	b088      	sub	sp, #32
    733e:	4605      	mov	r5, r0
    7340:	460e      	mov	r6, r1
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    7342:	7a0a      	ldrb	r2, [r1, #8]
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    7344:	d01c      	beq.n	7380 <log_output_msg_process+0x50>
	return msg->hdr.ids.source_id;
    7346:	8949      	ldrh	r1, [r1, #10]
    7348:	f3c3 03c2 	ubfx	r3, r3, #3, #3
    734c:	0989      	lsrs	r1, r1, #6
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    734e:	43d2      	mvns	r2, r2
    7350:	9102      	str	r1, [sp, #8]
    7352:	e9cd 4300 	strd	r4, r3, [sp]
    7356:	f002 0201 	and.w	r2, r2, #1
    735a:	68f3      	ldr	r3, [r6, #12]
    735c:	4639      	mov	r1, r7
    735e:	f7ff fedb 	bl	7118 <prefix_print>
    7362:	4681      	mov	r9, r0
    7364:	7a33      	ldrb	r3, [r6, #8]
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
    7366:	07da      	lsls	r2, r3, #31
    7368:	d40c      	bmi.n	7384 <log_output_msg_process+0x54>
		std_print(msg, log_output);
    736a:	4629      	mov	r1, r5
    736c:	4630      	mov	r0, r6
    736e:	f00a ff5c 	bl	1222a <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
    7372:	b34c      	cbz	r4, 73c8 <log_output_msg_process+0x98>
		postfix_print(log_output, flags, level);
    7374:	4622      	mov	r2, r4
    7376:	4639      	mov	r1, r7
    7378:	4628      	mov	r0, r5
    737a:	f7ff ffbb 	bl	72f4 <postfix_print>
    737e:	e023      	b.n	73c8 <log_output_msg_process+0x98>
			0 : prefix_print(log_output, flags, std_msg, timestamp,
    7380:	46a1      	mov	r9, r4
    7382:	e7ef      	b.n	7364 <log_output_msg_process+0x34>
	} else if (raw_string) {
    7384:	bb34      	cbnz	r4, 73d4 <log_output_msg_process+0xa4>
	size_t offset = 0;
    7386:	4627      	mov	r7, r4
		length = log_output->size;
    7388:	68eb      	ldr	r3, [r5, #12]
    738a:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
    738c:	aa06      	add	r2, sp, #24
    738e:	463b      	mov	r3, r7
    7390:	68a9      	ldr	r1, [r5, #8]
    7392:	4630      	mov	r0, r6
    7394:	f00a ff35 	bl	12202 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
    7398:	9a06      	ldr	r2, [sp, #24]
    739a:	686b      	ldr	r3, [r5, #4]
    739c:	601a      	str	r2, [r3, #0]
		if (length != 0) {
    739e:	b13a      	cbz	r2, 73b0 <log_output_msg_process+0x80>
			eol = (log_output->buf[length - 1] == '\n');
    73a0:	68ab      	ldr	r3, [r5, #8]
    73a2:	4413      	add	r3, r2
    73a4:	f813 4c01 	ldrb.w	r4, [r3, #-1]
    73a8:	f1a4 030a 	sub.w	r3, r4, #10
    73ac:	425c      	negs	r4, r3
    73ae:	415c      	adcs	r4, r3
		log_output_flush(log_output);
    73b0:	4628      	mov	r0, r5
    73b2:	f00b f897 	bl	124e4 <log_output_flush>
		offset += length;
    73b6:	9b06      	ldr	r3, [sp, #24]
    73b8:	441f      	add	r7, r3
	} while (length > 0);
    73ba:	2b00      	cmp	r3, #0
    73bc:	d1e4      	bne.n	7388 <log_output_msg_process+0x58>
	if (eol) {
    73be:	b11c      	cbz	r4, 73c8 <log_output_msg_process+0x98>
		print_formatted(log_output, "\r");
    73c0:	4914      	ldr	r1, [pc, #80]	; (7414 <log_output_msg_process+0xe4>)
    73c2:	4628      	mov	r0, r5
    73c4:	f7ff fe96 	bl	70f4 <print_formatted>
	}

	log_output_flush(log_output);
    73c8:	4628      	mov	r0, r5
    73ca:	f00b f88b 	bl	124e4 <log_output_flush>
}
    73ce:	b008      	add	sp, #32
    73d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(log_output, "%s", log_msg_str_get(msg));
    73d4:	4630      	mov	r0, r6
    73d6:	f00a febe 	bl	12156 <log_msg_str_get>
    73da:	490f      	ldr	r1, [pc, #60]	; (7418 <log_output_msg_process+0xe8>)
    73dc:	4602      	mov	r2, r0
    73de:	4628      	mov	r0, r5
    73e0:	f7ff fe88 	bl	70f4 <print_formatted>
	u32_t offset = 0U;
    73e4:	f04f 0800 	mov.w	r8, #0
		length = sizeof(buf);
    73e8:	f04f 0a08 	mov.w	sl, #8
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    73ec:	aa05      	add	r2, sp, #20
    73ee:	4643      	mov	r3, r8
    73f0:	a906      	add	r1, sp, #24
    73f2:	4630      	mov	r0, r6
		length = sizeof(buf);
    73f4:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    73f8:	f00a ff03 	bl	12202 <log_msg_hexdump_data_get>
		if (length) {
    73fc:	9a05      	ldr	r2, [sp, #20]
    73fe:	2a00      	cmp	r2, #0
    7400:	d0b8      	beq.n	7374 <log_output_msg_process+0x44>
			hexdump_line_print(log_output, buf, length,
    7402:	464b      	mov	r3, r9
    7404:	9700      	str	r7, [sp, #0]
    7406:	a906      	add	r1, sp, #24
    7408:	4628      	mov	r0, r5
    740a:	f7ff ff13 	bl	7234 <hexdump_line_print>
			offset += length;
    740e:	9b05      	ldr	r3, [sp, #20]
    7410:	4498      	add	r8, r3
    7412:	e7eb      	b.n	73ec <log_output_msg_process+0xbc>
    7414:	00017e09 	.word	0x00017e09
    7418:	000173c1 	.word	0x000173c1

0000741c <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
    741c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
	struct device *dev = (struct device *)log_output->control_block->ctx;
    741e:	e9d0 4300 	ldrd	r4, r3, [r0]
    7422:	685d      	ldr	r5, [r3, #4]

	cnt = MIN(cnt, 9999);
	len = snprintf(buf, sizeof(buf), "%d", cnt);
    7424:	4a0f      	ldr	r2, [pc, #60]	; (7464 <log_output_dropped_process+0x48>)
    7426:	f242 730f 	movw	r3, #9999	; 0x270f
    742a:	428b      	cmp	r3, r1
    742c:	bf28      	it	cs
    742e:	460b      	movcs	r3, r1
    7430:	4668      	mov	r0, sp
    7432:	2105      	movs	r1, #5
    7434:	f7f9 fd3b 	bl	eae <sniprintf>

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
    7438:	462b      	mov	r3, r5
	len = snprintf(buf, sizeof(buf), "%d", cnt);
    743a:	4606      	mov	r6, r0
	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
    743c:	220b      	movs	r2, #11
    743e:	4620      	mov	r0, r4
    7440:	4909      	ldr	r1, [pc, #36]	; (7468 <log_output_dropped_process+0x4c>)
    7442:	f00a fee5 	bl	12210 <buffer_write>
	buffer_write(outf, buf, len, dev);
    7446:	462b      	mov	r3, r5
    7448:	4632      	mov	r2, r6
    744a:	4669      	mov	r1, sp
    744c:	4620      	mov	r0, r4
    744e:	f00a fedf 	bl	12210 <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
    7452:	462b      	mov	r3, r5
    7454:	221b      	movs	r2, #27
    7456:	4905      	ldr	r1, [pc, #20]	; (746c <log_output_dropped_process+0x50>)
    7458:	4620      	mov	r0, r4
    745a:	f00a fed9 	bl	12210 <buffer_write>
}
    745e:	b002      	add	sp, #8
    7460:	bd70      	pop	{r4, r5, r6, pc}
    7462:	bf00      	nop
    7464:	00017423 	.word	0x00017423
    7468:	00017e27 	.word	0x00017e27
    746c:	00017e0b 	.word	0x00017e0b

00007470 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
    7470:	4a08      	ldr	r2, [pc, #32]	; (7494 <log_output_timestamp_freq_set+0x24>)
{
    7472:	b510      	push	{r4, lr}
	timestamp_div = 1U;
    7474:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    7476:	4c08      	ldr	r4, [pc, #32]	; (7498 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
    7478:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
    747a:	2100      	movs	r1, #0
    747c:	42a0      	cmp	r0, r4
    747e:	d804      	bhi.n	748a <log_output_timestamp_freq_set+0x1a>
    7480:	b101      	cbz	r1, 7484 <log_output_timestamp_freq_set+0x14>
    7482:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
    7484:	4b05      	ldr	r3, [pc, #20]	; (749c <log_output_timestamp_freq_set+0x2c>)
    7486:	6018      	str	r0, [r3, #0]
}
    7488:	bd10      	pop	{r4, pc}
		frequency /= 2U;
    748a:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    748c:	005b      	lsls	r3, r3, #1
    748e:	2101      	movs	r1, #1
    7490:	e7f4      	b.n	747c <log_output_timestamp_freq_set+0xc>
    7492:	bf00      	nop
    7494:	200025f8 	.word	0x200025f8
    7498:	000f4240 	.word	0x000f4240
    749c:	200025f4 	.word	0x200025f4

000074a0 <panic>:
	log_output_ctx_set(&log_output, dev);
}

static void panic(struct log_backend const *const backend)
{
	log_output_flush(&log_output);
    74a0:	4801      	ldr	r0, [pc, #4]	; (74a8 <panic+0x8>)
    74a2:	f00b b81f 	b.w	124e4 <log_output_flush>
    74a6:	bf00      	nop
    74a8:	000166dc 	.word	0x000166dc

000074ac <dropped>:

static void dropped(const struct log_backend *const backend, u32_t cnt)
{
	ARG_UNUSED(backend);

	log_output_dropped_process(&log_output, cnt);
    74ac:	4801      	ldr	r0, [pc, #4]	; (74b4 <dropped+0x8>)
    74ae:	f7ff bfb5 	b.w	741c <log_output_dropped_process>
    74b2:	bf00      	nop
    74b4:	000166dc 	.word	0x000166dc

000074b8 <put>:
{
    74b8:	b510      	push	{r4, lr}
	log_msg_get(msg);
    74ba:	4608      	mov	r0, r1
{
    74bc:	460c      	mov	r4, r1
	log_msg_get(msg);
    74be:	f00a fe0a 	bl	120d6 <log_msg_get>
	log_output_msg_process(&log_output, msg, flags);
    74c2:	4621      	mov	r1, r4
    74c4:	4804      	ldr	r0, [pc, #16]	; (74d8 <put+0x20>)
    74c6:	220f      	movs	r2, #15
    74c8:	f7ff ff32 	bl	7330 <log_output_msg_process>
	log_msg_put(msg);
    74cc:	4620      	mov	r0, r4
}
    74ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	log_msg_put(msg);
    74d2:	f00a be2d 	b.w	12130 <log_msg_put>
    74d6:	bf00      	nop
    74d8:	000166dc 	.word	0x000166dc

000074dc <log_backend_uart_init>:
{
    74dc:	b508      	push	{r3, lr}

#ifdef __cplusplus
extern "C" {
#endif

K_SYSCALL_DECLARE1(K_SYSCALL_DEVICE_GET_BINDING, device_get_binding, struct device *, const char *, name)
    74de:	4806      	ldr	r0, [pc, #24]	; (74f8 <log_backend_uart_init+0x1c>)
    74e0:	f007 fa80 	bl	e9e4 <z_impl_device_get_binding>
	assert(dev);
    74e4:	b928      	cbnz	r0, 74f2 <log_backend_uart_init+0x16>
    74e6:	4b05      	ldr	r3, [pc, #20]	; (74fc <log_backend_uart_init+0x20>)
    74e8:	4a05      	ldr	r2, [pc, #20]	; (7500 <log_backend_uart_init+0x24>)
    74ea:	4806      	ldr	r0, [pc, #24]	; (7504 <log_backend_uart_init+0x28>)
    74ec:	2138      	movs	r1, #56	; 0x38
    74ee:	f7f9 f945 	bl	77c <__assert_func>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
    74f2:	4b05      	ldr	r3, [pc, #20]	; (7508 <log_backend_uart_init+0x2c>)
    74f4:	6058      	str	r0, [r3, #4]
}
    74f6:	bd08      	pop	{r3, pc}
    74f8:	00017ea2 	.word	0x00017ea2
    74fc:	00017ea9 	.word	0x00017ea9
    7500:	00017e8c 	.word	0x00017e8c
    7504:	00017ead 	.word	0x00017ead
    7508:	20002604 	.word	0x20002604

0000750c <tty_init>:

	return out_size;
}

int tty_init(struct tty_serial *tty, struct device *uart_dev)
{
    750c:	4602      	mov	r2, r0
    750e:	4608      	mov	r0, r1
    7510:	b508      	push	{r3, lr}
	tty->uart_dev = uart_dev;
    7512:	6011      	str	r1, [r2, #0]

	/* We start in unbuffer mode. */
	tty->rx_ringbuf = NULL;
    7514:	2300      	movs	r3, #0
	tty->tx_ringbuf = NULL;
	tty->tx_ringbuf_sz = 0U;

	tty->rx_get = tty->rx_put = tty->tx_get = tty->tx_put = 0U;

	tty->rx_timeout = K_FOREVER;
    7516:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
	tty->rx_ringbuf_sz = 0U;
    751a:	e9c2 3307 	strd	r3, r3, [r2, #28]
	tty->rx_get = tty->rx_put = tty->tx_get = tty->tx_put = 0U;
    751e:	6253      	str	r3, [r2, #36]	; 0x24
	tty->tx_ringbuf_sz = 0U;
    7520:	e9c2 3311 	strd	r3, r3, [r2, #68]	; 0x44
	tty->tx_timeout = K_FOREVER;
    7524:	e9c2 3113 	strd	r3, r1, [r2, #76]	; 0x4c
static inline void uart_irq_callback_user_data_set(
					struct device *dev,
					uart_irq_callback_user_data_t cb,
					void *user_data)
{
	const struct uart_driver_api *api =
    7528:	6843      	ldr	r3, [r0, #4]
	tty->rx_timeout = K_FOREVER;
    752a:	6291      	str	r1, [r2, #40]	; 0x28
		(const struct uart_driver_api *)dev->driver_api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    752c:	b11b      	cbz	r3, 7536 <tty_init+0x2a>
    752e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    7530:	b10b      	cbz	r3, 7536 <tty_init+0x2a>
		api->irq_callback_set(dev, cb, user_data);
    7532:	4902      	ldr	r1, [pc, #8]	; (753c <tty_init+0x30>)
    7534:	4798      	blx	r3

	uart_irq_callback_user_data_set(uart_dev, tty_uart_isr, tty);

	return 0;
}
    7536:	2000      	movs	r0, #0
    7538:	bd08      	pop	{r3, pc}
    753a:	bf00      	nop
    753c:	000125b3 	.word	0x000125b3

00007540 <console_putchar>:

	return tty_read(&console_serial, buf, size);
}

int console_putchar(char c)
{
    7540:	b507      	push	{r0, r1, r2, lr}
	return tty_write(&console_serial, &c, 1);
    7542:	2201      	movs	r2, #1
{
    7544:	f88d 0007 	strb.w	r0, [sp, #7]
	return tty_write(&console_serial, &c, 1);
    7548:	f10d 0107 	add.w	r1, sp, #7
    754c:	4802      	ldr	r0, [pc, #8]	; (7558 <console_putchar+0x18>)
    754e:	f00b f888 	bl	12662 <tty_write>
}
    7552:	b003      	add	sp, #12
    7554:	f85d fb04 	ldr.w	pc, [sp], #4
    7558:	20002610 	.word	0x20002610

0000755c <console_getchar>:

int console_getchar(void)
{
    755c:	b507      	push	{r0, r1, r2, lr}
	u8_t c;
	int res;

	res = tty_read(&console_serial, &c, 1);
    755e:	2201      	movs	r2, #1
    7560:	f10d 0107 	add.w	r1, sp, #7
    7564:	4804      	ldr	r0, [pc, #16]	; (7578 <console_getchar+0x1c>)
    7566:	f00b f8a5 	bl	126b4 <tty_read>
	if (res < 0) {
    756a:	2800      	cmp	r0, #0
		return res;
	}

	return c;
    756c:	bfa8      	it	ge
    756e:	f89d 0007 	ldrbge.w	r0, [sp, #7]
}
    7572:	b003      	add	sp, #12
    7574:	f85d fb04 	ldr.w	pc, [sp], #4
    7578:	20002610 	.word	0x20002610

0000757c <console_init>:

void console_init(void)
{
    757c:	b510      	push	{r4, lr}
    757e:	480a      	ldr	r0, [pc, #40]	; (75a8 <console_init+0x2c>)
	struct device *uart_dev;

	uart_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
	tty_init(&console_serial, uart_dev);
    7580:	4c0a      	ldr	r4, [pc, #40]	; (75ac <console_init+0x30>)
    7582:	f007 fa2f 	bl	e9e4 <z_impl_device_get_binding>
    7586:	4601      	mov	r1, r0
    7588:	4620      	mov	r0, r4
    758a:	f7ff ffbf 	bl	750c <tty_init>
	tty_set_tx_buf(&console_serial, console_txbuf, sizeof(console_txbuf));
    758e:	f44f 7200 	mov.w	r2, #512	; 0x200
    7592:	4907      	ldr	r1, [pc, #28]	; (75b0 <console_init+0x34>)
    7594:	4620      	mov	r0, r4
    7596:	f00b f910 	bl	127ba <tty_set_tx_buf>
	tty_set_rx_buf(&console_serial, console_rxbuf, sizeof(console_rxbuf));
    759a:	4620      	mov	r0, r4
    759c:	2240      	movs	r2, #64	; 0x40
    759e:	4905      	ldr	r1, [pc, #20]	; (75b4 <console_init+0x38>)
}
    75a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tty_set_rx_buf(&console_serial, console_rxbuf, sizeof(console_rxbuf));
    75a4:	f00b b8f0 	b.w	12788 <tty_set_rx_buf>
    75a8:	00017ea2 	.word	0x00017ea2
    75ac:	20002610 	.word	0x20002610
    75b0:	200058fc 	.word	0x200058fc
    75b4:	200058bc 	.word	0x200058bc

000075b8 <parse_option>:
}

static int parse_option(u8_t *data, u16_t offset, u16_t *pos,
			u16_t max_len, u16_t *opt_delta, u16_t *opt_len,
			struct coap_option *option)
{	
    75b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (max_len - offset < 1) {
    75bc:	1a5f      	subs	r7, r3, r1
{	
    75be:	b086      	sub	sp, #24
	if (max_len - offset < 1) {
    75c0:	2f00      	cmp	r7, #0
{	
    75c2:	4681      	mov	r9, r0
    75c4:	4616      	mov	r6, r2
    75c6:	461d      	mov	r5, r3
    75c8:	e9dd a40e 	ldrd	sl, r4, [sp, #56]	; 0x38
    75cc:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
	if (max_len - offset < 1) {
    75d0:	dd13      	ble.n	75fa <parse_option+0x42>
	*value = data[offset++];
    75d2:	f101 0c01 	add.w	ip, r1, #1
    75d6:	fa1f fc8c 	uxth.w	ip, ip
    75da:	5c47      	ldrb	r7, [r0, r1]
	*pos = offset;
    75dc:	f8a2 c000 	strh.w	ip, [r2]
	u16_t len;
	u8_t opt;
	int r;

	r = read_u8(data, offset, pos, max_len, &opt);
	if (r < 0) {
    75e0:	ebb3 010c 	subs.w	r1, r3, ip
    75e4:	d442      	bmi.n	766c <parse_option+0xb4>
		return r;
	}

	*opt_len += 1U;
    75e6:	f8b4 c000 	ldrh.w	ip, [r4]

	/* This indicates that options have ended */
	if (opt == COAP_MARKER) {
    75ea:	2fff      	cmp	r7, #255	; 0xff
	*opt_len += 1U;
    75ec:	f10c 0c01 	add.w	ip, ip, #1
    75f0:	f8a4 c000 	strh.w	ip, [r4]
	if (opt == COAP_MARKER) {
    75f4:	d104      	bne.n	7600 <parse_option+0x48>
		/* packet w/ marker but no payload is malformed */
		return r > 0 ? 0 : -EINVAL;
    75f6:	2900      	cmp	r1, #0
    75f8:	d137      	bne.n	766a <parse_option+0xb2>
		 * CONFIG_COAP_EXTENDED_OPTIONS_LEN_VALUE=<size>
		 */
		if (len > sizeof(option->value)) {
			NET_ERR("%u is > sizeof(coap_option->value)(%zu)!",
				len, sizeof(option->value));
			return -EINVAL;
    75fa:	f06f 0115 	mvn.w	r1, #21
    75fe:	e035      	b.n	766c <parse_option+0xb4>
	return (opt & 0xF0) >> 4;
    7600:	ea4f 1c17 	mov.w	ip, r7, lsr #4
	delta = option_header_get_delta(opt);
    7604:	fa1f fe8c 	uxth.w	lr, ip
	len = option_header_get_len(opt);
    7608:	f007 070f 	and.w	r7, r7, #15
	delta = option_header_get_delta(opt);
    760c:	f8ad e014 	strh.w	lr, [sp, #20]
	len = option_header_get_len(opt);
    7610:	f8ad 7016 	strh.w	r7, [sp, #22]
	if (r == 0 && delta > COAP_OPTION_NO_EXT) {
    7614:	bb71      	cbnz	r1, 7674 <parse_option+0xbc>
    7616:	f1bc 0f0c 	cmp.w	ip, #12
    761a:	d8ee      	bhi.n	75fa <parse_option+0x42>
	if (len > COAP_OPTION_NO_EXT) {
    761c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    7620:	2b0c      	cmp	r3, #12
    7622:	d913      	bls.n	764c <parse_option+0x94>
		r = decode_delta(data, *pos, pos, max_len,
    7624:	f10d 0212 	add.w	r2, sp, #18
    7628:	9202      	str	r2, [sp, #8]
    762a:	f10d 0216 	add.w	r2, sp, #22
    762e:	e9cd 3200 	strd	r3, r2, [sp]
    7632:	8831      	ldrh	r1, [r6, #0]
    7634:	462b      	mov	r3, r5
    7636:	4632      	mov	r2, r6
    7638:	4648      	mov	r0, r9
    763a:	f00b f8d0 	bl	127de <decode_delta>
		if (r < 0) {
    763e:	1e01      	subs	r1, r0, #0
    7640:	dbdb      	blt.n	75fa <parse_option+0x42>
		*opt_len += hdr_len;
    7642:	8823      	ldrh	r3, [r4, #0]
    7644:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    7648:	4413      	add	r3, r2
    764a:	8023      	strh	r3, [r4, #0]
	*opt_delta += delta;
    764c:	f8ba 3000 	ldrh.w	r3, [sl]
    7650:	f8bd 2014 	ldrh.w	r2, [sp, #20]
	*opt_len += len;
    7654:	f8bd 7016 	ldrh.w	r7, [sp, #22]
	*opt_delta += delta;
    7658:	4413      	add	r3, r2
    765a:	f8aa 3000 	strh.w	r3, [sl]
	*opt_len += len;
    765e:	8823      	ldrh	r3, [r4, #0]
    7660:	443b      	add	r3, r7
    7662:	8023      	strh	r3, [r4, #0]
	if (r == 0) {
    7664:	b9f9      	cbnz	r1, 76a6 <parse_option+0xee>
		if (len == 0U) {
    7666:	2f00      	cmp	r7, #0
    7668:	d1c7      	bne.n	75fa <parse_option+0x42>
			return r;
    766a:	2100      	movs	r1, #0
		*pos += len;
		r = max_len - *pos;
	}

	return r;
}
    766c:	4608      	mov	r0, r1
    766e:	b006      	add	sp, #24
    7670:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (delta > COAP_OPTION_NO_EXT) {
    7674:	f1bc 0f0c 	cmp.w	ip, #12
    7678:	d9d0      	bls.n	761c <parse_option+0x64>
		r = decode_delta(data, *pos, pos, max_len,
    767a:	f10d 0112 	add.w	r1, sp, #18
    767e:	9102      	str	r1, [sp, #8]
    7680:	a905      	add	r1, sp, #20
    7682:	e9cd e100 	strd	lr, r1, [sp]
    7686:	8811      	ldrh	r1, [r2, #0]
    7688:	f00b f8a9 	bl	127de <decode_delta>
		if ((r < 0) || (r == 0 && len > COAP_OPTION_NO_EXT)) {
    768c:	1e01      	subs	r1, r0, #0
    768e:	dbb4      	blt.n	75fa <parse_option+0x42>
    7690:	d103      	bne.n	769a <parse_option+0xe2>
    7692:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    7696:	2b0c      	cmp	r3, #12
    7698:	d8af      	bhi.n	75fa <parse_option+0x42>
		*opt_len += hdr_len;
    769a:	8823      	ldrh	r3, [r4, #0]
    769c:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    76a0:	4413      	add	r3, r2
    76a2:	8023      	strh	r3, [r4, #0]
    76a4:	e7ba      	b.n	761c <parse_option+0x64>
	if (option) {
    76a6:	f1b8 0f00 	cmp.w	r8, #0
    76aa:	d029      	beq.n	7700 <parse_option+0x148>
		if (len > sizeof(option->value)) {
    76ac:	2f0c      	cmp	r7, #12
    76ae:	d910      	bls.n	76d2 <parse_option+0x11a>
			NET_ERR("%u is > sizeof(coap_option->value)(%zu)!",
    76b0:	2201      	movs	r2, #1
    76b2:	f04f 0300 	mov.w	r3, #0
    76b6:	f362 0307 	bfi	r3, r2, #0, #8
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    76ba:	4914      	ldr	r1, [pc, #80]	; (770c <parse_option+0x154>)
    76bc:	4a14      	ldr	r2, [pc, #80]	; (7710 <parse_option+0x158>)
    76be:	4815      	ldr	r0, [pc, #84]	; (7714 <parse_option+0x15c>)
    76c0:	1a52      	subs	r2, r2, r1
    76c2:	08d2      	lsrs	r2, r2, #3
    76c4:	f362 138f 	bfi	r3, r2, #6, #10
    76c8:	4639      	mov	r1, r7
    76ca:	220c      	movs	r2, #12
    76cc:	f00a fc73 	bl	11fb6 <log_2>
    76d0:	e793      	b.n	75fa <parse_option+0x42>
		option->delta = *opt_delta;
    76d2:	f8ba 3000 	ldrh.w	r3, [sl]
    76d6:	f8a8 3000 	strh.w	r3, [r8]
		option->len = len;
    76da:	f888 7002 	strb.w	r7, [r8, #2]
		r = read(data, *pos, pos, max_len, len, &option->value[0]);
    76de:	8834      	ldrh	r4, [r6, #0]
	if (max_len - offset < len) {
    76e0:	1b2b      	subs	r3, r5, r4
    76e2:	42bb      	cmp	r3, r7
		r = read(data, *pos, pos, max_len, len, &option->value[0]);
    76e4:	f108 0003 	add.w	r0, r8, #3
	if (max_len - offset < len) {
    76e8:	db87      	blt.n	75fa <parse_option+0x42>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    76ea:	eb09 0104 	add.w	r1, r9, r4
    76ee:	463a      	mov	r2, r7
    76f0:	f7fa fd40 	bl	2174 <memcpy>
	offset += len;
    76f4:	1939      	adds	r1, r7, r4
    76f6:	b289      	uxth	r1, r1
	*pos = offset;
    76f8:	8031      	strh	r1, [r6, #0]
		if (r < 0) {
    76fa:	1a69      	subs	r1, r5, r1
    76fc:	d5b6      	bpl.n	766c <parse_option+0xb4>
    76fe:	e77c      	b.n	75fa <parse_option+0x42>
		*pos += len;
    7700:	8831      	ldrh	r1, [r6, #0]
    7702:	4439      	add	r1, r7
    7704:	b289      	uxth	r1, r1
    7706:	8031      	strh	r1, [r6, #0]
		r = max_len - *pos;
    7708:	1a69      	subs	r1, r5, r1
    770a:	e7af      	b.n	766c <parse_option+0xb4>
    770c:	00016344 	.word	0x00016344
    7710:	00016364 	.word	0x00016364
    7714:	00017f1f 	.word	0x00017f1f

00007718 <zsock_accepted_cb>:
}
#endif /* CONFIG_USERSPACE */

static void zsock_accepted_cb(struct net_context *new_ctx,
			      struct sockaddr *addr, socklen_t addrlen,
			      int status, void *user_data) {
    7718:	b538      	push	{r3, r4, r5, lr}
    771a:	9d04      	ldr	r5, [sp, #16]
    771c:	4604      	mov	r4, r0
	struct net_context *parent = user_data;

	NET_DBG("parent=%p, ctx=%p, st=%d", parent, new_ctx, status);

	if (status == 0) {
    771e:	461a      	mov	r2, r3
    7720:	b96b      	cbnz	r3, 773e <zsock_accepted_cb+0x26>
		/* This just installs a callback, so cannot fail. */
		(void)net_context_recv(new_ctx, zsock_received_cb, K_NO_WAIT,
    7722:	4907      	ldr	r1, [pc, #28]	; (7740 <zsock_accepted_cb+0x28>)
    7724:	f003 fb7e 	bl	ae24 <net_context_recv>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_QUEUE_INIT, k_queue_init, struct k_queue *, queue)
    7728:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    772c:	f00e f9c2 	bl	15ab4 <z_impl_k_queue_init>
				       NULL);
		k_fifo_init(&new_ctx->recv_q);

		k_fifo_put(&parent->accept_q, new_ctx);
    7730:	4621      	mov	r1, r4
    7732:	f105 005c 	add.w	r0, r5, #92	; 0x5c
	}
}
    7736:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		k_fifo_put(&parent->accept_q, new_ctx);
    773a:	f00e b9d8 	b.w	15aee <k_queue_append>
}
    773e:	bd38      	pop	{r3, r4, r5, pc}
    7740:	00012913 	.word	0x00012913

00007744 <zsock_socket_internal>:
{
    7744:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7746:	4607      	mov	r7, r0
    7748:	460e      	mov	r6, r1
    774a:	4614      	mov	r4, r2
	int fd = z_reserve_fd();
    774c:	f7fd fe0c 	bl	5368 <z_reserve_fd>
	if (fd < 0) {
    7750:	1e05      	subs	r5, r0, #0
    7752:	db17      	blt.n	7784 <zsock_socket_internal+0x40>
	if (proto == 0) {
    7754:	b93c      	cbnz	r4, 7766 <zsock_socket_internal+0x22>
		if (family == AF_INET || family == AF_INET6) {
    7756:	1e7b      	subs	r3, r7, #1
    7758:	2b01      	cmp	r3, #1
    775a:	d804      	bhi.n	7766 <zsock_socket_internal+0x22>
			if (type == SOCK_DGRAM) {
    775c:	2e02      	cmp	r6, #2
    775e:	d014      	beq.n	778a <zsock_socket_internal+0x46>
			} else if (type == SOCK_STREAM) {
    7760:	2e01      	cmp	r6, #1
				proto = IPPROTO_TCP;
    7762:	bf08      	it	eq
    7764:	2406      	moveq	r4, #6
	res = net_context_get(family, type, proto, &ctx);
    7766:	b2f1      	uxtb	r1, r6
    7768:	ab01      	add	r3, sp, #4
    776a:	b2a2      	uxth	r2, r4
    776c:	b2b8      	uxth	r0, r7
    776e:	f003 f9e5 	bl	ab3c <net_context_get>
	if (res < 0) {
    7772:	1e06      	subs	r6, r0, #0
    7774:	da0b      	bge.n	778e <zsock_socket_internal+0x4a>
		z_free_fd(fd);
    7776:	4628      	mov	r0, r5
    7778:	f7fd fe22 	bl	53c0 <z_free_fd>
		errno = -res;
    777c:	f00b fc7b 	bl	13076 <__errno>
    7780:	4276      	negs	r6, r6
    7782:	6006      	str	r6, [r0, #0]
		return -1;
    7784:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    7788:	e012      	b.n	77b0 <zsock_socket_internal+0x6c>
				proto = IPPROTO_UDP;
    778a:	2411      	movs	r4, #17
    778c:	e7eb      	b.n	7766 <zsock_socket_internal+0x22>
	ctx->user_data = NULL;
    778e:	9801      	ldr	r0, [sp, #4]
    7790:	2300      	movs	r3, #0
    7792:	6003      	str	r3, [r0, #0]
	ctx->socket_data = NULL;
    7794:	6583      	str	r3, [r0, #88]	; 0x58
    7796:	305c      	adds	r0, #92	; 0x5c
    7798:	f00e f98c 	bl	15ab4 <z_impl_k_queue_init>
	if (proto == IPPROTO_TCP) {
    779c:	2c06      	cmp	r4, #6
    779e:	d102      	bne.n	77a6 <zsock_socket_internal+0x62>
		net_context_ref(ctx);
    77a0:	9801      	ldr	r0, [sp, #4]
    77a2:	f00b fe90 	bl	134c6 <net_context_ref>
	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
    77a6:	4a04      	ldr	r2, [pc, #16]	; (77b8 <zsock_socket_internal+0x74>)
    77a8:	9901      	ldr	r1, [sp, #4]
    77aa:	4628      	mov	r0, r5
    77ac:	f7fd fdfe 	bl	53ac <z_finalize_fd>
}
    77b0:	4628      	mov	r0, r5
    77b2:	b003      	add	sp, #12
    77b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    77b6:	bf00      	nop
    77b8:	000166ec 	.word	0x000166ec

000077bc <zsock_bind_ctx>:
	k_fifo_put(&ctx->recv_q, pkt);
}

int zsock_bind_ctx(struct net_context *ctx, const struct sockaddr *addr,
		   socklen_t addrlen)
{
    77bc:	b538      	push	{r3, r4, r5, lr}
    77be:	4604      	mov	r4, r0
	SET_ERRNO(net_context_bind(ctx, addr, addrlen));
    77c0:	f003 faa8 	bl	ad14 <net_context_bind>
    77c4:	1e05      	subs	r5, r0, #0
    77c6:	da06      	bge.n	77d6 <zsock_bind_ctx+0x1a>
    77c8:	f00b fc55 	bl	13076 <__errno>
    77cc:	426d      	negs	r5, r5
    77ce:	6005      	str	r5, [r0, #0]
	/* For DGRAM socket, we expect to receive packets after call to
	 * bind(), but for STREAM socket, next expected operation is
	 * listen(), which doesn't work if recv callback is set.
	 */
	if (net_context_get_type(ctx) == SOCK_DGRAM) {
		SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
    77d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    77d4:	e006      	b.n	77e4 <zsock_bind_ctx+0x28>
static inline
enum net_sock_type net_context_get_type(struct net_context *context)
{
	NET_ASSERT(context);

	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
    77d6:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
    77da:	f3c3 1381 	ubfx	r3, r3, #6, #2
	if (net_context_get_type(ctx) == SOCK_DGRAM) {
    77de:	2b02      	cmp	r3, #2
    77e0:	d001      	beq.n	77e6 <zsock_bind_ctx+0x2a>
					   ctx->user_data));
	}

	return 0;
    77e2:	2000      	movs	r0, #0
}
    77e4:	bd38      	pop	{r3, r4, r5, pc}
		SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
    77e6:	6823      	ldr	r3, [r4, #0]
    77e8:	4905      	ldr	r1, [pc, #20]	; (7800 <zsock_bind_ctx+0x44>)
    77ea:	4620      	mov	r0, r4
    77ec:	2200      	movs	r2, #0
    77ee:	f003 fb19 	bl	ae24 <net_context_recv>
    77f2:	1e04      	subs	r4, r0, #0
    77f4:	daf5      	bge.n	77e2 <zsock_bind_ctx+0x26>
    77f6:	f00b fc3e 	bl	13076 <__errno>
    77fa:	4264      	negs	r4, r4
    77fc:	6004      	str	r4, [r0, #0]
    77fe:	e7e7      	b.n	77d0 <zsock_bind_ctx+0x14>
    7800:	00012913 	.word	0x00012913

00007804 <zsock_connect_ctx>:
}
#endif /* CONFIG_USERSPACE */

int zsock_connect_ctx(struct net_context *ctx, const struct sockaddr *addr,
		      socklen_t addrlen)
{
    7804:	b573      	push	{r0, r1, r4, r5, r6, lr}
	SET_ERRNO(net_context_connect(ctx, addr, addrlen, NULL,
    7806:	f640 33b8 	movw	r3, #3000	; 0xbb8
    780a:	2400      	movs	r4, #0
    780c:	e9cd 3400 	strd	r3, r4, [sp]
    7810:	4623      	mov	r3, r4
{
    7812:	4606      	mov	r6, r0
	SET_ERRNO(net_context_connect(ctx, addr, addrlen, NULL,
    7814:	f00b ff98 	bl	13748 <net_context_connect>
    7818:	1e05      	subs	r5, r0, #0
    781a:	da07      	bge.n	782c <zsock_connect_ctx+0x28>
			      K_MSEC(CONFIG_NET_SOCKETS_CONNECT_TIMEOUT),
			      NULL));
	SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
    781c:	f00b fc2b 	bl	13076 <__errno>
    7820:	426d      	negs	r5, r5
    7822:	6005      	str	r5, [r0, #0]
    7824:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
				   ctx->user_data));

	return 0;
}
    7828:	b002      	add	sp, #8
    782a:	bd70      	pop	{r4, r5, r6, pc}
	SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
    782c:	6833      	ldr	r3, [r6, #0]
    782e:	4904      	ldr	r1, [pc, #16]	; (7840 <zsock_connect_ctx+0x3c>)
    7830:	4622      	mov	r2, r4
    7832:	4630      	mov	r0, r6
    7834:	f003 faf6 	bl	ae24 <net_context_recv>
    7838:	1e05      	subs	r5, r0, #0
    783a:	dbef      	blt.n	781c <zsock_connect_ctx+0x18>
	return 0;
    783c:	4620      	mov	r0, r4
    783e:	e7f3      	b.n	7828 <zsock_connect_ctx+0x24>
    7840:	00012913 	.word	0x00012913

00007844 <zsock_listen_ctx>:
				   addrlen);
}
#endif /* CONFIG_USERSPACE */

int zsock_listen_ctx(struct net_context *ctx, int backlog)
{
    7844:	b538      	push	{r3, r4, r5, lr}
    7846:	4605      	mov	r5, r0
	SET_ERRNO(net_context_listen(ctx, backlog));
    7848:	f00b fe94 	bl	13574 <net_context_listen>
    784c:	1e04      	subs	r4, r0, #0
    784e:	da06      	bge.n	785e <zsock_listen_ctx+0x1a>
	SET_ERRNO(net_context_accept(ctx, zsock_accepted_cb, K_NO_WAIT, ctx));
    7850:	f00b fc11 	bl	13076 <__errno>
    7854:	4264      	negs	r4, r4
    7856:	6004      	str	r4, [r0, #0]
    7858:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

	return 0;
}
    785c:	bd38      	pop	{r3, r4, r5, pc}
	SET_ERRNO(net_context_accept(ctx, zsock_accepted_cb, K_NO_WAIT, ctx));
    785e:	462b      	mov	r3, r5
    7860:	2200      	movs	r2, #0
    7862:	4904      	ldr	r1, [pc, #16]	; (7874 <zsock_listen_ctx+0x30>)
    7864:	4628      	mov	r0, r5
    7866:	f00b ffdd 	bl	13824 <net_context_accept>
    786a:	1e04      	subs	r4, r0, #0
    786c:	dbf0      	blt.n	7850 <zsock_listen_ctx+0xc>
	return 0;
    786e:	2000      	movs	r0, #0
    7870:	e7f4      	b.n	785c <zsock_listen_ctx+0x18>
    7872:	bf00      	nop
    7874:	00007719 	.word	0x00007719

00007878 <zsock_accept_ctx>:
}
#endif /* CONFIG_USERSPACE */

int zsock_accept_ctx(struct net_context *parent, struct sockaddr *addr,
		     socklen_t *addrlen)
{
    7878:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    787a:	4605      	mov	r5, r0
    787c:	460f      	mov	r7, r1
    787e:	4616      	mov	r6, r2
	int fd;

	fd = z_reserve_fd();
    7880:	f7fd fd72 	bl	5368 <z_reserve_fd>
	if (fd < 0) {
    7884:	1e04      	subs	r4, r0, #0
    7886:	db32      	blt.n	78ee <zsock_accept_ctx+0x76>
		return -1;
	}

	if (net_context_get_ip_proto(parent) == IPPROTO_TCP) {
    7888:	f8b5 306c 	ldrh.w	r3, [r5, #108]	; 0x6c
    788c:	2b06      	cmp	r3, #6
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
    788e:	bf02      	ittt	eq
    7890:	f8b5 306e 	ldrheq.w	r3, [r5, #110]	; 0x6e
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
    7894:	f043 0306 	orreq.w	r3, r3, #6
    7898:	f8a5 306e 	strheq.w	r3, [r5, #110]	; 0x6e
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
    789c:	f105 005c 	add.w	r0, r5, #92	; 0x5c
    78a0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    78a4:	f00e f92d 	bl	15b02 <z_impl_k_queue_get>
    78a8:	4605      	mov	r5, r0

#ifdef CONFIG_USERSPACE
	z_object_recycle(ctx);
#endif

	if (addr != NULL && addrlen != NULL) {
    78aa:	b177      	cbz	r7, 78ca <zsock_accept_ctx+0x52>
    78ac:	b16e      	cbz	r6, 78ca <zsock_accept_ctx+0x52>
		int len = MIN(*addrlen, sizeof(ctx->remote));
    78ae:	6832      	ldr	r2, [r6, #0]
    78b0:	2a08      	cmp	r2, #8
    78b2:	bf28      	it	cs
    78b4:	2208      	movcs	r2, #8
    78b6:	f100 0124 	add.w	r1, r0, #36	; 0x24
    78ba:	4638      	mov	r0, r7
    78bc:	f7fa fc5a 	bl	2174 <memcpy>

		memcpy(addr, &ctx->remote, len);
		/* addrlen is a value-result argument, set to actual
		 * size of source address
		 */
		if (ctx->remote.sa_family == AF_INET) {
    78c0:	8cab      	ldrh	r3, [r5, #36]	; 0x24
    78c2:	2b01      	cmp	r3, #1
    78c4:	d10b      	bne.n	78de <zsock_accept_ctx+0x66>
			*addrlen = sizeof(struct sockaddr_in);
    78c6:	2308      	movs	r3, #8
		} else if (ctx->remote.sa_family == AF_INET6) {
			*addrlen = sizeof(struct sockaddr_in6);
    78c8:	6033      	str	r3, [r6, #0]
	 * connection, but it must not dispose of the context behind
	 * the application back. Likewise, when application "closes"
	 * context, it's not disposed of immediately - there's yet
	 * closing handshake for stack to perform.
	 */
	net_context_ref(ctx);
    78ca:	4628      	mov	r0, r5
    78cc:	f00b fdfb 	bl	134c6 <net_context_ref>

	NET_DBG("accept: ctx=%p, fd=%d", ctx, fd);

	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
    78d0:	4a08      	ldr	r2, [pc, #32]	; (78f4 <zsock_accept_ctx+0x7c>)
    78d2:	4629      	mov	r1, r5
    78d4:	4620      	mov	r0, r4
    78d6:	f7fd fd69 	bl	53ac <z_finalize_fd>

	return fd;
}
    78da:	4620      	mov	r0, r4
    78dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		} else if (ctx->remote.sa_family == AF_INET6) {
    78de:	2b02      	cmp	r3, #2
    78e0:	d101      	bne.n	78e6 <zsock_accept_ctx+0x6e>
			*addrlen = sizeof(struct sockaddr_in6);
    78e2:	2318      	movs	r3, #24
    78e4:	e7f0      	b.n	78c8 <zsock_accept_ctx+0x50>
			errno = ENOTSUP;
    78e6:	f00b fbc6 	bl	13076 <__errno>
    78ea:	2386      	movs	r3, #134	; 0x86
    78ec:	6003      	str	r3, [r0, #0]
		return -1;
    78ee:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    78f2:	e7f2      	b.n	78da <zsock_accept_ctx+0x62>
    78f4:	000166ec 	.word	0x000166ec

000078f8 <zsock_sendto_ctx>:
#endif /* CONFIG_USERSPACE */

ssize_t zsock_sendto_ctx(struct net_context *ctx, const void *buf, size_t len,
			 int flags,
			 const struct sockaddr *dest_addr, socklen_t addrlen)
{
    78f8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	s32_t timeout = K_FOREVER;
	int status;

	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
    78fc:	065b      	lsls	r3, r3, #25
    78fe:	bf58      	it	pl
    7900:	6d84      	ldrpl	r4, [r0, #88]	; 0x58
	}

	/* Register the callback before sending in order to receive the response
	 * from the peer.
	 */
	status = net_context_recv(ctx, zsock_received_cb,
    7902:	6803      	ldr	r3, [r0, #0]
{
    7904:	b085      	sub	sp, #20
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
    7906:	bf58      	it	pl
    7908:	f084 0402 	eorpl.w	r4, r4, #2
{
    790c:	4688      	mov	r8, r1
    790e:	4691      	mov	r9, r2
	status = net_context_recv(ctx, zsock_received_cb,
    7910:	491a      	ldr	r1, [pc, #104]	; (797c <zsock_sendto_ctx+0x84>)
{
    7912:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	status = net_context_recv(ctx, zsock_received_cb,
    7914:	f04f 0200 	mov.w	r2, #0
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
    7918:	bf54      	ite	pl
    791a:	f344 0440 	sbfxpl	r4, r4, #1, #1
		timeout = K_NO_WAIT;
    791e:	2400      	movmi	r4, #0
{
    7920:	4605      	mov	r5, r0
	status = net_context_recv(ctx, zsock_received_cb,
    7922:	f003 fa7f 	bl	ae24 <net_context_recv>
				  K_NO_WAIT, ctx->user_data);
	if (status < 0) {
    7926:	1e07      	subs	r7, r0, #0
    7928:	da09      	bge.n	793e <zsock_sendto_ctx+0x46>
		errno = -status;
    792a:	f00b fba4 	bl	13076 <__errno>
    792e:	427f      	negs	r7, r7
    7930:	6007      	str	r7, [r0, #0]
					  ctx->user_data);
	}

	if (status < 0) {
		errno = -status;
		return -1;
    7932:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	}

	return status;
}
    7936:	4620      	mov	r0, r4
    7938:	b005      	add	sp, #20
    793a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (dest_addr) {
    793e:	682b      	ldr	r3, [r5, #0]
    7940:	b19e      	cbz	r6, 796a <zsock_sendto_ctx+0x72>
		status = net_context_sendto(ctx, buf, len, dest_addr,
    7942:	e9cd 4302 	strd	r4, r3, [sp, #8]
    7946:	2300      	movs	r3, #0
    7948:	9301      	str	r3, [sp, #4]
    794a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    794c:	9300      	str	r3, [sp, #0]
    794e:	464a      	mov	r2, r9
    7950:	4633      	mov	r3, r6
    7952:	4641      	mov	r1, r8
    7954:	4628      	mov	r0, r5
    7956:	f00b ffc0 	bl	138da <net_context_sendto>
	if (status < 0) {
    795a:	2800      	cmp	r0, #0
		status = net_context_send(ctx, buf, len, NULL, timeout,
    795c:	4604      	mov	r4, r0
	if (status < 0) {
    795e:	daea      	bge.n	7936 <zsock_sendto_ctx+0x3e>
		errno = -status;
    7960:	f00b fb89 	bl	13076 <__errno>
    7964:	4264      	negs	r4, r4
    7966:	6004      	str	r4, [r0, #0]
    7968:	e7e3      	b.n	7932 <zsock_sendto_ctx+0x3a>
		status = net_context_send(ctx, buf, len, NULL, timeout,
    796a:	e9cd 4300 	strd	r4, r3, [sp]
    796e:	464a      	mov	r2, r9
    7970:	4633      	mov	r3, r6
    7972:	4641      	mov	r1, r8
    7974:	4628      	mov	r0, r5
    7976:	f00b ff83 	bl	13880 <net_context_send>
    797a:	e7ee      	b.n	795a <zsock_sendto_ctx+0x62>
    797c:	00012913 	.word	0x00012913

00007980 <z_impl_zsock_poll>:

	return timeout - elapsed;
}

int z_impl_zsock_poll(struct zsock_pollfd *fds, int nfds, int timeout)
{
    7980:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7984:	b09d      	sub	sp, #116	; 0x74
    7986:	468b      	mov	fp, r1
    7988:	4616      	mov	r6, r2
    798a:	9003      	str	r0, [sp, #12]
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
    798c:	f00e fb04 	bl	15f98 <z_impl_k_uptime_get>

	if (timeout < 0) {
		timeout = K_FOREVER;
	}

	pev = poll_events;
    7990:	f10d 0920 	add.w	r9, sp, #32
	for (pfd = fds, i = nfds; i--; pfd++) {
    7994:	9d03      	ldr	r5, [sp, #12]
    7996:	9004      	str	r0, [sp, #16]
	if (timeout < 0) {
    7998:	ea46 76e6 	orr.w	r6, r6, r6, asr #31
	pev = poll_events;
    799c:	f8cd 9018 	str.w	r9, [sp, #24]
	for (pfd = fds, i = nfds; i--; pfd++) {
    79a0:	465c      	mov	r4, fp
		if (ctx == NULL) {
			/* Will set POLLNVAL in return loop */
			continue;
		}

		if (z_fdtable_call_ioctl(vtable, ctx, ZFD_IOCTL_POLL_PREPARE,
    79a2:	af06      	add	r7, sp, #24
	for (pfd = fds, i = nfds; i--; pfd++) {
    79a4:	b9e4      	cbnz	r4, 79e0 <z_impl_zsock_poll+0x60>
    79a6:	46b0      	mov	r8, r6

		pev = poll_events;
		for (pfd = fds, i = nfds; i--; pfd++) {
			struct net_context *ctx;

			pfd->revents = 0;
    79a8:	9405      	str	r4, [sp, #20]
		ret = k_poll(poll_events, pev - poll_events, remaining_time);
    79aa:	9906      	ldr	r1, [sp, #24]

K_SYSCALL_DECLARE6(K_SYSCALL_K_PIPE_PUT, k_pipe_put, int, struct k_pipe *, pipe, void *, data, size_t, bytes_to_write, size_t *, bytes_written, size_t, min_xfer, s32_t, timeout)

K_SYSCALL_DECLARE6(K_SYSCALL_K_PIPE_GET, k_pipe_get, int, struct k_pipe *, pipe, void *, data, size_t, bytes_to_read, size_t *, bytes_read, size_t, min_xfer, s32_t, timeout)

K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
    79ac:	4b3e      	ldr	r3, [pc, #248]	; (7aa8 <z_impl_zsock_poll+0x128>)
    79ae:	eba1 0109 	sub.w	r1, r1, r9
    79b2:	1089      	asrs	r1, r1, #2
    79b4:	4359      	muls	r1, r3
    79b6:	4642      	mov	r2, r8
    79b8:	4648      	mov	r0, r9
    79ba:	f008 f92d 	bl	fc18 <z_impl_k_poll>
		if (ret != 0 && ret != -EAGAIN && ret != -EINTR) {
    79be:	f100 030b 	add.w	r3, r0, #11
    79c2:	2b0b      	cmp	r3, #11
    79c4:	4605      	mov	r5, r0
    79c6:	d806      	bhi.n	79d6 <z_impl_zsock_poll+0x56>
    79c8:	f640 0481 	movw	r4, #2177	; 0x881
    79cc:	40dc      	lsrs	r4, r3
    79ce:	43e4      	mvns	r4, r4
    79d0:	f014 0401 	ands.w	r4, r4, #1
    79d4:	d026      	beq.n	7a24 <z_impl_zsock_poll+0xa4>
			errno = -ret;
    79d6:	f00b fb4e 	bl	13076 <__errno>
    79da:	426d      	negs	r5, r5
    79dc:	6005      	str	r5, [r0, #0]
    79de:	e017      	b.n	7a10 <z_impl_zsock_poll+0x90>
		if (pfd->fd < 0) {
    79e0:	6828      	ldr	r0, [r5, #0]
    79e2:	2800      	cmp	r0, #0
    79e4:	db1b      	blt.n	7a1e <z_impl_zsock_poll+0x9e>
		ctx = z_get_fd_obj_and_vtable(pfd->fd, &vtable);
    79e6:	a907      	add	r1, sp, #28
    79e8:	f7fd fcaa 	bl	5340 <z_get_fd_obj_and_vtable>
		if (ctx == NULL) {
    79ec:	4601      	mov	r1, r0
    79ee:	b1b0      	cbz	r0, 7a1e <z_impl_zsock_poll+0x9e>
		if (z_fdtable_call_ioctl(vtable, ctx, ZFD_IOCTL_POLL_PREPARE,
    79f0:	ab1c      	add	r3, sp, #112	; 0x70
    79f2:	e9cd 7300 	strd	r7, r3, [sp]
    79f6:	f240 1203 	movw	r2, #259	; 0x103
    79fa:	462b      	mov	r3, r5
    79fc:	9807      	ldr	r0, [sp, #28]
    79fe:	f00a ff79 	bl	128f4 <z_fdtable_call_ioctl>
    7a02:	2800      	cmp	r0, #0
    7a04:	da0b      	bge.n	7a1e <z_impl_zsock_poll+0x9e>
			if (errno == EALREADY) {
    7a06:	f00b fb36 	bl	13076 <__errno>
    7a0a:	6803      	ldr	r3, [r0, #0]
    7a0c:	2b78      	cmp	r3, #120	; 0x78
    7a0e:	d005      	beq.n	7a1c <z_impl_zsock_poll+0x9c>
			return -1;
    7a10:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
			}
		}
	} while (retry);

	return ret;
}
    7a14:	4628      	mov	r0, r5
    7a16:	b01d      	add	sp, #116	; 0x74
    7a18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				timeout = K_NO_WAIT;
    7a1c:	2600      	movs	r6, #0
	for (pfd = fds, i = nfds; i--; pfd++) {
    7a1e:	3508      	adds	r5, #8
    7a20:	3c01      	subs	r4, #1
    7a22:	e7bf      	b.n	79a4 <z_impl_zsock_poll+0x24>
		for (pfd = fds, i = nfds; i--; pfd++) {
    7a24:	9f03      	ldr	r7, [sp, #12]
		pev = poll_events;
    7a26:	f8cd 9018 	str.w	r9, [sp, #24]
		for (pfd = fds, i = nfds; i--; pfd++) {
    7a2a:	46da      	mov	sl, fp
		ret = 0;
    7a2c:	4625      	mov	r5, r4
		for (pfd = fds, i = nfds; i--; pfd++) {
    7a2e:	f1ba 0f00 	cmp.w	sl, #0
    7a32:	d112      	bne.n	7a5a <z_impl_zsock_poll+0xda>
		if (retry) {
    7a34:	2c00      	cmp	r4, #0
    7a36:	d0ed      	beq.n	7a14 <z_impl_zsock_poll+0x94>
			if (ret > 0) {
    7a38:	2d00      	cmp	r5, #0
    7a3a:	dceb      	bgt.n	7a14 <z_impl_zsock_poll+0x94>
			if (timeout == K_NO_WAIT) {
    7a3c:	2e00      	cmp	r6, #0
    7a3e:	d0e9      	beq.n	7a14 <z_impl_zsock_poll+0x94>
			if (timeout != K_FOREVER) {
    7a40:	1c73      	adds	r3, r6, #1
    7a42:	d0b2      	beq.n	79aa <z_impl_zsock_poll+0x2a>
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
    7a44:	f00e faa8 	bl	15f98 <z_impl_k_uptime_get>
	return timeout - elapsed;
    7a48:	9b04      	ldr	r3, [sp, #16]
    7a4a:	eb06 0803 	add.w	r8, r6, r3
    7a4e:	eba8 0800 	sub.w	r8, r8, r0
				if (remaining_time <= 0) {
    7a52:	f1b8 0f00 	cmp.w	r8, #0
    7a56:	dca8      	bgt.n	79aa <z_impl_zsock_poll+0x2a>
    7a58:	e7dc      	b.n	7a14 <z_impl_zsock_poll+0x94>
			if (pfd->fd < 0) {
    7a5a:	6838      	ldr	r0, [r7, #0]
			pfd->revents = 0;
    7a5c:	9b05      	ldr	r3, [sp, #20]
    7a5e:	80fb      	strh	r3, [r7, #6]
			if (pfd->fd < 0) {
    7a60:	2800      	cmp	r0, #0
    7a62:	db1d      	blt.n	7aa0 <z_impl_zsock_poll+0x120>
			ctx = z_get_fd_obj_and_vtable(pfd->fd, &vtable);
    7a64:	a907      	add	r1, sp, #28
    7a66:	f7fd fc6b 	bl	5340 <z_get_fd_obj_and_vtable>
			if (ctx == NULL) {
    7a6a:	4601      	mov	r1, r0
    7a6c:	b918      	cbnz	r0, 7a76 <z_impl_zsock_poll+0xf6>
				pfd->revents = ZSOCK_POLLNVAL;
    7a6e:	2320      	movs	r3, #32
    7a70:	80fb      	strh	r3, [r7, #6]
				ret++;
    7a72:	3501      	adds	r5, #1
    7a74:	e014      	b.n	7aa0 <z_impl_zsock_poll+0x120>
			if (z_fdtable_call_ioctl(vtable, ctx, ZFD_IOCTL_POLL_UPDATE,
    7a76:	ab06      	add	r3, sp, #24
    7a78:	9300      	str	r3, [sp, #0]
    7a7a:	f44f 7282 	mov.w	r2, #260	; 0x104
    7a7e:	463b      	mov	r3, r7
    7a80:	9807      	ldr	r0, [sp, #28]
    7a82:	f00a ff37 	bl	128f4 <z_fdtable_call_ioctl>
    7a86:	2800      	cmp	r0, #0
    7a88:	da06      	bge.n	7a98 <z_impl_zsock_poll+0x118>
				if (errno == EAGAIN) {
    7a8a:	f00b faf4 	bl	13076 <__errno>
    7a8e:	6803      	ldr	r3, [r0, #0]
    7a90:	2b0b      	cmp	r3, #11
    7a92:	d1bd      	bne.n	7a10 <z_impl_zsock_poll+0x90>
					retry = true;
    7a94:	2401      	movs	r4, #1
    7a96:	e003      	b.n	7aa0 <z_impl_zsock_poll+0x120>
			if (pfd->revents != 0) {
    7a98:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    7a9c:	2b00      	cmp	r3, #0
    7a9e:	d1e8      	bne.n	7a72 <z_impl_zsock_poll+0xf2>
		for (pfd = fds, i = nfds; i--; pfd++) {
    7aa0:	3708      	adds	r7, #8
    7aa2:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
    7aa6:	e7c2      	b.n	7a2e <z_impl_zsock_poll+0xae>
    7aa8:	cccccccd 	.word	0xcccccccd

00007aac <forward_status_cb>:
{
	usb_dev.status_callback = cb;
}

static void forward_status_cb(enum usb_dc_status_code status, const u8_t *param)
{
    7aac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	size_t size = (__usb_data_end - __usb_data_start);
    7ab0:	4b0b      	ldr	r3, [pc, #44]	; (7ae0 <forward_status_cb+0x34>)
    7ab2:	4c0c      	ldr	r4, [pc, #48]	; (7ae4 <forward_status_cb+0x38>)
    7ab4:	4d0c      	ldr	r5, [pc, #48]	; (7ae8 <forward_status_cb+0x3c>)
    7ab6:	1b1b      	subs	r3, r3, r4
    7ab8:	109b      	asrs	r3, r3, #2
{
    7aba:	4606      	mov	r6, r0
    7abc:	460f      	mov	r7, r1
	size_t size = (__usb_data_end - __usb_data_start);
    7abe:	435d      	muls	r5, r3

	for (size_t i = 0; i < size; i++) {
    7ac0:	f04f 0800 	mov.w	r8, #0
    7ac4:	45a8      	cmp	r8, r5
    7ac6:	d101      	bne.n	7acc <forward_status_cb+0x20>

		if (cfg->cb_usb_status) {
			cfg->cb_usb_status(cfg, status, param);
		}
	}
}
    7ac8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (cfg->cb_usb_status) {
    7acc:	68e3      	ldr	r3, [r4, #12]
    7ace:	b11b      	cbz	r3, 7ad8 <forward_status_cb+0x2c>
			cfg->cb_usb_status(cfg, status, param);
    7ad0:	463a      	mov	r2, r7
    7ad2:	4631      	mov	r1, r6
    7ad4:	4620      	mov	r0, r4
    7ad6:	4798      	blx	r3
	for (size_t i = 0; i < size; i++) {
    7ad8:	f108 0801 	add.w	r8, r8, #1
    7adc:	342c      	adds	r4, #44	; 0x2c
    7ade:	e7f1      	b.n	7ac4 <forward_status_cb+0x18>
    7ae0:	20011f68 	.word	0x20011f68
    7ae4:	20011f3c 	.word	0x20011f3c
    7ae8:	ba2e8ba3 	.word	0xba2e8ba3

00007aec <usb_handle_vendor_request>:
{
    7aec:	b570      	push	{r4, r5, r6, lr}
    7aee:	4604      	mov	r4, r0
    7af0:	460d      	mov	r5, r1
    7af2:	4616      	mov	r6, r2
	if (usb_os_desc_enabled()) {
    7af4:	f000 fd68 	bl	85c8 <usb_os_desc_enabled>
    7af8:	b928      	cbnz	r0, 7b06 <usb_handle_vendor_request+0x1a>
	if (usb_dev.vendor_req_handler) {
    7afa:	4b0a      	ldr	r3, [pc, #40]	; (7b24 <usb_handle_vendor_request+0x38>)
    7afc:	699b      	ldr	r3, [r3, #24]
    7afe:	b953      	cbnz	r3, 7b16 <usb_handle_vendor_request+0x2a>
	return -ENOTSUP;
    7b00:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
    7b04:	bd70      	pop	{r4, r5, r6, pc}
		if (!usb_handle_os_desc_feature(setup, len, data_buf)) {
    7b06:	4632      	mov	r2, r6
    7b08:	4629      	mov	r1, r5
    7b0a:	4620      	mov	r0, r4
    7b0c:	f000 fd46 	bl	859c <usb_handle_os_desc_feature>
    7b10:	2800      	cmp	r0, #0
    7b12:	d1f2      	bne.n	7afa <usb_handle_vendor_request+0xe>
    7b14:	e7f6      	b.n	7b04 <usb_handle_vendor_request+0x18>
		return usb_dev.vendor_req_handler(setup, len, data_buf);
    7b16:	4632      	mov	r2, r6
    7b18:	4629      	mov	r1, r5
    7b1a:	4620      	mov	r0, r4
}
    7b1c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return usb_dev.vendor_req_handler(setup, len, data_buf);
    7b20:	4718      	bx	r3
    7b22:	bf00      	nop
    7b24:	20002664 	.word	0x20002664

00007b28 <usb_data_to_host>:
{
    7b28:	b537      	push	{r0, r1, r2, r4, r5, lr}
	u32_t chunk = usb_dev.data_buf_residue;
    7b2a:	4c0f      	ldr	r4, [pc, #60]	; (7b68 <usb_data_to_host+0x40>)
	usb_dc_ep_write(USB_CONTROL_IN_EP0, usb_dev.data_buf, chunk, &chunk);
    7b2c:	ab01      	add	r3, sp, #4
	u32_t chunk = usb_dev.data_buf_residue;
    7b2e:	68e2      	ldr	r2, [r4, #12]
	usb_dc_ep_write(USB_CONTROL_IN_EP0, usb_dev.data_buf, chunk, &chunk);
    7b30:	68a1      	ldr	r1, [r4, #8]
	u32_t chunk = usb_dev.data_buf_residue;
    7b32:	9201      	str	r2, [sp, #4]
{
    7b34:	4605      	mov	r5, r0
	usb_dc_ep_write(USB_CONTROL_IN_EP0, usb_dev.data_buf, chunk, &chunk);
    7b36:	2080      	movs	r0, #128	; 0x80
    7b38:	f001 fd5a 	bl	95f0 <usb_dc_ep_write>
	usb_dev.data_buf += chunk;
    7b3c:	9a01      	ldr	r2, [sp, #4]
    7b3e:	68a3      	ldr	r3, [r4, #8]
    7b40:	4413      	add	r3, r2
    7b42:	60a3      	str	r3, [r4, #8]
	usb_dev.data_buf_residue -= chunk;
    7b44:	68e3      	ldr	r3, [r4, #12]
    7b46:	1a9b      	subs	r3, r3, r2
    7b48:	60e3      	str	r3, [r4, #12]
	if (!usb_dev.data_buf_residue && chunk == USB_MAX_CTRL_MPS
    7b4a:	b95b      	cbnz	r3, 7b64 <usb_data_to_host+0x3c>
    7b4c:	2a40      	cmp	r2, #64	; 0x40
    7b4e:	d109      	bne.n	7b64 <usb_data_to_host+0x3c>
	    && len > chunk) {
    7b50:	2d40      	cmp	r5, #64	; 0x40
    7b52:	d907      	bls.n	7b64 <usb_data_to_host+0x3c>
			ret = usb_dc_ep_write(USB_CONTROL_IN_EP0, NULL, 0,
    7b54:	2300      	movs	r3, #0
    7b56:	461a      	mov	r2, r3
    7b58:	4619      	mov	r1, r3
    7b5a:	2080      	movs	r0, #128	; 0x80
    7b5c:	f001 fd48 	bl	95f0 <usb_dc_ep_write>
		} while (ret == -EAGAIN);
    7b60:	300b      	adds	r0, #11
    7b62:	d0f7      	beq.n	7b54 <usb_data_to_host+0x2c>
}
    7b64:	b003      	add	sp, #12
    7b66:	bd30      	pop	{r4, r5, pc}
    7b68:	20002664 	.word	0x20002664

00007b6c <usb_handle_request.constprop.7>:
static bool usb_handle_request(struct usb_setup_packet *setup,
    7b6c:	b508      	push	{r3, lr}
	usb_request_handler handler = usb_dev.req_handlers[type];
    7b6e:	4809      	ldr	r0, [pc, #36]	; (7b94 <usb_handle_request.constprop.7+0x28>)
	u32_t type = REQTYPE_GET_TYPE(setup->bmRequestType);
    7b70:	7803      	ldrb	r3, [r0, #0]
    7b72:	f3c3 1341 	ubfx	r3, r3, #5, #2
	usb_request_handler handler = usb_dev.req_handlers[type];
    7b76:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    7b7a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	if (handler == NULL) {
    7b7c:	b13b      	cbz	r3, 7b8e <usb_handle_request.constprop.7+0x22>
	if ((*handler)(setup, len, data) < 0) {
    7b7e:	f100 0208 	add.w	r2, r0, #8
    7b82:	f100 0110 	add.w	r1, r0, #16
    7b86:	4798      	blx	r3
    7b88:	43c0      	mvns	r0, r0
    7b8a:	0fc0      	lsrs	r0, r0, #31
}
    7b8c:	bd08      	pop	{r3, pc}
		return false;
    7b8e:	4618      	mov	r0, r3
    7b90:	e7fc      	b.n	7b8c <usb_handle_request.constprop.7+0x20>
    7b92:	bf00      	nop
    7b94:	20002664 	.word	0x20002664

00007b98 <usb_handle_control_transfer>:
{
    7b98:	b537      	push	{r0, r1, r2, r4, r5, lr}
	u32_t chunk = 0U;
    7b9a:	2200      	movs	r2, #0
{
    7b9c:	460b      	mov	r3, r1
	u32_t chunk = 0U;
    7b9e:	9201      	str	r2, [sp, #4]
	if (ep == USB_CONTROL_OUT_EP0 && ep_status == USB_DC_EP_SETUP) {
    7ba0:	4605      	mov	r5, r0
    7ba2:	2800      	cmp	r0, #0
    7ba4:	d154      	bne.n	7c50 <usb_handle_control_transfer+0xb8>
    7ba6:	4c2e      	ldr	r4, [pc, #184]	; (7c60 <usb_handle_control_transfer+0xc8>)
    7ba8:	bb41      	cbnz	r1, 7bfc <usb_handle_control_transfer+0x64>
		if (usb_dc_ep_read(ep,
    7baa:	2208      	movs	r2, #8
    7bac:	4621      	mov	r1, r4
    7bae:	f00b fa1f 	bl	12ff0 <usb_dc_ep_read>
    7bb2:	2800      	cmp	r0, #0
    7bb4:	da04      	bge.n	7bc0 <usb_handle_control_transfer+0x28>
			usb_dc_ep_set_stall(USB_CONTROL_IN_EP0);
    7bb6:	2080      	movs	r0, #128	; 0x80
    7bb8:	f001 fc90 	bl	94dc <usb_dc_ep_set_stall>
}
    7bbc:	b003      	add	sp, #12
    7bbe:	bd30      	pop	{r4, r5, pc}
		type = REQTYPE_GET_TYPE(setup->bmRequestType);
    7bc0:	7822      	ldrb	r2, [r4, #0]
		length = sys_le16_to_cpu(setup->wLength);
    7bc2:	88e5      	ldrh	r5, [r4, #6]
		type = REQTYPE_GET_TYPE(setup->bmRequestType);
    7bc4:	f3c2 1341 	ubfx	r3, r2, #5, #2
		usb_dev.data_buf = usb_dev.data_store[type];
    7bc8:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    7bcc:	6b58      	ldr	r0, [r3, #52]	; 0x34
    7bce:	60a0      	str	r0, [r4, #8]
		if (!usb_dev.data_buf) {
    7bd0:	b910      	cbnz	r0, 7bd8 <usb_handle_control_transfer+0x40>
			usb_dc_ep_set_stall(USB_CONTROL_OUT_EP0);
    7bd2:	f001 fc83 	bl	94dc <usb_dc_ep_set_stall>
    7bd6:	e7ee      	b.n	7bb6 <usb_handle_control_transfer+0x1e>
		usb_dev.data_buf_len = length;
    7bd8:	e9c4 5503 	strd	r5, r5, [r4, #12]
		if (length &&
    7bdc:	b10d      	cbz	r5, 7be2 <usb_handle_control_transfer+0x4a>
    7bde:	09d3      	lsrs	r3, r2, #7
    7be0:	d0ec      	beq.n	7bbc <usb_handle_control_transfer+0x24>
		if (!usb_handle_request(setup,
    7be2:	f7ff ffc3 	bl	7b6c <usb_handle_request.constprop.7>
    7be6:	2800      	cmp	r0, #0
    7be8:	d0e5      	beq.n	7bb6 <usb_handle_control_transfer+0x1e>
		usb_dev.data_buf_residue = MIN(usb_dev.data_buf_len, length);
    7bea:	6923      	ldr	r3, [r4, #16]
    7bec:	42ab      	cmp	r3, r5
    7bee:	bfd4      	ite	le
    7bf0:	60e3      	strle	r3, [r4, #12]
    7bf2:	60e5      	strgt	r5, [r4, #12]
		usb_data_to_host(length);
    7bf4:	4628      	mov	r0, r5
			usb_data_to_host(sys_le16_to_cpu(setup->wLength));
    7bf6:	f7ff ff97 	bl	7b28 <usb_data_to_host>
		__ASSERT_NO_MSG(false);
    7bfa:	e7df      	b.n	7bbc <usb_handle_control_transfer+0x24>
		if (usb_dev.data_buf_residue <= 0) {
    7bfc:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
    7c00:	2a00      	cmp	r2, #0
			if (usb_dc_ep_read(USB_CONTROL_OUT_EP0,
    7c02:	ab01      	add	r3, sp, #4
		if (usb_dev.data_buf_residue <= 0) {
    7c04:	dc05      	bgt.n	7c12 <usb_handle_control_transfer+0x7a>
			if (usb_dc_ep_read(USB_CONTROL_OUT_EP0,
    7c06:	4602      	mov	r2, r0
    7c08:	f00b f9f2 	bl	12ff0 <usb_dc_ep_read>
    7c0c:	2800      	cmp	r0, #0
    7c0e:	dad5      	bge.n	7bbc <usb_handle_control_transfer+0x24>
    7c10:	e7d1      	b.n	7bb6 <usb_handle_control_transfer+0x1e>
		if (usb_dc_ep_read(USB_CONTROL_OUT_EP0,
    7c12:	f00b f9ed 	bl	12ff0 <usb_dc_ep_read>
    7c16:	2800      	cmp	r0, #0
    7c18:	da04      	bge.n	7c24 <usb_handle_control_transfer+0x8c>
			usb_dc_ep_set_stall(USB_CONTROL_IN_EP0);
    7c1a:	2080      	movs	r0, #128	; 0x80
    7c1c:	f001 fc5e 	bl	94dc <usb_dc_ep_set_stall>
			usb_dc_ep_set_stall(USB_CONTROL_OUT_EP0);
    7c20:	4628      	mov	r0, r5
    7c22:	e7c9      	b.n	7bb8 <usb_handle_control_transfer+0x20>
		usb_dev.data_buf += chunk;
    7c24:	9901      	ldr	r1, [sp, #4]
    7c26:	68a2      	ldr	r2, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
    7c28:	68e3      	ldr	r3, [r4, #12]
		usb_dev.data_buf += chunk;
    7c2a:	440a      	add	r2, r1
		usb_dev.data_buf_residue -= chunk;
    7c2c:	1a5b      	subs	r3, r3, r1
		usb_dev.data_buf += chunk;
    7c2e:	60a2      	str	r2, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
    7c30:	60e3      	str	r3, [r4, #12]
		if (usb_dev.data_buf_residue == 0) {
    7c32:	2b00      	cmp	r3, #0
    7c34:	d1c2      	bne.n	7bbc <usb_handle_control_transfer+0x24>
			type = REQTYPE_GET_TYPE(setup->bmRequestType);
    7c36:	7823      	ldrb	r3, [r4, #0]
    7c38:	f3c3 1341 	ubfx	r3, r3, #5, #2
			usb_dev.data_buf = usb_dev.data_store[type];
    7c3c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    7c40:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7c42:	60a3      	str	r3, [r4, #8]
			if (!usb_handle_request(setup,
    7c44:	f7ff ff92 	bl	7b6c <usb_handle_request.constprop.7>
    7c48:	2800      	cmp	r0, #0
    7c4a:	d0b4      	beq.n	7bb6 <usb_handle_control_transfer+0x1e>
			usb_data_to_host(sys_le16_to_cpu(setup->wLength));
    7c4c:	88e0      	ldrh	r0, [r4, #6]
    7c4e:	e7d2      	b.n	7bf6 <usb_handle_control_transfer+0x5e>
	} else if (ep == USB_CONTROL_IN_EP0) {
    7c50:	2880      	cmp	r0, #128	; 0x80
    7c52:	d1b3      	bne.n	7bbc <usb_handle_control_transfer+0x24>
		if (usb_dev.data_buf_residue != 0) {
    7c54:	4b02      	ldr	r3, [pc, #8]	; (7c60 <usb_handle_control_transfer+0xc8>)
    7c56:	68da      	ldr	r2, [r3, #12]
    7c58:	2a00      	cmp	r2, #0
    7c5a:	d0af      	beq.n	7bbc <usb_handle_control_transfer+0x24>
			usb_data_to_host(sys_le16_to_cpu(setup->wLength));
    7c5c:	88d8      	ldrh	r0, [r3, #6]
    7c5e:	e7ca      	b.n	7bf6 <usb_handle_control_transfer+0x5e>
    7c60:	20002664 	.word	0x20002664

00007c64 <k_work_submit_to_queue.constprop.9>:
 * @param work Address of work item.
 *
 * @return N/A
 * @req K-WORK-001
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
    7c64:	4601      	mov	r1, r0
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    7c66:	f100 0308 	add.w	r3, r0, #8
    7c6a:	f3bf 8f5b 	dmb	ish
    7c6e:	e853 2f00 	ldrex	r2, [r3]
    7c72:	f042 0001 	orr.w	r0, r2, #1
    7c76:	e843 0c00 	strex	ip, r0, [r3]
    7c7a:	f1bc 0f00 	cmp.w	ip, #0
    7c7e:	d1f6      	bne.n	7c6e <k_work_submit_to_queue.constprop.9+0xa>
    7c80:	f3bf 8f5b 	dmb	ish
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    7c84:	07d3      	lsls	r3, r2, #31
    7c86:	d402      	bmi.n	7c8e <k_work_submit_to_queue.constprop.9+0x2a>
		k_queue_append(&work_q->queue, work);
    7c88:	4801      	ldr	r0, [pc, #4]	; (7c90 <k_work_submit_to_queue.constprop.9+0x2c>)
    7c8a:	f00d bf30 	b.w	15aee <k_queue_append>
	}
}
    7c8e:	4770      	bx	lr
    7c90:	20005620 	.word	0x20005620

00007c94 <usb_handle_standard_request>:
{
    7c94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7c98:	b085      	sub	sp, #20
    7c9a:	4607      	mov	r7, r0
    7c9c:	460e      	mov	r6, r1
    7c9e:	4614      	mov	r4, r2
	if (!usb_handle_os_desc(setup, len, data_buf)) {
    7ca0:	f000 fc66 	bl	8570 <usb_handle_os_desc>
    7ca4:	b908      	cbnz	r0, 7caa <usb_handle_standard_request+0x16>
	int rc = 0;
    7ca6:	2000      	movs	r0, #0
    7ca8:	e0a5      	b.n	7df6 <usb_handle_standard_request+0x162>
	if (usb_dev.custom_req_handler &&
    7caa:	4daa      	ldr	r5, [pc, #680]	; (7f54 <usb_handle_standard_request+0x2c0>)
    7cac:	696b      	ldr	r3, [r5, #20]
    7cae:	b98b      	cbnz	r3, 7cd4 <usb_handle_standard_request+0x40>
	switch (REQTYPE_GET_RECIP(setup->bmRequestType)) {
    7cb0:	f897 8000 	ldrb.w	r8, [r7]
    7cb4:	f008 081f 	and.w	r8, r8, #31
    7cb8:	f1b8 0f01 	cmp.w	r8, #1
    7cbc:	f000 80a4 	beq.w	7e08 <usb_handle_standard_request+0x174>
    7cc0:	f1b8 0f00 	cmp.w	r8, #0
    7cc4:	d00d      	beq.n	7ce2 <usb_handle_standard_request+0x4e>
    7cc6:	f1b8 0f02 	cmp.w	r8, #2
    7cca:	f000 80ea 	beq.w	7ea2 <usb_handle_standard_request+0x20e>
		rc = -EINVAL;
    7cce:	f06f 0015 	mvn.w	r0, #21
    7cd2:	e090      	b.n	7df6 <usb_handle_standard_request+0x162>
	    !usb_dev.custom_req_handler(setup, len, data_buf)) {
    7cd4:	4622      	mov	r2, r4
    7cd6:	4631      	mov	r1, r6
    7cd8:	4638      	mov	r0, r7
    7cda:	4798      	blx	r3
	if (usb_dev.custom_req_handler &&
    7cdc:	2800      	cmp	r0, #0
    7cde:	d1e7      	bne.n	7cb0 <usb_handle_standard_request+0x1c>
    7ce0:	e7e1      	b.n	7ca6 <usb_handle_standard_request+0x12>
	switch (setup->bRequest) {
    7ce2:	787a      	ldrb	r2, [r7, #1]
	u16_t value = sys_le16_to_cpu(setup->wValue);
    7ce4:	8878      	ldrh	r0, [r7, #2]
	u8_t *data = *data_buf;
    7ce6:	6823      	ldr	r3, [r4, #0]
	switch (setup->bRequest) {
    7ce8:	2a09      	cmp	r2, #9
    7cea:	d8f0      	bhi.n	7cce <usb_handle_standard_request+0x3a>
    7cec:	a101      	add	r1, pc, #4	; (adr r1, 7cf4 <usb_handle_standard_request+0x60>)
    7cee:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    7cf2:	bf00      	nop
    7cf4:	00007d1d 	.word	0x00007d1d
    7cf8:	00007deb 	.word	0x00007deb
    7cfc:	00007ccf 	.word	0x00007ccf
    7d00:	00007dfd 	.word	0x00007dfd
    7d04:	00007ccf 	.word	0x00007ccf
    7d08:	00007d37 	.word	0x00007d37
    7d0c:	00007d3f 	.word	0x00007d3f
    7d10:	00007ccf 	.word	0x00007ccf
    7d14:	00007d6d 	.word	0x00007d6d
    7d18:	00007d77 	.word	0x00007d77
		data[0] = 0U;
    7d1c:	2000      	movs	r0, #0
    7d1e:	7018      	strb	r0, [r3, #0]
		data[1] = 0U;
    7d20:	7058      	strb	r0, [r3, #1]
			data[0] |= (usb_dev.remote_wakeup ?
    7d22:	f895 204e 	ldrb.w	r2, [r5, #78]	; 0x4e
    7d26:	4282      	cmp	r2, r0
    7d28:	bf14      	ite	ne
    7d2a:	2202      	movne	r2, #2
    7d2c:	4602      	moveq	r2, r0
    7d2e:	701a      	strb	r2, [r3, #0]
		*len = 2;
    7d30:	2302      	movs	r3, #2
    7d32:	6033      	str	r3, [r6, #0]
		break;
    7d34:	e05f      	b.n	7df6 <usb_handle_standard_request+0x162>
		usb_dc_set_address(value);
    7d36:	b2c0      	uxtb	r0, r0
    7d38:	f001 fb4a 	bl	93d0 <usb_dc_set_address>
	return ret;
    7d3c:	e7b3      	b.n	7ca6 <usb_handle_standard_request+0x12>
	type = GET_DESC_TYPE(type_index);
    7d3e:	0a02      	lsrs	r2, r0, #8
	if ((type == DESC_INTERFACE) || (type == DESC_ENDPOINT) ||
    7d40:	1f13      	subs	r3, r2, #4
    7d42:	2b01      	cmp	r3, #1
    7d44:	d9c3      	bls.n	7cce <usb_handle_standard_request+0x3a>
    7d46:	2a07      	cmp	r2, #7
    7d48:	d8c1      	bhi.n	7cce <usb_handle_standard_request+0x3a>
	p = (u8_t *)usb_dev.descriptors;
    7d4a:	6a2b      	ldr	r3, [r5, #32]
	cur_index = 0;
    7d4c:	2100      	movs	r1, #0
			if (cur_index == index) {
    7d4e:	b2c0      	uxtb	r0, r0
	while (p[DESC_bLength] != 0U) {
    7d50:	781d      	ldrb	r5, [r3, #0]
    7d52:	2d00      	cmp	r5, #0
    7d54:	d0bb      	beq.n	7cce <usb_handle_standard_request+0x3a>
		if (p[DESC_bDescriptorType] == type) {
    7d56:	785f      	ldrb	r7, [r3, #1]
    7d58:	4297      	cmp	r7, r2
    7d5a:	d103      	bne.n	7d64 <usb_handle_standard_request+0xd0>
			if (cur_index == index) {
    7d5c:	4288      	cmp	r0, r1
    7d5e:	f000 80f2 	beq.w	7f46 <usb_handle_standard_request+0x2b2>
			cur_index++;
    7d62:	3101      	adds	r1, #1
		p += p[DESC_bLength];
    7d64:	442b      	add	r3, r5
    7d66:	e7f3      	b.n	7d50 <usb_handle_standard_request+0xbc>
			*len = p[DESC_bLength];
    7d68:	781b      	ldrb	r3, [r3, #0]
    7d6a:	e0f1      	b.n	7f50 <usb_handle_standard_request+0x2bc>
		data[0] = usb_dev.configuration;
    7d6c:	f895 204d 	ldrb.w	r2, [r5, #77]	; 0x4d
    7d70:	701a      	strb	r2, [r3, #0]
		*len = 1;
    7d72:	2301      	movs	r3, #1
    7d74:	e0ec      	b.n	7f50 <usb_handle_standard_request+0x2bc>
		if (!usb_set_configuration(value, 0)) {
    7d76:	b2c4      	uxtb	r4, r0
    7d78:	f88d 4007 	strb.w	r4, [sp, #7]
	if (config_index == 0U) {
    7d7c:	b154      	cbz	r4, 7d94 <usb_handle_standard_request+0x100>
	cur_alt_setting = 0xFF;
    7d7e:	27ff      	movs	r7, #255	; 0xff
	p = (u8_t *)usb_dev.descriptors;
    7d80:	6a2e      	ldr	r6, [r5, #32]
	cur_config = 0xFF;
    7d82:	46b8      	mov	r8, r7
	while (p[DESC_bLength] != 0U) {
    7d84:	7833      	ldrb	r3, [r6, #0]
    7d86:	b943      	cbnz	r3, 7d9a <usb_handle_standard_request+0x106>
	if (usb_dev.status_callback) {
    7d88:	69eb      	ldr	r3, [r5, #28]
    7d8a:	b11b      	cbz	r3, 7d94 <usb_handle_standard_request+0x100>
		usb_dev.status_callback(USB_DC_CONFIGURED, &config_index);
    7d8c:	f10d 0107 	add.w	r1, sp, #7
    7d90:	2003      	movs	r0, #3
    7d92:	4798      	blx	r3
			usb_dev.configuration = value;
    7d94:	f885 404d 	strb.w	r4, [r5, #77]	; 0x4d
	return ret;
    7d98:	e785      	b.n	7ca6 <usb_handle_standard_request+0x12>
		switch (p[DESC_bDescriptorType]) {
    7d9a:	7873      	ldrb	r3, [r6, #1]
    7d9c:	2b04      	cmp	r3, #4
    7d9e:	d008      	beq.n	7db2 <usb_handle_standard_request+0x11e>
    7da0:	2b05      	cmp	r3, #5
    7da2:	d008      	beq.n	7db6 <usb_handle_standard_request+0x122>
    7da4:	2b02      	cmp	r3, #2
    7da6:	d101      	bne.n	7dac <usb_handle_standard_request+0x118>
			cur_config = p[CONF_DESC_bConfigurationValue];
    7da8:	f896 8005 	ldrb.w	r8, [r6, #5]
		p += p[DESC_bLength];
    7dac:	7833      	ldrb	r3, [r6, #0]
    7dae:	441e      	add	r6, r3
    7db0:	e7e8      	b.n	7d84 <usb_handle_standard_request+0xf0>
			cur_alt_setting =
    7db2:	78f7      	ldrb	r7, [r6, #3]
			break;
    7db4:	e7fa      	b.n	7dac <usb_handle_standard_request+0x118>
			if ((cur_config == config_index) &&
    7db6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7dba:	4543      	cmp	r3, r8
    7dbc:	d1f6      	bne.n	7dac <usb_handle_standard_request+0x118>
    7dbe:	2f00      	cmp	r7, #0
    7dc0:	d1f4      	bne.n	7dac <usb_handle_standard_request+0x118>
				    p[ENDP_DESC_bmAttributes];
    7dc2:	78f3      	ldrb	r3, [r6, #3]
				ep_cfg.ep_type =
    7dc4:	f88d 300c 	strb.w	r3, [sp, #12]
				    (p[ENDP_DESC_wMaxPacketSize + 1]
    7dc8:	7972      	ldrb	r2, [r6, #5]
				    (p[ENDP_DESC_wMaxPacketSize]) |
    7dca:	7933      	ldrb	r3, [r6, #4]
    7dcc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				ep_cfg.ep_mps =
    7dd0:	f8ad 300a 	strh.w	r3, [sp, #10]
				ep_cfg.ep_addr =
    7dd4:	78b3      	ldrb	r3, [r6, #2]
    7dd6:	f88d 3008 	strb.w	r3, [sp, #8]
				usb_dc_ep_configure(&ep_cfg);
    7dda:	a802      	add	r0, sp, #8
    7ddc:	f001 fb4a 	bl	9474 <usb_dc_ep_configure>
				usb_dc_ep_enable(ep_cfg.ep_addr);
    7de0:	f89d 0008 	ldrb.w	r0, [sp, #8]
    7de4:	f001 fbe6 	bl	95b4 <usb_dc_ep_enable>
    7de8:	e7e0      	b.n	7dac <usb_handle_standard_request+0x118>
			if (value == FEA_REMOTE_WAKEUP) {
    7dea:	2801      	cmp	r0, #1
    7dec:	f47f af6f 	bne.w	7cce <usb_handle_standard_request+0x3a>
				usb_dev.remote_wakeup = false;
    7df0:	2000      	movs	r0, #0
    7df2:	f885 004e 	strb.w	r0, [r5, #78]	; 0x4e
}
    7df6:	b005      	add	sp, #20
    7df8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (value == FEA_REMOTE_WAKEUP) {
    7dfc:	2801      	cmp	r0, #1
    7dfe:	f47f af66 	bne.w	7cce <usb_handle_standard_request+0x3a>
				usb_dev.remote_wakeup = true;
    7e02:	f885 004e 	strb.w	r0, [r5, #78]	; 0x4e
	return ret;
    7e06:	e74e      	b.n	7ca6 <usb_handle_standard_request+0x12>
	switch (setup->bRequest) {
    7e08:	7878      	ldrb	r0, [r7, #1]
		if (usb_handle_std_interface_req(setup, len, data_buf) == false)
    7e0a:	6823      	ldr	r3, [r4, #0]
	switch (setup->bRequest) {
    7e0c:	280a      	cmp	r0, #10
    7e0e:	d007      	beq.n	7e20 <usb_handle_standard_request+0x18c>
    7e10:	280b      	cmp	r0, #11
    7e12:	d00a      	beq.n	7e2a <usb_handle_standard_request+0x196>
    7e14:	2800      	cmp	r0, #0
    7e16:	f47f af5a 	bne.w	7cce <usb_handle_standard_request+0x3a>
		data[0] = 0U;
    7e1a:	7018      	strb	r0, [r3, #0]
		data[1] = 0U;
    7e1c:	7058      	strb	r0, [r3, #1]
    7e1e:	e787      	b.n	7d30 <usb_handle_standard_request+0x9c>
		data[0] = 0U;
    7e20:	2000      	movs	r0, #0
    7e22:	7018      	strb	r0, [r3, #0]
		*len = 1;
    7e24:	f8c6 8000 	str.w	r8, [r6]
		break;
    7e28:	e7e5      	b.n	7df6 <usb_handle_standard_request+0x162>
		usb_set_interface(sys_le16_to_cpu(setup->wIndex),
    7e2a:	f897 a004 	ldrb.w	sl, [r7, #4]
    7e2e:	f897 b002 	ldrb.w	fp, [r7, #2]
	const u8_t *p = usb_dev.descriptors;
    7e32:	6a2c      	ldr	r4, [r5, #32]
	u8_t cur_iface = 0xFF;
    7e34:	27ff      	movs	r7, #255	; 0xff
	u8_t cur_alt_setting = 0xFF;
    7e36:	46b9      	mov	r9, r7
	const u8_t *if_desc = NULL;
    7e38:	f04f 0800 	mov.w	r8, #0
	while (p[DESC_bLength] != 0U) {
    7e3c:	7823      	ldrb	r3, [r4, #0]
    7e3e:	b93b      	cbnz	r3, 7e50 <usb_handle_standard_request+0x1bc>
	if (usb_dev.status_callback) {
    7e40:	69eb      	ldr	r3, [r5, #28]
    7e42:	b113      	cbz	r3, 7e4a <usb_handle_standard_request+0x1b6>
		usb_dev.status_callback(USB_DC_INTERFACE, if_desc);
    7e44:	4641      	mov	r1, r8
    7e46:	2007      	movs	r0, #7
    7e48:	4798      	blx	r3
		*len = 0;
    7e4a:	2000      	movs	r0, #0
    7e4c:	6030      	str	r0, [r6, #0]
		break;
    7e4e:	e7d2      	b.n	7df6 <usb_handle_standard_request+0x162>
		switch (p[DESC_bDescriptorType]) {
    7e50:	7863      	ldrb	r3, [r4, #1]
    7e52:	2b04      	cmp	r3, #4
    7e54:	d004      	beq.n	7e60 <usb_handle_standard_request+0x1cc>
    7e56:	2b05      	cmp	r3, #5
    7e58:	d00b      	beq.n	7e72 <usb_handle_standard_request+0x1de>
		p += p[DESC_bLength];
    7e5a:	7823      	ldrb	r3, [r4, #0]
    7e5c:	441c      	add	r4, r3
    7e5e:	e7ed      	b.n	7e3c <usb_handle_standard_request+0x1a8>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
    7e60:	78a7      	ldrb	r7, [r4, #2]
			cur_alt_setting = p[INTF_DESC_bAlternateSetting];
    7e62:	f894 9003 	ldrb.w	r9, [r4, #3]
			if (cur_iface == iface &&
    7e66:	45ba      	cmp	sl, r7
    7e68:	d1f7      	bne.n	7e5a <usb_handle_standard_request+0x1c6>
    7e6a:	45cb      	cmp	fp, r9
    7e6c:	bf08      	it	eq
    7e6e:	46a0      	moveq	r8, r4
    7e70:	e7f3      	b.n	7e5a <usb_handle_standard_request+0x1c6>
			if ((cur_iface != iface) ||
    7e72:	45ba      	cmp	sl, r7
    7e74:	d1f1      	bne.n	7e5a <usb_handle_standard_request+0x1c6>
    7e76:	45cb      	cmp	fp, r9
    7e78:	d1ef      	bne.n	7e5a <usb_handle_standard_request+0x1c6>
			ep_cfg.ep_type = p[ENDP_DESC_bmAttributes];
    7e7a:	78e3      	ldrb	r3, [r4, #3]
    7e7c:	f88d 300c 	strb.w	r3, [sp, #12]
				(p[ENDP_DESC_wMaxPacketSize + 1] << 8);
    7e80:	7962      	ldrb	r2, [r4, #5]
			ep_cfg.ep_mps = (p[ENDP_DESC_wMaxPacketSize]) |
    7e82:	7923      	ldrb	r3, [r4, #4]
    7e84:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    7e88:	f8ad 300a 	strh.w	r3, [sp, #10]
			ep_cfg.ep_addr = p[ENDP_DESC_bEndpointAddress];
    7e8c:	78a3      	ldrb	r3, [r4, #2]
    7e8e:	f88d 3008 	strb.w	r3, [sp, #8]
			usb_dc_ep_configure(&ep_cfg);
    7e92:	a802      	add	r0, sp, #8
    7e94:	f001 faee 	bl	9474 <usb_dc_ep_configure>
			usb_dc_ep_enable(ep_cfg.ep_addr);
    7e98:	f89d 0008 	ldrb.w	r0, [sp, #8]
    7e9c:	f001 fb8a 	bl	95b4 <usb_dc_ep_enable>
			LOG_DBG("Found: ep_addr 0x%x", ep_cfg.ep_addr);
    7ea0:	e7db      	b.n	7e5a <usb_handle_standard_request+0x1c6>
	switch (setup->bRequest) {
    7ea2:	787b      	ldrb	r3, [r7, #1]
	u8_t ep = sys_le16_to_cpu(setup->wIndex);
    7ea4:	7938      	ldrb	r0, [r7, #4]
		if (usb_handle_std_endpoint_req(setup, len, data_buf) == false)
    7ea6:	f8d4 9000 	ldr.w	r9, [r4]
	u8_t ep = sys_le16_to_cpu(setup->wIndex);
    7eaa:	f88d 0008 	strb.w	r0, [sp, #8]
	switch (setup->bRequest) {
    7eae:	2b01      	cmp	r3, #1
    7eb0:	d02a      	beq.n	7f08 <usb_handle_standard_request+0x274>
    7eb2:	b25c      	sxtb	r4, r3
    7eb4:	b304      	cbz	r4, 7ef8 <usb_handle_standard_request+0x264>
    7eb6:	2b03      	cmp	r3, #3
    7eb8:	f47f af09 	bne.w	7cce <usb_handle_standard_request+0x3a>
		if (sys_le16_to_cpu(setup->wValue) == FEA_ENDPOINT_HALT) {
    7ebc:	887c      	ldrh	r4, [r7, #2]
    7ebe:	2c00      	cmp	r4, #0
    7ec0:	f47f af05 	bne.w	7cce <usb_handle_standard_request+0x3a>
			LOG_INF("--- EP SET halt %x", ep);
    7ec4:	2303      	movs	r3, #3
    7ec6:	f04f 0200 	mov.w	r2, #0
    7eca:	f363 0207 	bfi	r2, r3, #0, #8
    7ece:	4922      	ldr	r1, [pc, #136]	; (7f58 <usb_handle_standard_request+0x2c4>)
    7ed0:	4b22      	ldr	r3, [pc, #136]	; (7f5c <usb_handle_standard_request+0x2c8>)
    7ed2:	1a5b      	subs	r3, r3, r1
    7ed4:	08db      	lsrs	r3, r3, #3
    7ed6:	f363 128f 	bfi	r2, r3, #6, #10
    7eda:	4601      	mov	r1, r0
    7edc:	4820      	ldr	r0, [pc, #128]	; (7f60 <usb_handle_standard_request+0x2cc>)
    7ede:	f00a f856 	bl	11f8e <log_1>
			usb_dc_ep_set_stall(ep);
    7ee2:	f89d 0008 	ldrb.w	r0, [sp, #8]
    7ee6:	f001 faf9 	bl	94dc <usb_dc_ep_set_stall>
			if (usb_dev.status_callback) {
    7eea:	69eb      	ldr	r3, [r5, #28]
    7eec:	2b00      	cmp	r3, #0
    7eee:	f43f aeda 	beq.w	7ca6 <usb_handle_standard_request+0x12>
				usb_dev.status_callback(USB_DC_SET_HALT, &ep);
    7ef2:	a902      	add	r1, sp, #8
    7ef4:	2008      	movs	r0, #8
    7ef6:	e024      	b.n	7f42 <usb_handle_standard_request+0x2ae>
		usb_dc_ep_is_stalled(ep, &data[0]);
    7ef8:	4649      	mov	r1, r9
    7efa:	f001 fb41 	bl	9580 <usb_dc_ep_is_stalled>
		data[1] = 0U;
    7efe:	f889 4001 	strb.w	r4, [r9, #1]
		*len = 2;
    7f02:	f8c6 8000 	str.w	r8, [r6]
		break;
    7f06:	e6ce      	b.n	7ca6 <usb_handle_standard_request+0x12>
		if (sys_le16_to_cpu(setup->wValue) == FEA_ENDPOINT_HALT) {
    7f08:	887c      	ldrh	r4, [r7, #2]
    7f0a:	2c00      	cmp	r4, #0
    7f0c:	f47f aedf 	bne.w	7cce <usb_handle_standard_request+0x3a>
			LOG_INF("... EP clear halt %x", ep);
    7f10:	2303      	movs	r3, #3
    7f12:	f04f 0200 	mov.w	r2, #0
    7f16:	f363 0207 	bfi	r2, r3, #0, #8
    7f1a:	490f      	ldr	r1, [pc, #60]	; (7f58 <usb_handle_standard_request+0x2c4>)
    7f1c:	4b0f      	ldr	r3, [pc, #60]	; (7f5c <usb_handle_standard_request+0x2c8>)
    7f1e:	1a5b      	subs	r3, r3, r1
    7f20:	08db      	lsrs	r3, r3, #3
    7f22:	f363 128f 	bfi	r2, r3, #6, #10
    7f26:	4601      	mov	r1, r0
    7f28:	480e      	ldr	r0, [pc, #56]	; (7f64 <usb_handle_standard_request+0x2d0>)
    7f2a:	f00a f830 	bl	11f8e <log_1>
			usb_dc_ep_clear_stall(ep);
    7f2e:	f89d 0008 	ldrb.w	r0, [sp, #8]
    7f32:	f001 fb0d 	bl	9550 <usb_dc_ep_clear_stall>
			if (usb_dev.status_callback) {
    7f36:	69eb      	ldr	r3, [r5, #28]
    7f38:	2b00      	cmp	r3, #0
    7f3a:	f43f aeb4 	beq.w	7ca6 <usb_handle_standard_request+0x12>
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
    7f3e:	a902      	add	r1, sp, #8
    7f40:	2009      	movs	r0, #9
				usb_dev.status_callback(USB_DC_SET_HALT, &ep);
    7f42:	4798      	blx	r3
    7f44:	e6af      	b.n	7ca6 <usb_handle_standard_request+0x12>
		if (type == DESC_CONFIGURATION) {
    7f46:	2a02      	cmp	r2, #2
		*data = p;
    7f48:	6023      	str	r3, [r4, #0]
		if (type == DESC_CONFIGURATION) {
    7f4a:	f47f af0d 	bne.w	7d68 <usb_handle_standard_request+0xd4>
			*len = (p[CONF_DESC_wTotalLength]) |
    7f4e:	885b      	ldrh	r3, [r3, #2]
    7f50:	6033      	str	r3, [r6, #0]
    7f52:	e6a8      	b.n	7ca6 <usb_handle_standard_request+0x12>
    7f54:	20002664 	.word	0x20002664
    7f58:	00016344 	.word	0x00016344
    7f5c:	00016434 	.word	0x00016434
    7f60:	00017f88 	.word	0x00017f88
    7f64:	00017f73 	.word	0x00017f73

00007f68 <usb_set_config>:

	return 0;
}

int usb_set_config(struct usb_cfg_data *config)
{
    7f68:	b538      	push	{r3, r4, r5, lr}
	if (!config)
    7f6a:	4605      	mov	r5, r0
    7f6c:	b300      	cbz	r0, 7fb0 <usb_set_config+0x48>
	usb_dev.descriptors = usb_descriptors;
    7f6e:	4c12      	ldr	r4, [pc, #72]	; (7fb8 <usb_set_config+0x50>)
    7f70:	6803      	ldr	r3, [r0, #0]
    7f72:	6223      	str	r3, [r4, #32]
	usb_dev.req_handlers[type] = handler;
    7f74:	4b11      	ldr	r3, [pc, #68]	; (7fbc <usb_set_config+0x54>)
    7f76:	6263      	str	r3, [r4, #36]	; 0x24
	usb_dev.data_store[type] = data_store;
    7f78:	f104 0344 	add.w	r3, r4, #68	; 0x44
    7f7c:	6363      	str	r3, [r4, #52]	; 0x34
	usb_register_request_handler(REQTYPE_TYPE_STANDARD,
				     usb_handle_standard_request,
				     usb_dev.std_req_data);

	/* register class request handlers for each interface*/
	if (config->interface.class_handler != NULL) {
    7f7e:	6903      	ldr	r3, [r0, #16]
    7f80:	b113      	cbz	r3, 7f88 <usb_set_config+0x20>
		usb_register_request_handler(REQTYPE_TYPE_CLASS,
    7f82:	69c2      	ldr	r2, [r0, #28]
	usb_dev.data_store[type] = data_store;
    7f84:	63a2      	str	r2, [r4, #56]	; 0x38
	usb_dev.req_handlers[type] = handler;
    7f86:	62a3      	str	r3, [r4, #40]	; 0x28
					     config->interface.class_handler,
					     config->interface.payload_data);
	}

	/* register vendor request handler */
	if (config->interface.vendor_handler || usb_os_desc_enabled()) {
    7f88:	696b      	ldr	r3, [r5, #20]
    7f8a:	b153      	cbz	r3, 7fa2 <usb_set_config+0x3a>
		usb_register_request_handler(REQTYPE_TYPE_VENDOR,
    7f8c:	6a2b      	ldr	r3, [r5, #32]
	usb_dev.data_store[type] = data_store;
    7f8e:	63e3      	str	r3, [r4, #60]	; 0x3c
					     usb_handle_vendor_request,
					     config->interface.vendor_data);

		if (config->interface.vendor_handler) {
    7f90:	696b      	ldr	r3, [r5, #20]
	usb_dev.req_handlers[type] = handler;
    7f92:	4a0b      	ldr	r2, [pc, #44]	; (7fc0 <usb_set_config+0x58>)
    7f94:	62e2      	str	r2, [r4, #44]	; 0x2c
		if (config->interface.vendor_handler) {
    7f96:	b94b      	cbnz	r3, 7fac <usb_set_config+0x44>
				config->interface.vendor_handler;
		}
	}

	/* register class request handlers for each interface*/
	if (config->interface.custom_handler != NULL) {
    7f98:	69a8      	ldr	r0, [r5, #24]
    7f9a:	b108      	cbz	r0, 7fa0 <usb_set_config+0x38>
	usb_dev.custom_req_handler = handler;
    7f9c:	6160      	str	r0, [r4, #20]
		usb_register_custom_req_handler(
		    config->interface.custom_handler);
	}

	return 0;
    7f9e:	2000      	movs	r0, #0
}
    7fa0:	bd38      	pop	{r3, r4, r5, pc}
	if (config->interface.vendor_handler || usb_os_desc_enabled()) {
    7fa2:	f000 fb11 	bl	85c8 <usb_os_desc_enabled>
    7fa6:	2800      	cmp	r0, #0
    7fa8:	d1f0      	bne.n	7f8c <usb_set_config+0x24>
    7faa:	e7f5      	b.n	7f98 <usb_set_config+0x30>
			usb_dev.vendor_req_handler =
    7fac:	61a3      	str	r3, [r4, #24]
    7fae:	e7f3      	b.n	7f98 <usb_set_config+0x30>
		return -EINVAL;
    7fb0:	f06f 0015 	mvn.w	r0, #21
    7fb4:	e7f4      	b.n	7fa0 <usb_set_config+0x38>
    7fb6:	bf00      	nop
    7fb8:	20002664 	.word	0x20002664
    7fbc:	00007c95 	.word	0x00007c95
    7fc0:	00007aed 	.word	0x00007aed

00007fc4 <usb_enable>:

	return 0;
}

int usb_enable(struct usb_cfg_data *config)
{
    7fc4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	int ret;
	u32_t i;
	struct usb_dc_ep_cfg_data ep0_cfg;

	if (true == usb_dev.enabled) {
    7fc8:	4d32      	ldr	r5, [pc, #200]	; (8094 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x94>)
    7fca:	f895 404c 	ldrb.w	r4, [r5, #76]	; 0x4c
{
    7fce:	4606      	mov	r6, r0
	if (true == usb_dev.enabled) {
    7fd0:	2c00      	cmp	r4, #0
    7fd2:	d14e      	bne.n	8072 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x72>
	usb_dev.status_callback = cb;
    7fd4:	4830      	ldr	r0, [pc, #192]	; (8098 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x98>)
    7fd6:	61e8      	str	r0, [r5, #28]
	ret = usb_vbus_set(true);
	if (ret < 0)
		return ret;

	usb_register_status_callback(forward_status_cb);
	ret = usb_dc_set_status_callback(forward_status_cb);
    7fd8:	f001 fc1c 	bl	9814 <usb_dc_set_status_callback>
	if (ret < 0) {
    7fdc:	2800      	cmp	r0, #0
    7fde:	db49      	blt.n	8074 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x74>
		return ret;
	}

	ret = usb_dc_attach();
    7fe0:	f001 f9b6 	bl	9350 <usb_dc_attach>
	if (ret < 0)
    7fe4:	2800      	cmp	r0, #0
    7fe6:	db45      	blt.n	8074 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x74>
		return ret;

	/* Configure control EP */
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
    7fe8:	2340      	movs	r3, #64	; 0x40
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;

	ep0_cfg.ep_addr = USB_CONTROL_OUT_EP0;
	ret = usb_dc_ep_configure(&ep0_cfg);
    7fea:	4668      	mov	r0, sp
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
    7fec:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;
    7ff0:	f88d 4004 	strb.w	r4, [sp, #4]
	ep0_cfg.ep_addr = USB_CONTROL_OUT_EP0;
    7ff4:	f88d 4000 	strb.w	r4, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
    7ff8:	f001 fa3c 	bl	9474 <usb_dc_ep_configure>
	if (ret < 0)
    7ffc:	2800      	cmp	r0, #0
    7ffe:	db39      	blt.n	8074 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x74>
		return ret;

	ep0_cfg.ep_addr = USB_CONTROL_IN_EP0;
    8000:	2780      	movs	r7, #128	; 0x80
	ret = usb_dc_ep_configure(&ep0_cfg);
    8002:	4668      	mov	r0, sp
	ep0_cfg.ep_addr = USB_CONTROL_IN_EP0;
    8004:	f88d 7000 	strb.w	r7, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
    8008:	f001 fa34 	bl	9474 <usb_dc_ep_configure>
	if (ret < 0)
    800c:	2800      	cmp	r0, #0
    800e:	db31      	blt.n	8074 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x74>
		return ret;

	/*register endpoint 0 handlers*/
	ret = usb_dc_ep_set_callback(USB_CONTROL_OUT_EP0,
    8010:	4922      	ldr	r1, [pc, #136]	; (809c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x9c>)
    8012:	4620      	mov	r0, r4
    8014:	f001 fbea 	bl	97ec <usb_dc_ep_set_callback>
	    usb_handle_control_transfer);
	if (ret < 0)
    8018:	2800      	cmp	r0, #0
    801a:	db2b      	blt.n	8074 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x74>
		return ret;
	ret = usb_dc_ep_set_callback(USB_CONTROL_IN_EP0,
    801c:	491f      	ldr	r1, [pc, #124]	; (809c <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x9c>)
    801e:	4638      	mov	r0, r7
    8020:	f001 fbe4 	bl	97ec <usb_dc_ep_set_callback>
	    usb_handle_control_transfer);
	if (ret < 0)
    8024:	2800      	cmp	r0, #0
    8026:	db25      	blt.n	8074 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x74>
		return ret;

	/*register endpoint handlers*/
	for (i = 0U; i < config->num_endpoints; i++) {
    8028:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
    802c:	42a3      	cmp	r3, r4
    802e:	d824      	bhi.n	807a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7a>
		if (ret < 0)
			return ret;
	}

	/* init transfer slots */
	for (i = 0U; i < MAX_NUM_TRANSFERS; i++) {
    8030:	2600      	movs	r6, #0
    8032:	4c18      	ldr	r4, [pc, #96]	; (8094 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x94>)
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    8034:	f8df 8068 	ldr.w	r8, [pc, #104]	; 80a0 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xa0>
    8038:	4637      	mov	r7, r6
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    803a:	2201      	movs	r2, #1
    803c:	e9c4 7821 	strd	r7, r8, [r4, #132]	; 0x84
    8040:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
    8044:	f104 006c 	add.w	r0, r4, #108	; 0x6c
    8048:	4611      	mov	r1, r2
    804a:	3601      	adds	r6, #1
    804c:	f00d fea8 	bl	15da0 <z_impl_k_sem_init>
    8050:	2e04      	cmp	r6, #4
    8052:	f104 0444 	add.w	r4, r4, #68	; 0x44
    8056:	d1f0      	bne.n	803a <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3a>
		k_work_init(&usb_dev.transfer[i].work, usb_transfer_work);
		k_sem_init(&usb_dev.transfer[i].sem, 1, 1);
	}

	/* enable control EP */
	ret = usb_dc_ep_enable(USB_CONTROL_OUT_EP0);
    8058:	2000      	movs	r0, #0
    805a:	f001 faab 	bl	95b4 <usb_dc_ep_enable>
	if (ret < 0)
    805e:	2800      	cmp	r0, #0
    8060:	db08      	blt.n	8074 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x74>
		return ret;

	ret = usb_dc_ep_enable(USB_CONTROL_IN_EP0);
    8062:	2080      	movs	r0, #128	; 0x80
    8064:	f001 faa6 	bl	95b4 <usb_dc_ep_enable>
	if (ret < 0)
    8068:	2800      	cmp	r0, #0
    806a:	db03      	blt.n	8074 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x74>
		return ret;

	usb_dev.enabled = true;
    806c:	2301      	movs	r3, #1
    806e:	f885 304c 	strb.w	r3, [r5, #76]	; 0x4c
		return 0;
    8072:	2000      	movs	r0, #0

	return 0;
}
    8074:	b002      	add	sp, #8
    8076:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = usb_dc_ep_set_callback(config->endpoint[i].ep_addr,
    807a:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    807c:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
    8080:	f853 1034 	ldr.w	r1, [r3, r4, lsl #3]
    8084:	7910      	ldrb	r0, [r2, #4]
    8086:	f001 fbb1 	bl	97ec <usb_dc_ep_set_callback>
		if (ret < 0)
    808a:	2800      	cmp	r0, #0
    808c:	dbf2      	blt.n	8074 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x74>
	for (i = 0U; i < config->num_endpoints; i++) {
    808e:	3401      	adds	r4, #1
    8090:	e7ca      	b.n	8028 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x28>
    8092:	bf00      	nop
    8094:	20002664 	.word	0x20002664
    8098:	00007aad 	.word	0x00007aad
    809c:	00007b99 	.word	0x00007b99
    80a0:	00012eb3 	.word	0x00012eb3

000080a4 <usb_transfer_ep_callback>:
	}
}

void usb_transfer_ep_callback(u8_t ep, enum usb_dc_ep_cb_status_code status)
{
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);
    80a4:	4a21      	ldr	r2, [pc, #132]	; (812c <usb_transfer_ep_callback+0x88>)
{
    80a6:	b573      	push	{r0, r1, r4, r5, r6, lr}
	for (i = 0; i < ARRAY_SIZE(usb_dev.transfer); i++) {
    80a8:	2300      	movs	r3, #0
{
    80aa:	4606      	mov	r6, r0
    80ac:	460d      	mov	r5, r1
    80ae:	4614      	mov	r4, r2
		if (usb_dev.transfer[i].ep == ep) {
    80b0:	f892 1050 	ldrb.w	r1, [r2, #80]	; 0x50
    80b4:	42b1      	cmp	r1, r6
    80b6:	d124      	bne.n	8102 <usb_transfer_ep_callback+0x5e>
			return &usb_dev.transfer[i];
    80b8:	2244      	movs	r2, #68	; 0x44
    80ba:	fb02 4303 	mla	r3, r2, r3, r4
    80be:	f103 0450 	add.w	r4, r3, #80	; 0x50

	if (status != USB_DC_EP_DATA_IN && status != USB_DC_EP_DATA_OUT) {
    80c2:	1e6b      	subs	r3, r5, #1
    80c4:	2b01      	cmp	r3, #1
    80c6:	d81a      	bhi.n	80fe <usb_transfer_ep_callback+0x5a>
		return;
	}

	if (!trans) {
    80c8:	bb14      	cbnz	r4, 8110 <usb_transfer_ep_callback+0x6c>
		if (status == USB_DC_EP_DATA_OUT) {
    80ca:	2d01      	cmp	r5, #1
    80cc:	d117      	bne.n	80fe <usb_transfer_ep_callback+0x5a>
			 * so drain it).
			 */
			do {
				u8_t data;

				usb_dc_ep_read_wait(ep, &data, 1, &bytes);
    80ce:	ab01      	add	r3, sp, #4
    80d0:	2201      	movs	r2, #1
    80d2:	f10d 0103 	add.w	r1, sp, #3
    80d6:	4630      	mov	r0, r6
    80d8:	f001 fb0a 	bl	96f0 <usb_dc_ep_read_wait>
			} while (bytes);
    80dc:	9b01      	ldr	r3, [sp, #4]
    80de:	2b00      	cmp	r3, #0
    80e0:	d1f5      	bne.n	80ce <usb_transfer_ep_callback+0x2a>

			LOG_ERR("RX data lost, no transfer");
    80e2:	2301      	movs	r3, #1
    80e4:	f04f 0100 	mov.w	r1, #0
    80e8:	f363 0107 	bfi	r1, r3, #0, #8
    80ec:	4a10      	ldr	r2, [pc, #64]	; (8130 <usb_transfer_ep_callback+0x8c>)
    80ee:	4b11      	ldr	r3, [pc, #68]	; (8134 <usb_transfer_ep_callback+0x90>)
    80f0:	4811      	ldr	r0, [pc, #68]	; (8138 <usb_transfer_ep_callback+0x94>)
    80f2:	1a9b      	subs	r3, r3, r2
    80f4:	08db      	lsrs	r3, r3, #3
    80f6:	f363 118f 	bfi	r1, r3, #6, #10
    80fa:	f009 ff3b 	bl	11f74 <log_0>
		/* Read (out) needs to be done from ep_callback */
		usb_transfer_work(&trans->work);
	} else {
		k_work_submit(&trans->work);
	}
}
    80fe:	b002      	add	sp, #8
    8100:	bd70      	pop	{r4, r5, r6, pc}
	for (i = 0; i < ARRAY_SIZE(usb_dev.transfer); i++) {
    8102:	3301      	adds	r3, #1
    8104:	2b04      	cmp	r3, #4
    8106:	f102 0244 	add.w	r2, r2, #68	; 0x44
    810a:	d1d1      	bne.n	80b0 <usb_transfer_ep_callback+0xc>
	return NULL;
    810c:	2400      	movs	r4, #0
    810e:	e7d8      	b.n	80c2 <usb_transfer_ep_callback+0x1e>
	if (!k_is_in_isr() || (status == USB_DC_EP_DATA_OUT)) {
    8110:	f007 fae2 	bl	f6d8 <k_is_in_isr>
    8114:	3434      	adds	r4, #52	; 0x34
    8116:	b108      	cbz	r0, 811c <usb_transfer_ep_callback+0x78>
    8118:	2d01      	cmp	r5, #1
    811a:	d103      	bne.n	8124 <usb_transfer_ep_callback+0x80>
		usb_transfer_work(&trans->work);
    811c:	4620      	mov	r0, r4
    811e:	f00a fec8 	bl	12eb2 <usb_transfer_work>
    8122:	e7ec      	b.n	80fe <usb_transfer_ep_callback+0x5a>
 * @return N/A
 * @req K-WORK-001
 */
static inline void k_work_submit(struct k_work *work)
{
	k_work_submit_to_queue(&k_sys_work_q, work);
    8124:	4620      	mov	r0, r4
    8126:	f7ff fd9d 	bl	7c64 <k_work_submit_to_queue.constprop.9>
    812a:	e7e8      	b.n	80fe <usb_transfer_ep_callback+0x5a>
    812c:	20002664 	.word	0x20002664
    8130:	00016344 	.word	0x00016344
    8134:	00016434 	.word	0x00016434
    8138:	00017fb6 	.word	0x00017fb6

0000813c <usb_transfer>:

int usb_transfer(u8_t ep, u8_t *data, size_t dlen, unsigned int flags,
		 usb_transfer_callback cb, void *cb_data)
{
    813c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8140:	4605      	mov	r5, r0
    8142:	468b      	mov	fp, r1
    8144:	4690      	mov	r8, r2
    8146:	4699      	mov	r9, r3
	__asm__ volatile(
    8148:	f04f 0320 	mov.w	r3, #32
    814c:	f3ef 8a11 	mrs	sl, BASEPRI
    8150:	f383 8811 	msr	BASEPRI, r3
    8154:	f3bf 8f6f 	isb	sy

	LOG_DBG("transfer start, ep=%02x, data=%p, dlen=%d", ep, data, dlen);

	key = irq_lock();

	for (i = 0; i < MAX_NUM_TRANSFERS; i++) {
    8158:	4a31      	ldr	r2, [pc, #196]	; (8220 <usb_transfer+0xe4>)
    815a:	2400      	movs	r4, #0
    815c:	2744      	movs	r7, #68	; 0x44
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    815e:	4610      	mov	r0, r2
    8160:	2100      	movs	r1, #0
    8162:	9201      	str	r2, [sp, #4]
    8164:	f007 fa7c 	bl	f660 <z_impl_k_sem_take>
    8168:	fb07 f604 	mul.w	r6, r7, r4
		if (!k_sem_take(&usb_dev.transfer[i].sem, K_NO_WAIT)) {
    816c:	9a01      	ldr	r2, [sp, #4]
    816e:	b990      	cbnz	r0, 8196 <usb_transfer+0x5a>
		LOG_ERR("no transfer slot available");
		ret = -ENOMEM;
		goto done;
	}

	if (trans->status == -EBUSY) {
    8170:	4f2c      	ldr	r7, [pc, #176]	; (8224 <usb_transfer+0xe8>)
    8172:	19bc      	adds	r4, r7, r6
    8174:	6d63      	ldr	r3, [r4, #84]	; 0x54
    8176:	f113 0f10 	cmn.w	r3, #16
    817a:	d122      	bne.n	81c2 <usb_transfer+0x86>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    817c:	4610      	mov	r0, r2
    817e:	9301      	str	r3, [sp, #4]
    8180:	f007 fa42 	bl	f608 <z_impl_k_sem_give>
		/* A transfer is already ongoing and not completed */
		k_sem_give(&trans->sem);
		ret = -EBUSY;
		goto done;
    8184:	9b01      	ldr	r3, [sp, #4]
	__asm__ volatile(
    8186:	f38a 8811 	msr	BASEPRI, sl
    818a:	f3bf 8f6f 	isb	sy
	}

done:
	irq_unlock(key);
	return ret;
}
    818e:	4618      	mov	r0, r3
    8190:	b003      	add	sp, #12
    8192:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < MAX_NUM_TRANSFERS; i++) {
    8196:	3401      	adds	r4, #1
    8198:	2c04      	cmp	r4, #4
    819a:	f102 0244 	add.w	r2, r2, #68	; 0x44
    819e:	d1de      	bne.n	815e <usb_transfer+0x22>
		LOG_ERR("no transfer slot available");
    81a0:	2301      	movs	r3, #1
    81a2:	f04f 0100 	mov.w	r1, #0
    81a6:	f363 0107 	bfi	r1, r3, #0, #8
    81aa:	4a1f      	ldr	r2, [pc, #124]	; (8228 <usb_transfer+0xec>)
    81ac:	4b1f      	ldr	r3, [pc, #124]	; (822c <usb_transfer+0xf0>)
    81ae:	4820      	ldr	r0, [pc, #128]	; (8230 <usb_transfer+0xf4>)
    81b0:	1a9b      	subs	r3, r3, r2
    81b2:	08db      	lsrs	r3, r3, #3
    81b4:	f363 118f 	bfi	r1, r3, #6, #10
    81b8:	f009 fedc 	bl	11f74 <log_0>
		ret = -ENOMEM;
    81bc:	f06f 030b 	mvn.w	r3, #11
		goto done;
    81c0:	e7e1      	b.n	8186 <usb_transfer+0x4a>
	trans->cb = cb;
    81c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    81c4:	6663      	str	r3, [r4, #100]	; 0x64
	trans->priv = cb_data;
    81c6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    81c8:	66a3      	str	r3, [r4, #104]	; 0x68
	trans->status = -EBUSY;
    81ca:	f06f 030f 	mvn.w	r3, #15
	trans->tsize = 0;
    81ce:	6620      	str	r0, [r4, #96]	; 0x60
	trans->ep = ep;
    81d0:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
	trans->bsize = dlen;
    81d4:	e9c4 b816 	strd	fp, r8, [r4, #88]	; 0x58
	trans->flags = flags;
    81d8:	f8c4 9090 	str.w	r9, [r4, #144]	; 0x90
	trans->status = -EBUSY;
    81dc:	6563      	str	r3, [r4, #84]	; 0x54
	if (usb_dc_ep_mps(ep) && (dlen % usb_dc_ep_mps(ep))) {
    81de:	4628      	mov	r0, r5
    81e0:	f001 fb1e 	bl	9820 <usb_dc_ep_mps>
    81e4:	b168      	cbz	r0, 8202 <usb_transfer+0xc6>
    81e6:	4628      	mov	r0, r5
    81e8:	f001 fb1a 	bl	9820 <usb_dc_ep_mps>
    81ec:	fbb8 f3f0 	udiv	r3, r8, r0
    81f0:	fb03 8010 	mls	r0, r3, r0, r8
    81f4:	b128      	cbz	r0, 8202 <usb_transfer+0xc6>
		trans->flags |= USB_TRANS_NO_ZLP;
    81f6:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    81fa:	f043 0304 	orr.w	r3, r3, #4
    81fe:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
	if (flags & USB_TRANS_WRITE) {
    8202:	f019 0f02 	tst.w	r9, #2
    8206:	d006      	beq.n	8216 <usb_transfer+0xda>
		k_work_submit(&trans->work);
    8208:	f106 0084 	add.w	r0, r6, #132	; 0x84
    820c:	4438      	add	r0, r7
    820e:	f7ff fd29 	bl	7c64 <k_work_submit_to_queue.constprop.9>
	int i, key, ret = 0;
    8212:	2300      	movs	r3, #0
    8214:	e7b7      	b.n	8186 <usb_transfer+0x4a>
		ret = usb_dc_ep_read_continue(ep);
    8216:	4628      	mov	r0, r5
    8218:	f001 faae 	bl	9778 <usb_dc_ep_read_continue>
    821c:	4603      	mov	r3, r0
    821e:	e7b2      	b.n	8186 <usb_transfer+0x4a>
    8220:	200026d0 	.word	0x200026d0
    8224:	20002664 	.word	0x20002664
    8228:	00016344 	.word	0x00016344
    822c:	00016434 	.word	0x00016434
    8230:	00017f9b 	.word	0x00017f9b

00008234 <usb_cancel_transfer>:

void usb_cancel_transfer(u8_t ep)
{
    8234:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    8236:	f04f 0320 	mov.w	r3, #32
    823a:	f3ef 8411 	mrs	r4, BASEPRI
    823e:	f383 8811 	msr	BASEPRI, r3
    8242:	f3bf 8f6f 	isb	sy
	for (i = 0; i < ARRAY_SIZE(usb_dev.transfer); i++) {
    8246:	4b0f      	ldr	r3, [pc, #60]	; (8284 <usb_cancel_transfer+0x50>)
    8248:	2200      	movs	r2, #0
    824a:	4619      	mov	r1, r3
		if (usb_dev.transfer[i].ep == ep) {
    824c:	f893 5050 	ldrb.w	r5, [r3, #80]	; 0x50
    8250:	4285      	cmp	r5, r0
    8252:	d10d      	bne.n	8270 <usb_cancel_transfer+0x3c>
	trans = usb_ep_get_transfer(ep);
	if (!trans) {
		goto done;
	}

	if (trans->status != -EBUSY) {
    8254:	2344      	movs	r3, #68	; 0x44
    8256:	4353      	muls	r3, r2
    8258:	18ca      	adds	r2, r1, r3
    825a:	6d50      	ldr	r0, [r2, #84]	; 0x54
    825c:	3010      	adds	r0, #16
    825e:	d10c      	bne.n	827a <usb_cancel_transfer+0x46>
		goto done;
	}

	trans->status = -ECANCELED;
    8260:	f06f 008b 	mvn.w	r0, #139	; 0x8b
	k_work_submit(&trans->work);
    8264:	3384      	adds	r3, #132	; 0x84
	trans->status = -ECANCELED;
    8266:	6550      	str	r0, [r2, #84]	; 0x54
    8268:	18c8      	adds	r0, r1, r3
    826a:	f7ff fcfb 	bl	7c64 <k_work_submit_to_queue.constprop.9>
    826e:	e004      	b.n	827a <usb_cancel_transfer+0x46>
	for (i = 0; i < ARRAY_SIZE(usb_dev.transfer); i++) {
    8270:	3201      	adds	r2, #1
    8272:	2a04      	cmp	r2, #4
    8274:	f103 0344 	add.w	r3, r3, #68	; 0x44
    8278:	d1e8      	bne.n	824c <usb_cancel_transfer+0x18>
	__asm__ volatile(
    827a:	f384 8811 	msr	BASEPRI, r4
    827e:	f3bf 8f6f 	isb	sy

done:
	irq_unlock(key);
}
    8282:	bd38      	pop	{r3, r4, r5, pc}
    8284:	20002664 	.word	0x20002664

00008288 <usb_transfer_sync>:
	pdata->tsize = size;
	k_sem_give(&pdata->sem);
}

int usb_transfer_sync(u8_t ep, u8_t *data, size_t dlen, unsigned int flags)
{
    8288:	b5f0      	push	{r4, r5, r6, r7, lr}
    828a:	b08b      	sub	sp, #44	; 0x2c
    828c:	4604      	mov	r4, r0
    828e:	460d      	mov	r5, r1
    8290:	4616      	mov	r6, r2
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    8292:	2100      	movs	r1, #0
    8294:	2201      	movs	r2, #1
    8296:	a804      	add	r0, sp, #16
    8298:	461f      	mov	r7, r3
    829a:	f00d fd81 	bl	15da0 <z_impl_k_sem_init>
	struct usb_transfer_sync_priv pdata;
	int ret;

	k_sem_init(&pdata.sem, 0, 1);

	ret = usb_transfer(ep, data, dlen, flags, usb_transfer_sync_cb, &pdata);
    829e:	ab03      	add	r3, sp, #12
    82a0:	9301      	str	r3, [sp, #4]
    82a2:	4b08      	ldr	r3, [pc, #32]	; (82c4 <usb_transfer_sync+0x3c>)
    82a4:	9300      	str	r3, [sp, #0]
    82a6:	4632      	mov	r2, r6
    82a8:	463b      	mov	r3, r7
    82aa:	4629      	mov	r1, r5
    82ac:	4620      	mov	r0, r4
    82ae:	f7ff ff45 	bl	813c <usb_transfer>
	if (ret) {
    82b2:	b928      	cbnz	r0, 82c0 <usb_transfer_sync+0x38>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    82b4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    82b8:	a804      	add	r0, sp, #16
    82ba:	f007 f9d1 	bl	f660 <z_impl_k_sem_take>
	}

	/* Semaphore will be released by the transfer completion callback */
	k_sem_take(&pdata.sem, K_FOREVER);

	return pdata.tsize;
    82be:	9803      	ldr	r0, [sp, #12]
}
    82c0:	b00b      	add	sp, #44	; 0x2c
    82c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    82c4:	00012ea9 	.word	0x00012ea9

000082c8 <usb_get_str_descriptor_idx>:
 * Look for the bString that has the address equal to the ptr and
 * return its index. Use it to determine the index of the bString and
 * assign it to the interfaces iInterface variable.
 */
int usb_get_str_descriptor_idx(void *ptr)
{
    82c8:	b510      	push	{r4, lr}
	struct usb_desc_header *head = __usb_descriptor_start;
    82ca:	4b07      	ldr	r3, [pc, #28]	; (82e8 <usb_get_str_descriptor_idx+0x20>)
	struct usb_string_descriptor *str = ptr;
	int str_descr_idx = 0;
    82cc:	2200      	movs	r2, #0

	while (head->bLength != 0U) {
    82ce:	7819      	ldrb	r1, [r3, #0]
    82d0:	b911      	cbnz	r1, 82d8 <usb_get_str_descriptor_idx+0x10>

		/* move to next descriptor */
		head = (struct usb_desc_header *)((u8_t *)head + head->bLength);
	}

	return 0;
    82d2:	460a      	mov	r2, r1
}
    82d4:	4610      	mov	r0, r2
    82d6:	bd10      	pop	{r4, pc}
		switch (head->bDescriptorType) {
    82d8:	785c      	ldrb	r4, [r3, #1]
    82da:	2c03      	cmp	r4, #3
    82dc:	d102      	bne.n	82e4 <usb_get_str_descriptor_idx+0x1c>
			if (head == (struct usb_desc_header *)str) {
    82de:	4283      	cmp	r3, r0
    82e0:	d0f8      	beq.n	82d4 <usb_get_str_descriptor_idx+0xc>
			str_descr_idx += 1;
    82e2:	3201      	adds	r2, #1
		head = (struct usb_desc_header *)((u8_t *)head + head->bLength);
    82e4:	440b      	add	r3, r1
    82e6:	e7f2      	b.n	82ce <usb_get_str_descriptor_idx+0x6>
    82e8:	20011e90 	.word	0x20011e90

000082ec <usb_fix_descriptor>:
 * Restrictions:
 * - just one device configuration (there is only one)
 * - string descriptor must be present
 */
static int usb_fix_descriptor(struct usb_desc_header *head)
{
    82ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t length = (__usb_data_end - __usb_data_start);
    82f0:	4a84      	ldr	r2, [pc, #528]	; (8504 <usb_fix_descriptor+0x218>)
    82f2:	4b85      	ldr	r3, [pc, #532]	; (8508 <usb_fix_descriptor+0x21c>)
    82f4:	4e85      	ldr	r6, [pc, #532]	; (850c <usb_fix_descriptor+0x220>)
    82f6:	1a9b      	subs	r3, r3, r2
    82f8:	4a85      	ldr	r2, [pc, #532]	; (8510 <usb_fix_descriptor+0x224>)
{
    82fa:	b087      	sub	sp, #28
	size_t length = (__usb_data_end - __usb_data_start);
    82fc:	109b      	asrs	r3, r3, #2
    82fe:	4353      	muls	r3, r2
    8300:	9300      	str	r3, [sp, #0]
		LOG_ERR("the new SN descriptor doesn't has the same "
    8302:	4b84      	ldr	r3, [pc, #528]	; (8514 <usb_fix_descriptor+0x228>)
	struct usb_cfg_descriptor *cfg_descr = NULL;
	struct usb_if_descriptor *if_descr = NULL;
	struct usb_cfg_data *cfg_data = NULL;
	struct usb_ep_descriptor *ep_descr = NULL;
	u8_t numof_ifaces = 0U;
	u8_t str_descr_idx = 0U;
    8304:	2500      	movs	r5, #0
		LOG_ERR("the new SN descriptor doesn't has the same "
    8306:	1af6      	subs	r6, r6, r3
{
    8308:	4604      	mov	r4, r0
		LOG_ERR("the new SN descriptor doesn't has the same "
    830a:	f3c6 06c9 	ubfx	r6, r6, #3, #10
	u32_t requested_ep = BIT(16) | BIT(0);
    830e:	f04f 1a01 	mov.w	sl, #65537	; 0x10001
	u8_t numof_ifaces = 0U;
    8312:	46a9      	mov	r9, r5
	struct usb_cfg_data *cfg_data = NULL;
    8314:	46a8      	mov	r8, r5
	struct usb_cfg_descriptor *cfg_descr = NULL;
    8316:	462f      	mov	r7, r5

	while (head->bLength != 0U) {
    8318:	7823      	ldrb	r3, [r4, #0]
    831a:	b94b      	cbnz	r3, 8330 <usb_fix_descriptor+0x44>

		/* Move to next descriptor */
		head = (struct usb_desc_header *)((u8_t *)head + head->bLength);
	}

	if ((head + 1) != __usb_descriptor_end) {
    831c:	4a7e      	ldr	r2, [pc, #504]	; (8518 <usb_fix_descriptor+0x22c>)
    831e:	1ca0      	adds	r0, r4, #2
    8320:	4290      	cmp	r0, r2
    8322:	f000 80ec 	beq.w	84fe <usb_fix_descriptor+0x212>
		LOG_DBG("try to fix next descriptor at %p", head + 1);
		return usb_fix_descriptor(head + 1);
    8326:	f7ff ffe1 	bl	82ec <usb_fix_descriptor>
	}

	return 0;
}
    832a:	b007      	add	sp, #28
    832c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch (head->bDescriptorType) {
    8330:	7863      	ldrb	r3, [r4, #1]
    8332:	2b05      	cmp	r3, #5
    8334:	d805      	bhi.n	8342 <usb_fix_descriptor+0x56>
    8336:	e8df f003 	tbb	[pc, r3]
    833a:	049a      	.short	0x049a
    833c:	98079a03 	.word	0x98079a03
    8340:	4627      	mov	r7, r4
		head = (struct usb_desc_header *)((u8_t *)head + head->bLength);
    8342:	7823      	ldrb	r3, [r4, #0]
    8344:	441c      	add	r4, r3
    8346:	e7e7      	b.n	8318 <usb_fix_descriptor+0x2c>
			if (if_descr->bAlternateSetting) {
    8348:	78e3      	ldrb	r3, [r4, #3]
    834a:	2b00      	cmp	r3, #0
    834c:	d1f9      	bne.n	8342 <usb_fix_descriptor+0x56>
			if (if_descr->bInterfaceNumber == 0U) {
    834e:	78a3      	ldrb	r3, [r4, #2]
    8350:	b9e3      	cbnz	r3, 838c <usb_fix_descriptor+0xa0>
    8352:	4a6c      	ldr	r2, [pc, #432]	; (8504 <usb_fix_descriptor+0x218>)
    8354:	4610      	mov	r0, r2
	for (size_t i = 0; i < length; i++) {
    8356:	9900      	ldr	r1, [sp, #0]
    8358:	4299      	cmp	r1, r3
    835a:	d10b      	bne.n	8374 <usb_fix_descriptor+0x88>
					LOG_ERR("There is no usb_cfg_data "
    835c:	2301      	movs	r3, #1
    835e:	f04f 0200 	mov.w	r2, #0
    8362:	f363 0207 	bfi	r2, r3, #0, #8
    8366:	f366 128f 	bfi	r2, r6, #6, #10
    836a:	4621      	mov	r1, r4
    836c:	486b      	ldr	r0, [pc, #428]	; (851c <usb_fix_descriptor+0x230>)
    836e:	f009 fe0e 	bl	11f8e <log_1>
    8372:	e02d      	b.n	83d0 <usb_fix_descriptor+0xe4>
		if (__usb_data_start[i].interface_descriptor == iface) {
    8374:	322c      	adds	r2, #44	; 0x2c
    8376:	f852 1c28 	ldr.w	r1, [r2, #-40]
    837a:	428c      	cmp	r4, r1
    837c:	d10b      	bne.n	8396 <usb_fix_descriptor+0xaa>
			return &__usb_data_start[i];
    837e:	f04f 082c 	mov.w	r8, #44	; 0x2c
    8382:	fb08 0803 	mla	r8, r8, r3, r0
				if (cfg_data->interface_config) {
    8386:	f8d8 3008 	ldr.w	r3, [r8, #8]
    838a:	b933      	cbnz	r3, 839a <usb_fix_descriptor+0xae>
			numof_ifaces++;
    838c:	f109 0901 	add.w	r9, r9, #1
    8390:	fa5f f989 	uxtb.w	r9, r9
			break;
    8394:	e7d5      	b.n	8342 <usb_fix_descriptor+0x56>
	for (size_t i = 0; i < length; i++) {
    8396:	3301      	adds	r3, #1
    8398:	e7dd      	b.n	8356 <usb_fix_descriptor+0x6a>
					cfg_data->interface_config(head,
    839a:	4649      	mov	r1, r9
    839c:	4620      	mov	r0, r4
    839e:	4798      	blx	r3
    83a0:	e7f4      	b.n	838c <usb_fix_descriptor+0xa0>
		if (ep_descr->bEndpointAddress != ep_data[i].ep_addr) {
    83a2:	f8d8 1028 	ldr.w	r1, [r8, #40]	; 0x28
    83a6:	78a0      	ldrb	r0, [r4, #2]
    83a8:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
    83ac:	790b      	ldrb	r3, [r1, #4]
    83ae:	4298      	cmp	r0, r3
    83b0:	d011      	beq.n	83d6 <usb_fix_descriptor+0xea>
	for (int i = 0; i < cfg_data->num_endpoints; i++) {
    83b2:	3201      	adds	r2, #1
    83b4:	f898 3024 	ldrb.w	r3, [r8, #36]	; 0x24
    83b8:	429a      	cmp	r2, r3
    83ba:	dbf2      	blt.n	83a2 <usb_fix_descriptor+0xb6>
				LOG_ERR("Failed to validate endpoints");
    83bc:	f04f 0100 	mov.w	r1, #0
    83c0:	2301      	movs	r3, #1
    83c2:	f363 0107 	bfi	r1, r3, #0, #8
    83c6:	4856      	ldr	r0, [pc, #344]	; (8520 <usb_fix_descriptor+0x234>)
    83c8:	f366 118f 	bfi	r1, r6, #6, #10
					LOG_ERR("Incomplete device descriptor");
    83cc:	f009 fdd2 	bl	11f74 <log_0>
					return -1;
    83d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    83d4:	e7a9      	b.n	832a <usb_fix_descriptor+0x3e>
		if (ep_descr->bEndpointAddress != ep_data[i].ep_addr) {
    83d6:	2301      	movs	r3, #1
			ep_cfg.ep_type = ep_descr->bmAttributes;
    83d8:	f894 c003 	ldrb.w	ip, [r4, #3]
    83dc:	f88d c014 	strb.w	ip, [sp, #20]
			ep_cfg.ep_mps = ep_descr->wMaxPacketSize;
    83e0:	f894 e005 	ldrb.w	lr, [r4, #5]
    83e4:	f894 c004 	ldrb.w	ip, [r4, #4]
    83e8:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
    83ec:	f8ad c012 	strh.w	ip, [sp, #18]
			ep_cfg.ep_addr = ep_descr->bEndpointAddress;
    83f0:	f894 c002 	ldrb.w	ip, [r4, #2]
    83f4:	f88d c010 	strb.w	ip, [sp, #16]
			if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
    83f8:	f01c 0f80 	tst.w	ip, #128	; 0x80
    83fc:	b2d8      	uxtb	r0, r3
    83fe:	d029      	beq.n	8454 <usb_fix_descriptor+0x168>
				if ((*requested_ep & (1 << (idx + 16)))) {
    8400:	f103 0c10 	add.w	ip, r3, #16
    8404:	f04f 0e01 	mov.w	lr, #1
    8408:	fa0e fc0c 	lsl.w	ip, lr, ip
    840c:	ea1c 0f0a 	tst.w	ip, sl
    8410:	d127      	bne.n	8462 <usb_fix_descriptor+0x176>
				ep_cfg.ep_addr = (USB_EP_DIR_IN | idx);
    8412:	f060 007f 	orn	r0, r0, #127	; 0x7f
				ep_cfg.ep_addr = idx;
    8416:	f88d 0010 	strb.w	r0, [sp, #16]
			if (!usb_dc_ep_check_cap(&ep_cfg)) {
    841a:	a804      	add	r0, sp, #16
    841c:	e9cd 1302 	strd	r1, r3, [sp, #8]
    8420:	9201      	str	r2, [sp, #4]
    8422:	f000 ffe5 	bl	93f0 <usb_dc_ep_check_cap>
    8426:	e9dd 2101 	ldrd	r2, r1, [sp, #4]
    842a:	9b03      	ldr	r3, [sp, #12]
    842c:	b9c8      	cbnz	r0, 8462 <usb_fix_descriptor+0x176>
				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
    842e:	f89d 2010 	ldrb.w	r2, [sp, #16]
    8432:	70a2      	strb	r2, [r4, #2]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
    8434:	f012 0f80 	tst.w	r2, #128	; 0x80
				ep_data[i].ep_addr = ep_cfg.ep_addr;
    8438:	710a      	strb	r2, [r1, #4]
					*requested_ep |= (1 << (idx + 16));
    843a:	bf18      	it	ne
    843c:	3310      	addne	r3, #16
    843e:	f04f 0201 	mov.w	r2, #1
    8442:	bf15      	itete	ne
    8444:	409a      	lslne	r2, r3
					*requested_ep |= (1 << idx);
    8446:	fa02 f303 	lsleq.w	r3, r2, r3
					*requested_ep |= (1 << (idx + 16));
    844a:	ea4a 0a02 	orrne.w	sl, sl, r2
					*requested_ep |= (1 << idx);
    844e:	ea4a 0a03 	orreq.w	sl, sl, r3
				return 0;
    8452:	e776      	b.n	8342 <usb_fix_descriptor+0x56>
				if ((*requested_ep & (1 << (idx)))) {
    8454:	f04f 0c01 	mov.w	ip, #1
    8458:	fa0c fc03 	lsl.w	ip, ip, r3
    845c:	ea1c 0f0a 	tst.w	ip, sl
    8460:	d0d9      	beq.n	8416 <usb_fix_descriptor+0x12a>
    8462:	3301      	adds	r3, #1
		for (u8_t idx = 1; idx < 16; idx++) {
    8464:	2b10      	cmp	r3, #16
    8466:	d1b7      	bne.n	83d8 <usb_fix_descriptor+0xec>
    8468:	e7a3      	b.n	83b2 <usb_fix_descriptor+0xc6>
	for (int i = 0; i < cfg_data->num_endpoints; i++) {
    846a:	2200      	movs	r2, #0
    846c:	e7a2      	b.n	83b4 <usb_fix_descriptor+0xc8>
			if (str_descr_idx == USB_DESC_SERIAL_NUMBER_IDX) {
    846e:	2d03      	cmp	r5, #3
    8470:	d12a      	bne.n	84c8 <usb_fix_descriptor+0x1dc>
	u8_t *runtime_sn =  usb_update_sn_string_descriptor();
    8472:	f00a fd9e 	bl	12fb2 <usb_update_sn_string_descriptor>
	if (!runtime_sn) {
    8476:	9002      	str	r0, [sp, #8]
    8478:	b1a8      	cbz	r0, 84a6 <usb_fix_descriptor+0x1ba>
	runtime_sn_len = strlen(runtime_sn);
    847a:	f7f9 fed5 	bl	2228 <strlen>
    847e:	9001      	str	r0, [sp, #4]
	default_sn_len = strlen(CONFIG_USB_DEVICE_SN);
    8480:	4828      	ldr	r0, [pc, #160]	; (8524 <usb_fix_descriptor+0x238>)
    8482:	f7f9 fed1 	bl	2228 <strlen>
	if (runtime_sn_len != default_sn_len) {
    8486:	9a01      	ldr	r2, [sp, #4]
    8488:	9902      	ldr	r1, [sp, #8]
    848a:	4282      	cmp	r2, r0
    848c:	d018      	beq.n	84c0 <usb_fix_descriptor+0x1d4>
		LOG_ERR("the new SN descriptor doesn't has the same "
    848e:	f02b 033f 	bic.w	r3, fp, #63	; 0x3f
    8492:	f043 0301 	orr.w	r3, r3, #1
    8496:	f363 0b07 	bfi	fp, r3, #0, #8
    849a:	f366 1b8f 	bfi	fp, r6, #6, #10
    849e:	4659      	mov	r1, fp
    84a0:	4821      	ldr	r0, [pc, #132]	; (8528 <usb_fix_descriptor+0x23c>)
    84a2:	f009 fd67 	bl	11f74 <log_0>
	int idx_max = USB_BSTRING_UTF16LE_IDX_MAX(str_descr->bLength);
    84a6:	7823      	ldrb	r3, [r4, #0]
	for (int i = idx_max; i >= 0; i -= 2) {
    84a8:	f06f 0102 	mvn.w	r1, #2
    84ac:	18e2      	adds	r2, r4, r3
    84ae:	1b09      	subs	r1, r1, r4
    84b0:	eb04 0353 	add.w	r3, r4, r3, lsr #1
		buf[i] = 0U;
    84b4:	2000      	movs	r0, #0
	for (int i = idx_max; i >= 0; i -= 2) {
    84b6:	42d1      	cmn	r1, r2
    84b8:	d512      	bpl.n	84e0 <usb_fix_descriptor+0x1f4>
			str_descr_idx += 1U;
    84ba:	3501      	adds	r5, #1
    84bc:	b2ed      	uxtb	r5, r5
			break;
    84be:	e740      	b.n	8342 <usb_fix_descriptor+0x56>
    84c0:	1ca0      	adds	r0, r4, #2
    84c2:	f7f9 fe57 	bl	2174 <memcpy>
    84c6:	e7ee      	b.n	84a6 <usb_fix_descriptor+0x1ba>
			if (str_descr_idx) {
    84c8:	2d00      	cmp	r5, #0
    84ca:	d1ec      	bne.n	84a6 <usb_fix_descriptor+0x1ba>
				if (!cfg_descr) {
    84cc:	b97f      	cbnz	r7, 84ee <usb_fix_descriptor+0x202>
					LOG_ERR("Incomplete device descriptor");
    84ce:	f04f 0100 	mov.w	r1, #0
    84d2:	2301      	movs	r3, #1
    84d4:	f363 0107 	bfi	r1, r3, #0, #8
    84d8:	f366 118f 	bfi	r1, r6, #6, #10
    84dc:	4813      	ldr	r0, [pc, #76]	; (852c <usb_fix_descriptor+0x240>)
    84de:	e775      	b.n	83cc <usb_fix_descriptor+0xe0>
		buf[i] = 0U;
    84e0:	f802 0c01 	strb.w	r0, [r2, #-1]
		buf[i - 1] = buf[ascii_idx_max--];
    84e4:	f813 c901 	ldrb.w	ip, [r3], #-1
    84e8:	f802 cd02 	strb.w	ip, [r2, #-2]!
    84ec:	e7e3      	b.n	84b6 <usb_fix_descriptor+0x1ca>
				sys_put_le16((u8_t *)head - (u8_t *)cfg_descr,
    84ee:	1be3      	subs	r3, r4, r7
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(u16_t val, u8_t dst[2])
{
	dst[0] = val;
    84f0:	70bb      	strb	r3, [r7, #2]
	dst[1] = val >> 8;
    84f2:	f3c3 2307 	ubfx	r3, r3, #8, #8
    84f6:	70fb      	strb	r3, [r7, #3]
				cfg_descr->bNumInterfaces = numof_ifaces;
    84f8:	f887 9004 	strb.w	r9, [r7, #4]
    84fc:	e7dd      	b.n	84ba <usb_fix_descriptor+0x1ce>
	return 0;
    84fe:	4618      	mov	r0, r3
    8500:	e713      	b.n	832a <usb_fix_descriptor+0x3e>
    8502:	bf00      	nop
    8504:	20011f3c 	.word	0x20011f3c
    8508:	20011f68 	.word	0x20011f68
    850c:	0001642c 	.word	0x0001642c
    8510:	ba2e8ba3 	.word	0xba2e8ba3
    8514:	00016344 	.word	0x00016344
    8518:	20011f3a 	.word	0x20011f3a
    851c:	00018068 	.word	0x00018068
    8520:	00017fdf 	.word	0x00017fdf
    8524:	00017ffc 	.word	0x00017ffc
    8528:	00018001 	.word	0x00018001
    852c:	0001804b 	.word	0x0001804b

00008530 <usb_get_device_descriptor>:


u8_t *usb_get_device_descriptor(void)
{
    8530:	b508      	push	{r3, lr}
	LOG_DBG("__usb_descriptor_start %p", __usb_descriptor_start);
	LOG_DBG("__usb_descriptor_end %p", __usb_descriptor_end);

	if (usb_fix_descriptor(__usb_descriptor_start)) {
    8532:	480b      	ldr	r0, [pc, #44]	; (8560 <usb_get_device_descriptor+0x30>)
    8534:	f7ff feda 	bl	82ec <usb_fix_descriptor>
    8538:	b178      	cbz	r0, 855a <usb_get_device_descriptor+0x2a>
		LOG_ERR("Failed to fixup USB descriptor");
    853a:	2301      	movs	r3, #1
    853c:	f04f 0100 	mov.w	r1, #0
    8540:	f363 0107 	bfi	r1, r3, #0, #8
    8544:	4a07      	ldr	r2, [pc, #28]	; (8564 <usb_get_device_descriptor+0x34>)
    8546:	4b08      	ldr	r3, [pc, #32]	; (8568 <usb_get_device_descriptor+0x38>)
    8548:	4808      	ldr	r0, [pc, #32]	; (856c <usb_get_device_descriptor+0x3c>)
    854a:	1a9b      	subs	r3, r3, r2
    854c:	08db      	lsrs	r3, r3, #3
    854e:	f363 118f 	bfi	r1, r3, #6, #10
    8552:	f009 fd0f 	bl	11f74 <log_0>
		return NULL;
    8556:	2000      	movs	r0, #0
	}

	return (u8_t *) __usb_descriptor_start;
}
    8558:	bd08      	pop	{r3, pc}
	return (u8_t *) __usb_descriptor_start;
    855a:	4801      	ldr	r0, [pc, #4]	; (8560 <usb_get_device_descriptor+0x30>)
    855c:	e7fc      	b.n	8558 <usb_get_device_descriptor+0x28>
    855e:	bf00      	nop
    8560:	20011e90 	.word	0x20011e90
    8564:	00016344 	.word	0x00016344
    8568:	0001642c 	.word	0x0001642c
    856c:	00018088 	.word	0x00018088

00008570 <usb_handle_os_desc>:
int usb_handle_os_desc(struct usb_setup_packet *setup,
		       s32_t *len, u8_t **data)
{
	LOG_DBG("wValue 0x%x", setup->wValue);

	if (!os_desc) {
    8570:	4b09      	ldr	r3, [pc, #36]	; (8598 <usb_handle_os_desc+0x28>)
{
    8572:	b510      	push	{r4, lr}
	if (!os_desc) {
    8574:	681c      	ldr	r4, [r3, #0]
    8576:	b164      	cbz	r4, 8592 <usb_handle_os_desc+0x22>
		return -ENOTSUP;
	}

	if (GET_DESC_TYPE(setup->wValue) == DESC_STRING &&
    8578:	8843      	ldrh	r3, [r0, #2]
    857a:	0a18      	lsrs	r0, r3, #8
    857c:	2803      	cmp	r0, #3
    857e:	d108      	bne.n	8592 <usb_handle_os_desc+0x22>
    8580:	b2db      	uxtb	r3, r3
    8582:	2bee      	cmp	r3, #238	; 0xee
    8584:	d105      	bne.n	8592 <usb_handle_os_desc+0x22>
	    GET_DESC_INDEX(setup->wValue) == USB_OSDESC_STRING_DESC_INDEX) {
		LOG_DBG("MS OS Descriptor string read");
		*data = os_desc->string;
    8586:	6823      	ldr	r3, [r4, #0]
    8588:	6013      	str	r3, [r2, #0]
		*len = os_desc->string_len;
    858a:	6863      	ldr	r3, [r4, #4]
    858c:	600b      	str	r3, [r1, #0]

		return 0;
    858e:	2000      	movs	r0, #0
	}

	return -ENOTSUP;
}
    8590:	bd10      	pop	{r4, pc}
		return -ENOTSUP;
    8592:	f06f 0085 	mvn.w	r0, #133	; 0x85
    8596:	e7fb      	b.n	8590 <usb_handle_os_desc+0x20>
    8598:	200027c4 	.word	0x200027c4

0000859c <usb_handle_os_desc_feature>:
int usb_handle_os_desc_feature(struct usb_setup_packet *setup,
			       s32_t *len, u8_t **data)
{
	LOG_DBG("bRequest 0x%x", setup->bRequest);

	if (!os_desc) {
    859c:	4b09      	ldr	r3, [pc, #36]	; (85c4 <usb_handle_os_desc_feature+0x28>)
    859e:	681b      	ldr	r3, [r3, #0]
{
    85a0:	b530      	push	{r4, r5, lr}
	if (!os_desc) {
    85a2:	b163      	cbz	r3, 85be <usb_handle_os_desc_feature+0x22>
		return -ENOTSUP;
	}

	if (setup->bRequest == os_desc->vendor_code) {
    85a4:	7845      	ldrb	r5, [r0, #1]
    85a6:	7a1c      	ldrb	r4, [r3, #8]
    85a8:	42a5      	cmp	r5, r4
    85aa:	d108      	bne.n	85be <usb_handle_os_desc_feature+0x22>
		switch (setup->wIndex) {
    85ac:	8880      	ldrh	r0, [r0, #4]
    85ae:	2804      	cmp	r0, #4
    85b0:	d105      	bne.n	85be <usb_handle_os_desc_feature+0x22>
		case USB_OSDESC_EXTENDED_COMPAT_ID:
			LOG_DBG("Handle Compat ID");
			*data = os_desc->compat_id;
    85b2:	68d8      	ldr	r0, [r3, #12]
			*len = os_desc->compat_id_len;
    85b4:	691b      	ldr	r3, [r3, #16]
			*data = os_desc->compat_id;
    85b6:	6010      	str	r0, [r2, #0]
			*len = os_desc->compat_id_len;
    85b8:	600b      	str	r3, [r1, #0]

			return 0;
    85ba:	2000      	movs	r0, #0
			break;
		}
	}

	return -ENOTSUP;
}
    85bc:	bd30      	pop	{r4, r5, pc}
		return -ENOTSUP;
    85be:	f06f 0085 	mvn.w	r0, #133	; 0x85
    85c2:	e7fb      	b.n	85bc <usb_handle_os_desc_feature+0x20>
    85c4:	200027c4 	.word	0x200027c4

000085c8 <usb_os_desc_enabled>:
	os_desc = desc;
}

bool usb_os_desc_enabled(void)
{
	return !!os_desc;
    85c8:	4b02      	ldr	r3, [pc, #8]	; (85d4 <usb_os_desc_enabled+0xc>)
    85ca:	6818      	ldr	r0, [r3, #0]
}
    85cc:	3000      	adds	r0, #0
    85ce:	bf18      	it	ne
    85d0:	2001      	movne	r0, #1
    85d2:	4770      	bx	lr
    85d4:	200027c4 	.word	0x200027c4

000085d8 <sys_rand32_get>:
#include <entropy.h>

static atomic_t entropy_driver;

u32_t sys_rand32_get(void)
{
    85d8:	b513      	push	{r0, r1, r4, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    85da:	4c11      	ldr	r4, [pc, #68]	; (8620 <sys_rand32_get+0x48>)
    85dc:	f3bf 8f5b 	dmb	ish
    85e0:	6820      	ldr	r0, [r4, #0]
    85e2:	f3bf 8f5b 	dmb	ish
	struct device *dev = (struct device *)atomic_get(&entropy_driver);
	u32_t random_num;
	int ret;

	if (unlikely(!dev)) {
    85e6:	b960      	cbnz	r0, 8602 <sys_rand32_get+0x2a>
    85e8:	480e      	ldr	r0, [pc, #56]	; (8624 <sys_rand32_get+0x4c>)
    85ea:	f006 f9fb 	bl	e9e4 <z_impl_device_get_binding>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    85ee:	f3bf 8f5b 	dmb	ish
    85f2:	e854 3f00 	ldrex	r3, [r4]
    85f6:	e844 0200 	strex	r2, r0, [r4]
    85fa:	2a00      	cmp	r2, #0
    85fc:	d1f9      	bne.n	85f2 <sys_rand32_get+0x1a>
    85fe:	f3bf 8f5b 	dmb	ish
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
    8602:	6843      	ldr	r3, [r0, #4]
    8604:	2204      	movs	r2, #4
    8606:	681b      	ldr	r3, [r3, #0]
    8608:	eb0d 0102 	add.w	r1, sp, r2
    860c:	4798      	blx	r3
		atomic_set(&entropy_driver, (atomic_t)(uintptr_t)dev);
	}

	ret = entropy_get_entropy(dev, (u8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
    860e:	2800      	cmp	r0, #0
    8610:	da02      	bge.n	8618 <sys_rand32_get+0x40>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
    8612:	f001 f9df 	bl	99d4 <z_timer_cycle_get_32>
    8616:	9001      	str	r0, [sp, #4]
	}

	return random_num;
}
    8618:	9801      	ldr	r0, [sp, #4]
    861a:	b002      	add	sp, #8
    861c:	bd10      	pop	{r4, pc}
    861e:	bf00      	nop
    8620:	200027c8 	.word	0x200027c8
    8624:	000180b3 	.word	0x000180b3

00008628 <console_out>:

static int console_out(int c)
{
#ifdef CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS

	int handled_by_debug_server = HANDLE_DEBUG_HOOK_OUT(c);
    8628:	4b0a      	ldr	r3, [pc, #40]	; (8654 <console_out+0x2c>)
{
    862a:	b570      	push	{r4, r5, r6, lr}
	int handled_by_debug_server = HANDLE_DEBUG_HOOK_OUT(c);
    862c:	b2c6      	uxtb	r6, r0
{
    862e:	4604      	mov	r4, r0
	int handled_by_debug_server = HANDLE_DEBUG_HOOK_OUT(c);
    8630:	681b      	ldr	r3, [r3, #0]
    8632:	4630      	mov	r0, r6
    8634:	4798      	blx	r3

	if (handled_by_debug_server) {
    8636:	2801      	cmp	r0, #1
    8638:	d00a      	beq.n	8650 <console_out+0x28>
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    863a:	2c0a      	cmp	r4, #10
    863c:	4d06      	ldr	r5, [pc, #24]	; (8658 <console_out+0x30>)
    863e:	d103      	bne.n	8648 <console_out+0x20>

K_SYSCALL_DECLARE1(K_SYSCALL_UART_ERR_CHECK, uart_err_check, int, struct device *, dev)

K_SYSCALL_DECLARE2(K_SYSCALL_UART_POLL_IN, uart_poll_in, int, struct device *, dev, unsigned char *, p_char)

K_SYSCALL_DECLARE2_VOID(K_SYSCALL_UART_POLL_OUT, uart_poll_out, struct device *, dev, unsigned char, out_char)
    8640:	210d      	movs	r1, #13
    8642:	6828      	ldr	r0, [r5, #0]
    8644:	f00a fcb7 	bl	12fb6 <z_impl_uart_poll_out>
    8648:	4631      	mov	r1, r6
    864a:	6828      	ldr	r0, [r5, #0]
    864c:	f00a fcb3 	bl	12fb6 <z_impl_uart_poll_out>
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);

	return c;
}
    8650:	4620      	mov	r0, r4
    8652:	bd70      	pop	{r4, r5, r6, pc}
    8654:	20010ce8 	.word	0x20010ce8
    8658:	200027cc 	.word	0x200027cc

0000865c <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
    865c:	b510      	push	{r4, lr}
	__stdout_hook_install(console_out);
    865e:	4c04      	ldr	r4, [pc, #16]	; (8670 <uart_console_hook_install+0x14>)
    8660:	4620      	mov	r0, r4
    8662:	f001 fde1 	bl	a228 <__stdout_hook_install>
	__printk_hook_install(console_out);
    8666:	4620      	mov	r0, r4
}
    8668:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__printk_hook_install(console_out);
    866c:	f7fc bf08 	b.w	5480 <__printk_hook_install>
    8670:	00008629 	.word	0x00008629

00008674 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
    8674:	b508      	push	{r3, lr}
    8676:	4804      	ldr	r0, [pc, #16]	; (8688 <uart_console_init+0x14>)
    8678:	f006 f9b4 	bl	e9e4 <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    867c:	4b03      	ldr	r3, [pc, #12]	; (868c <uart_console_init+0x18>)
    867e:	6018      	str	r0, [r3, #0]
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
    8680:	f7ff ffec 	bl	865c <uart_console_hook_install>

	return 0;
}
    8684:	2000      	movs	r0, #0
    8686:	bd08      	pop	{r3, pc}
    8688:	00017ea2 	.word	0x00017ea2
    868c:	200027cc 	.word	0x200027cc

00008690 <m16src_stop>:
		return -EINPROGRESS;
	}
}

static int m16src_stop(struct device *dev, clock_control_subsys_t sub_system)
{
    8690:	b510      	push	{r4, lr}
	__asm__ volatile(
    8692:	f04f 0320 	mov.w	r3, #32
    8696:	f3ef 8211 	mrs	r2, BASEPRI
    869a:	f383 8811 	msr	BASEPRI, r3
    869e:	f3bf 8f6f 	isb	sy
	/* Test for started resource, if so, decrement reference and acquire
	 * resource guard.
	 */
	imask = irq_lock();

	if (!m16src_ref) {
    86a2:	4c15      	ldr	r4, [pc, #84]	; (86f8 <m16src_stop+0x68>)
    86a4:	7823      	ldrb	r3, [r4, #0]
    86a6:	b933      	cbnz	r3, 86b6 <m16src_stop+0x26>
	__asm__ volatile(
    86a8:	f382 8811 	msr	BASEPRI, r2
    86ac:	f3bf 8f6f 	isb	sy
		irq_unlock(imask);
		return -EALREADY;
    86b0:	f06f 0077 	mvn.w	r0, #119	; 0x77

	/* release resource guard */
	m16src_grd = 0U;

	return 0;
}
    86b4:	bd10      	pop	{r4, pc}
	if (--m16src_ref) {
    86b6:	3b01      	subs	r3, #1
    86b8:	b2db      	uxtb	r3, r3
    86ba:	7023      	strb	r3, [r4, #0]
    86bc:	b133      	cbz	r3, 86cc <m16src_stop+0x3c>
    86be:	f382 8811 	msr	BASEPRI, r2
    86c2:	f3bf 8f6f 	isb	sy
		return -EBUSY;
    86c6:	f06f 000f 	mvn.w	r0, #15
    86ca:	e7f3      	b.n	86b4 <m16src_stop+0x24>
	if (m16src_grd) {
    86cc:	4b0b      	ldr	r3, [pc, #44]	; (86fc <m16src_stop+0x6c>)
    86ce:	7818      	ldrb	r0, [r3, #0]
    86d0:	2101      	movs	r1, #1
    86d2:	b138      	cbz	r0, 86e4 <m16src_stop+0x54>
		m16src_ref++;
    86d4:	7021      	strb	r1, [r4, #0]
    86d6:	f382 8811 	msr	BASEPRI, r2
    86da:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
    86de:	f06f 000a 	mvn.w	r0, #10
    86e2:	e7e7      	b.n	86b4 <m16src_stop+0x24>
	m16src_grd = 1U;
    86e4:	7019      	strb	r1, [r3, #0]
    86e6:	f382 8811 	msr	BASEPRI, r2
    86ea:	f3bf 8f6f 	isb	sy
    return ((uint32_t )NRF_CLOCK + task);
}

__STATIC_INLINE void nrf_clock_task_trigger(nrf_clock_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = NRF_CLOCK_TASK_TRIGGER;
    86ee:	4a04      	ldr	r2, [pc, #16]	; (8700 <m16src_stop+0x70>)
    86f0:	6011      	str	r1, [r2, #0]
	m16src_grd = 0U;
    86f2:	7018      	strb	r0, [r3, #0]
	return 0;
    86f4:	e7de      	b.n	86b4 <m16src_stop+0x24>
    86f6:	bf00      	nop
    86f8:	20005afe 	.word	0x20005afe
    86fc:	20005afd 	.word	0x20005afd
    8700:	40000004 	.word	0x40000004

00008704 <m16src_start>:
{
    8704:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    8706:	f04f 0220 	mov.w	r2, #32
    870a:	f3ef 8311 	mrs	r3, BASEPRI
    870e:	f382 8811 	msr	BASEPRI, r2
    8712:	f3bf 8f6f 	isb	sy
	if (m16src_ref++) {
    8716:	4a29      	ldr	r2, [pc, #164]	; (87bc <m16src_start+0xb8>)
    8718:	7810      	ldrb	r0, [r2, #0]
    871a:	1c44      	adds	r4, r0, #1
    871c:	7014      	strb	r4, [r2, #0]
    871e:	b180      	cbz	r0, 8742 <m16src_start+0x3e>
	__asm__ volatile(
    8720:	f383 8811 	msr	BASEPRI, r3
    8724:	f3bf 8f6f 	isb	sy
	if ((NRF_CLOCK->HFCLKSTAT & stat) == stat) {
    8728:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    872c:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
    8730:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
		return -EINPROGRESS;
    8734:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
    8738:	bf0c      	ite	eq
    873a:	2000      	moveq	r0, #0
    873c:	f06f 0076 	mvnne.w	r0, #118	; 0x76
    8740:	e009      	b.n	8756 <m16src_start+0x52>
	if (m16src_grd) {
    8742:	4d1f      	ldr	r5, [pc, #124]	; (87c0 <m16src_start+0xbc>)
    8744:	782f      	ldrb	r7, [r5, #0]
    8746:	b13f      	cbz	r7, 8758 <m16src_start+0x54>
		m16src_ref--;
    8748:	7010      	strb	r0, [r2, #0]
    874a:	f383 8811 	msr	BASEPRI, r3
    874e:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
    8752:	f06f 000a 	mvn.w	r0, #10
}
    8756:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	m16src_grd = 1U;
    8758:	2601      	movs	r6, #1
    875a:	702e      	strb	r6, [r5, #0]
    875c:	f383 8811 	msr	BASEPRI, r3
    8760:	f3bf 8f6f 	isb	sy
	if (blocking) {
    8764:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
    8768:	b319      	cbz	r1, 87b2 <m16src_start+0xae>
		irq_disable(DT_NORDIC_NRF_CLOCK_0_IRQ_0);
    876a:	4638      	mov	r0, r7
    876c:	f001 fb1e 	bl	9dac <z_arch_irq_disable>
		NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
    8770:	f8c4 7100 	str.w	r7, [r4, #256]	; 0x100
		intenset = NRF_CLOCK->INTENSET;
    8774:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
    NRF_CLOCK->INTENSET = int_mask;
    8778:	f8c4 6304 	str.w	r6, [r4, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = NRF_CLOCK_TASK_TRIGGER;
    877c:	6026      	str	r6, [r4, #0]
		while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0) {
    877e:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    8782:	b192      	cbz	r2, 87aa <m16src_start+0xa6>
		NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
    8784:	2200      	movs	r2, #0
    8786:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
    878a:	4a0e      	ldr	r2, [pc, #56]	; (87c4 <m16src_start+0xc0>)
		if (!(intenset & CLOCK_INTENSET_HFCLKSTARTED_Msk)) {
    878c:	f013 0f01 	tst.w	r3, #1
    8790:	f04f 0301 	mov.w	r3, #1
    NRF_CLOCK->INTENCLR = int_mask;
    8794:	bf08      	it	eq
    8796:	f8c4 3308 	streq.w	r3, [r4, #776]	; 0x308
		irq_enable(DT_NORDIC_NRF_CLOCK_0_IRQ_0);
    879a:	2000      	movs	r0, #0
    879c:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
    87a0:	f001 faf4 	bl	9d8c <z_arch_irq_enable>
	m16src_grd = 0U;
    87a4:	2300      	movs	r3, #0
    87a6:	702b      	strb	r3, [r5, #0]
    87a8:	e7be      	b.n	8728 <m16src_start+0x24>
			__WFE();
    87aa:	bf20      	wfe
			__SEV();
    87ac:	bf40      	sev
			__WFE();
    87ae:	bf20      	wfe
    87b0:	e7e5      	b.n	877e <m16src_start+0x7a>
		NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
    87b2:	f8c4 1100 	str.w	r1, [r4, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = NRF_CLOCK_TASK_TRIGGER;
    87b6:	6026      	str	r6, [r4, #0]
    87b8:	e7f4      	b.n	87a4 <m16src_start+0xa0>
    87ba:	bf00      	nop
    87bc:	20005afe 	.word	0x20005afe
    87c0:	20005afd 	.word	0x20005afd
    87c4:	e000e100 	.word	0xe000e100

000087c8 <k32src_start>:

static int k32src_start(struct device *dev, clock_control_subsys_t sub_system)
{
    87c8:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
    87ca:	f04f 0220 	mov.w	r2, #32
    87ce:	f3ef 8311 	mrs	r3, BASEPRI
    87d2:	f382 8811 	msr	BASEPRI, r2
    87d6:	f3bf 8f6f 	isb	sy
	 * initialized flag.
	 */

	imask = irq_lock();

	if (k32src_initialized) {
    87da:	4d24      	ldr	r5, [pc, #144]	; (886c <k32src_start+0xa4>)
    87dc:	782a      	ldrb	r2, [r5, #0]
    87de:	b19a      	cbz	r2, 8808 <k32src_start+0x40>
	__asm__ volatile(
    87e0:	f383 8811 	msr	BASEPRI, r3
    87e4:	f3bf 8f6f 	isb	sy
		}
	}
#endif /* NRF_CLOCK_HAS_CALIBRATION */

lf_already_started:
	stat = (NRF_CLOCK->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk) |
    87e8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    87ec:	f8d2 341c 	ldr.w	r3, [r2, #1052]	; 0x41c
	       CLOCK_LFCLKSTAT_STATE_Msk;
	if ((NRF_CLOCK->LFCLKSTAT & stat) == stat) {
    87f0:	f8d2 2418 	ldr.w	r2, [r2, #1048]	; 0x418
	stat = (NRF_CLOCK->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk) |
    87f4:	f003 0303 	and.w	r3, r3, #3
    87f8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
	if ((NRF_CLOCK->LFCLKSTAT & stat) == stat) {
    87fc:	4393      	bics	r3, r2
		return 0;
	} else {
		return -EINPROGRESS;
	}
}
    87fe:	bf14      	ite	ne
    8800:	f06f 0076 	mvnne.w	r0, #118	; 0x76
    8804:	2000      	moveq	r0, #0
    8806:	bd70      	pop	{r4, r5, r6, pc}
	k32src_initialized = 1U;
    8808:	2401      	movs	r4, #1
    880a:	702c      	strb	r4, [r5, #0]
    880c:	f383 8811 	msr	BASEPRI, r3
    8810:	f3bf 8f6f 	isb	sy
	NRF_CLOCK->EVENTS_LFCLKSTARTED = 0;
    8814:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8818:	4e15      	ldr	r6, [pc, #84]	; (8870 <k32src_start+0xa8>)
    881a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    NRF_CLOCK->INTENSET = int_mask;
    881e:	2502      	movs	r5, #2
	NRF_CLOCK->LFCLKSRC = lf_clk_src;
    8820:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    8824:	f8c3 5304 	str.w	r5, [r3, #772]	; 0x304
	if ((lf_clk_src & CLOCK_LFCLKSRC_SRC_Msk) == CLOCK_LFCLKSRC_SRC_RC) {
    8828:	f011 0103 	ands.w	r1, r1, #3
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = NRF_CLOCK_TASK_TRIGGER;
    882c:	6034      	str	r4, [r6, #0]
    NRF_CLOCK->INTENCLR = int_mask;
    882e:	f04f 0618 	mov.w	r6, #24
    8832:	f8c3 6308 	str.w	r6, [r3, #776]	; 0x308
	NRF_CLOCK->EVENTS_DONE = 0;
    8836:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_CLOCK->EVENTS_CTTO = 0;
    883a:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
	if ((lf_clk_src & CLOCK_LFCLKSRC_SRC_Msk) == CLOCK_LFCLKSRC_SRC_RC) {
    883e:	d1d3      	bne.n	87e8 <k32src_start+0x20>
		NRF_CLOCK->CTIV = 16;	/* 4s in 0.25s units */
    8840:	2210      	movs	r2, #16
    8842:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    NRF_CLOCK->INTENSET = int_mask;
    8846:	f8c3 6304 	str.w	r6, [r3, #772]	; 0x304
		if ((NRF_CLOCK->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk) == 0) {
    884a:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
    884e:	03d2      	lsls	r2, r2, #15
    8850:	d402      	bmi.n	8858 <k32src_start+0x90>
    8852:	f8c3 5304 	str.w	r5, [r3, #772]	; 0x304
			goto lf_already_started;
    8856:	e7c7      	b.n	87e8 <k32src_start+0x20>
    8858:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
		err = m16src_start(dev, false);
    885c:	f7ff ff52 	bl	8704 <m16src_start>
		if (!err) {
    8860:	2800      	cmp	r0, #0
    8862:	d1c1      	bne.n	87e8 <k32src_start+0x20>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    8864:	4b03      	ldr	r3, [pc, #12]	; (8874 <k32src_start+0xac>)
    8866:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
    886a:	e7bd      	b.n	87e8 <k32src_start+0x20>
    886c:	20005afc 	.word	0x20005afc
    8870:	40000008 	.word	0x40000008
    8874:	e000e100 	.word	0xe000e100

00008878 <nrf_power_clock_isr>:
 * probably better abstract that at some point (e.g. query and reset
 * it by pointer at runtime, maybe?) so we don't have this leaky
 * symbol.
 */
void nrf_power_clock_isr(void *arg)
{
    8878:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#endif
#if defined(CONFIG_USB) && defined(CONFIG_SOC_NRF52840)
	bool usb_detected, usb_pwr_rdy, usb_removed;
#endif

	pof = (NRF_POWER->EVENTS_POFWARN != 0);
    887c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    return (bool)*(volatile uint32_t *)((uint8_t *)NRF_POWER + (uint32_t)event);
    8880:	4d4e      	ldr	r5, [pc, #312]	; (89bc <nrf_power_clock_isr+0x144>)
    8882:	f8d3 9108 	ldr.w	r9, [r3, #264]	; 0x108

	hf_intenset = ((NRF_CLOCK->INTENSET &
    8886:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
		       CLOCK_INTENSET_HFCLKSTARTED_Msk) != 0);
	hf = (NRF_CLOCK->EVENTS_HFCLKSTARTED != 0);
    888a:	f8d3 e100 	ldr.w	lr, [r3, #256]	; 0x100
{
    888e:	4680      	mov	r8, r0

	lf_intenset = ((NRF_CLOCK->INTENSET &
    8890:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
		       CLOCK_INTENSET_LFCLKSTARTED_Msk) != 0);
	lf = (NRF_CLOCK->EVENTS_LFCLKSTARTED != 0);
    8894:	f8d3 c104 	ldr.w	ip, [r3, #260]	; 0x104

#if NRF_CLOCK_HAS_CALIBRATION
	done = (NRF_CLOCK->EVENTS_DONE != 0);
    8898:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
	ctto = (NRF_CLOCK->EVENTS_CTTO != 0);
    889c:	f8d3 4110 	ldr.w	r4, [r3, #272]	; 0x110
    88a0:	682f      	ldr	r7, [r5, #0]
    88a2:	68ae      	ldr	r6, [r5, #8]
    88a4:	3504      	adds	r5, #4
    88a6:	3400      	adds	r4, #0
{
    88a8:	b085      	sub	sp, #20
	hf_intenset = ((NRF_CLOCK->INTENSET &
    88aa:	f002 0201 	and.w	r2, r2, #1
	ctto = (NRF_CLOCK->EVENTS_CTTO != 0);
    88ae:	bf18      	it	ne
    88b0:	2401      	movne	r4, #1
    88b2:	682d      	ldr	r5, [r5, #0]
#if defined(CONFIG_USB) && defined(CONFIG_SOC_NRF52840)
			|| usb_detected || usb_pwr_rdy || usb_removed
#endif
	);

	if (pof) {
    88b4:	f1b9 0f00 	cmp.w	r9, #0
    88b8:	d003      	beq.n	88c2 <nrf_power_clock_isr+0x4a>
		NRF_POWER->EVENTS_POFWARN = 0;
    88ba:	f04f 0900 	mov.w	r9, #0
    88be:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
	}

	if (hf) {
    88c2:	f1be 0f00 	cmp.w	lr, #0
    88c6:	d069      	beq.n	899c <nrf_power_clock_isr+0x124>
		NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
    88c8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    88cc:	f04f 0e00 	mov.w	lr, #0
    88d0:	f8c3 e100 	str.w	lr, [r3, #256]	; 0x100
	}

	if (hf_intenset && (hf || ((NRF_CLOCK->HFCLKSTAT &
    88d4:	b15a      	cbz	r2, 88ee <nrf_power_clock_isr+0x76>
				   (CLOCK_HFCLKSTAT_STATE_Msk |
				    CLOCK_HFCLKSTAT_SRC_Msk)))){
		/* INTENSET is used as state flag to start calibration,
		 * hence clear it here.
		 */
		NRF_CLOCK->INTENCLR = CLOCK_INTENCLR_HFCLKSTARTED_Msk;
    88d6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#if defined(CONFIG_SOC_SERIES_NRF52X)
		/* NOTE: Errata [192] CLOCK: LFRC frequency offset after
		 * calibration.
		 * Calibration start, workaround.
		 */
		*(volatile u32_t *)0x40000C34 = 0x00000002;
    88da:	f8df e0e4 	ldr.w	lr, [pc, #228]	; 89c0 <nrf_power_clock_isr+0x148>
		NRF_CLOCK->INTENCLR = CLOCK_INTENCLR_HFCLKSTARTED_Msk;
    88de:	2201      	movs	r2, #1
		*(volatile u32_t *)0x40000C34 = 0x00000002;
    88e0:	f04f 0902 	mov.w	r9, #2
		NRF_CLOCK->INTENCLR = CLOCK_INTENCLR_HFCLKSTARTED_Msk;
    88e4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
		*(volatile u32_t *)0x40000C34 = 0x00000002;
    88e8:	f8ce 9000 	str.w	r9, [lr]
#endif /* CONFIG_SOC_SERIES_NRF52X */

#if NRF_CLOCK_HAS_CALIBRATION
		/* Start Calibration */
		NRF_CLOCK->TASKS_CAL = 1;
    88ec:	611a      	str	r2, [r3, #16]
#endif
	}

	if (lf) {
    88ee:	f1bc 0f00 	cmp.w	ip, #0
    88f2:	d141      	bne.n	8978 <nrf_power_clock_isr+0x100>
#endif
		}
	}

#if NRF_CLOCK_HAS_CALIBRATION
	if (done) {
    88f4:	b161      	cbz	r1, 8910 <nrf_power_clock_isr+0x98>
#if defined(CONFIG_SOC_SERIES_NRF52X)
		/* NOTE: Errata [192] CLOCK: LFRC frequency offset after
		 * calibration.
		 * Calibration done, workaround.
		 */
		*(volatile u32_t *)0x40000C34 = 0x00000000;
    88f6:	4b32      	ldr	r3, [pc, #200]	; (89c0 <nrf_power_clock_isr+0x148>)
#endif /* CONFIG_SOC_SERIES_NRF52X */

		NRF_CLOCK->EVENTS_DONE = 0;
    88f8:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
		*(volatile u32_t *)0x40000C34 = 0x00000000;
    88fc:	2100      	movs	r1, #0
    88fe:	6019      	str	r1, [r3, #0]

		/* Calibration done, stop 16M Xtal. */
		err = m16src_stop(dev, NULL);
    8900:	4640      	mov	r0, r8
		NRF_CLOCK->EVENTS_DONE = 0;
    8902:	f8c9 110c 	str.w	r1, [r9, #268]	; 0x10c
		err = m16src_stop(dev, NULL);
    8906:	f7ff fec3 	bl	8690 <m16src_stop>
		__ASSERT_NO_MSG(!err || err == -EBUSY);

		/* Start timer for next calibration. */
		NRF_CLOCK->TASKS_CTSTART = 1;
    890a:	2301      	movs	r3, #1
    890c:	f8c9 3014 	str.w	r3, [r9, #20]
	}

	if (ctto) {
    8910:	b174      	cbz	r4, 8930 <nrf_power_clock_isr+0xb8>
		int err;

		NRF_CLOCK->EVENTS_CTTO = 0;
    8912:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    8916:	2100      	movs	r1, #0

		/* Start HF clock, if already started
		 * then explicitly assert IRQ; we use the INTENSET
		 * as a state flag to start calibration.
		 */
		NRF_CLOCK->INTENSET = CLOCK_INTENSET_HFCLKSTARTED_Msk;
    8918:	2401      	movs	r4, #1
		NRF_CLOCK->EVENTS_CTTO = 0;
    891a:	f8c3 1110 	str.w	r1, [r3, #272]	; 0x110

		err = m16src_start(dev, false);
    891e:	4640      	mov	r0, r8
		NRF_CLOCK->INTENSET = CLOCK_INTENSET_HFCLKSTARTED_Msk;
    8920:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
		err = m16src_start(dev, false);
    8924:	f7ff feee 	bl	8704 <m16src_start>
		if (!err) {
    8928:	b910      	cbnz	r0, 8930 <nrf_power_clock_isr+0xb8>
    892a:	4b26      	ldr	r3, [pc, #152]	; (89c4 <nrf_power_clock_isr+0x14c>)
    892c:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
		}
	}
#endif /* NRF_CLOCK_HAS_CALIBRATION */

#if defined(CONFIG_USB) && defined(CONFIG_SOC_NRF52840)
	if (usb_detected) {
    8930:	b14f      	cbz	r7, 8946 <nrf_power_clock_isr+0xce>
    *((volatile uint32_t *)((uint8_t *)NRF_POWER + (uint32_t)event)) = 0x0UL;
    8932:	4b22      	ldr	r3, [pc, #136]	; (89bc <nrf_power_clock_isr+0x144>)
    8934:	2200      	movs	r2, #0
    8936:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_POWER + (uint32_t)event));
    8938:	681b      	ldr	r3, [r3, #0]
    893a:	9301      	str	r3, [sp, #4]
	usb_dc_nrfx_power_event_callback(event);
    893c:	f44f 708e 	mov.w	r0, #284	; 0x11c
    (void)dummy;
    8940:	9b01      	ldr	r3, [sp, #4]
    8942:	f000 fccd 	bl	92e0 <usb_dc_nrfx_power_event_callback>
		nrf_power_event_clear(NRF_POWER_EVENT_USBDETECTED);
		power_event_cb(NRF_POWER_EVENT_USBDETECTED);
	}

	if (usb_pwr_rdy) {
    8946:	b14e      	cbz	r6, 895c <nrf_power_clock_isr+0xe4>
    *((volatile uint32_t *)((uint8_t *)NRF_POWER + (uint32_t)event)) = 0x0UL;
    8948:	4b1f      	ldr	r3, [pc, #124]	; (89c8 <nrf_power_clock_isr+0x150>)
    894a:	2200      	movs	r2, #0
    894c:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_POWER + (uint32_t)event));
    894e:	681b      	ldr	r3, [r3, #0]
    8950:	9302      	str	r3, [sp, #8]
	usb_dc_nrfx_power_event_callback(event);
    8952:	f44f 7092 	mov.w	r0, #292	; 0x124
    (void)dummy;
    8956:	9b02      	ldr	r3, [sp, #8]
    8958:	f000 fcc2 	bl	92e0 <usb_dc_nrfx_power_event_callback>
		nrf_power_event_clear(NRF_POWER_EVENT_USBPWRRDY);
		power_event_cb(NRF_POWER_EVENT_USBPWRRDY);
	}

	if (usb_removed) {
    895c:	b355      	cbz	r5, 89b4 <nrf_power_clock_isr+0x13c>
    *((volatile uint32_t *)((uint8_t *)NRF_POWER + (uint32_t)event)) = 0x0UL;
    895e:	4b1b      	ldr	r3, [pc, #108]	; (89cc <nrf_power_clock_isr+0x154>)
    8960:	2200      	movs	r2, #0
    8962:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_POWER + (uint32_t)event));
    8964:	681b      	ldr	r3, [r3, #0]
    8966:	9303      	str	r3, [sp, #12]
    (void)dummy;
    8968:	9b03      	ldr	r3, [sp, #12]
	usb_dc_nrfx_power_event_callback(event);
    896a:	f44f 7090 	mov.w	r0, #288	; 0x120
		nrf_power_event_clear(NRF_POWER_EVENT_USBREMOVED);
		power_event_cb(NRF_POWER_EVENT_USBREMOVED);
	}
#endif
}
    896e:	b005      	add	sp, #20
    8970:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	usb_dc_nrfx_power_event_callback(event);
    8974:	f000 bcb4 	b.w	92e0 <usb_dc_nrfx_power_event_callback>
		NRF_CLOCK->EVENTS_LFCLKSTARTED = 0;
    8978:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    897c:	2200      	movs	r2, #0
    897e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
		if (lf_intenset) {
    8982:	0782      	lsls	r2, r0, #30
    8984:	d5b6      	bpl.n	88f4 <nrf_power_clock_isr+0x7c>
			NRF_CLOCK->INTENCLR = CLOCK_INTENCLR_LFCLKSTARTED_Msk;
    8986:	2202      	movs	r2, #2
    8988:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
			if ((NRF_CLOCK->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk) ==
    898c:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
    8990:	079b      	lsls	r3, r3, #30
    8992:	d1af      	bne.n	88f4 <nrf_power_clock_isr+0x7c>
	if (done) {
    8994:	2900      	cmp	r1, #0
    8996:	d0bc      	beq.n	8912 <nrf_power_clock_isr+0x9a>
				ctto = 1U;
    8998:	2401      	movs	r4, #1
    899a:	e7ac      	b.n	88f6 <nrf_power_clock_isr+0x7e>
	if (hf_intenset && (hf || ((NRF_CLOCK->HFCLKSTAT &
    899c:	2a00      	cmp	r2, #0
    899e:	d0a6      	beq.n	88ee <nrf_power_clock_isr+0x76>
    89a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    89a4:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
    89a8:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
    89ac:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
    89b0:	d19d      	bne.n	88ee <nrf_power_clock_isr+0x76>
    89b2:	e790      	b.n	88d6 <nrf_power_clock_isr+0x5e>
}
    89b4:	b005      	add	sp, #20
    89b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    89ba:	bf00      	nop
    89bc:	4000011c 	.word	0x4000011c
    89c0:	40000c34 	.word	0x40000c34
    89c4:	e000e100 	.word	0xe000e100
    89c8:	40000124 	.word	0x40000124
    89cc:	40000120 	.word	0x40000120

000089d0 <endpoint_ctx>:
	}

	ctx = get_usbd_ctx();
	ep_num = NRF_USBD_EP_NR_GET(ep);

	if (NRF_USBD_EPIN_CHECK(ep)) {
    89d0:	0601      	lsls	r1, r0, #24
	ep_num = NRF_USBD_EP_NR_GET(ep);
    89d2:	f000 030f 	and.w	r3, r0, #15
	if (NRF_USBD_EPIN_CHECK(ep)) {
    89d6:	f000 0208 	and.w	r2, r0, #8
    89da:	d506      	bpl.n	89ea <endpoint_ctx+0x1a>
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
    89dc:	b96a      	cbnz	r2, 89fa <endpoint_ctx+0x2a>
			return &ctx->ep_ctx[EP_ISOIN_INDEX];
		} else {
			return &ctx->ep_ctx[ep_num];
    89de:	4809      	ldr	r0, [pc, #36]	; (8a04 <endpoint_ctx+0x34>)
    89e0:	2224      	movs	r2, #36	; 0x24
    89e2:	fb02 0003 	mla	r0, r2, r3, r0
		}
	} else {
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
			return &ctx->ep_ctx[EP_ISOOUT_INDEX];
		} else {
			return &ctx->ep_ctx[CFG_EPIN_CNT +
    89e6:	3028      	adds	r0, #40	; 0x28
    89e8:	4770      	bx	lr
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
    89ea:	b942      	cbnz	r2, 89fe <endpoint_ctx+0x2e>
					    CFG_EP_ISOIN_CNT +
    89ec:	f103 0009 	add.w	r0, r3, #9
			return &ctx->ep_ctx[CFG_EPIN_CNT +
    89f0:	4b04      	ldr	r3, [pc, #16]	; (8a04 <endpoint_ctx+0x34>)
    89f2:	2224      	movs	r2, #36	; 0x24
    89f4:	fb02 3000 	mla	r0, r2, r0, r3
    89f8:	e7f5      	b.n	89e6 <endpoint_ctx+0x16>
			return &ctx->ep_ctx[EP_ISOIN_INDEX];
    89fa:	4803      	ldr	r0, [pc, #12]	; (8a08 <endpoint_ctx+0x38>)
    89fc:	4770      	bx	lr
			return &ctx->ep_ctx[EP_ISOOUT_INDEX];
    89fe:	4803      	ldr	r0, [pc, #12]	; (8a0c <endpoint_ctx+0x3c>)
					    ep_num];
		}
	}

	return NULL;
}
    8a00:	4770      	bx	lr
    8a02:	bf00      	nop
    8a04:	20003730 	.word	0x20003730
    8a08:	20003878 	.word	0x20003878
    8a0c:	200039bc 	.word	0x200039bc

00008a10 <usbd_evt_put>:
 *
 * @param Pointer to the previously allocated and filled event structure.
 */
static inline void usbd_evt_put(struct usbd_event *ev)
{
	k_fifo_put(&work_queue, ev);
    8a10:	4601      	mov	r1, r0
    8a12:	4801      	ldr	r0, [pc, #4]	; (8a18 <usbd_evt_put+0x8>)
    8a14:	f00d b86b 	b.w	15aee <k_queue_append>
    8a18:	20011dec 	.word	0x20011dec

00008a1c <hf_clock_enable.constprop.9>:
 * @param on		Set true to enable the HF clock, false to disable.
 * @param blocking	Set true to block wait till HF clock stabilizes.
 *
 * @return 0 on success, error number otherwise
 */
static int hf_clock_enable(bool on, bool blocking)
    8a1c:	b570      	push	{r4, r5, r6, lr}
    8a1e:	4605      	mov	r5, r0
    8a20:	4822      	ldr	r0, [pc, #136]	; (8aac <hf_clock_enable.constprop.9+0x90>)
    8a22:	f005 ffdf 	bl	e9e4 <z_impl_device_get_binding>
	int ret = -ENODEV;
	struct device *clock;
	static bool clock_requested;

	clock = device_get_binding(DT_NORDIC_NRF_CLOCK_0_LABEL "_16M");
	if (!clock) {
    8a26:	b988      	cbnz	r0, 8a4c <hf_clock_enable.constprop.9+0x30>
		LOG_ERR("NRF HF Clock device not found!");
    8a28:	2301      	movs	r3, #1
    8a2a:	f04f 0100 	mov.w	r1, #0
    8a2e:	f363 0107 	bfi	r1, r3, #0, #8
    8a32:	4a1f      	ldr	r2, [pc, #124]	; (8ab0 <hf_clock_enable.constprop.9+0x94>)
    8a34:	4b1f      	ldr	r3, [pc, #124]	; (8ab4 <hf_clock_enable.constprop.9+0x98>)
    8a36:	4820      	ldr	r0, [pc, #128]	; (8ab8 <hf_clock_enable.constprop.9+0x9c>)
    8a38:	1a9b      	subs	r3, r3, r2
    8a3a:	08db      	lsrs	r3, r3, #3
    8a3c:	f363 118f 	bfi	r1, r3, #6, #10
    8a40:	f009 fa98 	bl	11f74 <log_0>
		return ret;
    8a44:	f06f 0412 	mvn.w	r4, #18
	/* NOTE: Non-blocking HF clock enable can return -EINPROGRESS
	 * if HF clock start was already requested. Such error code
	 * does not need to be propagated, hence returned value is 0.
	 */
	return 0;
}
    8a48:	4620      	mov	r0, r4
    8a4a:	bd70      	pop	{r4, r5, r6, pc}
	if (on) {
    8a4c:	4e1b      	ldr	r6, [pc, #108]	; (8abc <hf_clock_enable.constprop.9+0xa0>)
    8a4e:	7831      	ldrb	r1, [r6, #0]
    8a50:	b1ed      	cbz	r5, 8a8e <hf_clock_enable.constprop.9+0x72>
		if (clock_requested) {
    8a52:	bb31      	cbnz	r1, 8aa2 <hf_clock_enable.constprop.9+0x86>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
    8a54:	6843      	ldr	r3, [r0, #4]
    8a56:	681b      	ldr	r3, [r3, #0]
    8a58:	4798      	blx	r3
    8a5a:	4604      	mov	r4, r0
	if (ret && (blocking || (ret != -EINPROGRESS))) {
    8a5c:	b304      	cbz	r4, 8aa0 <hf_clock_enable.constprop.9+0x84>
    8a5e:	f114 0f77 	cmn.w	r4, #119	; 0x77
    8a62:	d01d      	beq.n	8aa0 <hf_clock_enable.constprop.9+0x84>
		LOG_ERR("HF clock %s fail: %d",
    8a64:	2201      	movs	r2, #1
    8a66:	f04f 0300 	mov.w	r3, #0
    8a6a:	f362 0307 	bfi	r3, r2, #0, #8
    8a6e:	4910      	ldr	r1, [pc, #64]	; (8ab0 <hf_clock_enable.constprop.9+0x94>)
    8a70:	4a10      	ldr	r2, [pc, #64]	; (8ab4 <hf_clock_enable.constprop.9+0x98>)
    8a72:	4813      	ldr	r0, [pc, #76]	; (8ac0 <hf_clock_enable.constprop.9+0xa4>)
    8a74:	1a52      	subs	r2, r2, r1
    8a76:	4913      	ldr	r1, [pc, #76]	; (8ac4 <hf_clock_enable.constprop.9+0xa8>)
    8a78:	08d2      	lsrs	r2, r2, #3
    8a7a:	f362 138f 	bfi	r3, r2, #6, #10
    8a7e:	2d00      	cmp	r5, #0
    8a80:	bf08      	it	eq
    8a82:	4601      	moveq	r1, r0
    8a84:	4622      	mov	r2, r4
    8a86:	4810      	ldr	r0, [pc, #64]	; (8ac8 <hf_clock_enable.constprop.9+0xac>)
    8a88:	f009 fa95 	bl	11fb6 <log_2>
		return ret;
    8a8c:	e7dc      	b.n	8a48 <hf_clock_enable.constprop.9+0x2c>
		if (!clock_requested) {
    8a8e:	b151      	cbz	r1, 8aa6 <hf_clock_enable.constprop.9+0x8a>
				    clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->off(dev, sys);
    8a90:	6843      	ldr	r3, [r0, #4]
    8a92:	4629      	mov	r1, r5
    8a94:	685b      	ldr	r3, [r3, #4]
    8a96:	4798      	blx	r3
		if (ret == -EBUSY) {
    8a98:	f110 0f10 	cmn.w	r0, #16
    8a9c:	4604      	mov	r4, r0
    8a9e:	d1dd      	bne.n	8a5c <hf_clock_enable.constprop.9+0x40>
	clock_requested = on;
    8aa0:	7035      	strb	r5, [r6, #0]
			return 0;
    8aa2:	2400      	movs	r4, #0
    8aa4:	e7d0      	b.n	8a48 <hf_clock_enable.constprop.9+0x2c>
    8aa6:	460c      	mov	r4, r1
    8aa8:	e7ce      	b.n	8a48 <hf_clock_enable.constprop.9+0x2c>
    8aaa:	bf00      	nop
    8aac:	000180cd 	.word	0x000180cd
    8ab0:	00016344 	.word	0x00016344
    8ab4:	0001644c 	.word	0x0001644c
    8ab8:	0001815f 	.word	0x0001815f
    8abc:	20005aff 	.word	0x20005aff
    8ac0:	0001817e 	.word	0x0001817e
    8ac4:	0001726b 	.word	0x0001726b
    8ac8:	00018183 	.word	0x00018183

00008acc <usbd_work_schedule>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    8acc:	4909      	ldr	r1, [pc, #36]	; (8af4 <usbd_work_schedule+0x28>)
    8ace:	f3bf 8f5b 	dmb	ish
    8ad2:	e851 3f00 	ldrex	r3, [r1]
    8ad6:	f043 0201 	orr.w	r2, r3, #1
    8ada:	e841 2000 	strex	r0, r2, [r1]
    8ade:	2800      	cmp	r0, #0
    8ae0:	d1f7      	bne.n	8ad2 <usbd_work_schedule+0x6>
    8ae2:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
    8ae6:	07db      	lsls	r3, r3, #31
    8ae8:	d403      	bmi.n	8af2 <usbd_work_schedule+0x26>
		k_queue_append(&work_q->queue, work);
    8aea:	3908      	subs	r1, #8
    8aec:	4802      	ldr	r0, [pc, #8]	; (8af8 <usbd_work_schedule+0x2c>)
    8aee:	f00c bffe 	b.w	15aee <k_queue_append>
}
    8af2:	4770      	bx	lr
    8af4:	20003740 	.word	0x20003740
    8af8:	20005620 	.word	0x20005620

00008afc <usbd_evt_flush>:
{
    8afc:	b510      	push	{r4, lr}
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
    8afe:	4c05      	ldr	r4, [pc, #20]	; (8b14 <usbd_evt_flush+0x18>)
    8b00:	2100      	movs	r1, #0
    8b02:	4620      	mov	r0, r4
    8b04:	f00c fffd 	bl	15b02 <z_impl_k_queue_get>
		if (ev) {
    8b08:	b118      	cbz	r0, 8b12 <usbd_evt_flush+0x16>
	k_mem_pool_free(&ev->block);
    8b0a:	3004      	adds	r0, #4
    8b0c:	f00c ff42 	bl	15994 <k_mem_pool_free>
    8b10:	e7f6      	b.n	8b00 <usbd_evt_flush+0x4>
}
    8b12:	bd10      	pop	{r4, pc}
    8b14:	20011dec 	.word	0x20011dec

00008b18 <usbd_evt_alloc>:
{
    8b18:	b537      	push	{r0, r1, r2, r4, r5, lr}
	ret = k_mem_pool_alloc(&fifo_elem_pool, &block,
    8b1a:	466c      	mov	r4, sp
    8b1c:	2300      	movs	r3, #0
    8b1e:	2218      	movs	r2, #24
    8b20:	4621      	mov	r1, r4
    8b22:	4820      	ldr	r0, [pc, #128]	; (8ba4 <usbd_evt_alloc+0x8c>)
    8b24:	f006 f902 	bl	ed2c <k_mem_pool_alloc>
	if (ret < 0) {
    8b28:	2800      	cmp	r0, #0
    8b2a:	da34      	bge.n	8b96 <usbd_evt_alloc+0x7e>
		LOG_ERR("USBD event allocation failed!");
    8b2c:	2301      	movs	r3, #1
    8b2e:	f04f 0100 	mov.w	r1, #0
    8b32:	f363 0107 	bfi	r1, r3, #0, #8
    8b36:	4d1c      	ldr	r5, [pc, #112]	; (8ba8 <usbd_evt_alloc+0x90>)
    8b38:	4b1c      	ldr	r3, [pc, #112]	; (8bac <usbd_evt_alloc+0x94>)
    8b3a:	481d      	ldr	r0, [pc, #116]	; (8bb0 <usbd_evt_alloc+0x98>)
    8b3c:	1aed      	subs	r5, r5, r3
    8b3e:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    8b42:	f365 118f 	bfi	r1, r5, #6, #10
    8b46:	f009 fa15 	bl	11f74 <log_0>
		usbd_evt_flush();
    8b4a:	f7ff ffd7 	bl	8afc <usbd_evt_flush>
		ret = k_mem_pool_alloc(&fifo_elem_pool, &block,
    8b4e:	2300      	movs	r3, #0
    8b50:	2218      	movs	r2, #24
    8b52:	4621      	mov	r1, r4
    8b54:	4813      	ldr	r0, [pc, #76]	; (8ba4 <usbd_evt_alloc+0x8c>)
    8b56:	f006 f8e9 	bl	ed2c <k_mem_pool_alloc>
		if (ret < 0) {
    8b5a:	2800      	cmp	r0, #0
    8b5c:	da0d      	bge.n	8b7a <usbd_evt_alloc+0x62>
			LOG_ERR("USBD event memory corrupted.");
    8b5e:	f04f 0100 	mov.w	r1, #0
    8b62:	2301      	movs	r3, #1
    8b64:	f363 0107 	bfi	r1, r3, #0, #8
    8b68:	f365 118f 	bfi	r1, r5, #6, #10
    8b6c:	4811      	ldr	r0, [pc, #68]	; (8bb4 <usbd_evt_alloc+0x9c>)
    8b6e:	f009 fa01 	bl	11f74 <log_0>
		return NULL;
    8b72:	2300      	movs	r3, #0
}
    8b74:	4618      	mov	r0, r3
    8b76:	b003      	add	sp, #12
    8b78:	bd30      	pop	{r4, r5, pc}
		ev = (struct usbd_event *)block.data;
    8b7a:	9b00      	ldr	r3, [sp, #0]
		ev->block = block;
    8b7c:	e894 0003 	ldmia.w	r4, {r0, r1}
    8b80:	1d1a      	adds	r2, r3, #4
    8b82:	e882 0003 	stmia.w	r2, {r0, r1}
		ev->evt_type = USBD_EVT_REINIT;
    8b86:	2204      	movs	r2, #4
    8b88:	751a      	strb	r2, [r3, #20]
		usbd_evt_put(ev);
    8b8a:	4618      	mov	r0, r3
    8b8c:	f7ff ff40 	bl	8a10 <usbd_evt_put>
		usbd_work_schedule();
    8b90:	f7ff ff9c 	bl	8acc <usbd_work_schedule>
    8b94:	e7ed      	b.n	8b72 <usbd_evt_alloc+0x5a>
	ev = (struct usbd_event *)block.data;
    8b96:	9b00      	ldr	r3, [sp, #0]
	ev->block = block;
    8b98:	e894 0003 	ldmia.w	r4, {r0, r1}
    8b9c:	1d1a      	adds	r2, r3, #4
    8b9e:	e882 0003 	stmia.w	r2, {r0, r1}
	return ev;
    8ba2:	e7e7      	b.n	8b74 <usbd_evt_alloc+0x5c>
    8ba4:	20011d58 	.word	0x20011d58
    8ba8:	0001644c 	.word	0x0001644c
    8bac:	00016344 	.word	0x00016344
    8bb0:	000182e8 	.word	0x000182e8
    8bb4:	00018306 	.word	0x00018306

00008bb8 <usbd_event_transfer_data>:
		}
	}
}

static void usbd_event_transfer_data(nrfx_usbd_evt_t const *const p_event)
{
    8bb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct nrf_usbd_ep_ctx *ep_ctx =
		endpoint_ctx(p_event->data.eptransfer.ep);
    8bbc:	7886      	ldrb	r6, [r0, #2]
{
    8bbe:	4607      	mov	r7, r0
		endpoint_ctx(p_event->data.eptransfer.ep);
    8bc0:	4630      	mov	r0, r6
    8bc2:	f7ff ff05 	bl	89d0 <endpoint_ctx>

	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
    8bc6:	0633      	lsls	r3, r6, #24
		endpoint_ctx(p_event->data.eptransfer.ep);
    8bc8:	4605      	mov	r5, r0
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
    8bca:	78fc      	ldrb	r4, [r7, #3]
    8bcc:	d513      	bpl.n	8bf6 <usbd_event_transfer_data+0x3e>
		switch (p_event->data.eptransfer.status) {
    8bce:	2c00      	cmp	r4, #0
    8bd0:	d146      	bne.n	8c60 <usbd_event_transfer_data+0xa8>
		case NRFX_USBD_EP_OK: {
			struct usbd_event *ev = usbd_evt_alloc();
    8bd2:	f7ff ffa1 	bl	8b18 <usbd_evt_alloc>

			if (!ev) {
    8bd6:	4603      	mov	r3, r0
    8bd8:	2800      	cmp	r0, #0
    8bda:	d053      	beq.n	8c84 <usbd_event_transfer_data+0xcc>

			LOG_DBG("write complete, ep %d",
				(u32_t)p_event->data.eptransfer.ep);

			ep_ctx->write_in_progress = false;
			ev->evt_type = USBD_EVT_EP;
    8bdc:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
    8bde:	f885 4022 	strb.w	r4, [r5, #34]	; 0x22
			ev->evt_type = USBD_EVT_EP;
    8be2:	7502      	strb	r2, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
    8be4:	2203      	movs	r2, #3
    8be6:	7402      	strb	r2, [r0, #16]
				(u32_t)p_event->data.eptransfer.ep);

			ep_ctx->read_pending = true;
			ev->evt_type = USBD_EVT_EP;
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
			ev->evt.ep_evt.ep = ep_ctx;
    8be8:	60dd      	str	r5, [r3, #12]

			usbd_evt_put(ev);
    8bea:	f7ff ff11 	bl	8a10 <usbd_evt_put>
				p_event->data.eptransfer.ep);
		}
		break;
		}
	}
}
    8bee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			usbd_work_schedule();
    8bf2:	f7ff bf6b 	b.w	8acc <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
    8bf6:	b15c      	cbz	r4, 8c10 <usbd_event_transfer_data+0x58>
    8bf8:	2c01      	cmp	r4, #1
    8bfa:	d131      	bne.n	8c60 <usbd_event_transfer_data+0xa8>
			struct usbd_event *ev = usbd_evt_alloc();
    8bfc:	f7ff ff8c 	bl	8b18 <usbd_evt_alloc>
			if (!ev) {
    8c00:	4603      	mov	r3, r0
    8c02:	2800      	cmp	r0, #0
    8c04:	d03e      	beq.n	8c84 <usbd_event_transfer_data+0xcc>
			ep_ctx->read_pending = true;
    8c06:	f885 4021 	strb.w	r4, [r5, #33]	; 0x21
			ev->evt_type = USBD_EVT_EP;
    8c0a:	7504      	strb	r4, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
    8c0c:	7404      	strb	r4, [r0, #16]
    8c0e:	e7eb      	b.n	8be8 <usbd_event_transfer_data+0x30>
			struct usbd_event *ev = usbd_evt_alloc();
    8c10:	f7ff ff82 	bl	8b18 <usbd_evt_alloc>
			if (!ev) {
    8c14:	b3b0      	cbz	r0, 8c84 <usbd_event_transfer_data+0xcc>
				p_event->data.eptransfer.ep);
    8c16:	78bb      	ldrb	r3, [r7, #2]

uint32_t nrf_usbd_ep_amount_get(uint8_t ep)
{
    uint32_t ret;

    if (NRF_USBD_EPIN_CHECK(ep))
    8c18:	4a1b      	ldr	r2, [pc, #108]	; (8c88 <usbd_event_transfer_data+0xd0>)
    8c1a:	f013 0f80 	tst.w	r3, #128	; 0x80
    8c1e:	f003 0108 	and.w	r1, r3, #8
    8c22:	d011      	beq.n	8c48 <usbd_event_transfer_data+0x90>
    {
        if (NRF_USBD_EPISO_CHECK(ep))
    8c24:	b141      	cbz	r1, 8c38 <usbd_event_transfer_data+0x80>
        {
            ret = NRF_USBD->ISOIN.AMOUNT;
    8c26:	f8d2 36a8 	ldr.w	r3, [r2, #1704]	; 0x6a8
			ep_ctx->buf.len = nrf_usbd_ep_amount_get(
    8c2a:	60eb      	str	r3, [r5, #12]
			ev->evt_type = USBD_EVT_EP;
    8c2c:	2301      	movs	r3, #1
    8c2e:	7503      	strb	r3, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
    8c30:	2302      	movs	r3, #2
    8c32:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
    8c34:	60c5      	str	r5, [r0, #12]
			usbd_evt_put(ev);
    8c36:	e7d8      	b.n	8bea <usbd_event_transfer_data+0x32>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT(epnr < NRFX_ARRAY_SIZE(NRF_USBD->EPOUT));
            ret = NRF_USBD->EPIN[epnr].AMOUNT;
    8c38:	f003 030f 	and.w	r3, r3, #15
    8c3c:	2114      	movs	r1, #20
    8c3e:	fb01 2303 	mla	r3, r1, r3, r2
    8c42:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    8c46:	e7f0      	b.n	8c2a <usbd_event_transfer_data+0x72>
        }
    }
    else
    {
        if (NRF_USBD_EPISO_CHECK(ep))
    8c48:	b111      	cbz	r1, 8c50 <usbd_event_transfer_data+0x98>
        {
            ret = NRF_USBD->ISOOUT.AMOUNT;
    8c4a:	f8d2 37a8 	ldr.w	r3, [r2, #1960]	; 0x7a8
    8c4e:	e7ec      	b.n	8c2a <usbd_event_transfer_data+0x72>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT(epnr < NRFX_ARRAY_SIZE(NRF_USBD->EPOUT));
            ret = NRF_USBD->EPOUT[epnr].AMOUNT;
    8c50:	f003 030f 	and.w	r3, r3, #15
    8c54:	2114      	movs	r1, #20
    8c56:	fb01 2303 	mla	r3, r1, r3, r2
    8c5a:	f8d3 3708 	ldr.w	r3, [r3, #1800]	; 0x708
    8c5e:	e7e4      	b.n	8c2a <usbd_event_transfer_data+0x72>
			LOG_ERR("Unexpected event from nrfx_usbd: %d, ep %d",
    8c60:	2201      	movs	r2, #1
    8c62:	f04f 0300 	mov.w	r3, #0
    8c66:	f362 0307 	bfi	r3, r2, #0, #8
    8c6a:	4908      	ldr	r1, [pc, #32]	; (8c8c <usbd_event_transfer_data+0xd4>)
    8c6c:	4a08      	ldr	r2, [pc, #32]	; (8c90 <usbd_event_transfer_data+0xd8>)
    8c6e:	4809      	ldr	r0, [pc, #36]	; (8c94 <usbd_event_transfer_data+0xdc>)
    8c70:	1a89      	subs	r1, r1, r2
    8c72:	08c9      	lsrs	r1, r1, #3
    8c74:	f361 138f 	bfi	r3, r1, #6, #10
    8c78:	4632      	mov	r2, r6
    8c7a:	4621      	mov	r1, r4
}
    8c7c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			LOG_ERR("Unexpected event from nrfx_usbd: %d, ep %d",
    8c80:	f009 b999 	b.w	11fb6 <log_2>
}
    8c84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8c88:	40027000 	.word	0x40027000
    8c8c:	0001644c 	.word	0x0001644c
    8c90:	00016344 	.word	0x00016344
    8c94:	000182bd 	.word	0x000182bd

00008c98 <usbd_event_handler>:

/**
 * @brief nRFx USBD driver event handler function.
 */
static void usbd_event_handler(nrfx_usbd_evt_t const *const p_event)
{
    8c98:	b5f0      	push	{r4, r5, r6, r7, lr}
    8c9a:	4606      	mov	r6, r0
    8c9c:	b089      	sub	sp, #36	; 0x24
	struct nrf_usbd_ep_ctx *ep_ctx;
	struct usbd_event evt = {0};
    8c9e:	2218      	movs	r2, #24
    8ca0:	2100      	movs	r1, #0
    8ca2:	a802      	add	r0, sp, #8
    8ca4:	f7f9 faa1 	bl	21ea <memset>
	bool put_evt = false;

	switch (p_event->type) {
    8ca8:	7833      	ldrb	r3, [r6, #0]
    8caa:	3b01      	subs	r3, #1
    8cac:	2b05      	cmp	r3, #5
    8cae:	d820      	bhi.n	8cf2 <usbd_event_handler+0x5a>
    8cb0:	e8df f003 	tbb	[pc, r3]
    8cb4:	1f1403a8 	.word	0x1f1403a8
    8cb8:	1697      	.short	0x1697
	case NRFX_USBD_EVT_SUSPEND:
		LOG_DBG("SUSPEND state detected.");
		evt.evt_type = USBD_EVT_POWER;
		evt.evt.pwr_evt.state = USBD_SUSPENDED;
    8cba:	2303      	movs	r3, #3
		put_evt = true;
		break;
	case NRFX_USBD_EVT_RESUME:
		LOG_DBG("RESUMING from suspend.");
		evt.evt_type = USBD_EVT_POWER;
		evt.evt.pwr_evt.state = USBD_RESUMED;
    8cbc:	f88d 3014 	strb.w	r3, [sp, #20]
		evt.evt_type = USBD_EVT_POWER;
    8cc0:	2400      	movs	r4, #0
	}

	if (put_evt) {
		struct usbd_event *ev;

		ev = usbd_evt_alloc();
    8cc2:	f7ff ff29 	bl	8b18 <usbd_evt_alloc>
		if (!ev) {
    8cc6:	4603      	mov	r3, r0
    8cc8:	b198      	cbz	r0, 8cf2 <usbd_event_handler+0x5a>
			return;
		}
		ev->evt_type = evt.evt_type;
		ev->evt = evt.evt;
    8cca:	a905      	add	r1, sp, #20
		ev->evt_type = evt.evt_type;
    8ccc:	7504      	strb	r4, [r0, #20]
		ev->evt = evt.evt;
    8cce:	f100 020c 	add.w	r2, r0, #12
    8cd2:	c903      	ldmia	r1, {r0, r1}
    8cd4:	e882 0003 	stmia.w	r2, {r0, r1}
		usbd_evt_put(ev);
    8cd8:	4618      	mov	r0, r3
    8cda:	e01c      	b.n	8d16 <usbd_event_handler+0x7e>
		evt.evt.pwr_evt.state = USBD_RESUMED;
    8cdc:	2304      	movs	r3, #4
    8cde:	e7ed      	b.n	8cbc <usbd_event_handler+0x24>
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
    8ce0:	78b7      	ldrb	r7, [r6, #2]
    8ce2:	4638      	mov	r0, r7
    8ce4:	f7ff fe74 	bl	89d0 <endpoint_ctx>
		switch (ep_ctx->cfg.type) {
    8ce8:	7a83      	ldrb	r3, [r0, #10]
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
    8cea:	4605      	mov	r5, r0
		switch (ep_ctx->cfg.type) {
    8cec:	b11b      	cbz	r3, 8cf6 <usbd_event_handler+0x5e>
    8cee:	2b03      	cmp	r3, #3
    8cf0:	d973      	bls.n	8dda <usbd_event_handler+0x142>
		usbd_work_schedule();
	}
}
    8cf2:	b009      	add	sp, #36	; 0x24
    8cf4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
    8cf6:	063b      	lsls	r3, r7, #24
    8cf8:	78f4      	ldrb	r4, [r6, #3]
    8cfa:	d522      	bpl.n	8d42 <usbd_event_handler+0xaa>
		switch (p_event->data.eptransfer.status) {
    8cfc:	b984      	cbnz	r4, 8d20 <usbd_event_handler+0x88>
			struct usbd_event *ev = usbd_evt_alloc();
    8cfe:	f7ff ff0b 	bl	8b18 <usbd_evt_alloc>
			if (!ev) {
    8d02:	4603      	mov	r3, r0
    8d04:	2800      	cmp	r0, #0
    8d06:	d0f4      	beq.n	8cf2 <usbd_event_handler+0x5a>
			ev->evt_type = USBD_EVT_EP;
    8d08:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
    8d0a:	f885 4022 	strb.w	r4, [r5, #34]	; 0x22
			ev->evt_type = USBD_EVT_EP;
    8d0e:	7502      	strb	r2, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
    8d10:	2203      	movs	r2, #3
    8d12:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
    8d14:	60dd      	str	r5, [r3, #12]
		usbd_evt_put(ev);
    8d16:	f7ff fe7b 	bl	8a10 <usbd_evt_put>
		usbd_work_schedule();
    8d1a:	f7ff fed7 	bl	8acc <usbd_work_schedule>
    8d1e:	e7e8      	b.n	8cf2 <usbd_event_handler+0x5a>
			LOG_ERR(
    8d20:	2201      	movs	r2, #1
    8d22:	f04f 0300 	mov.w	r3, #0
    8d26:	f362 0307 	bfi	r3, r2, #0, #8
    8d2a:	4937      	ldr	r1, [pc, #220]	; (8e08 <usbd_event_handler+0x170>)
    8d2c:	4a37      	ldr	r2, [pc, #220]	; (8e0c <usbd_event_handler+0x174>)
    8d2e:	4838      	ldr	r0, [pc, #224]	; (8e10 <usbd_event_handler+0x178>)
    8d30:	1a89      	subs	r1, r1, r2
    8d32:	08c9      	lsrs	r1, r1, #3
    8d34:	f361 138f 	bfi	r3, r1, #6, #10
    8d38:	463a      	mov	r2, r7
    8d3a:	4621      	mov	r1, r4
			LOG_ERR("Unexpected event from nrfx_usbd: %d, ep %d",
    8d3c:	f009 f93b 	bl	11fb6 <log_2>
		break;
    8d40:	e7d7      	b.n	8cf2 <usbd_event_handler+0x5a>
		switch (p_event->data.eptransfer.status) {
    8d42:	b15c      	cbz	r4, 8d5c <usbd_event_handler+0xc4>
    8d44:	2c01      	cmp	r4, #1
    8d46:	d139      	bne.n	8dbc <usbd_event_handler+0x124>
			struct usbd_event *ev = usbd_evt_alloc();
    8d48:	f7ff fee6 	bl	8b18 <usbd_evt_alloc>
			if (!ev) {
    8d4c:	4603      	mov	r3, r0
    8d4e:	2800      	cmp	r0, #0
    8d50:	d0cf      	beq.n	8cf2 <usbd_event_handler+0x5a>
			ep_ctx->read_pending = true;
    8d52:	f885 4021 	strb.w	r4, [r5, #33]	; 0x21
			ev->evt_type = USBD_EVT_EP;
    8d56:	7504      	strb	r4, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
    8d58:	7404      	strb	r4, [r0, #16]
    8d5a:	e7db      	b.n	8d14 <usbd_event_handler+0x7c>
			struct usbd_event *ev = usbd_evt_alloc();
    8d5c:	f7ff fedc 	bl	8b18 <usbd_evt_alloc>
			if (!ev) {
    8d60:	4604      	mov	r4, r0
    8d62:	2800      	cmp	r0, #0
    8d64:	d0c5      	beq.n	8cf2 <usbd_event_handler+0x5a>
			ev->evt_type = USBD_EVT_EP;
    8d66:	2301      	movs	r3, #1
    8d68:	7503      	strb	r3, [r0, #20]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
    8d6a:	2302      	movs	r3, #2
    8d6c:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
    8d6e:	60c5      	str	r5, [r0, #12]
			err_code = nrfx_usbd_ep_status_get(
    8d70:	f105 010c 	add.w	r1, r5, #12
    8d74:	78b0      	ldrb	r0, [r6, #2]
    8d76:	f009 f89b 	bl	11eb0 <nrfx_usbd_ep_status_get>
			if (err_code != NRFX_USBD_EP_OK) {
    8d7a:	4601      	mov	r1, r0
    8d7c:	b168      	cbz	r0, 8d9a <usbd_event_handler+0x102>
				LOG_ERR("_ep_status_get failed! Code: %d.",
    8d7e:	2301      	movs	r3, #1
    8d80:	f04f 0200 	mov.w	r2, #0
    8d84:	f363 0207 	bfi	r2, r3, #0, #8
    8d88:	4820      	ldr	r0, [pc, #128]	; (8e0c <usbd_event_handler+0x174>)
    8d8a:	4b1f      	ldr	r3, [pc, #124]	; (8e08 <usbd_event_handler+0x170>)
    8d8c:	1a1b      	subs	r3, r3, r0
    8d8e:	08db      	lsrs	r3, r3, #3
    8d90:	f363 128f 	bfi	r2, r3, #6, #10
    8d94:	481f      	ldr	r0, [pc, #124]	; (8e14 <usbd_event_handler+0x17c>)
    8d96:	f009 f8fa 	bl	11f8e <log_1>
			if (ctx->ctrl_read_len > ep_ctx->buf.len) {
    8d9a:	4a1f      	ldr	r2, [pc, #124]	; (8e18 <usbd_event_handler+0x180>)
    8d9c:	68e9      	ldr	r1, [r5, #12]
    8d9e:	f8b2 32b0 	ldrh.w	r3, [r2, #688]	; 0x2b0
    8da2:	428b      	cmp	r3, r1
    8da4:	d906      	bls.n	8db4 <usbd_event_handler+0x11c>
				ctx->ctrl_read_len -= ep_ctx->buf.len;
    8da6:	1a5b      	subs	r3, r3, r1
    8da8:	f8a2 32b0 	strh.w	r3, [r2, #688]	; 0x2b0
				nrfx_usbd_setup_data_clear();
    8dac:	f009 f8ad 	bl	11f0a <nrfx_usbd_setup_data_clear>
			usbd_evt_put(ev);
    8db0:	4620      	mov	r0, r4
    8db2:	e7b0      	b.n	8d16 <usbd_event_handler+0x7e>
				ctx->ctrl_read_len = 0U;
    8db4:	2300      	movs	r3, #0
    8db6:	f8a2 32b0 	strh.w	r3, [r2, #688]	; 0x2b0
    8dba:	e7f9      	b.n	8db0 <usbd_event_handler+0x118>
			LOG_ERR("Unexpected event from nrfx_usbd: %d, ep %d",
    8dbc:	2201      	movs	r2, #1
    8dbe:	f04f 0300 	mov.w	r3, #0
    8dc2:	f362 0307 	bfi	r3, r2, #0, #8
    8dc6:	4910      	ldr	r1, [pc, #64]	; (8e08 <usbd_event_handler+0x170>)
    8dc8:	4a10      	ldr	r2, [pc, #64]	; (8e0c <usbd_event_handler+0x174>)
    8dca:	4814      	ldr	r0, [pc, #80]	; (8e1c <usbd_event_handler+0x184>)
    8dcc:	1a89      	subs	r1, r1, r2
    8dce:	08c9      	lsrs	r1, r1, #3
    8dd0:	f361 138f 	bfi	r3, r1, #6, #10
    8dd4:	463a      	mov	r2, r7
    8dd6:	4621      	mov	r1, r4
    8dd8:	e7b0      	b.n	8d3c <usbd_event_handler+0xa4>
			usbd_event_transfer_data(p_event);
    8dda:	4630      	mov	r0, r6
    8ddc:	f7ff feec 	bl	8bb8 <usbd_event_transfer_data>
	if (put_evt) {
    8de0:	e787      	b.n	8cf2 <usbd_event_handler+0x5a>
		nrfx_usbd_setup_get(&drv_setup);
    8de2:	4668      	mov	r0, sp
    8de4:	f7fd fb9a 	bl	651c <nrfx_usbd_setup_get>
		if ((drv_setup.bRequest != USB_BREQUEST_SETADDRESS)
    8de8:	f89d 3001 	ldrb.w	r3, [sp, #1]
    8dec:	2b05      	cmp	r3, #5
    8dee:	d105      	bne.n	8dfc <usbd_event_handler+0x164>
		    || ((drv_setup.bmRequestType & USB_BMREQUESTTYPE_TYPE_MASK)
    8df0:	f89d 3000 	ldrb.w	r3, [sp]
    8df4:	f013 0f60 	tst.w	r3, #96	; 0x60
    8df8:	f43f af7b 	beq.w	8cf2 <usbd_event_handler+0x5a>
			evt.evt.ep_evt.ep = ep_ctx;
    8dfc:	4b08      	ldr	r3, [pc, #32]	; (8e20 <usbd_event_handler+0x188>)
    8dfe:	9305      	str	r3, [sp, #20]
			evt.evt_type = USBD_EVT_EP;
    8e00:	2401      	movs	r4, #1
    8e02:	e75e      	b.n	8cc2 <usbd_event_handler+0x2a>
		evt.evt_type = USBD_EVT_RESET;
    8e04:	2402      	movs	r4, #2
    8e06:	e75c      	b.n	8cc2 <usbd_event_handler+0x2a>
    8e08:	0001644c 	.word	0x0001644c
    8e0c:	00016344 	.word	0x00016344
    8e10:	00018274 	.word	0x00018274
    8e14:	0001829c 	.word	0x0001829c
    8e18:	20003730 	.word	0x20003730
    8e1c:	000182bd 	.word	0x000182bd
    8e20:	2000389c 	.word	0x2000389c

00008e24 <eps_ctx_init>:
{
    8e24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
    8e26:	2500      	movs	r5, #0
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    8e28:	4f58      	ldr	r7, [pc, #352]	; (8f8c <eps_ctx_init+0x168>)
    8e2a:	462e      	mov	r6, r5
	return endpoint_ctx(NRF_USBD_EPIN(ep));
    8e2c:	f065 007f 	orn	r0, r5, #127	; 0x7f
    8e30:	b2c0      	uxtb	r0, r0
    8e32:	f7ff fdcd 	bl	89d0 <endpoint_ctx>
		if (!ep_ctx->buf.block.data) {
    8e36:	6903      	ldr	r3, [r0, #16]
	return endpoint_ctx(NRF_USBD_EPIN(ep));
    8e38:	4604      	mov	r4, r0
		if (!ep_ctx->buf.block.data) {
    8e3a:	b9cb      	cbnz	r3, 8e70 <eps_ctx_init+0x4c>
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    8e3c:	f100 0110 	add.w	r1, r0, #16
    8e40:	2240      	movs	r2, #64	; 0x40
    8e42:	4638      	mov	r0, r7
    8e44:	f005 ff72 	bl	ed2c <k_mem_pool_alloc>
			if (err < 0) {
    8e48:	2800      	cmp	r0, #0
    8e4a:	da11      	bge.n	8e70 <eps_ctx_init+0x4c>
				LOG_ERR("EP buffer alloc failed for EPIN%d", i);
    8e4c:	2301      	movs	r3, #1
    8e4e:	f04f 0200 	mov.w	r2, #0
    8e52:	f363 0207 	bfi	r2, r3, #0, #8
    8e56:	494e      	ldr	r1, [pc, #312]	; (8f90 <eps_ctx_init+0x16c>)
    8e58:	4b4e      	ldr	r3, [pc, #312]	; (8f94 <eps_ctx_init+0x170>)
    8e5a:	484f      	ldr	r0, [pc, #316]	; (8f98 <eps_ctx_init+0x174>)
    8e5c:	1a5b      	subs	r3, r3, r1
    8e5e:	08db      	lsrs	r3, r3, #3
    8e60:	f363 128f 	bfi	r2, r3, #6, #10
    8e64:	4629      	mov	r1, r5
				LOG_ERR("EP buffer alloc failed for EPOUT%d", i);
    8e66:	f009 f892 	bl	11f8e <log_1>
				return -ENOMEM;
    8e6a:	f06f 000b 	mvn.w	r0, #11
}
    8e6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ep_ctx->buf.data = ep_ctx->buf.block.data;
    8e70:	6923      	ldr	r3, [r4, #16]
	ep_ctx->buf.len  = 0U;
    8e72:	60e6      	str	r6, [r4, #12]
	ep_ctx->buf.curr = ep_ctx->buf.data;
    8e74:	e9c4 3306 	strd	r3, r3, [r4, #24]
	ep_ctx->read_complete = true;
    8e78:	2301      	movs	r3, #1
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
    8e7a:	441d      	add	r5, r3
    8e7c:	2d08      	cmp	r5, #8
	ep_ctx->read_complete = true;
    8e7e:	f884 3020 	strb.w	r3, [r4, #32]
	ep_ctx->read_pending = false;
    8e82:	f884 6021 	strb.w	r6, [r4, #33]	; 0x21
	ep_ctx->write_in_progress = false;
    8e86:	f884 6022 	strb.w	r6, [r4, #34]	; 0x22
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
    8e8a:	d1cf      	bne.n	8e2c <eps_ctx_init+0x8>
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
    8e8c:	2500      	movs	r5, #0
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    8e8e:	4f3f      	ldr	r7, [pc, #252]	; (8f8c <eps_ctx_init+0x168>)
    8e90:	462e      	mov	r6, r5
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
    8e92:	b2e8      	uxtb	r0, r5
    8e94:	f7ff fd9c 	bl	89d0 <endpoint_ctx>
		if (!ep_ctx->buf.block.data) {
    8e98:	6903      	ldr	r3, [r0, #16]
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
    8e9a:	4604      	mov	r4, r0
		if (!ep_ctx->buf.block.data) {
    8e9c:	b9ab      	cbnz	r3, 8eca <eps_ctx_init+0xa6>
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    8e9e:	f100 0110 	add.w	r1, r0, #16
    8ea2:	2240      	movs	r2, #64	; 0x40
    8ea4:	4638      	mov	r0, r7
    8ea6:	f005 ff41 	bl	ed2c <k_mem_pool_alloc>
			if (err < 0) {
    8eaa:	2800      	cmp	r0, #0
    8eac:	da0d      	bge.n	8eca <eps_ctx_init+0xa6>
				LOG_ERR("EP buffer alloc failed for EPOUT%d", i);
    8eae:	2301      	movs	r3, #1
    8eb0:	f04f 0200 	mov.w	r2, #0
    8eb4:	f363 0207 	bfi	r2, r3, #0, #8
    8eb8:	4935      	ldr	r1, [pc, #212]	; (8f90 <eps_ctx_init+0x16c>)
    8eba:	4b36      	ldr	r3, [pc, #216]	; (8f94 <eps_ctx_init+0x170>)
    8ebc:	4837      	ldr	r0, [pc, #220]	; (8f9c <eps_ctx_init+0x178>)
    8ebe:	1a5b      	subs	r3, r3, r1
    8ec0:	08db      	lsrs	r3, r3, #3
    8ec2:	f363 128f 	bfi	r2, r3, #6, #10
    8ec6:	4629      	mov	r1, r5
    8ec8:	e7cd      	b.n	8e66 <eps_ctx_init+0x42>
	ep_ctx->buf.data = ep_ctx->buf.block.data;
    8eca:	6923      	ldr	r3, [r4, #16]
	ep_ctx->buf.len  = 0U;
    8ecc:	60e6      	str	r6, [r4, #12]
	ep_ctx->buf.curr = ep_ctx->buf.data;
    8ece:	e9c4 3306 	strd	r3, r3, [r4, #24]
	ep_ctx->read_complete = true;
    8ed2:	2301      	movs	r3, #1
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
    8ed4:	441d      	add	r5, r3
    8ed6:	2d08      	cmp	r5, #8
	ep_ctx->read_complete = true;
    8ed8:	f884 3020 	strb.w	r3, [r4, #32]
	ep_ctx->read_pending = false;
    8edc:	f884 6021 	strb.w	r6, [r4, #33]	; 0x21
	ep_ctx->write_in_progress = false;
    8ee0:	f884 6022 	strb.w	r6, [r4, #34]	; 0x22
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
    8ee4:	d1d5      	bne.n	8e92 <eps_ctx_init+0x6e>
		if (!ep_ctx->buf.block.data) {
    8ee6:	492e      	ldr	r1, [pc, #184]	; (8fa0 <eps_ctx_init+0x17c>)
    8ee8:	f8d1 3158 	ldr.w	r3, [r1, #344]	; 0x158
    8eec:	460c      	mov	r4, r1
    8eee:	b9bb      	cbnz	r3, 8f20 <eps_ctx_init+0xfc>
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    8ef0:	f44f 6280 	mov.w	r2, #1024	; 0x400
    8ef4:	f501 71ac 	add.w	r1, r1, #344	; 0x158
    8ef8:	4824      	ldr	r0, [pc, #144]	; (8f8c <eps_ctx_init+0x168>)
    8efa:	f005 ff17 	bl	ed2c <k_mem_pool_alloc>
			if (err < 0) {
    8efe:	2800      	cmp	r0, #0
    8f00:	da0e      	bge.n	8f20 <eps_ctx_init+0xfc>
				LOG_ERR("EP buffer alloc failed for ISOIN");
    8f02:	2301      	movs	r3, #1
    8f04:	f04f 0100 	mov.w	r1, #0
    8f08:	f363 0107 	bfi	r1, r3, #0, #8
    8f0c:	4a20      	ldr	r2, [pc, #128]	; (8f90 <eps_ctx_init+0x16c>)
    8f0e:	4b21      	ldr	r3, [pc, #132]	; (8f94 <eps_ctx_init+0x170>)
    8f10:	4824      	ldr	r0, [pc, #144]	; (8fa4 <eps_ctx_init+0x180>)
    8f12:	1a9b      	subs	r3, r3, r2
    8f14:	08db      	lsrs	r3, r3, #3
    8f16:	f363 118f 	bfi	r1, r3, #6, #10
				LOG_ERR("EP buffer alloc failed for ISOOUT");
    8f1a:	f009 f82b 	bl	11f74 <log_0>
    8f1e:	e7a4      	b.n	8e6a <eps_ctx_init+0x46>
	ep_ctx->buf.data = ep_ctx->buf.block.data;
    8f20:	f8d4 3158 	ldr.w	r3, [r4, #344]	; 0x158
	ep_ctx->read_complete = true;
    8f24:	2201      	movs	r2, #1
	ep_ctx->buf.curr = ep_ctx->buf.data;
    8f26:	e9c4 3358 	strd	r3, r3, [r4, #352]	; 0x160
	ep_ctx->buf.len  = 0U;
    8f2a:	2300      	movs	r3, #0
	ep_ctx->read_complete = true;
    8f2c:	f884 2168 	strb.w	r2, [r4, #360]	; 0x168
	ep_ctx->buf.len  = 0U;
    8f30:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
	ep_ctx->read_pending = false;
    8f34:	f884 3169 	strb.w	r3, [r4, #361]	; 0x169
	ep_ctx->write_in_progress = false;
    8f38:	f884 316a 	strb.w	r3, [r4, #362]	; 0x16a
		if (!ep_ctx->buf.block.data) {
    8f3c:	f8d4 329c 	ldr.w	r3, [r4, #668]	; 0x29c
    8f40:	b9a3      	cbnz	r3, 8f6c <eps_ctx_init+0x148>
			err = k_mem_pool_alloc(&ep_buf_pool, &ep_ctx->buf.block,
    8f42:	f44f 6280 	mov.w	r2, #1024	; 0x400
    8f46:	4918      	ldr	r1, [pc, #96]	; (8fa8 <eps_ctx_init+0x184>)
    8f48:	4810      	ldr	r0, [pc, #64]	; (8f8c <eps_ctx_init+0x168>)
    8f4a:	f005 feef 	bl	ed2c <k_mem_pool_alloc>
			if (err < 0) {
    8f4e:	2800      	cmp	r0, #0
    8f50:	da0c      	bge.n	8f6c <eps_ctx_init+0x148>
				LOG_ERR("EP buffer alloc failed for ISOOUT");
    8f52:	2301      	movs	r3, #1
    8f54:	f04f 0100 	mov.w	r1, #0
    8f58:	f363 0107 	bfi	r1, r3, #0, #8
    8f5c:	4a0c      	ldr	r2, [pc, #48]	; (8f90 <eps_ctx_init+0x16c>)
    8f5e:	4b0d      	ldr	r3, [pc, #52]	; (8f94 <eps_ctx_init+0x170>)
    8f60:	4812      	ldr	r0, [pc, #72]	; (8fac <eps_ctx_init+0x188>)
    8f62:	1a9b      	subs	r3, r3, r2
    8f64:	08db      	lsrs	r3, r3, #3
    8f66:	f363 118f 	bfi	r1, r3, #6, #10
    8f6a:	e7d6      	b.n	8f1a <eps_ctx_init+0xf6>
	ep_ctx->buf.data = ep_ctx->buf.block.data;
    8f6c:	f8d4 329c 	ldr.w	r3, [r4, #668]	; 0x29c
	ep_ctx->buf.len  = 0U;
    8f70:	2000      	movs	r0, #0
	ep_ctx->buf.curr = ep_ctx->buf.data;
    8f72:	e9c4 33a9 	strd	r3, r3, [r4, #676]	; 0x2a4
	ep_ctx->read_complete = true;
    8f76:	2301      	movs	r3, #1
    8f78:	f884 32ac 	strb.w	r3, [r4, #684]	; 0x2ac
	ep_ctx->buf.len  = 0U;
    8f7c:	f8c4 0298 	str.w	r0, [r4, #664]	; 0x298
	ep_ctx->read_pending = false;
    8f80:	f884 02ad 	strb.w	r0, [r4, #685]	; 0x2ad
	ep_ctx->write_in_progress = false;
    8f84:	f884 02ae 	strb.w	r0, [r4, #686]	; 0x2ae
    8f88:	e771      	b.n	8e6e <eps_ctx_init+0x4a>
    8f8a:	bf00      	nop
    8f8c:	20011d3c 	.word	0x20011d3c
    8f90:	00016344 	.word	0x00016344
    8f94:	0001644c 	.word	0x0001644c
    8f98:	000180d7 	.word	0x000180d7
    8f9c:	000180f9 	.word	0x000180f9
    8fa0:	20003730 	.word	0x20003730
    8fa4:	0001811c 	.word	0x0001811c
    8fa8:	200039cc 	.word	0x200039cc
    8fac:	0001813d 	.word	0x0001813d

00008fb0 <usbd_work_handler>:
}


/* Work handler */
static void usbd_work_handler(struct k_work *item)
{
    8fb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8fb4:	4ba7      	ldr	r3, [pc, #668]	; (9254 <usbd_work_handler+0x2a4>)
				ctx->status_cb(USB_DC_SOF, NULL);
			}
			break;
		case USBD_EVT_REINIT: {
				/* Reinitialize the peripheral after queue overflow. */
				LOG_ERR("USBD event queue full!");
    8fb6:	4aa8      	ldr	r2, [pc, #672]	; (9258 <usbd_work_handler+0x2a8>)
	return get_usbd_ctx()->ready;
    8fb8:	4da8      	ldr	r5, [pc, #672]	; (925c <usbd_work_handler+0x2ac>)
{
    8fba:	b087      	sub	sp, #28
				LOG_ERR("USBD event queue full!");
    8fbc:	1a9b      	subs	r3, r3, r2
    8fbe:	f3c3 03c9 	ubfx	r3, r3, #3, #10
{
    8fc2:	4607      	mov	r7, r0
				LOG_ERR("USBD event queue full!");
    8fc4:	9300      	str	r3, [sp, #0]
    8fc6:	2100      	movs	r1, #0
    8fc8:	48a5      	ldr	r0, [pc, #660]	; (9260 <usbd_work_handler+0x2b0>)
    8fca:	f00c fd9a 	bl	15b02 <z_impl_k_queue_get>
	while ((ev = usbd_evt_get()) != NULL) {
    8fce:	4606      	mov	r6, r0
    8fd0:	b910      	cbnz	r0, 8fd8 <usbd_work_handler+0x28>
			LOG_ERR("Unknown USBD event: %"PRId16".", ev->evt_type);
			break;
		}
		usbd_evt_free(ev);
	}
}
    8fd2:	b007      	add	sp, #28
    8fd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return get_usbd_ctx()->ready;
    8fd8:	796b      	ldrb	r3, [r5, #5]
    8fda:	7d31      	ldrb	r1, [r6, #20]
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
    8fdc:	b95b      	cbnz	r3, 8ff6 <usbd_work_handler+0x46>
    8fde:	2900      	cmp	r1, #0
    8fe0:	d1f1      	bne.n	8fc6 <usbd_work_handler+0x16>
	switch (pwr_evt->state) {
    8fe2:	7b32      	ldrb	r2, [r6, #12]
    8fe4:	2a04      	cmp	r2, #4
    8fe6:	d865      	bhi.n	90b4 <usbd_work_handler+0x104>
    8fe8:	e8df f012 	tbh	[pc, r2, lsl #1]
    8fec:	00b400f3 	.word	0x00b400f3
    8ff0:	010100be 	.word	0x010100be
    8ff4:	010d      	.short	0x010d
		switch (ev->evt_type) {
    8ff6:	2904      	cmp	r1, #4
    8ff8:	f200 815d 	bhi.w	92b6 <usbd_work_handler+0x306>
    8ffc:	a201      	add	r2, pc, #4	; (adr r2, 9004 <usbd_work_handler+0x54>)
    8ffe:	f852 f021 	ldr.w	pc, [r2, r1, lsl #2]
    9002:	bf00      	nop
    9004:	00008fe3 	.word	0x00008fe3
    9008:	00009019 	.word	0x00009019
    900c:	0000921d 	.word	0x0000921d
    9010:	00009245 	.word	0x00009245
    9014:	00009279 	.word	0x00009279
			if (!ctx->attached) {
    9018:	f817 3c04 	ldrb.w	r3, [r7, #-4]
    901c:	b973      	cbnz	r3, 903c <usbd_work_handler+0x8c>
				LOG_ERR("EP %d event dropped (not attached).",
    901e:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
    9022:	f043 0301 	orr.w	r3, r3, #1
    9026:	f363 0907 	bfi	r9, r3, #0, #8
    902a:	9b00      	ldr	r3, [sp, #0]
    902c:	68f1      	ldr	r1, [r6, #12]
    902e:	488d      	ldr	r0, [pc, #564]	; (9264 <usbd_work_handler+0x2b4>)
    9030:	7a49      	ldrb	r1, [r1, #9]
    9032:	f363 198f 	bfi	r9, r3, #6, #10
    9036:	464a      	mov	r2, r9
    9038:	f008 ffa9 	bl	11f8e <log_1>
	switch (ep_evt->evt_type) {
    903c:	7c33      	ldrb	r3, [r6, #16]
	struct nrf_usbd_ep_ctx *ep_ctx = ep_evt->ep;
    903e:	68f4      	ldr	r4, [r6, #12]
	switch (ep_evt->evt_type) {
    9040:	2b03      	cmp	r3, #3
    9042:	d837      	bhi.n	90b4 <usbd_work_handler+0x104>
    9044:	e8df f003 	tbb	[pc, r3]
    9048:	746f3e02 	.word	0x746f3e02
	usbd_setup = (struct usb_setup_packet *)ep_ctx->buf.data;
    904c:	69a3      	ldr	r3, [r4, #24]
    return (uint8_t)(NRF_USBD->BMREQUESTTYPE);
    904e:	4a86      	ldr	r2, [pc, #536]	; (9268 <usbd_work_handler+0x2b8>)
__ssp_bos_icheck3(memset, void *, int)
    9050:	2100      	movs	r1, #0
    9052:	6019      	str	r1, [r3, #0]
    9054:	6059      	str	r1, [r3, #4]
    9056:	f8d2 0480 	ldr.w	r0, [r2, #1152]	; 0x480
    905a:	7018      	strb	r0, [r3, #0]
    return (uint8_t)(NRF_USBD->BREQUEST);
    905c:	f8d2 0484 	ldr.w	r0, [r2, #1156]	; 0x484
    9060:	7058      	strb	r0, [r3, #1]
    const uint16_t val = NRF_USBD->WVALUEL;
    9062:	f8d2 0488 	ldr.w	r0, [r2, #1160]	; 0x488
    return (uint16_t)(val | ((NRF_USBD->WVALUEH) << 8));
    9066:	f8d2 c48c 	ldr.w	ip, [r2, #1164]	; 0x48c
    906a:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
	usbd_setup->wValue = nrf_usbd_setup_wvalue_get();
    906e:	8058      	strh	r0, [r3, #2]
    const uint16_t val = NRF_USBD->WINDEXL;
    9070:	f8d2 0490 	ldr.w	r0, [r2, #1168]	; 0x490
    return (uint16_t)(val | ((NRF_USBD->WINDEXH) << 8));
    9074:	f8d2 c494 	ldr.w	ip, [r2, #1172]	; 0x494
    9078:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
	usbd_setup->wIndex = nrf_usbd_setup_windex_get();
    907c:	8098      	strh	r0, [r3, #4]
    const uint16_t val = NRF_USBD->WLENGTHL;
    907e:	f8d2 0498 	ldr.w	r0, [r2, #1176]	; 0x498
    return (uint16_t)(val | ((NRF_USBD->WLENGTHH) << 8));
    9082:	f8d2 249c 	ldr.w	r2, [r2, #1180]	; 0x49c
	usbd_setup->wLength = nrf_usbd_setup_wlength_get();
    9086:	9301      	str	r3, [sp, #4]
    9088:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
    908c:	80da      	strh	r2, [r3, #6]
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
    908e:	2208      	movs	r2, #8
    9090:	60e2      	str	r2, [r4, #12]
	ep_ctx->cfg.cb(ep_ctx->cfg.addr, USB_DC_EP_SETUP);
    9092:	7a60      	ldrb	r0, [r4, #9]
    9094:	6822      	ldr	r2, [r4, #0]
    9096:	4790      	blx	r2
	if (((usbd_setup->bmRequestType & USB_BMREQUESTTYPE_DIR_MASK)
    9098:	9b01      	ldr	r3, [sp, #4]
    909a:	f993 2000 	ldrsb.w	r2, [r3]
    909e:	2a00      	cmp	r2, #0
    90a0:	db0c      	blt.n	90bc <usbd_work_handler+0x10c>
	    && (usbd_setup->wLength)) {
    90a2:	88da      	ldrh	r2, [r3, #6]
    90a4:	b152      	cbz	r2, 90bc <usbd_work_handler+0x10c>
		ctx->ctrl_read_len -= usbd_setup->wLength;
    90a6:	f8b5 32b0 	ldrh.w	r3, [r5, #688]	; 0x2b0
    90aa:	1a9b      	subs	r3, r3, r2
    90ac:	f8a5 32b0 	strh.w	r3, [r5, #688]	; 0x2b0
		nrfx_usbd_setup_data_clear();
    90b0:	f008 ff2b 	bl	11f0a <nrfx_usbd_setup_data_clear>
	k_mem_pool_free(&ev->block);
    90b4:	1d30      	adds	r0, r6, #4
    90b6:	f00c fc6d 	bl	15994 <k_mem_pool_free>
    90ba:	e784      	b.n	8fc6 <usbd_work_handler+0x16>
		ctx->ctrl_read_len = 0U;
    90bc:	2300      	movs	r3, #0
    90be:	f8a5 32b0 	strh.w	r3, [r5, #688]	; 0x2b0
    90c2:	e7f7      	b.n	90b4 <usbd_work_handler+0x104>
	if (!ep_ctx->read_pending) {
    90c4:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    90c8:	2b00      	cmp	r3, #0
    90ca:	d0f3      	beq.n	90b4 <usbd_work_handler+0x104>
	if (!ep_ctx->read_complete) {
    90cc:	f894 3020 	ldrb.w	r3, [r4, #32]
    90d0:	2b00      	cmp	r3, #0
    90d2:	d0ef      	beq.n	90b4 <usbd_work_handler+0x104>
	ep_ctx->read_pending = false;
    90d4:	2300      	movs	r3, #0
    90d6:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    90da:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
	ep_ctx->read_complete = false;
    90de:	f884 3020 	strb.w	r3, [r4, #32]
    90e2:	4862      	ldr	r0, [pc, #392]	; (926c <usbd_work_handler+0x2bc>)
    90e4:	f005 fec2 	bl	ee6c <z_impl_k_mutex_lock>
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
    90e8:	69a2      	ldr	r2, [r4, #24]
    90ea:	9203      	str	r2, [sp, #12]
    90ec:	2300      	movs	r3, #0
    90ee:	6862      	ldr	r2, [r4, #4]
    90f0:	9305      	str	r3, [sp, #20]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
    90f2:	a903      	add	r1, sp, #12
    90f4:	7a60      	ldrb	r0, [r4, #9]
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
    90f6:	9204      	str	r2, [sp, #16]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
    90f8:	f7fc ff94 	bl	6024 <nrfx_usbd_ep_transfer>
	if (err != NRFX_SUCCESS) {
    90fc:	4b5c      	ldr	r3, [pc, #368]	; (9270 <usbd_work_handler+0x2c0>)
    90fe:	4298      	cmp	r0, r3
	nrfx_err_t err = nrfx_usbd_ep_transfer(
    9100:	4601      	mov	r1, r0
	if (err != NRFX_SUCCESS) {
    9102:	d00c      	beq.n	911e <usbd_work_handler+0x16e>
		LOG_ERR("nRF USBD transfer error (OUT): %d.", err);
    9104:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
    9108:	f043 0301 	orr.w	r3, r3, #1
    910c:	f363 0807 	bfi	r8, r3, #0, #8
    9110:	9b00      	ldr	r3, [sp, #0]
    9112:	4858      	ldr	r0, [pc, #352]	; (9274 <usbd_work_handler+0x2c4>)
    9114:	f363 188f 	bfi	r8, r3, #6, #10
    9118:	4642      	mov	r2, r8
    911a:	f008 ff38 	bl	11f8e <log_1>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    911e:	4853      	ldr	r0, [pc, #332]	; (926c <usbd_work_handler+0x2bc>)
    9120:	f005 ff14 	bl	ef4c <z_impl_k_mutex_unlock>
    9124:	e7c6      	b.n	90b4 <usbd_work_handler+0x104>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
    9126:	6823      	ldr	r3, [r4, #0]
    9128:	2101      	movs	r1, #1
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
    912a:	7a60      	ldrb	r0, [r4, #9]
    912c:	4798      	blx	r3
		break;
    912e:	e7c1      	b.n	90b4 <usbd_work_handler+0x104>
		if ((ep_ctx->cfg.type == USB_DC_EP_CONTROL)
    9130:	7aa3      	ldrb	r3, [r4, #10]
    9132:	b963      	cbnz	r3, 914e <usbd_work_handler+0x19e>
		    && (!ep_ctx->write_fragmented)) {
    9134:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    9138:	b94b      	cbnz	r3, 914e <usbd_work_handler+0x19e>
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    913a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    913e:	484b      	ldr	r0, [pc, #300]	; (926c <usbd_work_handler+0x2bc>)
    9140:	f005 fe94 	bl	ee6c <z_impl_k_mutex_lock>
			nrfx_usbd_setup_clear();
    9144:	f008 fef6 	bl	11f34 <nrfx_usbd_setup_clear>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    9148:	4848      	ldr	r0, [pc, #288]	; (926c <usbd_work_handler+0x2bc>)
    914a:	f005 feff 	bl	ef4c <z_impl_k_mutex_unlock>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
    914e:	6823      	ldr	r3, [r4, #0]
    9150:	2102      	movs	r1, #2
    9152:	e7ea      	b.n	912a <usbd_work_handler+0x17a>
		if (!nrfx_usbd_is_enabled()) {
    9154:	f7fc fedc 	bl	5f10 <nrfx_usbd_is_enabled>
    9158:	2800      	cmp	r0, #0
    915a:	d1ab      	bne.n	90b4 <usbd_work_handler+0x104>
			nrfx_usbd_enable();
    915c:	f7fc fdda 	bl	5d14 <nrfx_usbd_enable>
			(void) hf_clock_enable(true, false);
    9160:	2001      	movs	r0, #1
    9162:	f7ff fc5b 	bl	8a1c <hf_clock_enable.constprop.9>
    9166:	e7a5      	b.n	90b4 <usbd_work_handler+0x104>
	for (i = 0; i < CFG_EPIN_CNT; i++) {
    9168:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
    916a:	f064 007f 	orn	r0, r4, #127	; 0x7f
    916e:	b2c0      	uxtb	r0, r0
    9170:	f7ff fc2e 	bl	89d0 <endpoint_ctx>
		if (ep_ctx->cfg.en) {
    9174:	7a03      	ldrb	r3, [r0, #8]
    9176:	b113      	cbz	r3, 917e <usbd_work_handler+0x1ce>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    9178:	7a40      	ldrb	r0, [r0, #9]
    917a:	f7fd fcb5 	bl	6ae8 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPIN_CNT; i++) {
    917e:	3401      	adds	r4, #1
    9180:	2c08      	cmp	r4, #8
    9182:	d1f2      	bne.n	916a <usbd_work_handler+0x1ba>
		if (ep_ctx->cfg.en) {
    9184:	f895 3150 	ldrb.w	r3, [r5, #336]	; 0x150
    9188:	b11b      	cbz	r3, 9192 <usbd_work_handler+0x1e2>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    918a:	f895 0151 	ldrb.w	r0, [r5, #337]	; 0x151
    918e:	f7fd fcab 	bl	6ae8 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPIN_CNT; i++) {
    9192:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
    9194:	b2e0      	uxtb	r0, r4
    9196:	f7ff fc1b 	bl	89d0 <endpoint_ctx>
		if (ep_ctx->cfg.en) {
    919a:	7a03      	ldrb	r3, [r0, #8]
    919c:	b113      	cbz	r3, 91a4 <usbd_work_handler+0x1f4>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    919e:	7a40      	ldrb	r0, [r0, #9]
    91a0:	f7fd fca2 	bl	6ae8 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPOUT_CNT; i++) {
    91a4:	3401      	adds	r4, #1
    91a6:	2c08      	cmp	r4, #8
    91a8:	d1f4      	bne.n	9194 <usbd_work_handler+0x1e4>
		if (ep_ctx->cfg.en) {
    91aa:	f895 3294 	ldrb.w	r3, [r5, #660]	; 0x294
    91ae:	b11b      	cbz	r3, 91b8 <usbd_work_handler+0x208>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
    91b0:	f895 0295 	ldrb.w	r0, [r5, #661]	; 0x295
    91b4:	f7fd fc98 	bl	6ae8 <nrfx_usbd_ep_enable>
		nrfx_usbd_start(true);
    91b8:	2001      	movs	r0, #1
    91ba:	f7fc fe71 	bl	5ea0 <nrfx_usbd_start>
		ctx->ready = true;
    91be:	2301      	movs	r3, #1
    91c0:	716b      	strb	r3, [r5, #5]
		if (ctx->status_cb) {
    91c2:	682b      	ldr	r3, [r5, #0]
    91c4:	2b00      	cmp	r3, #0
    91c6:	f43f af75 	beq.w	90b4 <usbd_work_handler+0x104>
			ctx->status_cb(USB_DC_CONNECTED, NULL);
    91ca:	2100      	movs	r1, #0
    91cc:	2002      	movs	r0, #2
				ctx->status_cb(USB_DC_SOF, NULL);
    91ce:	4798      	blx	r3
    91d0:	e770      	b.n	90b4 <usbd_work_handler+0x104>
		ctx->ready = false;
    91d2:	2400      	movs	r4, #0
    91d4:	716c      	strb	r4, [r5, #5]
		nrfx_usbd_disable();
    91d6:	f7fd fc33 	bl	6a40 <nrfx_usbd_disable>
		(void) hf_clock_enable(false, false);
    91da:	4620      	mov	r0, r4
    91dc:	f7ff fc1e 	bl	8a1c <hf_clock_enable.constprop.9>
		if (ctx->status_cb) {
    91e0:	682b      	ldr	r3, [r5, #0]
    91e2:	2b00      	cmp	r3, #0
    91e4:	f43f af66 	beq.w	90b4 <usbd_work_handler+0x104>
			ctx->status_cb(USB_DC_DISCONNECTED, NULL);
    91e8:	4621      	mov	r1, r4
    91ea:	2004      	movs	r0, #4
    91ec:	e7ef      	b.n	91ce <usbd_work_handler+0x21e>
		if (dev_ready()) {
    91ee:	2b00      	cmp	r3, #0
    91f0:	f43f af60 	beq.w	90b4 <usbd_work_handler+0x104>
			nrfx_usbd_suspend();
    91f4:	f7fd fc4c 	bl	6a90 <nrfx_usbd_suspend>
			if (ctx->status_cb) {
    91f8:	682b      	ldr	r3, [r5, #0]
    91fa:	2b00      	cmp	r3, #0
    91fc:	f43f af5a 	beq.w	90b4 <usbd_work_handler+0x104>
				ctx->status_cb(USB_DC_SUSPEND, NULL);
    9200:	2100      	movs	r1, #0
    9202:	2005      	movs	r0, #5
    9204:	e7e3      	b.n	91ce <usbd_work_handler+0x21e>
		if (ctx->status_cb && dev_ready()) {
    9206:	682a      	ldr	r2, [r5, #0]
    9208:	2a00      	cmp	r2, #0
    920a:	f43f af53 	beq.w	90b4 <usbd_work_handler+0x104>
    920e:	2b00      	cmp	r3, #0
    9210:	f43f af50 	beq.w	90b4 <usbd_work_handler+0x104>
			ctx->status_cb(USB_DC_RESUME, NULL);
    9214:	2100      	movs	r1, #0
    9216:	2006      	movs	r0, #6
    9218:	4790      	blx	r2
    921a:	e74b      	b.n	90b4 <usbd_work_handler+0x104>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
    921c:	f107 040c 	add.w	r4, r7, #12
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    9220:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    9224:	4620      	mov	r0, r4
    9226:	f005 fe21 	bl	ee6c <z_impl_k_mutex_lock>
			eps_ctx_init();
    922a:	f7ff fdfb 	bl	8e24 <eps_ctx_init>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    922e:	4620      	mov	r0, r4
    9230:	f005 fe8c 	bl	ef4c <z_impl_k_mutex_unlock>
			if (ctx->status_cb) {
    9234:	f857 3c08 	ldr.w	r3, [r7, #-8]
    9238:	2b00      	cmp	r3, #0
    923a:	f43f af3b 	beq.w	90b4 <usbd_work_handler+0x104>
				ctx->status_cb(USB_DC_RESET, NULL);
    923e:	2100      	movs	r1, #0
    9240:	2001      	movs	r0, #1
    9242:	e7c4      	b.n	91ce <usbd_work_handler+0x21e>
			if (ctx->status_cb) {
    9244:	f857 3c08 	ldr.w	r3, [r7, #-8]
    9248:	2b00      	cmp	r3, #0
    924a:	f43f af33 	beq.w	90b4 <usbd_work_handler+0x104>
				ctx->status_cb(USB_DC_SOF, NULL);
    924e:	2100      	movs	r1, #0
    9250:	200a      	movs	r0, #10
    9252:	e7bc      	b.n	91ce <usbd_work_handler+0x21e>
    9254:	0001644c 	.word	0x0001644c
    9258:	00016344 	.word	0x00016344
    925c:	20003730 	.word	0x20003730
    9260:	20011dec 	.word	0x20011dec
    9264:	00018323 	.word	0x00018323
    9268:	40027000 	.word	0x40027000
    926c:	20003744 	.word	0x20003744
    9270:	0bad0000 	.word	0x0bad0000
    9274:	00018347 	.word	0x00018347
				LOG_ERR("USBD event queue full!");
    9278:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
    927c:	f043 0301 	orr.w	r3, r3, #1
    9280:	f363 0a07 	bfi	sl, r3, #0, #8
    9284:	9b00      	ldr	r3, [sp, #0]
    9286:	4813      	ldr	r0, [pc, #76]	; (92d4 <usbd_work_handler+0x324>)
    9288:	f363 1a8f 	bfi	sl, r3, #6, #10
    928c:	4651      	mov	r1, sl
    928e:	f008 fe71 	bl	11f74 <log_0>
	nrf5_power_usb_power_int_enable(false);
    9292:	2000      	movs	r0, #0
    9294:	f009 fe9f 	bl	12fd6 <nrf5_power_usb_power_int_enable>
	nrfx_usbd_disable();
    9298:	f7fd fbd2 	bl	6a40 <nrfx_usbd_disable>
	nrfx_usbd_uninit();
    929c:	f7fc fd1e 	bl	5cdc <nrfx_usbd_uninit>
	usbd_evt_flush();
    92a0:	f7ff fc2c 	bl	8afc <usbd_evt_flush>
	ret = eps_ctx_init();
    92a4:	f7ff fdbe 	bl	8e24 <eps_ctx_init>
	nrf5_power_usb_power_int_enable(true);
    92a8:	2001      	movs	r0, #1
    92aa:	f009 fe94 	bl	12fd6 <nrf5_power_usb_power_int_enable>
	err = nrfx_usbd_init(usbd_event_handler);
    92ae:	480a      	ldr	r0, [pc, #40]	; (92d8 <usbd_work_handler+0x328>)
    92b0:	f7fc fe68 	bl	5f84 <nrfx_usbd_init>
		__ASSERT_NO_MSG(0);
    92b4:	e6fe      	b.n	90b4 <usbd_work_handler+0x104>
			LOG_ERR("Unknown USBD event: %"PRId16".", ev->evt_type);
    92b6:	f02b 033f 	bic.w	r3, fp, #63	; 0x3f
    92ba:	f043 0301 	orr.w	r3, r3, #1
    92be:	f363 0b07 	bfi	fp, r3, #0, #8
    92c2:	9b00      	ldr	r3, [sp, #0]
    92c4:	4805      	ldr	r0, [pc, #20]	; (92dc <usbd_work_handler+0x32c>)
    92c6:	f363 1b8f 	bfi	fp, r3, #6, #10
    92ca:	465a      	mov	r2, fp
    92cc:	f008 fe5f 	bl	11f8e <log_1>
			break;
    92d0:	e6f0      	b.n	90b4 <usbd_work_handler+0x104>
    92d2:	bf00      	nop
    92d4:	0001836a 	.word	0x0001836a
    92d8:	00008c99 	.word	0x00008c99
    92dc:	00018381 	.word	0x00018381

000092e0 <usb_dc_nrfx_power_event_callback>:
	switch (event) {
    92e0:	f5b0 7f90 	cmp.w	r0, #288	; 0x120
{
    92e4:	b510      	push	{r4, lr}
	switch (event) {
    92e6:	d015      	beq.n	9314 <usb_dc_nrfx_power_event_callback+0x34>
    92e8:	f5b0 7f92 	cmp.w	r0, #292	; 0x124
    92ec:	d022      	beq.n	9334 <usb_dc_nrfx_power_event_callback+0x54>
    92ee:	f5b0 7f8e 	cmp.w	r0, #284	; 0x11c
    92f2:	d021      	beq.n	9338 <usb_dc_nrfx_power_event_callback+0x58>
		LOG_ERR("Unknown USB power event");
    92f4:	2301      	movs	r3, #1
    92f6:	f04f 0100 	mov.w	r1, #0
    92fa:	f363 0107 	bfi	r1, r3, #0, #8
    92fe:	4a10      	ldr	r2, [pc, #64]	; (9340 <usb_dc_nrfx_power_event_callback+0x60>)
    9300:	4b10      	ldr	r3, [pc, #64]	; (9344 <usb_dc_nrfx_power_event_callback+0x64>)
    9302:	4811      	ldr	r0, [pc, #68]	; (9348 <usb_dc_nrfx_power_event_callback+0x68>)
    9304:	1a9b      	subs	r3, r3, r2
    9306:	08db      	lsrs	r3, r3, #3
    9308:	f363 118f 	bfi	r1, r3, #6, #10
}
    930c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		LOG_ERR("Unknown USB power event");
    9310:	f008 be30 	b.w	11f74 <log_0>
		new_state = USBD_DETACHED;
    9314:	2400      	movs	r4, #0
	struct usbd_event *ev = usbd_evt_alloc();
    9316:	f7ff fbff 	bl	8b18 <usbd_evt_alloc>
	if (!ev) {
    931a:	b178      	cbz	r0, 933c <usb_dc_nrfx_power_event_callback+0x5c>
	ev->evt_type = USBD_EVT_POWER;
    931c:	2200      	movs	r2, #0
    931e:	7502      	strb	r2, [r0, #20]
	ev->evt.pwr_evt.state = new_state;
    9320:	7304      	strb	r4, [r0, #12]
	usbd_evt_put(ev);
    9322:	f7ff fb75 	bl	8a10 <usbd_evt_put>
	if (usbd_ctx.attached) {
    9326:	4b09      	ldr	r3, [pc, #36]	; (934c <usb_dc_nrfx_power_event_callback+0x6c>)
    9328:	791b      	ldrb	r3, [r3, #4]
    932a:	b13b      	cbz	r3, 933c <usb_dc_nrfx_power_event_callback+0x5c>
}
    932c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usbd_work_schedule();
    9330:	f7ff bbcc 	b.w	8acc <usbd_work_schedule>
		new_state = USBD_POWERED;
    9334:	2402      	movs	r4, #2
    9336:	e7ee      	b.n	9316 <usb_dc_nrfx_power_event_callback+0x36>
		new_state = USBD_ATTACHED;
    9338:	2401      	movs	r4, #1
    933a:	e7ec      	b.n	9316 <usb_dc_nrfx_power_event_callback+0x36>
}
    933c:	bd10      	pop	{r4, pc}
    933e:	bf00      	nop
    9340:	00016344 	.word	0x00016344
    9344:	0001644c 	.word	0x0001644c
    9348:	0001825c 	.word	0x0001825c
    934c:	20003730 	.word	0x20003730

00009350 <usb_dc_attach>:

int usb_dc_attach(void)
{
    9350:	b538      	push	{r3, r4, r5, lr}
	struct nrf_usbd_ctx *ctx = get_usbd_ctx();
	nrfx_err_t err;
	int ret;

	if (ctx->attached) {
    9352:	4c1a      	ldr	r4, [pc, #104]	; (93bc <usb_dc_attach+0x6c>)
    9354:	7925      	ldrb	r5, [r4, #4]
    9356:	bb65      	cbnz	r5, 93b2 <usb_dc_attach+0x62>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    9358:	4b19      	ldr	r3, [pc, #100]	; (93c0 <usb_dc_attach+0x70>)
    935a:	60a5      	str	r5, [r4, #8]
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_INIT, k_mutex_init, struct k_mutex *, mutex)
    935c:	f104 0014 	add.w	r0, r4, #20
    9360:	e9c4 3503 	strd	r3, r5, [r4, #12]
    9364:	f00c fb43 	bl	159ee <z_impl_k_mutex_init>
	}

	k_work_init(&ctx->usb_work, usbd_work_handler);
	k_mutex_init(&ctx->drv_lock);

	IRQ_CONNECT(DT_NORDIC_NRF_USBD_USBD_0_IRQ,
    9368:	462a      	mov	r2, r5
    936a:	2101      	movs	r1, #1
    936c:	2027      	movs	r0, #39	; 0x27
    936e:	f000 fd3f 	bl	9df0 <z_irq_priority_set>
		    DT_NORDIC_NRF_USBD_USBD_0_IRQ_PRIORITY,
		    nrfx_isr, nrfx_usbd_irq_handler, 0);

	err = nrfx_usbd_init(usbd_event_handler);
    9372:	4814      	ldr	r0, [pc, #80]	; (93c4 <usb_dc_attach+0x74>)
    9374:	f7fc fe06 	bl	5f84 <nrfx_usbd_init>

	if (err != NRFX_SUCCESS) {
    9378:	4b13      	ldr	r3, [pc, #76]	; (93c8 <usb_dc_attach+0x78>)
    937a:	4298      	cmp	r0, r3
    937c:	d11b      	bne.n	93b6 <usb_dc_attach+0x66>
		LOG_DBG("nRF USBD driver init failed. Code: %d.",
			(u32_t)err);
		return -EIO;
	}
	nrf5_power_usb_power_int_enable(true);
    937e:	2001      	movs	r0, #1
    9380:	f009 fe29 	bl	12fd6 <nrf5_power_usb_power_int_enable>

	ret = eps_ctx_init();
    9384:	f7ff fd4e 	bl	8e24 <eps_ctx_init>
	if (ret == 0) {
    9388:	4605      	mov	r5, r0
    938a:	b908      	cbnz	r0, 9390 <usb_dc_attach+0x40>
		ctx->attached = true;
    938c:	2301      	movs	r3, #1
    938e:	7123      	strb	r3, [r4, #4]
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
    9390:	4b0e      	ldr	r3, [pc, #56]	; (93cc <usb_dc_attach+0x7c>)
	}

	if (!k_fifo_is_empty(&work_queue)) {
    9392:	681b      	ldr	r3, [r3, #0]
    9394:	b10b      	cbz	r3, 939a <usb_dc_attach+0x4a>
		usbd_work_schedule();
    9396:	f7ff fb99 	bl	8acc <usbd_work_schedule>
#endif // NRF_POWER_HAS_VDDH

#if NRF_POWER_HAS_USBREG
__STATIC_INLINE uint32_t nrf_power_usbregstatus_get(void)
{
    return NRF_POWER->USBREGSTATUS;
    939a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    939e:	f8d3 3438 	ldr.w	r3, [r3, #1080]	; 0x438
	}

	if (nrf_power_usbregstatus_vbusdet_get()) {
    93a2:	07db      	lsls	r3, r3, #31
    93a4:	d503      	bpl.n	93ae <usb_dc_attach+0x5e>
		 * the peripheral is re-enabled.
		 * When USB-enabled bootloader is used, target application
		 * will not receive this event and it needs to be generated
		 * again here.
		 */
		usb_dc_nrfx_power_event_callback(NRF_POWER_EVENT_USBDETECTED);
    93a6:	f44f 708e 	mov.w	r0, #284	; 0x11c
    93aa:	f7ff ff99 	bl	92e0 <usb_dc_nrfx_power_event_callback>
	}

	return ret;
}
    93ae:	4628      	mov	r0, r5
    93b0:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
    93b2:	2500      	movs	r5, #0
    93b4:	e7fb      	b.n	93ae <usb_dc_attach+0x5e>
		return -EIO;
    93b6:	f06f 0504 	mvn.w	r5, #4
    93ba:	e7f8      	b.n	93ae <usb_dc_attach+0x5e>
    93bc:	20003730 	.word	0x20003730
    93c0:	00008fb1 	.word	0x00008fb1
    93c4:	00008c99 	.word	0x00008c99
    93c8:	0bad0000 	.word	0x0bad0000
    93cc:	20011dec 	.word	0x20011dec

000093d0 <usb_dc_set_address>:
	return get_usbd_ctx()->attached;
    93d0:	4b06      	ldr	r3, [pc, #24]	; (93ec <usb_dc_set_address+0x1c>)

int usb_dc_set_address(const u8_t addr)
{
	struct nrf_usbd_ctx *ctx;

	if (!dev_attached() || !dev_ready()) {
    93d2:	791a      	ldrb	r2, [r3, #4]
    93d4:	b132      	cbz	r2, 93e4 <usb_dc_set_address+0x14>
    93d6:	795b      	ldrb	r3, [r3, #5]
    93d8:	2b00      	cmp	r3, #0

	ctx = get_usbd_ctx();

	LOG_DBG("Address set to: %d.", addr);

	return 0;
    93da:	bf0c      	ite	eq
    93dc:	f06f 0012 	mvneq.w	r0, #18
    93e0:	2000      	movne	r0, #0
    93e2:	4770      	bx	lr
		return -ENODEV;
    93e4:	f06f 0012 	mvn.w	r0, #18
}
    93e8:	4770      	bx	lr
    93ea:	bf00      	nop
    93ec:	20003730 	.word	0x20003730

000093f0 <usb_dc_ep_check_cap>:


int usb_dc_ep_check_cap(const struct usb_dc_ep_cfg_data *const ep_cfg)
{
    93f0:	b508      	push	{r3, lr}
	u8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);

	LOG_DBG("ep %x, mps %d, type %d", ep_cfg->ep_addr, ep_cfg->ep_mps,
		ep_cfg->ep_type);

	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
    93f2:	7901      	ldrb	r1, [r0, #4]
	u8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
    93f4:	7802      	ldrb	r2, [r0, #0]
    93f6:	f002 030f 	and.w	r3, r2, #15
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
    93fa:	b979      	cbnz	r1, 941c <usb_dc_ep_check_cap+0x2c>
    93fc:	b373      	cbz	r3, 945c <usb_dc_ep_check_cap+0x6c>
		LOG_ERR("invalid endpoint configuration");
    93fe:	2301      	movs	r3, #1
    9400:	f363 0107 	bfi	r1, r3, #0, #8
    9404:	4a16      	ldr	r2, [pc, #88]	; (9460 <usb_dc_ep_check_cap+0x70>)
    9406:	4b17      	ldr	r3, [pc, #92]	; (9464 <usb_dc_ep_check_cap+0x74>)
    9408:	4817      	ldr	r0, [pc, #92]	; (9468 <usb_dc_ep_check_cap+0x78>)
    940a:	1a9b      	subs	r3, r3, r2
    940c:	08db      	lsrs	r3, r3, #3
    940e:	f363 118f 	bfi	r1, r3, #6, #10
		return -1;
	}

	if ((ep_cfg->ep_type == USB_DC_EP_ISOCHRONOUS) &&
	    (!NRF_USBD_EPISO_CHECK(ep_cfg->ep_addr))) {
		LOG_WRN("invalid endpoint type");
    9412:	f008 fdaf 	bl	11f74 <log_0>
		return -1;
    9416:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}

	return 0;
}
    941a:	bd08      	pop	{r3, pc}
	if (!NRF_USBD_EP_VALIDATE(ep_cfg->ep_addr)) {
    941c:	2b08      	cmp	r3, #8
    941e:	d90c      	bls.n	943a <usb_dc_ep_check_cap+0x4a>
		LOG_ERR("invalid endpoint index/address");
    9420:	2301      	movs	r3, #1
    9422:	f04f 0100 	mov.w	r1, #0
    9426:	f363 0107 	bfi	r1, r3, #0, #8
    942a:	4a0d      	ldr	r2, [pc, #52]	; (9460 <usb_dc_ep_check_cap+0x70>)
    942c:	4b0d      	ldr	r3, [pc, #52]	; (9464 <usb_dc_ep_check_cap+0x74>)
    942e:	480f      	ldr	r0, [pc, #60]	; (946c <usb_dc_ep_check_cap+0x7c>)
    9430:	1a9b      	subs	r3, r3, r2
    9432:	08db      	lsrs	r3, r3, #3
    9434:	f363 118f 	bfi	r1, r3, #6, #10
    9438:	e7eb      	b.n	9412 <usb_dc_ep_check_cap+0x22>
	if ((ep_cfg->ep_type == USB_DC_EP_ISOCHRONOUS) &&
    943a:	2901      	cmp	r1, #1
    943c:	d10e      	bne.n	945c <usb_dc_ep_check_cap+0x6c>
    943e:	0713      	lsls	r3, r2, #28
    9440:	d40c      	bmi.n	945c <usb_dc_ep_check_cap+0x6c>
		LOG_WRN("invalid endpoint type");
    9442:	2302      	movs	r3, #2
    9444:	f04f 0100 	mov.w	r1, #0
    9448:	f363 0107 	bfi	r1, r3, #0, #8
    944c:	4a04      	ldr	r2, [pc, #16]	; (9460 <usb_dc_ep_check_cap+0x70>)
    944e:	4b05      	ldr	r3, [pc, #20]	; (9464 <usb_dc_ep_check_cap+0x74>)
    9450:	4807      	ldr	r0, [pc, #28]	; (9470 <usb_dc_ep_check_cap+0x80>)
    9452:	1a9b      	subs	r3, r3, r2
    9454:	08db      	lsrs	r3, r3, #3
    9456:	f363 118f 	bfi	r1, r3, #6, #10
    945a:	e7da      	b.n	9412 <usb_dc_ep_check_cap+0x22>
	return 0;
    945c:	2000      	movs	r0, #0
    945e:	e7dc      	b.n	941a <usb_dc_ep_check_cap+0x2a>
    9460:	00016344 	.word	0x00016344
    9464:	0001644c 	.word	0x0001644c
    9468:	000181a1 	.word	0x000181a1
    946c:	000181c0 	.word	0x000181c0
    9470:	000181df 	.word	0x000181df

00009474 <usb_dc_ep_configure>:

int usb_dc_ep_configure(const struct usb_dc_ep_cfg_data *const ep_cfg)
{
    9474:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
    9476:	4b15      	ldr	r3, [pc, #84]	; (94cc <usb_dc_ep_configure+0x58>)
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached()) {
    9478:	791b      	ldrb	r3, [r3, #4]
{
    947a:	4604      	mov	r4, r0
	if (!dev_attached()) {
    947c:	b313      	cbz	r3, 94c4 <usb_dc_ep_configure+0x50>
	 * accordingly. So either this needs to be chosen in the
	 * menuconfig in application area or perhaps in device tree
	 * at compile time or introduce a new API to read the endpoint
	 * configuration at runtime before configuring them.
	 */
	ep_ctx = endpoint_ctx(ep_cfg->ep_addr);
    947e:	7805      	ldrb	r5, [r0, #0]
    9480:	4628      	mov	r0, r5
    9482:	f7ff faa5 	bl	89d0 <endpoint_ctx>
	if (!ep_ctx) {
    9486:	b1a8      	cbz	r0, 94b4 <usb_dc_ep_configure+0x40>
		return -EINVAL;
	}

	ep_ctx->cfg.addr = ep_cfg->ep_addr;
    9488:	7245      	strb	r5, [r0, #9]
	ep_ctx->cfg.type = ep_cfg->ep_type;
	ep_ctx->cfg.max_sz = ep_cfg->ep_mps;
    948a:	8861      	ldrh	r1, [r4, #2]
	ep_ctx->cfg.type = ep_cfg->ep_type;
    948c:	7923      	ldrb	r3, [r4, #4]
    948e:	7283      	strb	r3, [r0, #10]

	if ((ep_cfg->ep_mps & (ep_cfg->ep_mps - 1)) != 0U) {
    9490:	1e4c      	subs	r4, r1, #1
    9492:	400c      	ands	r4, r1
	ep_ctx->cfg.max_sz = ep_cfg->ep_mps;
    9494:	6041      	str	r1, [r0, #4]
	if ((ep_cfg->ep_mps & (ep_cfg->ep_mps - 1)) != 0U) {
    9496:	d010      	beq.n	94ba <usb_dc_ep_configure+0x46>
		LOG_ERR("EP max packet size must be a power of 2.");
    9498:	2301      	movs	r3, #1
    949a:	f04f 0100 	mov.w	r1, #0
    949e:	f363 0107 	bfi	r1, r3, #0, #8
    94a2:	4a0b      	ldr	r2, [pc, #44]	; (94d0 <usb_dc_ep_configure+0x5c>)
    94a4:	4b0b      	ldr	r3, [pc, #44]	; (94d4 <usb_dc_ep_configure+0x60>)
    94a6:	480c      	ldr	r0, [pc, #48]	; (94d8 <usb_dc_ep_configure+0x64>)
    94a8:	1a9b      	subs	r3, r3, r2
    94aa:	08db      	lsrs	r3, r3, #3
    94ac:	f363 118f 	bfi	r1, r3, #6, #10
    94b0:	f008 fd60 	bl	11f74 <log_0>
		return -EINVAL;
    94b4:	f06f 0415 	mvn.w	r4, #21
    94b8:	e002      	b.n	94c0 <usb_dc_ep_configure+0x4c>
		return -EINVAL;
	}
	nrfx_usbd_ep_max_packet_size_set(ep_addr_to_nrfx(ep_cfg->ep_addr),
    94ba:	4628      	mov	r0, r5
    94bc:	f7fc fd32 	bl	5f24 <nrfx_usbd_ep_max_packet_size_set>
					 ep_cfg->ep_mps);

	return 0;
}
    94c0:	4620      	mov	r0, r4
    94c2:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    94c4:	f06f 0412 	mvn.w	r4, #18
    94c8:	e7fa      	b.n	94c0 <usb_dc_ep_configure+0x4c>
    94ca:	bf00      	nop
    94cc:	20003730 	.word	0x20003730
    94d0:	00016344 	.word	0x00016344
    94d4:	0001644c 	.word	0x0001644c
    94d8:	000181f5 	.word	0x000181f5

000094dc <usb_dc_ep_set_stall>:

int usb_dc_ep_set_stall(const u8_t ep)
{
    94dc:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
    94de:	4b18      	ldr	r3, [pc, #96]	; (9540 <usb_dc_ep_set_stall+0x64>)
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached() || !dev_ready()) {
    94e0:	791a      	ldrb	r2, [r3, #4]
{
    94e2:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
    94e4:	b342      	cbz	r2, 9538 <usb_dc_ep_set_stall+0x5c>
    94e6:	795b      	ldrb	r3, [r3, #5]
    94e8:	b333      	cbz	r3, 9538 <usb_dc_ep_set_stall+0x5c>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    94ea:	f7ff fa71 	bl	89d0 <endpoint_ctx>
	if (!ep_ctx) {
    94ee:	4604      	mov	r4, r0
    94f0:	b1f8      	cbz	r0, 9532 <usb_dc_ep_set_stall+0x56>
		return -EINVAL;
	}

	switch (ep_ctx->cfg.type) {
    94f2:	7a83      	ldrb	r3, [r0, #10]
    94f4:	2b03      	cmp	r3, #3
    94f6:	d805      	bhi.n	9504 <usb_dc_ep_set_stall+0x28>
    94f8:	e8df f003 	tbb	[pc, r3]
    94fc:	09090d02 	.word	0x09090d02
	case USB_DC_EP_CONTROL:
		nrfx_usbd_setup_stall();
    9500:	f008 fd1b 	bl	11f3a <nrfx_usbd_setup_stall>
	case USB_DC_EP_ISOCHRONOUS:
		LOG_ERR("STALL unsupported on ISO endpoint.s");
		return -EINVAL;
	}

	ep_ctx->buf.len = 0U;
    9504:	2000      	movs	r0, #0
	ep_ctx->buf.curr = ep_ctx->buf.data;
    9506:	69a3      	ldr	r3, [r4, #24]
	ep_ctx->buf.len = 0U;
    9508:	60e0      	str	r0, [r4, #12]
	ep_ctx->buf.curr = ep_ctx->buf.data;
    950a:	61e3      	str	r3, [r4, #28]

	LOG_DBG("STALL on EP %d.", ep);

	return 0;
}
    950c:	bd38      	pop	{r3, r4, r5, pc}
		nrfx_usbd_ep_stall(ep_addr_to_nrfx(ep));
    950e:	4628      	mov	r0, r5
    9510:	f7fc ffc2 	bl	6498 <nrfx_usbd_ep_stall>
		break;
    9514:	e7f6      	b.n	9504 <usb_dc_ep_set_stall+0x28>
		LOG_ERR("STALL unsupported on ISO endpoint.s");
    9516:	2301      	movs	r3, #1
    9518:	f04f 0100 	mov.w	r1, #0
    951c:	f363 0107 	bfi	r1, r3, #0, #8
    9520:	4a08      	ldr	r2, [pc, #32]	; (9544 <usb_dc_ep_set_stall+0x68>)
    9522:	4b09      	ldr	r3, [pc, #36]	; (9548 <usb_dc_ep_set_stall+0x6c>)
    9524:	4809      	ldr	r0, [pc, #36]	; (954c <usb_dc_ep_set_stall+0x70>)
    9526:	1a9b      	subs	r3, r3, r2
    9528:	08db      	lsrs	r3, r3, #3
    952a:	f363 118f 	bfi	r1, r3, #6, #10
    952e:	f008 fd21 	bl	11f74 <log_0>
		return -EINVAL;
    9532:	f06f 0015 	mvn.w	r0, #21
    9536:	e7e9      	b.n	950c <usb_dc_ep_set_stall+0x30>
		return -ENODEV;
    9538:	f06f 0012 	mvn.w	r0, #18
    953c:	e7e6      	b.n	950c <usb_dc_ep_set_stall+0x30>
    953e:	bf00      	nop
    9540:	20003730 	.word	0x20003730
    9544:	00016344 	.word	0x00016344
    9548:	0001644c 	.word	0x0001644c
    954c:	0001821e 	.word	0x0001821e

00009550 <usb_dc_ep_clear_stall>:
	return get_usbd_ctx()->attached;
    9550:	4b0a      	ldr	r3, [pc, #40]	; (957c <usb_dc_ep_clear_stall+0x2c>)
int usb_dc_ep_clear_stall(const u8_t ep)
{

	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached() || !dev_ready()) {
    9552:	791a      	ldrb	r2, [r3, #4]
{
    9554:	b510      	push	{r4, lr}
    9556:	4604      	mov	r4, r0
	if (!dev_attached() || !dev_ready()) {
    9558:	b14a      	cbz	r2, 956e <usb_dc_ep_clear_stall+0x1e>
    955a:	795b      	ldrb	r3, [r3, #5]
    955c:	b13b      	cbz	r3, 956e <usb_dc_ep_clear_stall+0x1e>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    955e:	f7ff fa37 	bl	89d0 <endpoint_ctx>
	if (!ep_ctx) {
    9562:	b138      	cbz	r0, 9574 <usb_dc_ep_clear_stall+0x24>
		return -EINVAL;
	}

	nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
    9564:	4620      	mov	r0, r4
    9566:	f7fd fb19 	bl	6b9c <nrfx_usbd_ep_stall_clear>
	LOG_DBG("Unstall on EP %d", ep);

	return 0;
    956a:	2000      	movs	r0, #0
}
    956c:	bd10      	pop	{r4, pc}
		return -ENODEV;
    956e:	f06f 0012 	mvn.w	r0, #18
    9572:	e7fb      	b.n	956c <usb_dc_ep_clear_stall+0x1c>
		return -EINVAL;
    9574:	f06f 0015 	mvn.w	r0, #21
    9578:	e7f8      	b.n	956c <usb_dc_ep_clear_stall+0x1c>
    957a:	bf00      	nop
    957c:	20003730 	.word	0x20003730

00009580 <usb_dc_ep_is_stalled>:
{
	return usb_dc_ep_set_stall(ep);
}

int usb_dc_ep_is_stalled(const u8_t ep, u8_t *const stalled)
{
    9580:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
    9582:	4b0b      	ldr	r3, [pc, #44]	; (95b0 <usb_dc_ep_is_stalled+0x30>)
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached() || !dev_ready()) {
    9584:	791a      	ldrb	r2, [r3, #4]
{
    9586:	4605      	mov	r5, r0
    9588:	460c      	mov	r4, r1
	if (!dev_attached() || !dev_ready()) {
    958a:	b152      	cbz	r2, 95a2 <usb_dc_ep_is_stalled+0x22>
    958c:	795b      	ldrb	r3, [r3, #5]
    958e:	b143      	cbz	r3, 95a2 <usb_dc_ep_is_stalled+0x22>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    9590:	f7ff fa1e 	bl	89d0 <endpoint_ctx>
	if (!ep_ctx) {
    9594:	b140      	cbz	r0, 95a8 <usb_dc_ep_is_stalled+0x28>
		return -EINVAL;
	}

	*stalled = (u8_t) nrfx_usbd_ep_stall_check(ep_addr_to_nrfx(ep));
    9596:	4628      	mov	r0, r5
    9598:	f7fc ffa0 	bl	64dc <nrfx_usbd_ep_stall_check>
    959c:	7020      	strb	r0, [r4, #0]

	return 0;
    959e:	2000      	movs	r0, #0
}
    95a0:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    95a2:	f06f 0012 	mvn.w	r0, #18
    95a6:	e7fb      	b.n	95a0 <usb_dc_ep_is_stalled+0x20>
		return -EINVAL;
    95a8:	f06f 0015 	mvn.w	r0, #21
    95ac:	e7f8      	b.n	95a0 <usb_dc_ep_is_stalled+0x20>
    95ae:	bf00      	nop
    95b0:	20003730 	.word	0x20003730

000095b4 <usb_dc_ep_enable>:

int usb_dc_ep_enable(const u8_t ep)
{
    95b4:	b570      	push	{r4, r5, r6, lr}
	return get_usbd_ctx()->attached;
    95b6:	4d0d      	ldr	r5, [pc, #52]	; (95ec <usb_dc_ep_enable+0x38>)
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached()) {
    95b8:	792b      	ldrb	r3, [r5, #4]
{
    95ba:	4606      	mov	r6, r0
	if (!dev_attached()) {
    95bc:	b16b      	cbz	r3, 95da <usb_dc_ep_enable+0x26>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    95be:	f7ff fa07 	bl	89d0 <endpoint_ctx>
	if (!ep_ctx) {
    95c2:	b168      	cbz	r0, 95e0 <usb_dc_ep_enable+0x2c>
		return -EINVAL;
	}

	if (ep_ctx->cfg.en) {
    95c4:	7a04      	ldrb	r4, [r0, #8]
    95c6:	b974      	cbnz	r4, 95e6 <usb_dc_ep_enable+0x32>
		return -EALREADY;
	}

	LOG_DBG("EP enable: %d.", ep);

	ep_ctx->cfg.en = true;
    95c8:	2301      	movs	r3, #1
    95ca:	7203      	strb	r3, [r0, #8]

	/* Defer the endpoint enable if USBD is not ready yet. */
	if (dev_ready()) {
    95cc:	7968      	ldrb	r0, [r5, #5]
    95ce:	b118      	cbz	r0, 95d8 <usb_dc_ep_enable+0x24>
		nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep));
    95d0:	4630      	mov	r0, r6
    95d2:	f7fd fa89 	bl	6ae8 <nrfx_usbd_ep_enable>
	}

	return 0;
    95d6:	4620      	mov	r0, r4
}
    95d8:	bd70      	pop	{r4, r5, r6, pc}
		return -ENODEV;
    95da:	f06f 0012 	mvn.w	r0, #18
    95de:	e7fb      	b.n	95d8 <usb_dc_ep_enable+0x24>
		return -EINVAL;
    95e0:	f06f 0015 	mvn.w	r0, #21
    95e4:	e7f8      	b.n	95d8 <usb_dc_ep_enable+0x24>
		return -EALREADY;
    95e6:	f06f 0077 	mvn.w	r0, #119	; 0x77
    95ea:	e7f5      	b.n	95d8 <usb_dc_ep_enable+0x24>
    95ec:	20003730 	.word	0x20003730

000095f0 <usb_dc_ep_write>:
	return 0;
}

int usb_dc_ep_write(const u8_t ep, const u8_t *const data,
		    const u32_t data_len, u32_t *const ret_bytes)
{
    95f0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	return get_usbd_ctx()->attached;
    95f4:	4e38      	ldr	r6, [pc, #224]	; (96d8 <usb_dc_ep_write+0xe8>)
{
    95f6:	4698      	mov	r8, r3
	LOG_DBG("ep_write: ep %d, len %d", ep, data_len);
	struct nrf_usbd_ctx *ctx = get_usbd_ctx();
	struct nrf_usbd_ep_ctx *ep_ctx;
	u32_t bytes_to_copy;

	if (!dev_attached() || !dev_ready()) {
    95f8:	7933      	ldrb	r3, [r6, #4]
{
    95fa:	4607      	mov	r7, r0
    95fc:	468a      	mov	sl, r1
    95fe:	4614      	mov	r4, r2
	if (!dev_attached() || !dev_ready()) {
    9600:	2b00      	cmp	r3, #0
    9602:	d062      	beq.n	96ca <usb_dc_ep_write+0xda>
	return get_usbd_ctx()->ready;
    9604:	f896 9005 	ldrb.w	r9, [r6, #5]
	if (!dev_attached() || !dev_ready()) {
    9608:	f1b9 0f00 	cmp.w	r9, #0
    960c:	d05d      	beq.n	96ca <usb_dc_ep_write+0xda>
		return -ENODEV;
	}

	if (NRF_USBD_EPOUT_CHECK(ep)) {
    960e:	0603      	lsls	r3, r0, #24
    9610:	d55e      	bpl.n	96d0 <usb_dc_ep_write+0xe0>
		return -EINVAL;
	}

	ep_ctx = endpoint_ctx(ep);
    9612:	f7ff f9dd 	bl	89d0 <endpoint_ctx>
	if (!ep_ctx) {
    9616:	4605      	mov	r5, r0
    9618:	2800      	cmp	r0, #0
    961a:	d059      	beq.n	96d0 <usb_dc_ep_write+0xe0>
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    961c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    9620:	f106 0014 	add.w	r0, r6, #20
    9624:	f005 fc22 	bl	ee6c <z_impl_k_mutex_lock>

	/* USBD driver does not allow scheduling multiple DMA transfers
	 * for one EP at a time. Next USB transfer on this endpoint can be
	 * triggered after the completion of previous one.
	 */
	if (ep_ctx->write_in_progress) {
    9628:	f895 2022 	ldrb.w	r2, [r5, #34]	; 0x22
    962c:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    9630:	b14a      	cbz	r2, 9646 <usb_dc_ep_write+0x56>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    9632:	f106 0014 	add.w	r0, r6, #20
    9636:	f005 fc89 	bl	ef4c <z_impl_k_mutex_unlock>
		k_mutex_unlock(&ctx->drv_lock);
		return -EAGAIN;
    963a:	f06f 040a 	mvn.w	r4, #10
		LOG_ERR("nRF USBD write error: %d.", (u32_t)err);
	}

	k_mutex_unlock(&ctx->drv_lock);
	return result;
}
    963e:	4620      	mov	r0, r4
    9640:	b004      	add	sp, #16
    9642:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (data_len > ep_ctx->cfg.max_sz) {
    9646:	686a      	ldr	r2, [r5, #4]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    9648:	69a8      	ldr	r0, [r5, #24]
    964a:	42a2      	cmp	r2, r4
    964c:	bf3c      	itt	cc
    964e:	4614      	movcc	r4, r2
		ep_ctx->write_fragmented = true;
    9650:	464b      	movcc	r3, r9
    9652:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
    9656:	4622      	mov	r2, r4
    9658:	4651      	mov	r1, sl
    965a:	f7f8 fd8b 	bl	2174 <memcpy>
	ep_ctx->buf.len = bytes_to_copy;
    965e:	60ec      	str	r4, [r5, #12]
	if (ret_bytes) {
    9660:	f1b8 0f00 	cmp.w	r8, #0
    9664:	d001      	beq.n	966a <usb_dc_ep_write+0x7a>
		*ret_bytes = bytes_to_copy;
    9666:	f8c8 4000 	str.w	r4, [r8]
	if ((ep_ctx->cfg.type == USB_DC_EP_CONTROL)
    966a:	7aac      	ldrb	r4, [r5, #10]
    966c:	b94c      	cbnz	r4, 9682 <usb_dc_ep_write+0x92>
	    && (nrfx_usbd_last_setup_dir_get() != ep)) {
    966e:	f7fc ff9b 	bl	65a8 <nrfx_usbd_last_setup_dir_get>
    9672:	42b8      	cmp	r0, r7
    9674:	d005      	beq.n	9682 <usb_dc_ep_write+0x92>
		nrfx_usbd_setup_clear();
    9676:	f008 fc5d 	bl	11f34 <nrfx_usbd_setup_clear>
    967a:	4818      	ldr	r0, [pc, #96]	; (96dc <usb_dc_ep_write+0xec>)
    967c:	f005 fc66 	bl	ef4c <z_impl_k_mutex_unlock>
	return result;
    9680:	e7dd      	b.n	963e <usb_dc_ep_write+0x4e>
	ep_ctx->write_in_progress = true;
    9682:	2301      	movs	r3, #1
    9684:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
	NRFX_USBD_TRANSFER_IN(transfer, ep_ctx->buf.data, ep_ctx->buf.len, 0);
    9688:	69ab      	ldr	r3, [r5, #24]
    968a:	9301      	str	r3, [sp, #4]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
    968c:	a901      	add	r1, sp, #4
	NRFX_USBD_TRANSFER_IN(transfer, ep_ctx->buf.data, ep_ctx->buf.len, 0);
    968e:	68eb      	ldr	r3, [r5, #12]
    9690:	9302      	str	r3, [sp, #8]
    9692:	2400      	movs	r4, #0
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
    9694:	4638      	mov	r0, r7
	NRFX_USBD_TRANSFER_IN(transfer, ep_ctx->buf.data, ep_ctx->buf.len, 0);
    9696:	9403      	str	r4, [sp, #12]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
    9698:	f7fc fcc4 	bl	6024 <nrfx_usbd_ep_transfer>
	if (err != NRFX_SUCCESS) {
    969c:	4b10      	ldr	r3, [pc, #64]	; (96e0 <usb_dc_ep_write+0xf0>)
    969e:	4298      	cmp	r0, r3
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
    96a0:	4601      	mov	r1, r0
	if (err != NRFX_SUCCESS) {
    96a2:	d0ea      	beq.n	967a <usb_dc_ep_write+0x8a>
		LOG_ERR("nRF USBD write error: %d.", (u32_t)err);
    96a4:	2301      	movs	r3, #1
    96a6:	f04f 0200 	mov.w	r2, #0
    96aa:	f363 0207 	bfi	r2, r3, #0, #8
    96ae:	480d      	ldr	r0, [pc, #52]	; (96e4 <usb_dc_ep_write+0xf4>)
    96b0:	4b0d      	ldr	r3, [pc, #52]	; (96e8 <usb_dc_ep_write+0xf8>)
		ep_ctx->write_in_progress = false;
    96b2:	f885 4022 	strb.w	r4, [r5, #34]	; 0x22
    96b6:	1a1b      	subs	r3, r3, r0
    96b8:	08db      	lsrs	r3, r3, #3
		LOG_ERR("nRF USBD write error: %d.", (u32_t)err);
    96ba:	f363 128f 	bfi	r2, r3, #6, #10
    96be:	480b      	ldr	r0, [pc, #44]	; (96ec <usb_dc_ep_write+0xfc>)
    96c0:	f008 fc65 	bl	11f8e <log_1>
		result = -EIO;
    96c4:	f06f 0404 	mvn.w	r4, #4
    96c8:	e7d7      	b.n	967a <usb_dc_ep_write+0x8a>
		return -ENODEV;
    96ca:	f06f 0412 	mvn.w	r4, #18
    96ce:	e7b6      	b.n	963e <usb_dc_ep_write+0x4e>
		return -EINVAL;
    96d0:	f06f 0415 	mvn.w	r4, #21
    96d4:	e7b3      	b.n	963e <usb_dc_ep_write+0x4e>
    96d6:	bf00      	nop
    96d8:	20003730 	.word	0x20003730
    96dc:	20003744 	.word	0x20003744
    96e0:	0bad0000 	.word	0x0bad0000
    96e4:	00016344 	.word	0x00016344
    96e8:	0001644c 	.word	0x0001644c
    96ec:	00018242 	.word	0x00018242

000096f0 <usb_dc_ep_read_wait>:

int usb_dc_ep_read_wait(u8_t ep, u8_t *data, u32_t max_data_len,
			u32_t *read_bytes)
{
    96f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    96f4:	461d      	mov	r5, r3
	return get_usbd_ctx()->attached;
    96f6:	4b1e      	ldr	r3, [pc, #120]	; (9770 <usb_dc_ep_read_wait+0x80>)
{
    96f8:	4690      	mov	r8, r2
	struct nrf_usbd_ep_ctx *ep_ctx;
	struct nrf_usbd_ctx *ctx = get_usbd_ctx();
	u32_t bytes_to_copy;

	if (!dev_attached() || !dev_ready()) {
    96fa:	791a      	ldrb	r2, [r3, #4]
{
    96fc:	460f      	mov	r7, r1
	if (!dev_attached() || !dev_ready()) {
    96fe:	2a00      	cmp	r2, #0
    9700:	d030      	beq.n	9764 <usb_dc_ep_read_wait+0x74>
    9702:	795b      	ldrb	r3, [r3, #5]
    9704:	b373      	cbz	r3, 9764 <usb_dc_ep_read_wait+0x74>
		return -ENODEV;
	}

	if (NRF_USBD_EPIN_CHECK(ep)) {
    9706:	0603      	lsls	r3, r0, #24
    9708:	d42f      	bmi.n	976a <usb_dc_ep_read_wait+0x7a>
		return -EINVAL;
	}

	if (!data && max_data_len) {
    970a:	b911      	cbnz	r1, 9712 <usb_dc_ep_read_wait+0x22>
    970c:	f1b8 0f00 	cmp.w	r8, #0
    9710:	d12b      	bne.n	976a <usb_dc_ep_read_wait+0x7a>
		return -EINVAL;
	}

	ep_ctx = endpoint_ctx(ep);
    9712:	f7ff f95d 	bl	89d0 <endpoint_ctx>
	if (!ep_ctx) {
    9716:	4604      	mov	r4, r0
    9718:	b338      	cbz	r0, 976a <usb_dc_ep_read_wait+0x7a>
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    971a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    971e:	4815      	ldr	r0, [pc, #84]	; (9774 <usb_dc_ep_read_wait+0x84>)
    9720:	f005 fba4 	bl	ee6c <z_impl_k_mutex_lock>
		return -EINVAL;
	}

	k_mutex_lock(&ctx->drv_lock, K_FOREVER);

	bytes_to_copy = MIN(max_data_len, ep_ctx->buf.len);
    9724:	68e3      	ldr	r3, [r4, #12]
    9726:	4543      	cmp	r3, r8
    9728:	461e      	mov	r6, r3
    972a:	bf28      	it	cs
    972c:	4646      	movcs	r6, r8

	if (!data && !max_data_len) {
    972e:	b957      	cbnz	r7, 9746 <usb_dc_ep_read_wait+0x56>
    9730:	f1b8 0f00 	cmp.w	r8, #0
    9734:	d107      	bne.n	9746 <usb_dc_ep_read_wait+0x56>
		if (read_bytes) {
    9736:	b105      	cbz	r5, 973a <usb_dc_ep_read_wait+0x4a>
			*read_bytes = ep_ctx->buf.len;
    9738:	602b      	str	r3, [r5, #0]
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    973a:	480e      	ldr	r0, [pc, #56]	; (9774 <usb_dc_ep_read_wait+0x84>)
    973c:	f005 fc06 	bl	ef4c <z_impl_k_mutex_unlock>
		}
		k_mutex_unlock(&ctx->drv_lock);
		return 0;
    9740:	2000      	movs	r0, #0
		*read_bytes = bytes_to_copy;
	}

	k_mutex_unlock(&ctx->drv_lock);
	return 0;
}
    9742:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9746:	4632      	mov	r2, r6
    9748:	69e1      	ldr	r1, [r4, #28]
    974a:	4638      	mov	r0, r7
    974c:	f7f8 fd12 	bl	2174 <memcpy>
	ep_ctx->buf.curr += bytes_to_copy;
    9750:	69e3      	ldr	r3, [r4, #28]
    9752:	4433      	add	r3, r6
    9754:	61e3      	str	r3, [r4, #28]
	ep_ctx->buf.len -= bytes_to_copy;
    9756:	68e3      	ldr	r3, [r4, #12]
    9758:	1b9b      	subs	r3, r3, r6
    975a:	60e3      	str	r3, [r4, #12]
	if (read_bytes) {
    975c:	2d00      	cmp	r5, #0
    975e:	d0ec      	beq.n	973a <usb_dc_ep_read_wait+0x4a>
		*read_bytes = bytes_to_copy;
    9760:	602e      	str	r6, [r5, #0]
    9762:	e7ea      	b.n	973a <usb_dc_ep_read_wait+0x4a>
		return -ENODEV;
    9764:	f06f 0012 	mvn.w	r0, #18
    9768:	e7eb      	b.n	9742 <usb_dc_ep_read_wait+0x52>
		return -EINVAL;
    976a:	f06f 0015 	mvn.w	r0, #21
    976e:	e7e8      	b.n	9742 <usb_dc_ep_read_wait+0x52>
    9770:	20003730 	.word	0x20003730
    9774:	20003744 	.word	0x20003744

00009778 <usb_dc_ep_read_continue>:

int usb_dc_ep_read_continue(u8_t ep)
{
    9778:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
    977a:	4d1a      	ldr	r5, [pc, #104]	; (97e4 <usb_dc_ep_read_continue+0x6c>)
	struct nrf_usbd_ep_ctx *ep_ctx;
	struct nrf_usbd_ctx *ctx = get_usbd_ctx();

	if (!dev_attached() || !dev_ready()) {
    977c:	792a      	ldrb	r2, [r5, #4]
{
    977e:	4603      	mov	r3, r0
	if (!dev_attached() || !dev_ready()) {
    9780:	b332      	cbz	r2, 97d0 <usb_dc_ep_read_continue+0x58>
    9782:	796a      	ldrb	r2, [r5, #5]
    9784:	b322      	cbz	r2, 97d0 <usb_dc_ep_read_continue+0x58>
		return -ENODEV;
	}

	if (NRF_USBD_EPIN_CHECK(ep)) {
    9786:	061b      	lsls	r3, r3, #24
    9788:	d425      	bmi.n	97d6 <usb_dc_ep_read_continue+0x5e>
		return -EINVAL;
	}

	ep_ctx = endpoint_ctx(ep);
    978a:	f7ff f921 	bl	89d0 <endpoint_ctx>
	if (!ep_ctx) {
    978e:	4604      	mov	r4, r0
    9790:	b308      	cbz	r0, 97d6 <usb_dc_ep_read_continue+0x5e>
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    9792:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    9796:	f105 0014 	add.w	r0, r5, #20
    979a:	f005 fb67 	bl	ee6c <z_impl_k_mutex_lock>
		return -EINVAL;
	}

	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
	if (!ep_ctx->buf.len) {
    979e:	68e3      	ldr	r3, [r4, #12]
    97a0:	b98b      	cbnz	r3, 97c6 <usb_dc_ep_read_continue+0x4e>
		ep_ctx->buf.curr = ep_ctx->buf.data;
		ep_ctx->read_complete = true;
    97a2:	2501      	movs	r5, #1
		ep_ctx->buf.curr = ep_ctx->buf.data;
    97a4:	69a3      	ldr	r3, [r4, #24]
		ep_ctx->read_complete = true;
    97a6:	f884 5020 	strb.w	r5, [r4, #32]
		ep_ctx->buf.curr = ep_ctx->buf.data;
    97aa:	61e3      	str	r3, [r4, #28]

		if (ep_ctx->read_pending) {
    97ac:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
    97b0:	b14b      	cbz	r3, 97c6 <usb_dc_ep_read_continue+0x4e>
			struct usbd_event *ev = usbd_evt_alloc();
    97b2:	f7ff f9b1 	bl	8b18 <usbd_evt_alloc>

			if (!ev) {
    97b6:	b188      	cbz	r0, 97dc <usb_dc_ep_read_continue+0x64>
				return -ENOMEM;
			}

			ev->evt_type = USBD_EVT_EP;
    97b8:	7505      	strb	r5, [r0, #20]
			ev->evt.ep_evt.ep = ep_ctx;
    97ba:	60c4      	str	r4, [r0, #12]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
    97bc:	7405      	strb	r5, [r0, #16]
			usbd_evt_put(ev);
    97be:	f7ff f927 	bl	8a10 <usbd_evt_put>
			usbd_work_schedule();
    97c2:	f7ff f983 	bl	8acc <usbd_work_schedule>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    97c6:	4808      	ldr	r0, [pc, #32]	; (97e8 <usb_dc_ep_read_continue+0x70>)
    97c8:	f005 fbc0 	bl	ef4c <z_impl_k_mutex_unlock>
		}
	}
	k_mutex_unlock(&ctx->drv_lock);

	return 0;
    97cc:	2000      	movs	r0, #0
}
    97ce:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    97d0:	f06f 0012 	mvn.w	r0, #18
    97d4:	e7fb      	b.n	97ce <usb_dc_ep_read_continue+0x56>
		return -EINVAL;
    97d6:	f06f 0015 	mvn.w	r0, #21
    97da:	e7f8      	b.n	97ce <usb_dc_ep_read_continue+0x56>
				return -ENOMEM;
    97dc:	f06f 000b 	mvn.w	r0, #11
    97e0:	e7f5      	b.n	97ce <usb_dc_ep_read_continue+0x56>
    97e2:	bf00      	nop
    97e4:	20003730 	.word	0x20003730
    97e8:	20003744 	.word	0x20003744

000097ec <usb_dc_ep_set_callback>:
	return get_usbd_ctx()->attached;
    97ec:	4b08      	ldr	r3, [pc, #32]	; (9810 <usb_dc_ep_set_callback+0x24>)

int usb_dc_ep_set_callback(const u8_t ep, const usb_dc_ep_callback cb)
{
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached()) {
    97ee:	791b      	ldrb	r3, [r3, #4]
{
    97f0:	b510      	push	{r4, lr}
    97f2:	460c      	mov	r4, r1
	if (!dev_attached()) {
    97f4:	b12b      	cbz	r3, 9802 <usb_dc_ep_set_callback+0x16>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    97f6:	f7ff f8eb 	bl	89d0 <endpoint_ctx>
	if (!ep_ctx) {
    97fa:	b128      	cbz	r0, 9808 <usb_dc_ep_set_callback+0x1c>
		return -EINVAL;
	}

	ep_ctx->cfg.cb = cb;
    97fc:	6004      	str	r4, [r0, #0]

	return 0;
    97fe:	2000      	movs	r0, #0
}
    9800:	bd10      	pop	{r4, pc}
		return -ENODEV;
    9802:	f06f 0012 	mvn.w	r0, #18
    9806:	e7fb      	b.n	9800 <usb_dc_ep_set_callback+0x14>
		return -EINVAL;
    9808:	f06f 0015 	mvn.w	r0, #21
    980c:	e7f8      	b.n	9800 <usb_dc_ep_set_callback+0x14>
    980e:	bf00      	nop
    9810:	20003730 	.word	0x20003730

00009814 <usb_dc_set_status_callback>:

int usb_dc_set_status_callback(const usb_dc_status_callback cb)
{
	get_usbd_ctx()->status_cb = cb;
    9814:	4b01      	ldr	r3, [pc, #4]	; (981c <usb_dc_set_status_callback+0x8>)
    9816:	6018      	str	r0, [r3, #0]
	return 0;
}
    9818:	2000      	movs	r0, #0
    981a:	4770      	bx	lr
    981c:	20003730 	.word	0x20003730

00009820 <usb_dc_ep_mps>:

int usb_dc_ep_mps(const u8_t ep)
{
    9820:	b508      	push	{r3, lr}
	return get_usbd_ctx()->attached;
    9822:	4b07      	ldr	r3, [pc, #28]	; (9840 <usb_dc_ep_mps+0x20>)
	struct nrf_usbd_ep_ctx *ep_ctx;

	if (!dev_attached()) {
    9824:	791b      	ldrb	r3, [r3, #4]
    9826:	b123      	cbz	r3, 9832 <usb_dc_ep_mps+0x12>
		return -ENODEV;
	}

	ep_ctx = endpoint_ctx(ep);
    9828:	f7ff f8d2 	bl	89d0 <endpoint_ctx>
	if (!ep_ctx) {
    982c:	b120      	cbz	r0, 9838 <usb_dc_ep_mps+0x18>
		return -EINVAL;
	}

	return ep_ctx->cfg.max_sz;
    982e:	6840      	ldr	r0, [r0, #4]
}
    9830:	bd08      	pop	{r3, pc}
		return -ENODEV;
    9832:	f06f 0012 	mvn.w	r0, #18
    9836:	e7fb      	b.n	9830 <usb_dc_ep_mps+0x10>
		return -EINVAL;
    9838:	f06f 0015 	mvn.w	r0, #21
    983c:	e7f8      	b.n	9830 <usb_dc_ep_mps+0x10>
    983e:	bf00      	nop
    9840:	20003730 	.word	0x20003730

00009844 <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
    9844:	4b10      	ldr	r3, [pc, #64]	; (9888 <rtc1_nrf_isr+0x44>)
    9846:	2200      	movs	r2, #0
{
    9848:	b410      	push	{r4}
	RTC->EVENTS_COMPARE[0] = 0;
    984a:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
    984e:	f04f 0220 	mov.w	r2, #32
    9852:	f3ef 8411 	mrs	r4, BASEPRI
    9856:	f382 8811 	msr	BASEPRI, r2
    985a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    985e:	4a0b      	ldr	r2, [pc, #44]	; (988c <rtc1_nrf_isr+0x48>)
#endif
}

__STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type * p_reg)
{
     return p_reg->COUNTER;
    9860:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
    9864:	6811      	ldr	r1, [r2, #0]
    9866:	f240 1347 	movw	r3, #327	; 0x147
	return (a - b) & COUNTER_MAX;
    986a:	1a40      	subs	r0, r0, r1
    986c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    9870:	fbb0 f0f3 	udiv	r0, r0, r3

	last_count += dticks * CYC_PER_TICK;
    9874:	fb03 1300 	mla	r3, r3, r0, r1
    9878:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
    987a:	f384 8811 	msr	BASEPRI, r4
    987e:	f3bf 8f6f 	isb	sy
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
    9882:	bc10      	pop	{r4}
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    9884:	f006 b940 	b.w	fb08 <z_clock_announce>
    9888:	40011000 	.word	0x40011000
    988c:	200039e4 	.word	0x200039e4

00009890 <z_clock_driver_init>:

int z_clock_driver_init(struct device *device)
{
    9890:	b537      	push	{r0, r1, r2, r4, r5, lr}
    9892:	481f      	ldr	r0, [pc, #124]	; (9910 <z_clock_driver_init+0x80>)
    9894:	f005 f8a6 	bl	e9e4 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_NORDIC_NRF_CLOCK_0_LABEL "_32K");
	if (!clock) {
    9898:	2800      	cmp	r0, #0
    989a:	d035      	beq.n	9908 <z_clock_driver_init+0x78>
	return api->on(dev, sys);
    989c:	6843      	ldr	r3, [r0, #4]
}

__STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
    989e:	4d1d      	ldr	r5, [pc, #116]	; (9914 <z_clock_driver_init+0x84>)
    98a0:	681b      	ldr	r3, [r3, #0]
    98a2:	2101      	movs	r1, #1
    98a4:	4798      	blx	r3
    98a6:	2400      	movs	r4, #0
    p_reg->CC[ch] = cc_val;
    98a8:	f240 1347 	movw	r3, #327	; 0x147
    p_reg->PRESCALER = val;
    98ac:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
    98b0:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

__STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    98b4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    98b8:	f8c5 3344 	str.w	r3, [r5, #836]	; 0x344
    p_reg->INTENSET = mask;
    98bc:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    98c0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    98c4:	f503 538a 	add.w	r3, r3, #4416	; 0x1140
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    98c8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    98cc:	601c      	str	r4, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    98ce:	681b      	ldr	r3, [r3, #0]
    98d0:	9301      	str	r3, [sp, #4]
    (void)dummy;
    98d2:	9b01      	ldr	r3, [sp, #4]
    98d4:	4b10      	ldr	r3, [pc, #64]	; (9918 <z_clock_driver_init+0x88>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
    98d6:	2101      	movs	r1, #1
    98d8:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    98dc:	2011      	movs	r0, #17
    98de:	4622      	mov	r2, r4
    98e0:	f000 fa86 	bl	9df0 <z_irq_priority_set>
	irq_enable(RTC1_IRQn);
    98e4:	2011      	movs	r0, #17
    98e6:	f000 fa51 	bl	9d8c <z_arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    98ea:	4a0c      	ldr	r2, [pc, #48]	; (991c <z_clock_driver_init+0x8c>)
    98ec:	2301      	movs	r3, #1
    98ee:	6013      	str	r3, [r2, #0]
    98f0:	602b      	str	r3, [r5, #0]
     return p_reg->COUNTER;
    98f2:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	if (!IS_ENABLED(TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
    98f6:	f203 1347 	addw	r3, r3, #327	; 0x147
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    98fa:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    98fe:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
	}

	return 0;
    9902:	4620      	mov	r0, r4
}
    9904:	b003      	add	sp, #12
    9906:	bd30      	pop	{r4, r5, pc}
		return -1;
    9908:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    990c:	e7fa      	b.n	9904 <z_clock_driver_init+0x74>
    990e:	bf00      	nop
    9910:	000180c3 	.word	0x000180c3
    9914:	40011000 	.word	0x40011000
    9918:	e000e100 	.word	0xe000e100
    991c:	40011008 	.word	0x40011008

00009920 <z_clock_set_timeout>:
void z_clock_set_timeout(s32_t ticks, bool idle)
{
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
    9920:	f64c 0269 	movw	r2, #51305	; 0xc869
{
    9924:	b570      	push	{r4, r5, r6, lr}
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
    9926:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    992a:	bf08      	it	eq
    992c:	4610      	moveq	r0, r2
	__asm__ volatile(
    992e:	f04f 0320 	mov.w	r3, #32
    9932:	f3ef 8411 	mrs	r4, BASEPRI
    9936:	f383 8811 	msr	BASEPRI, r3
    993a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, t = counter();

	/* Round up to next tick boundary */
	cyc = ticks * CYC_PER_TICK + counter_sub(t, last_count);
    993e:	4d14      	ldr	r5, [pc, #80]	; (9990 <z_clock_set_timeout+0x70>)
     return p_reg->COUNTER;
    9940:	4914      	ldr	r1, [pc, #80]	; (9994 <z_clock_set_timeout+0x74>)
    9942:	682e      	ldr	r6, [r5, #0]
    9944:	f8d1 3504 	ldr.w	r3, [r1, #1284]	; 0x504
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    9948:	3801      	subs	r0, #1
    994a:	4290      	cmp	r0, r2
    994c:	bfa8      	it	ge
    994e:	4610      	movge	r0, r2
	return (a - b) & COUNTER_MAX;
    9950:	1b9a      	subs	r2, r3, r6
    9952:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
	cyc = ticks * CYC_PER_TICK + counter_sub(t, last_count);
    9956:	f240 1547 	movw	r5, #327	; 0x147
    995a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
	cyc += (CYC_PER_TICK - 1);
    995e:	f502 72a3 	add.w	r2, r2, #326	; 0x146
    9962:	fb05 2000 	mla	r0, r5, r0, r2
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
    9966:	fbb0 f0f5 	udiv	r0, r0, r5
	cyc += last_count;
    996a:	fb05 6000 	mla	r0, r5, r0, r6
	return (a - b) & COUNTER_MAX;
    996e:	1ac3      	subs	r3, r0, r3

	if (counter_sub(cyc, t) < MIN_DELAY) {
    9970:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    9974:	f023 031f 	bic.w	r3, r3, #31
    9978:	b903      	cbnz	r3, 997c <z_clock_set_timeout+0x5c>
		cyc += CYC_PER_TICK;
    997a:	4428      	add	r0, r5
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    997c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    9980:	f8c1 0540 	str.w	r0, [r1, #1344]	; 0x540
	__asm__ volatile(
    9984:	f384 8811 	msr	BASEPRI, r4
    9988:	f3bf 8f6f 	isb	sy
	}

	set_comparator(cyc);
	k_spin_unlock(&lock, key);
#endif
}
    998c:	bd70      	pop	{r4, r5, r6, pc}
    998e:	bf00      	nop
    9990:	200039e4 	.word	0x200039e4
    9994:	40011000 	.word	0x40011000

00009998 <z_clock_elapsed>:
	__asm__ volatile(
    9998:	f04f 0220 	mov.w	r2, #32
    999c:	f3ef 8311 	mrs	r3, BASEPRI
    99a0:	f382 8811 	msr	BASEPRI, r2
    99a4:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    99a8:	4a08      	ldr	r2, [pc, #32]	; (99cc <z_clock_elapsed+0x34>)
    99aa:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    99ae:	4a08      	ldr	r2, [pc, #32]	; (99d0 <z_clock_elapsed+0x38>)
	return (a - b) & COUNTER_MAX;
    99b0:	6812      	ldr	r2, [r2, #0]
    99b2:	1a80      	subs	r0, r0, r2
    99b4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    99b8:	f240 1247 	movw	r2, #327	; 0x147
    99bc:	fbb0 f0f2 	udiv	r0, r0, r2
	__asm__ volatile(
    99c0:	f383 8811 	msr	BASEPRI, r3
    99c4:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    99c8:	4770      	bx	lr
    99ca:	bf00      	nop
    99cc:	40011000 	.word	0x40011000
    99d0:	200039e4 	.word	0x200039e4

000099d4 <z_timer_cycle_get_32>:
	__asm__ volatile(
    99d4:	f04f 0320 	mov.w	r3, #32
    99d8:	f3ef 8211 	mrs	r2, BASEPRI
    99dc:	f383 8811 	msr	BASEPRI, r3
    99e0:	f3bf 8f6f 	isb	sy

u32_t z_timer_cycle_get_32(void)
{
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
    99e4:	4906      	ldr	r1, [pc, #24]	; (9a00 <z_timer_cycle_get_32+0x2c>)
    99e6:	4b07      	ldr	r3, [pc, #28]	; (9a04 <z_timer_cycle_get_32+0x30>)
    99e8:	6808      	ldr	r0, [r1, #0]
    99ea:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	__asm__ volatile(
    99ee:	f382 8811 	msr	BASEPRI, r2
    99f2:	f3bf 8f6f 	isb	sy
	return (a - b) & COUNTER_MAX;
    99f6:	1a1b      	subs	r3, r3, r0
    99f8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

	k_spin_unlock(&lock, key);
	return ret;
}
    99fc:	4418      	add	r0, r3
    99fe:	4770      	bx	lr
    9a00:	200039e4 	.word	0x200039e4
    9a04:	40011000 	.word	0x40011000

00009a08 <_IntExit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_ExcExit)

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
    9a08:	4804      	ldr	r0, [pc, #16]	; (9a1c <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
    9a0a:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
    9a0c:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
    9a0e:	4288      	cmp	r0, r1
    beq _EXIT_EXC
    9a10:	d003      	beq.n	9a1a <_EXIT_EXC>

    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
    9a12:	4903      	ldr	r1, [pc, #12]	; (9a20 <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
    9a14:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
    9a18:	600a      	str	r2, [r1, #0]

00009a1a <_EXIT_EXC>:
    mov lr, r1
#else
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */
    bx lr
    9a1a:	4770      	bx	lr
    ldr r0, =_kernel
    9a1c:	200055e4 	.word	0x200055e4
    ldr r1, =_SCS_ICSR
    9a20:	e000ed04 	.word	0xe000ed04

00009a24 <z_IntLibInit>:
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9a24:	4804      	ldr	r0, [pc, #16]	; (9a38 <z_IntLibInit+0x14>)
 * @return N/A
 */

void z_IntLibInit(void)
{
	int irq = 0;
    9a26:	2300      	movs	r3, #0
    9a28:	2120      	movs	r1, #32
    9a2a:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    9a2c:	3301      	adds	r3, #1
    9a2e:	2b30      	cmp	r3, #48	; 0x30
    9a30:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    9a34:	d1f9      	bne.n	9a2a <z_IntLibInit+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    9a36:	4770      	bx	lr
    9a38:	e000e100 	.word	0xe000e100

00009a3c <__swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    9a3c:	4a09      	ldr	r2, [pc, #36]	; (9a64 <__swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    9a3e:	490a      	ldr	r1, [pc, #40]	; (9a68 <__swap+0x2c>)
	_current->arch.basepri = key;
    9a40:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    9a42:	6809      	ldr	r1, [r1, #0]
    9a44:	6699      	str	r1, [r3, #104]	; 0x68

	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    9a46:	4909      	ldr	r1, [pc, #36]	; (9a6c <__swap+0x30>)
	_current->arch.basepri = key;
    9a48:	6658      	str	r0, [r3, #100]	; 0x64
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    9a4a:	684b      	ldr	r3, [r1, #4]
    9a4c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    9a50:	604b      	str	r3, [r1, #4]
    9a52:	2300      	movs	r3, #0
    9a54:	f383 8811 	msr	BASEPRI, r3
    9a58:	f3bf 8f6f 	isb	sy
	irq_unlock(0);

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    9a5c:	6893      	ldr	r3, [r2, #8]
}
    9a5e:	6e98      	ldr	r0, [r3, #104]	; 0x68
    9a60:	4770      	bx	lr
    9a62:	bf00      	nop
    9a64:	200055e4 	.word	0x200055e4
    9a68:	00016834 	.word	0x00016834
    9a6c:	e000ed00 	.word	0xe000ed00

00009a70 <__pendsv>:

    /* protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    9a70:	2020      	movs	r0, #32
    msr BASEPRI, r0
    9a72:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    9a76:	f3bf 8f6f 	isb	sy
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    9a7a:	4911      	ldr	r1, [pc, #68]	; (9ac0 <__pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
    9a7c:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    9a7e:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
    9a82:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
    mrs ip, PSP
    9a84:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    9a88:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
     * don't clear it yet. PendSV must not be cleared until
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
    ldr v4, =_SCS_ICSR
    9a8c:	4f0d      	ldr	r7, [pc, #52]	; (9ac4 <__pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    9a8e:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    9a92:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    9a94:	608a      	str	r2, [r1, #8]
     * since they were based on the previous kernel state and this
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
    str v3, [v4, #0]
    9a96:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    9a98:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs.n r3, #0
    9a9a:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    9a9c:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    9a9e:	f380 8811 	msr	BASEPRI, r0
    vldmia r0, {s16-s31}
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
    9aa2:	b504      	push	{r2, lr}
    ldr r0, =_kernel
    9aa4:	4806      	ldr	r0, [pc, #24]	; (9ac0 <__pendsv+0x50>)
    ldr r0, [r0, #_kernel_offset_to_current]
    9aa6:	6880      	ldr	r0, [r0, #8]
    bl z_arch_configure_dynamic_mpu_regions
    9aa8:	f009 fac0 	bl	1302c <z_arch_configure_dynamic_mpu_regions>
    pop {r2,lr}
    9aac:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    9ab0:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
    9ab4:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    /* clear stack pointer limit before setting the PSP */
    mov r0, #0
    msr PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

    msr PSP, ip
    9ab8:	f38c 8809 	msr	PSP, ip
    pop {r0, lr}
#endif
#endif /* CONFIG_TRACING */

    /* exc return */
    bx lr
    9abc:	4770      	bx	lr
    9abe:	0000      	.short	0x0000
    ldr r1, =_kernel
    9ac0:	200055e4 	.word	0x200055e4
    ldr v4, =_SCS_ICSR
    9ac4:	e000ed04 	.word	0xe000ed04

00009ac8 <__svc>:
 * - System Calls (User mode)
 *
 * @return N/A
 */
SECTION_FUNC(TEXT, __svc)
    tst lr, #0x4    /* did we come from thread mode ? */
    9ac8:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    9acc:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    9ace:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    9ad2:	f3ef 8009 	mrsne	r0, PSP

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    9ad6:	6981      	ldr	r1, [r0, #24]
    /* SVC is a two-byte instruction, point to it and read encoding */
    ldrh r1, [r1, #-2]
    9ad8:	f831 1c02 	ldrh.w	r1, [r1, #-2]
    * 2: kernel panic or oops (software generated fatal exception)
    * 3: System call (if user mode supported)
    * Planned implementation of system calls for memory protection will
    * expand this case.
    */
    ands r1, #0xff
    9adc:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
    tst r2, #0x1
    bne _oops

#endif

    cmp r1, #2
    9ae0:	2902      	cmp	r1, #2
    beq _oops
    9ae2:	d0ff      	beq.n	9ae4 <_oops>

00009ae4 <_oops>:
    /* exception return is done in _IntExit() */
    b _IntExit
#endif

_oops:
    push {r0, lr}
    9ae4:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    9ae6:	f009 fa96 	bl	13016 <z_do_kernel_oops>
    pop {r0, pc}
    9aea:	bd01      	pop	{r0, pc}

00009aec <MpuFault.isra.2>:
 *
 * See _FaultDump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t MpuFault(NANO_ESF *esf, int fromHardFault)
    9aec:	b538      	push	{r3, r4, r5, lr}
	u32_t reason = _NANO_ERR_HW_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****\n");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    9aee:	4c1c      	ldr	r4, [pc, #112]	; (9b60 <MpuFault.isra.2+0x74>)
static u32_t MpuFault(NANO_ESF *esf, int fromHardFault)
    9af0:	4605      	mov	r5, r0
	PR_FAULT_INFO("***** MPU FAULT *****\n");
    9af2:	481c      	ldr	r0, [pc, #112]	; (9b64 <MpuFault.isra.2+0x78>)
    9af4:	f008 f984 	bl	11e00 <printk>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    9af8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    9afa:	06d1      	lsls	r1, r2, #27
    9afc:	d502      	bpl.n	9b04 <MpuFault.isra.2+0x18>
		PR_FAULT_INFO("  Stacking error (context area might be"
    9afe:	481a      	ldr	r0, [pc, #104]	; (9b68 <MpuFault.isra.2+0x7c>)
    9b00:	f008 f97e 	bl	11e00 <printk>
			" not valid)\n");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    9b04:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9b06:	071a      	lsls	r2, r3, #28
    9b08:	d502      	bpl.n	9b10 <MpuFault.isra.2+0x24>
		PR_FAULT_INFO("  Unstacking error\n");
    9b0a:	4818      	ldr	r0, [pc, #96]	; (9b6c <MpuFault.isra.2+0x80>)
    9b0c:	f008 f978 	bl	11e00 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    9b10:	4c13      	ldr	r4, [pc, #76]	; (9b60 <MpuFault.isra.2+0x74>)
    9b12:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9b14:	079b      	lsls	r3, r3, #30
    9b16:	d50e      	bpl.n	9b36 <MpuFault.isra.2+0x4a>
		PR_FAULT_INFO("  Data Access Violation\n");
    9b18:	4815      	ldr	r0, [pc, #84]	; (9b70 <MpuFault.isra.2+0x84>)
    9b1a:	f008 f971 	bl	11e00 <printk>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
    9b1e:	6b61      	ldr	r1, [r4, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    9b20:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9b22:	0618      	lsls	r0, r3, #24
    9b24:	d507      	bpl.n	9b36 <MpuFault.isra.2+0x4a>
			PR_EXC("  MMFAR Address: 0x%x\n", mmfar);
    9b26:	4813      	ldr	r0, [pc, #76]	; (9b74 <MpuFault.isra.2+0x88>)
    9b28:	f008 f96a 	bl	11e00 <printk>
			if (fromHardFault) {
    9b2c:	b11d      	cbz	r5, 9b36 <MpuFault.isra.2+0x4a>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    9b2e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9b30:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    9b34:	62a3      	str	r3, [r4, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    9b36:	4c0a      	ldr	r4, [pc, #40]	; (9b60 <MpuFault.isra.2+0x74>)
    9b38:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    9b3a:	07d2      	lsls	r2, r2, #31
    9b3c:	d502      	bpl.n	9b44 <MpuFault.isra.2+0x58>
		PR_FAULT_INFO("  Instruction Access Violation\n");
    9b3e:	480e      	ldr	r0, [pc, #56]	; (9b78 <MpuFault.isra.2+0x8c>)
    9b40:	f008 f95e 	bl	11e00 <printk>
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    9b44:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9b46:	069b      	lsls	r3, r3, #26
    9b48:	d502      	bpl.n	9b50 <MpuFault.isra.2+0x64>
		PR_FAULT_INFO(
    9b4a:	480c      	ldr	r0, [pc, #48]	; (9b7c <MpuFault.isra.2+0x90>)
    9b4c:	f008 f958 	bl	11e00 <printk>
	 * if the memory violation error is a stack corruption.
	 *
	 * By design, being a Stacking MemManage fault is a necessary
	 * and sufficient condition for a thread stack corruption.
	 */
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    9b50:	4b03      	ldr	r3, [pc, #12]	; (9b60 <MpuFault.isra.2+0x74>)
    9b52:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		"Stacking error without stack guard / User-mode support\n");
#endif /* CONFIG_MPU_STACK_GUARD || CONFIG_USERSPACE */
	}

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    9b54:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    9b56:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    9b5a:	629a      	str	r2, [r3, #40]	; 0x28
	if (MemoryFaultIsRecoverable(esf)) {
		reason = _NANO_ERR_RECOVERABLE;
	}

	return reason;
}
    9b5c:	2000      	movs	r0, #0
    9b5e:	bd38      	pop	{r3, r4, r5, pc}
    9b60:	e000ed00 	.word	0xe000ed00
    9b64:	00018432 	.word	0x00018432
    9b68:	00018449 	.word	0x00018449
    9b6c:	0001847d 	.word	0x0001847d
    9b70:	00018491 	.word	0x00018491
    9b74:	000184aa 	.word	0x000184aa
    9b78:	000184c1 	.word	0x000184c1
    9b7c:	000184e1 	.word	0x000184e1

00009b80 <BusFault.isra.3>:
 *
 * See _FaultDump() for example.
 *
 * @return N/A
 */
static int BusFault(NANO_ESF *esf, int fromHardFault)
    9b80:	b538      	push	{r3, r4, r5, lr}
{
	u32_t reason = _NANO_ERR_HW_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****\n");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    9b82:	4c1e      	ldr	r4, [pc, #120]	; (9bfc <BusFault.isra.3+0x7c>)
static int BusFault(NANO_ESF *esf, int fromHardFault)
    9b84:	4605      	mov	r5, r0
	PR_FAULT_INFO("***** BUS FAULT *****\n");
    9b86:	481e      	ldr	r0, [pc, #120]	; (9c00 <BusFault.isra.3+0x80>)
    9b88:	f008 f93a 	bl	11e00 <printk>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    9b8c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    9b8e:	04d1      	lsls	r1, r2, #19
    9b90:	d502      	bpl.n	9b98 <BusFault.isra.3+0x18>
		PR_FAULT_INFO("  Stacking error\n");
    9b92:	481c      	ldr	r0, [pc, #112]	; (9c04 <BusFault.isra.3+0x84>)
    9b94:	f008 f934 	bl	11e00 <printk>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    9b98:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9b9a:	051a      	lsls	r2, r3, #20
    9b9c:	d502      	bpl.n	9ba4 <BusFault.isra.3+0x24>
		PR_FAULT_INFO("  Unstacking error\n");
    9b9e:	481a      	ldr	r0, [pc, #104]	; (9c08 <BusFault.isra.3+0x88>)
    9ba0:	f008 f92e 	bl	11e00 <printk>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    9ba4:	4c15      	ldr	r4, [pc, #84]	; (9bfc <BusFault.isra.3+0x7c>)
    9ba6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9ba8:	059b      	lsls	r3, r3, #22
    9baa:	d50e      	bpl.n	9bca <BusFault.isra.3+0x4a>
		PR_FAULT_INFO("  Precise data bus error\n");
    9bac:	4817      	ldr	r0, [pc, #92]	; (9c0c <BusFault.isra.3+0x8c>)
    9bae:	f008 f927 	bl	11e00 <printk>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    9bb2:	6ba1      	ldr	r1, [r4, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    9bb4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9bb6:	0418      	lsls	r0, r3, #16
    9bb8:	d507      	bpl.n	9bca <BusFault.isra.3+0x4a>
			PR_EXC("  BFAR Address: 0x%x\n", bfar);
    9bba:	4815      	ldr	r0, [pc, #84]	; (9c10 <BusFault.isra.3+0x90>)
    9bbc:	f008 f920 	bl	11e00 <printk>
			if (fromHardFault) {
    9bc0:	b11d      	cbz	r5, 9bca <BusFault.isra.3+0x4a>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    9bc2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9bc4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    9bc8:	62a3      	str	r3, [r4, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    9bca:	4c0c      	ldr	r4, [pc, #48]	; (9bfc <BusFault.isra.3+0x7c>)
    9bcc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9bce:	0559      	lsls	r1, r3, #21
    9bd0:	d502      	bpl.n	9bd8 <BusFault.isra.3+0x58>
		PR_FAULT_INFO("  Imprecise data bus error\n");
    9bd2:	4810      	ldr	r0, [pc, #64]	; (9c14 <BusFault.isra.3+0x94>)
    9bd4:	f008 f914 	bl	11e00 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    9bd8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9bda:	05da      	lsls	r2, r3, #23
    9bdc:	d509      	bpl.n	9bf2 <BusFault.isra.3+0x72>
		PR_FAULT_INFO("  Instruction bus error\n");
    9bde:	480e      	ldr	r0, [pc, #56]	; (9c18 <BusFault.isra.3+0x98>)
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
		PR_FAULT_INFO("  Floating-point lazy state preservation error\n");
    9be0:	f008 f90e 	bl	11e00 <printk>
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    9be4:	4a05      	ldr	r2, [pc, #20]	; (9bfc <BusFault.isra.3+0x7c>)
    9be6:	6a93      	ldr	r3, [r2, #40]	; 0x28
    9be8:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    9bec:	6293      	str	r3, [r2, #40]	; 0x28
	if (MemoryFaultIsRecoverable(esf)) {
		reason = _NANO_ERR_RECOVERABLE;
	}

	return reason;
}
    9bee:	2000      	movs	r0, #0
    9bf0:	bd38      	pop	{r3, r4, r5, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    9bf2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9bf4:	049b      	lsls	r3, r3, #18
    9bf6:	d5f5      	bpl.n	9be4 <BusFault.isra.3+0x64>
		PR_FAULT_INFO("  Floating-point lazy state preservation error\n");
    9bf8:	4808      	ldr	r0, [pc, #32]	; (9c1c <BusFault.isra.3+0x9c>)
    9bfa:	e7f1      	b.n	9be0 <BusFault.isra.3+0x60>
    9bfc:	e000ed00 	.word	0xe000ed00
    9c00:	000183a4 	.word	0x000183a4
    9c04:	000183bb 	.word	0x000183bb
    9c08:	0001847d 	.word	0x0001847d
    9c0c:	000183cd 	.word	0x000183cd
    9c10:	000183e7 	.word	0x000183e7
    9c14:	000183fd 	.word	0x000183fd
    9c18:	00018419 	.word	0x00018419
    9c1c:	000184e1 	.word	0x000184e1

00009c20 <UsageFault.isra.4>:
 *
 * See _FaultDump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t UsageFault(const NANO_ESF *esf)
    9c20:	b510      	push	{r4, lr}
	u32_t reason = _NANO_ERR_HW_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****\n");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    9c22:	4c19      	ldr	r4, [pc, #100]	; (9c88 <UsageFault.isra.4+0x68>)
	PR_FAULT_INFO("***** USAGE FAULT *****\n");
    9c24:	4819      	ldr	r0, [pc, #100]	; (9c8c <UsageFault.isra.4+0x6c>)
    9c26:	f008 f8eb 	bl	11e00 <printk>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    9c2a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    9c2c:	0193      	lsls	r3, r2, #6
    9c2e:	d502      	bpl.n	9c36 <UsageFault.isra.4+0x16>
		PR_FAULT_INFO("  Division by zero\n");
    9c30:	4817      	ldr	r0, [pc, #92]	; (9c90 <UsageFault.isra.4+0x70>)
    9c32:	f008 f8e5 	bl	11e00 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    9c36:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9c38:	01dc      	lsls	r4, r3, #7
    9c3a:	d502      	bpl.n	9c42 <UsageFault.isra.4+0x22>
		PR_FAULT_INFO("  Unaligned memory access\n");
    9c3c:	4815      	ldr	r0, [pc, #84]	; (9c94 <UsageFault.isra.4+0x74>)
    9c3e:	f008 f8df 	bl	11e00 <printk>
		 */
		reason = _NANO_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    9c42:	4c11      	ldr	r4, [pc, #68]	; (9c88 <UsageFault.isra.4+0x68>)
    9c44:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    9c46:	0310      	lsls	r0, r2, #12
    9c48:	d502      	bpl.n	9c50 <UsageFault.isra.4+0x30>
		PR_FAULT_INFO("  No coprocessor instructions\n");
    9c4a:	4813      	ldr	r0, [pc, #76]	; (9c98 <UsageFault.isra.4+0x78>)
    9c4c:	f008 f8d8 	bl	11e00 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    9c50:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9c52:	0359      	lsls	r1, r3, #13
    9c54:	d502      	bpl.n	9c5c <UsageFault.isra.4+0x3c>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC\n");
    9c56:	4811      	ldr	r0, [pc, #68]	; (9c9c <UsageFault.isra.4+0x7c>)
    9c58:	f008 f8d2 	bl	11e00 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    9c5c:	4c0a      	ldr	r4, [pc, #40]	; (9c88 <UsageFault.isra.4+0x68>)
    9c5e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    9c60:	0392      	lsls	r2, r2, #14
    9c62:	d502      	bpl.n	9c6a <UsageFault.isra.4+0x4a>
		PR_FAULT_INFO("  Illegal use of the EPSR\n");
    9c64:	480e      	ldr	r0, [pc, #56]	; (9ca0 <UsageFault.isra.4+0x80>)
    9c66:	f008 f8cb 	bl	11e00 <printk>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    9c6a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    9c6c:	03db      	lsls	r3, r3, #15
    9c6e:	d502      	bpl.n	9c76 <UsageFault.isra.4+0x56>
		PR_FAULT_INFO("  Attempt to execute undefined instruction\n");
    9c70:	480c      	ldr	r0, [pc, #48]	; (9ca4 <UsageFault.isra.4+0x84>)
    9c72:	f008 f8c5 	bl	11e00 <printk>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    9c76:	4a04      	ldr	r2, [pc, #16]	; (9c88 <UsageFault.isra.4+0x68>)
    9c78:	6a93      	ldr	r3, [r2, #40]	; 0x28
    9c7a:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    9c7e:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    9c82:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    9c84:	2000      	movs	r0, #0
    9c86:	bd10      	pop	{r4, pc}
    9c88:	e000ed00 	.word	0xe000ed00
    9c8c:	00018511 	.word	0x00018511
    9c90:	0001852a 	.word	0x0001852a
    9c94:	0001853e 	.word	0x0001853e
    9c98:	00018559 	.word	0x00018559
    9c9c:	00018578 	.word	0x00018578
    9ca0:	0001859e 	.word	0x0001859e
    9ca4:	000185b9 	.word	0x000185b9

00009ca8 <_Fault>:
 *
 * Note: exc_return argument shall only be used by the Fault handler if we are
 * running a Secure Firmware.
 */
void _Fault(NANO_ESF *esf, u32_t exc_return)
{
    9ca8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t reason = _NANO_ERR_HW_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    9caa:	4d29      	ldr	r5, [pc, #164]	; (9d50 <_Fault+0xa8>)
    9cac:	686e      	ldr	r6, [r5, #4]
    9cae:	f3c6 0408 	ubfx	r4, r6, #0, #9
{
    9cb2:	4607      	mov	r7, r0
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_LOG_PANIC, log_panic)
    9cb4:	f7fd f924 	bl	6f00 <z_impl_log_panic>
	switch (fault) {
    9cb8:	1ee3      	subs	r3, r4, #3
    9cba:	2b09      	cmp	r3, #9
    9cbc:	d83b      	bhi.n	9d36 <_Fault+0x8e>
    9cbe:	e8df f003 	tbb	[pc, r3]
    9cc2:	3405      	.short	0x3405
    9cc4:	3a3a2936 	.word	0x3a3a2936
    9cc8:	383a3a3a 	.word	0x383a3a3a
	PR_FAULT_INFO("***** HARD FAULT *****\n");
    9ccc:	4821      	ldr	r0, [pc, #132]	; (9d54 <_Fault+0xac>)
    9cce:	f008 f897 	bl	11e00 <printk>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    9cd2:	6aec      	ldr	r4, [r5, #44]	; 0x2c
    9cd4:	f014 0402 	ands.w	r4, r4, #2
    9cd8:	d004      	beq.n	9ce4 <_Fault+0x3c>
		PR_EXC("  Bus fault on vector table read\n");
    9cda:	481f      	ldr	r0, [pc, #124]	; (9d58 <_Fault+0xb0>)
	PR_FAULT_INFO(
    9cdc:	f008 f890 	bl	11e00 <printk>
	u32_t reason = _NANO_ERR_HW_EXCEPTION;
    9ce0:	2400      	movs	r4, #0
    9ce2:	e01c      	b.n	9d1e <_Fault+0x76>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    9ce4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    9ce6:	005b      	lsls	r3, r3, #1
    9ce8:	d519      	bpl.n	9d1e <_Fault+0x76>
		PR_EXC("  Fault escalation (see below)\n");
    9cea:	481c      	ldr	r0, [pc, #112]	; (9d5c <_Fault+0xb4>)
    9cec:	f008 f888 	bl	11e00 <printk>
		if (SCB_MMFSR != 0) {
    9cf0:	4b1b      	ldr	r3, [pc, #108]	; (9d60 <_Fault+0xb8>)
    9cf2:	781b      	ldrb	r3, [r3, #0]
    9cf4:	b11b      	cbz	r3, 9cfe <_Fault+0x56>
			reason = MpuFault(esf, 1);
    9cf6:	2001      	movs	r0, #1
		reason = MpuFault(esf, 0);
    9cf8:	f7ff fef8 	bl	9aec <MpuFault.isra.2>
    9cfc:	e00c      	b.n	9d18 <_Fault+0x70>
		} else if (SCB_BFSR != 0) {
    9cfe:	4b19      	ldr	r3, [pc, #100]	; (9d64 <_Fault+0xbc>)
    9d00:	781b      	ldrb	r3, [r3, #0]
    9d02:	b11b      	cbz	r3, 9d0c <_Fault+0x64>
			reason = BusFault(esf, 1);
    9d04:	2001      	movs	r0, #1
		reason = BusFault(esf, 0);
    9d06:	f7ff ff3b 	bl	9b80 <BusFault.isra.3>
    9d0a:	e005      	b.n	9d18 <_Fault+0x70>
		} else if (SCB_UFSR != 0) {
    9d0c:	4b16      	ldr	r3, [pc, #88]	; (9d68 <_Fault+0xc0>)
    9d0e:	881b      	ldrh	r3, [r3, #0]
    9d10:	b29b      	uxth	r3, r3
    9d12:	b123      	cbz	r3, 9d1e <_Fault+0x76>
			reason = UsageFault(esf);
    9d14:	f7ff ff84 	bl	9c20 <UsageFault.isra.4>
	(void) exc_return;
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	reason = FaultHandle(esf, fault);

	if (reason == _NANO_ERR_RECOVERABLE) {
    9d18:	2806      	cmp	r0, #6
			reason = UsageFault(esf);
    9d1a:	4604      	mov	r4, r0
	if (reason == _NANO_ERR_RECOVERABLE) {
    9d1c:	d017      	beq.n	9d4e <_Fault+0xa6>

#if defined(CONFIG_ARM_SECURE_FIRMWARE) || \
	defined(CONFIG_ARM_NONSECURE_FIRMWARE)
_exit_fatal:
#endif
	z_NanoFatalErrorHandler(reason, esf);
    9d1e:	4639      	mov	r1, r7
    9d20:	4620      	mov	r0, r4
}
    9d22:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_NanoFatalErrorHandler(reason, esf);
    9d26:	f000 b8c5 	b.w	9eb4 <z_NanoFatalErrorHandler>
		reason = MpuFault(esf, 0);
    9d2a:	2000      	movs	r0, #0
    9d2c:	e7e4      	b.n	9cf8 <_Fault+0x50>
		reason = BusFault(esf, 0);
    9d2e:	2000      	movs	r0, #0
    9d30:	e7e9      	b.n	9d06 <_Fault+0x5e>
	PR_FAULT_INFO(
    9d32:	480e      	ldr	r0, [pc, #56]	; (9d6c <_Fault+0xc4>)
    9d34:	e7d2      	b.n	9cdc <_Fault+0x34>
	PR_FAULT_INFO("***** %s %d) *****\n",
    9d36:	4b0e      	ldr	r3, [pc, #56]	; (9d70 <_Fault+0xc8>)
    9d38:	490e      	ldr	r1, [pc, #56]	; (9d74 <_Fault+0xcc>)
    9d3a:	480f      	ldr	r0, [pc, #60]	; (9d78 <_Fault+0xd0>)
    9d3c:	f416 7ff8 	tst.w	r6, #496	; 0x1f0
    9d40:	f1a4 0210 	sub.w	r2, r4, #16
    9d44:	bf18      	it	ne
    9d46:	4619      	movne	r1, r3
    9d48:	f008 f85a 	bl	11e00 <printk>
	if (reason == _NANO_ERR_RECOVERABLE) {
    9d4c:	e7c8      	b.n	9ce0 <_Fault+0x38>
}
    9d4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9d50:	e000ed00 	.word	0xe000ed00
    9d54:	00018613 	.word	0x00018613
    9d58:	0001862b 	.word	0x0001862b
    9d5c:	0001864d 	.word	0x0001864d
    9d60:	e000ed28 	.word	0xe000ed28
    9d64:	e000ed29 	.word	0xe000ed29
    9d68:	e000ed2a 	.word	0xe000ed2a
    9d6c:	0001866d 	.word	0x0001866d
    9d70:	000185fa 	.word	0x000185fa
    9d74:	000185e5 	.word	0x000185e5
    9d78:	000186a4 	.word	0x000186a4

00009d7c <z_FaultInit>:
 */
void z_FaultInit(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    9d7c:	4a02      	ldr	r2, [pc, #8]	; (9d88 <z_FaultInit+0xc>)
    9d7e:	6953      	ldr	r3, [r2, #20]
    9d80:	f043 0310 	orr.w	r3, r3, #16
    9d84:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    9d86:	4770      	bx	lr
    9d88:	e000ed00 	.word	0xe000ed00

00009d8c <z_arch_irq_enable>:
 *
 * @return N/A
 */
void z_arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    9d8c:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    9d8e:	2b00      	cmp	r3, #0
    9d90:	db08      	blt.n	9da4 <z_arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9d92:	2201      	movs	r2, #1
    9d94:	f000 001f 	and.w	r0, r0, #31
    9d98:	fa02 f000 	lsl.w	r0, r2, r0
    9d9c:	095b      	lsrs	r3, r3, #5
    9d9e:	4a02      	ldr	r2, [pc, #8]	; (9da8 <z_arch_irq_enable+0x1c>)
    9da0:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    9da4:	4770      	bx	lr
    9da6:	bf00      	nop
    9da8:	e000e100 	.word	0xe000e100

00009dac <z_arch_irq_disable>:
 *
 * @return N/A
 */
void z_arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    9dac:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    9dae:	2b00      	cmp	r3, #0
    9db0:	db0d      	blt.n	9dce <z_arch_irq_disable+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9db2:	2201      	movs	r2, #1
    9db4:	095b      	lsrs	r3, r3, #5
    9db6:	f000 001f 	and.w	r0, r0, #31
    9dba:	fa02 f000 	lsl.w	r0, r2, r0
    9dbe:	3320      	adds	r3, #32
    9dc0:	4a03      	ldr	r2, [pc, #12]	; (9dd0 <z_arch_irq_disable+0x24>)
    9dc2:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    9dc6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    9dca:	f3bf 8f6f 	isb	sy
}
    9dce:	4770      	bx	lr
    9dd0:	e000e100 	.word	0xe000e100

00009dd4 <z_arch_irq_is_enabled>:
 * @param irq IRQ line
 * @return interrupt enable state, true or false
 */
int z_arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    9dd4:	0942      	lsrs	r2, r0, #5
    9dd6:	4b05      	ldr	r3, [pc, #20]	; (9dec <z_arch_irq_is_enabled+0x18>)
    9dd8:	f000 001f 	and.w	r0, r0, #31
    9ddc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    9de0:	2301      	movs	r3, #1
    9de2:	fa03 f000 	lsl.w	r0, r3, r0
}
    9de6:	4010      	ands	r0, r2
    9de8:	4770      	bx	lr
    9dea:	bf00      	nop
    9dec:	e000e100 	.word	0xe000e100

00009df0 <z_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    9df0:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    9df2:	2b00      	cmp	r3, #0
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9df4:	bfa8      	it	ge
    9df6:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
	prio += _IRQ_PRIO_OFFSET;
    9dfa:	f101 0101 	add.w	r1, r1, #1
    9dfe:	ea4f 1141 	mov.w	r1, r1, lsl #5
    9e02:	bfae      	itee	ge
    9e04:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9e08:	f000 000f 	andlt.w	r0, r0, #15
    9e0c:	4b03      	ldrlt	r3, [pc, #12]	; (9e1c <z_irq_priority_set+0x2c>)
    9e0e:	b2c9      	uxtb	r1, r1
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9e10:	bfac      	ite	ge
    9e12:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9e16:	5419      	strblt	r1, [r3, r0]
}
    9e18:	4770      	bx	lr
    9e1a:	bf00      	nop
    9e1c:	e000ed14 	.word	0xe000ed14

00009e20 <z_new_thread>:

void z_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		 size_t stackSize, k_thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned int options)
{
    9e20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	 * k_thread_create(). If K_THREAD_STACK_SIZEOF() is used, the
	 * Guard size has already been take out of stackSize.
	 */
	stackSize -= MPU_GUARD_ALIGN_AND_SIZE;
#endif
	stackEnd = pStackMem + stackSize;
    9e24:	188c      	adds	r4, r1, r2
{
    9e26:	4688      	mov	r8, r1
    9e28:	4617      	mov	r7, r2
    9e2a:	461e      	mov	r6, r3
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
    9e2c:	2204      	movs	r2, #4
    9e2e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9e30:	9909      	ldr	r1, [sp, #36]	; 0x24
    9e32:	4605      	mov	r5, r0
    9e34:	f00b ffe8 	bl	15e08 <z_init_thread_base>

	z_new_thread_init(thread, pStackMem, stackSize, priority,
			 options);

	/* carve the thread entry struct from the "base" of the stack */
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    9e38:	f1a4 0320 	sub.w	r3, r4, #32
#else
	pInitCtx->pc = (u32_t)z_thread_entry;
#endif

	/* force ARM mode by clearing LSB of address */
	pInitCtx->pc &= 0xfffffffe;
    9e3c:	490c      	ldr	r1, [pc, #48]	; (9e70 <z_new_thread+0x50>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    9e3e:	f023 0307 	bic.w	r3, r3, #7

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
    9e42:	2200      	movs	r2, #0
	pInitCtx->pc &= 0xfffffffe;
    9e44:	f021 0101 	bic.w	r1, r1, #1
	thread->fn_abort = NULL;
    9e48:	e9c5 2213 	strd	r2, r2, [r5, #76]	; 0x4c
	thread->mem_domain_info.mem_domain = NULL;
#endif /* CONFIG_USERSPACE */

#if defined(CONFIG_THREAD_STACK_INFO)
	thread->stack_info.start = (u32_t)pStack;
	thread->stack_info.size = (u32_t)stackSize;
    9e4c:	e9c5 8716 	strd	r8, r7, [r5, #88]	; 0x58
    9e50:	6199      	str	r1, [r3, #24]

	pInitCtx->a1 = (u32_t)pEntry;
	pInitCtx->a2 = (u32_t)parameter1;
    9e52:	9906      	ldr	r1, [sp, #24]
    9e54:	6059      	str	r1, [r3, #4]
	pInitCtx->a3 = (u32_t)parameter2;
    9e56:	9907      	ldr	r1, [sp, #28]
    9e58:	6099      	str	r1, [r3, #8]
	pInitCtx->a4 = (u32_t)parameter3;
    9e5a:	9908      	ldr	r1, [sp, #32]
    9e5c:	60d9      	str	r1, [r3, #12]
	pInitCtx->xpsr =
    9e5e:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
	pInitCtx->a1 = (u32_t)pEntry;
    9e62:	601e      	str	r6, [r3, #0]
	pInitCtx->xpsr =
    9e64:	61d9      	str	r1, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */
#ifdef CONFIG_FLOAT
	pInitCtx->fpscr = (u32_t)0; /* clears FPU status/control register*/
#endif

	thread->callee_saved.psp = (u32_t)pInitCtx;
    9e66:	64ab      	str	r3, [r5, #72]	; 0x48
	thread->arch.basepri = 0;
    9e68:	666a      	str	r2, [r5, #100]	; 0x64

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    9e6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9e6e:	bf00      	nop
    9e70:	00011aed 	.word	0x00011aed

00009e74 <z_CpuIdleInit>:
 *
 * void z_CpuIdleInit (void);
 */

SECTION_FUNC(TEXT, z_CpuIdleInit)
	ldr r1, =_SCB_SCR
    9e74:	4901      	ldr	r1, [pc, #4]	; (9e7c <z_CpuIdleInit+0x8>)
	movs.n r2, #_SCR_INIT_BITS
    9e76:	2210      	movs	r2, #16
	str r2, [r1]
    9e78:	600a      	str	r2, [r1, #0]
	bx lr
    9e7a:	4770      	bx	lr
	ldr r1, =_SCB_SCR
    9e7c:	e000ed10 	.word	0xe000ed10

00009e80 <k_cpu_idle>:

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
    9e80:	4040      	eors	r0, r0
	msr BASEPRI, r0
    9e82:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
    9e86:	bf30      	wfi

	bx lr
    9e88:	4770      	bx	lr
    9e8a:	bf00      	nop

00009e8c <__bus_fault>:
	mrs r0, MSP
_stack_frame_endif:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* force unlock interrupts */
	eors.n r0, r0
    9e8c:	4040      	eors	r0, r0
	msr BASEPRI, r0
    9e8e:	f380 8811 	msr	BASEPRI, r0

#if !defined(CONFIG_ARM_SECURE_FIRMWARE) && \
	!defined(CONFIG_ARM_NONSECURE_FIRMWARE)
	/* this checks to see if we are in a nested exception */
	ldr ip, =_SCS_ICSR
    9e92:	f8df c01c 	ldr.w	ip, [pc, #28]	; 9eb0 <__bus_fault+0x24>
	ldr ip, [ip]
    9e96:	f8dc c000 	ldr.w	ip, [ip]
	ands.w ip, #_SCS_ICSR_RETTOBASE
    9e9a:	f41c 6c00 	ands.w	ip, ip, #2048	; 0x800

	ite eq			/* is the RETTOBASE bit zero ? */
    9e9e:	bf0c      	ite	eq
		mrseq r0, MSP	/* if so, we're not returning to thread mode,
    9ea0:	f3ef 8008 	mrseq	r0, MSP
				 * thus this is a nested exception: the stack
				 * frame is on the MSP */
		mrsne r0, PSP	/* if not, we are returning to thread mode, thus
    9ea4:	f3ef 8009 	mrsne	r0, PSP
	 * located in the LR. Therefore, we supply the LR value as an
	 * argument to the fault handler.
	 */
	mov r1, lr
#endif /* CONFIG_ARM_SECURE_FIRMWARE || CONFIG_ARM_NONSECURE_FIRMWARE */
	push {r0, lr}
    9ea8:	b501      	push	{r0, lr}
	bl _Fault
    9eaa:	f7ff fefd 	bl	9ca8 <_Fault>

	pop {r0, pc}
    9eae:	bd01      	pop	{r0, pc}
	ldr ip, =_SCS_ICSR
    9eb0:	e000ed04 	.word	0xe000ed04

00009eb4 <z_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
void z_NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
    9eb4:	b538      	push	{r3, r4, r5, lr}
    9eb6:	4604      	mov	r4, r0
    9eb8:	460d      	mov	r5, r1
    9eba:	f7fd f821 	bl	6f00 <z_impl_log_panic>
	LOG_PANIC();

	switch (reason) {
    9ebe:	2c05      	cmp	r4, #5
    9ec0:	d81a      	bhi.n	9ef8 <z_NanoFatalErrorHandler+0x44>
    9ec2:	e8df f004 	tbb	[pc, r4]
    9ec6:	1903      	.short	0x1903
    9ec8:	17151319 	.word	0x17151319
	case _NANO_ERR_HW_EXCEPTION:
		printk("***** Hardware exception *****\n");
    9ecc:	480d      	ldr	r0, [pc, #52]	; (9f04 <z_NanoFatalErrorHandler+0x50>)
		printk("***** Stack Check Fail! *****\n");
		break;
#endif /* CONFIG_STACK_CANARIES */

	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
    9ece:	f007 ff97 	bl	11e00 <printk>
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
    9ed2:	f005 fb93 	bl	f5fc <z_impl_k_current_get>

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
		break;
	}
	printk("Current thread ID = %p\n"
    9ed6:	69aa      	ldr	r2, [r5, #24]
    9ed8:	4601      	mov	r1, r0
    9eda:	480b      	ldr	r0, [pc, #44]	; (9f08 <z_NanoFatalErrorHandler+0x54>)
    9edc:	f007 ff90 	bl	11e00 <printk>
	 * to respond to the error.  The decisions as to what responses are
	 * appropriate to the various errors are something the customer must
	 * decide.
	 */

	z_SysFatalErrorHandler(reason, pEsf);
    9ee0:	4629      	mov	r1, r5
    9ee2:	4620      	mov	r0, r4
}
    9ee4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_SysFatalErrorHandler(reason, pEsf);
    9ee8:	f000 b818 	b.w	9f1c <z_SysFatalErrorHandler>
		printk("**** Kernel Allocation Failure! ****\n");
    9eec:	4807      	ldr	r0, [pc, #28]	; (9f0c <z_NanoFatalErrorHandler+0x58>)
    9eee:	e7ee      	b.n	9ece <z_NanoFatalErrorHandler+0x1a>
		printk("***** Kernel OOPS! *****\n");
    9ef0:	4807      	ldr	r0, [pc, #28]	; (9f10 <z_NanoFatalErrorHandler+0x5c>)
    9ef2:	e7ec      	b.n	9ece <z_NanoFatalErrorHandler+0x1a>
		printk("***** Kernel Panic! *****\n");
    9ef4:	4807      	ldr	r0, [pc, #28]	; (9f14 <z_NanoFatalErrorHandler+0x60>)
    9ef6:	e7ea      	b.n	9ece <z_NanoFatalErrorHandler+0x1a>
		printk("**** Unknown Fatal Error %d! ****\n", reason);
    9ef8:	4621      	mov	r1, r4
    9efa:	4807      	ldr	r0, [pc, #28]	; (9f18 <z_NanoFatalErrorHandler+0x64>)
    9efc:	f007 ff80 	bl	11e00 <printk>
		break;
    9f00:	e7e7      	b.n	9ed2 <z_NanoFatalErrorHandler+0x1e>
    9f02:	bf00      	nop
    9f04:	000186b8 	.word	0x000186b8
    9f08:	00018756 	.word	0x00018756
    9f0c:	000186d8 	.word	0x000186d8
    9f10:	000186fe 	.word	0x000186fe
    9f14:	00018718 	.word	0x00018718
    9f18:	00018733 	.word	0x00018733

00009f1c <z_SysFatalErrorHandler>:
#ifdef CONFIG_STACK_SENTINEL
	if (reason == _NANO_ERR_STACK_CHK_FAIL) {
		goto hang_system;
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
    9f1c:	2805      	cmp	r0, #5
{
    9f1e:	b510      	push	{r4, lr}
	if (reason == _NANO_ERR_KERNEL_PANIC) {
    9f20:	d00c      	beq.n	9f3c <z_SysFatalErrorHandler+0x20>
		goto hang_system;
	}
	if (k_is_in_isr() || z_is_thread_essential()) {
    9f22:	f005 fbd9 	bl	f6d8 <k_is_in_isr>
    9f26:	b160      	cbz	r0, 9f42 <z_SysFatalErrorHandler+0x26>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
    9f28:	f005 fbd6 	bl	f6d8 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
    9f2c:	490c      	ldr	r1, [pc, #48]	; (9f60 <z_SysFatalErrorHandler+0x44>)
    9f2e:	4b0d      	ldr	r3, [pc, #52]	; (9f64 <z_SysFatalErrorHandler+0x48>)
    9f30:	2800      	cmp	r0, #0
    9f32:	bf08      	it	eq
    9f34:	4619      	moveq	r1, r3
    9f36:	480c      	ldr	r0, [pc, #48]	; (9f68 <z_SysFatalErrorHandler+0x4c>)
    9f38:	f007 ff62 	bl	11e00 <printk>
#else
	ARG_UNUSED(reason);
#endif

	for (;;) {
		k_cpu_idle();
    9f3c:	f7ff ffa0 	bl	9e80 <k_cpu_idle>
    9f40:	e7fc      	b.n	9f3c <z_SysFatalErrorHandler+0x20>
	if (k_is_in_isr() || z_is_thread_essential()) {
    9f42:	f005 fbe3 	bl	f70c <z_is_thread_essential>
    9f46:	2800      	cmp	r0, #0
    9f48:	d1ee      	bne.n	9f28 <z_SysFatalErrorHandler+0xc>
	printk("Fatal fault in thread %p! Aborting.\n", _current);
    9f4a:	4c08      	ldr	r4, [pc, #32]	; (9f6c <z_SysFatalErrorHandler+0x50>)
    9f4c:	4808      	ldr	r0, [pc, #32]	; (9f70 <z_SysFatalErrorHandler+0x54>)
    9f4e:	68a1      	ldr	r1, [r4, #8]
    9f50:	f007 ff56 	bl	11e00 <printk>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
    9f54:	68a0      	ldr	r0, [r4, #8]
	}
	CODE_UNREACHABLE;
}
    9f56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    9f5a:	f000 b80b 	b.w	9f74 <z_impl_k_thread_abort>
    9f5e:	bf00      	nop
    9f60:	00018792 	.word	0x00018792
    9f64:	00018796 	.word	0x00018796
    9f68:	000187a7 	.word	0x000187a7
    9f6c:	200055e4 	.word	0x200055e4
    9f70:	000187c7 	.word	0x000187c7

00009f74 <z_impl_k_thread_abort>:
#include <misc/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    9f74:	b538      	push	{r3, r4, r5, lr}
    9f76:	4605      	mov	r5, r0
	__asm__ volatile(
    9f78:	f04f 0320 	mov.w	r3, #32
    9f7c:	f3ef 8411 	mrs	r4, BASEPRI
    9f80:	f383 8811 	msr	BASEPRI, r3
    9f84:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    9f88:	f00b ff1f 	bl	15dca <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    9f8c:	4b0a      	ldr	r3, [pc, #40]	; (9fb8 <z_impl_k_thread_abort+0x44>)
    9f8e:	689b      	ldr	r3, [r3, #8]
    9f90:	42ab      	cmp	r3, r5
    9f92:	d10b      	bne.n	9fac <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    9f94:	4b09      	ldr	r3, [pc, #36]	; (9fbc <z_impl_k_thread_abort+0x48>)
    9f96:	685a      	ldr	r2, [r3, #4]
    9f98:	f3c2 0208 	ubfx	r2, r2, #0, #9
    9f9c:	b912      	cbnz	r2, 9fa4 <z_impl_k_thread_abort+0x30>
#ifndef CONFIG_ARM
#ifdef CONFIG_TRACING
	sys_trace_thread_switched_out();
#endif
#endif
	ret = __swap(key);
    9f9e:	4620      	mov	r0, r4
    9fa0:	f7ff fd4c 	bl	9a3c <__swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    9fa4:	685a      	ldr	r2, [r3, #4]
    9fa6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    9faa:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    9fac:	4620      	mov	r0, r4
}
    9fae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    9fb2:	f00b be44 	b.w	15c3e <z_reschedule_irqlock>
    9fb6:	bf00      	nop
    9fb8:	200055e4 	.word	0x200055e4
    9fbc:	e000ed00 	.word	0xe000ed00

00009fc0 <_isr_wrapper>:
 *
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

	push {r0,lr}		/* r0, lr are now the first items on the stack */
    9fc0:	b501      	push	{r0, lr}
	 * for the next timer deadline is not interrupted.  For non-tickless idle,
	 * this ensures that the clearing of the kernel idle state is not
	 * interrupted.  In each case, z_sys_power_save_idle_exit is called with
	 * interrupts disabled.
	 */
	cpsid i  /* PRIMASK = 1 */
    9fc2:	b672      	cpsid	i

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    9fc4:	4a0b      	ldr	r2, [pc, #44]	; (9ff4 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    9fc6:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    9fc8:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    9fca:	bf1e      	ittt	ne
	movne	r1, #0
    9fcc:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    9fce:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    9fd0:	f00b fccc 	blne	1596c <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    9fd4:	b662      	cpsie	i
#endif

	mrs r0, IPSR	/* get exception number */
    9fd6:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    9fda:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    9fde:	ea4f 00c0 	mov.w	r0, r0, lsl #3
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
    9fe2:	4905      	ldr	r1, [pc, #20]	; (9ff8 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    9fe4:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    9fe6:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    9fe8:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    9fea:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * _IntExit() */
	ldr r0, =_IntExit
    9fee:	4803      	ldr	r0, [pc, #12]	; (9ffc <_isr_wrapper+0x3c>)
	bx r0
    9ff0:	4700      	bx	r0
    9ff2:	0000      	.short	0x0000
	ldr r2, =_kernel
    9ff4:	200055e4 	.word	0x200055e4
	ldr r1, =_sw_isr_table
    9ff8:	000160e8 	.word	0x000160e8
	ldr r0, =_IntExit
    9ffc:	00009a09 	.word	0x00009a09

0000a000 <__reset>:

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    a000:	2020      	movs	r0, #32
    msr BASEPRI, r0
    a002:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
    a006:	4808      	ldr	r0, [pc, #32]	; (a028 <__reset+0x28>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    a008:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    adds r0, r0, r1
    a00c:	1840      	adds	r0, r0, r1
    msr PSP, r0
    a00e:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    a012:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    a016:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    a018:	4308      	orrs	r0, r1
    msr CONTROL, r0
    a01a:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    a01e:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to _PrepC
     * (even though we do not intend to return).
     */
    bl _PrepC
    a022:	f000 f807 	bl	a034 <_PrepC>
    a026:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
    a028:	20008e58 	.word	0x20008e58

0000a02c <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    a02c:	bf30      	wfi
    b z_SysNmiOnReset
    a02e:	f7ff bffd 	b.w	a02c <z_SysNmiOnReset>
    a032:	bf00      	nop

0000a034 <_PrepC>:

#ifdef CONFIG_BOOT_TIME_MEASUREMENT
	extern u64_t __start_time_stamp;
#endif
void _PrepC(void)
{
    a034:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    a036:	4b08      	ldr	r3, [pc, #32]	; (a058 <_PrepC+0x24>)
    a038:	4a08      	ldr	r2, [pc, #32]	; (a05c <_PrepC+0x28>)
    a03a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    a03e:	6093      	str	r3, [r2, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    a040:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    a044:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
    a048:	f004 fd12 	bl	ea70 <z_bss_zero>
	z_data_copy();
    a04c:	f004 fd1a 	bl	ea84 <z_data_copy>
#ifdef CONFIG_BOOT_TIME_MEASUREMENT
	__start_time_stamp = 0U;
#endif
	z_IntLibInit();
    a050:	f7ff fce8 	bl	9a24 <z_IntLibInit>
	z_cstart();
    a054:	f004 fd48 	bl	eae8 <z_cstart>
    a058:	00000000 	.word	0x00000000
    a05c:	e000ed00 	.word	0xe000ed00

0000a060 <z_arch_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arch_configure_static_mpu_regions(void)
{
    a060:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    a062:	4b08      	ldr	r3, [pc, #32]	; (a084 <z_arch_configure_static_mpu_regions+0x24>)
    a064:	9301      	str	r3, [sp, #4]
    a066:	4b08      	ldr	r3, [pc, #32]	; (a088 <z_arch_configure_static_mpu_regions+0x28>)
    a068:	9302      	str	r3, [sp, #8]
    a06a:	4b08      	ldr	r3, [pc, #32]	; (a08c <z_arch_configure_static_mpu_regions+0x2c>)
    a06c:	9303      	str	r3, [sp, #12]

	/* Define a constant array of k_mem_partition objects
	 * to hold the configuration of the respective static
	 * MPU regions.
	 */
	const struct k_mem_partition *static_regions[] = {
    a06e:	ab01      	add	r3, sp, #4
    a070:	9300      	str	r3, [sp, #0]
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    a072:	4a07      	ldr	r2, [pc, #28]	; (a090 <z_arch_configure_static_mpu_regions+0x30>)
    a074:	4b07      	ldr	r3, [pc, #28]	; (a094 <z_arch_configure_static_mpu_regions+0x34>)
    a076:	2101      	movs	r1, #1
    a078:	4668      	mov	r0, sp
    a07a:	f000 f8b5 	bl	a1e8 <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    a07e:	b005      	add	sp, #20
    a080:	f85d fb04 	ldr.w	pc, [sp], #4
    a084:	20000000 	.word	0x20000000
    a088:	00002000 	.word	0x00002000
    a08c:	030b0000 	.word	0x030b0000
    a090:	20000000 	.word	0x20000000
    a094:	20040000 	.word	0x20040000

0000a098 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
	*regions[], u8_t regions_num, u8_t start_reg_index,
	bool do_sanity_check)
{
    a098:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	MPU->RNR = index;
    a09a:	4f2e      	ldr	r7, [pc, #184]	; (a154 <mpu_configure_regions+0xbc>)
{
    a09c:	460e      	mov	r6, r1
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    a09e:	2100      	movs	r1, #0
    a0a0:	42b1      	cmp	r1, r6
    a0a2:	da22      	bge.n	a0ea <mpu_configure_regions+0x52>
		if (regions[i]->size == 0U) {
    a0a4:	f850 c021 	ldr.w	ip, [r0, r1, lsl #2]
    a0a8:	f8dc 4004 	ldr.w	r4, [ip, #4]
    a0ac:	2c00      	cmp	r4, #0
    a0ae:	d04f      	beq.n	a150 <mpu_configure_regions+0xb8>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
    a0b0:	b1eb      	cbz	r3, a0ee <mpu_configure_regions+0x56>
		((part->size & (part->size - 1)) == 0U)
    a0b2:	f104 3eff 	add.w	lr, r4, #4294967295	; 0xffffffff
		&&
    a0b6:	ea14 0f0e 	tst.w	r4, lr
    a0ba:	d106      	bne.n	a0ca <mpu_configure_regions+0x32>
		&&
    a0bc:	2c1f      	cmp	r4, #31
    a0be:	d904      	bls.n	a0ca <mpu_configure_regions+0x32>
		((part->start & (part->size - 1)) == 0U);
    a0c0:	f8dc 5000 	ldr.w	r5, [ip]
		&&
    a0c4:	ea1e 0f05 	tst.w	lr, r5
    a0c8:	d011      	beq.n	a0ee <mpu_configure_regions+0x56>
				(!mpu_partition_is_valid(regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    a0ca:	2301      	movs	r3, #1
    a0cc:	f04f 0200 	mov.w	r2, #0
    a0d0:	f363 0207 	bfi	r2, r3, #0, #8
    a0d4:	4820      	ldr	r0, [pc, #128]	; (a158 <mpu_configure_regions+0xc0>)
    a0d6:	4b21      	ldr	r3, [pc, #132]	; (a15c <mpu_configure_regions+0xc4>)
    a0d8:	1a1b      	subs	r3, r3, r0
    a0da:	08db      	lsrs	r3, r3, #3
    a0dc:	4820      	ldr	r0, [pc, #128]	; (a160 <mpu_configure_regions+0xc8>)
    a0de:	f363 128f 	bfi	r2, r3, #6, #10
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    a0e2:	f007 ff54 	bl	11f8e <log_1>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, regions[i]);
    a0e6:	f06f 0215 	mvn.w	r2, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    a0ea:	4610      	mov	r0, r2
    a0ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (size <= 32U) {
    a0ee:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, regions[i]);
    a0f0:	b2d5      	uxtb	r5, r2
	struct arm_mpu_region region_conf;

	LOG_DBG("Configure MPU region at index 0x%x", index);

	/* Populate internal ARM MPU region configuration structure. */
	region_conf.base = new_region->start;
    a0f2:	f8dc 2000 	ldr.w	r2, [ip]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    a0f6:	f8dc c008 	ldr.w	ip, [ip, #8]
	if (size <= 32U) {
    a0fa:	d91a      	bls.n	a132 <mpu_configure_regions+0x9a>
	if (size > (1UL << 31)) {
    a0fc:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    a100:	d819      	bhi.n	a136 <mpu_configure_regions+0x9e>
	return ((32 - __builtin_clz(size - 1) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    a102:	3c01      	subs	r4, #1
    a104:	fab4 f484 	clz	r4, r4
    a108:	f1c4 041f 	rsb	r4, r4, #31
    a10c:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1)) {
    a10e:	2d07      	cmp	r5, #7
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    a110:	ea4c 0404 	orr.w	r4, ip, r4
    a114:	d911      	bls.n	a13a <mpu_configure_regions+0xa2>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    a116:	2301      	movs	r3, #1
    a118:	f04f 0200 	mov.w	r2, #0
    a11c:	f363 0207 	bfi	r2, r3, #0, #8
    a120:	490d      	ldr	r1, [pc, #52]	; (a158 <mpu_configure_regions+0xc0>)
    a122:	4b0e      	ldr	r3, [pc, #56]	; (a15c <mpu_configure_regions+0xc4>)
    a124:	480f      	ldr	r0, [pc, #60]	; (a164 <mpu_configure_regions+0xcc>)
    a126:	1a5b      	subs	r3, r3, r1
    a128:	08db      	lsrs	r3, r3, #3
    a12a:	f363 128f 	bfi	r2, r3, #6, #10
    a12e:	4629      	mov	r1, r5
    a130:	e7d7      	b.n	a0e2 <mpu_configure_regions+0x4a>
		return REGION_32B;
    a132:	2408      	movs	r4, #8
    a134:	e7eb      	b.n	a10e <mpu_configure_regions+0x76>
		return REGION_4G;
    a136:	243e      	movs	r4, #62	; 0x3e
    a138:	e7e9      	b.n	a10e <mpu_configure_regions+0x76>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    a13a:	f022 021f 	bic.w	r2, r2, #31
				| MPU_RBAR_VALID_Msk | index;
    a13e:	432a      	orrs	r2, r5
    a140:	f042 0210 	orr.w	r2, r2, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    a144:	f044 0401 	orr.w	r4, r4, #1
	MPU->RNR = index;
    a148:	60bd      	str	r5, [r7, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    a14a:	60fa      	str	r2, [r7, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    a14c:	613c      	str	r4, [r7, #16]
		reg_index++;
    a14e:	1c6a      	adds	r2, r5, #1
	for (i = 0; i < regions_num; i++) {
    a150:	3101      	adds	r1, #1
    a152:	e7a5      	b.n	a0a0 <mpu_configure_regions+0x8>
    a154:	e000ed90 	.word	0xe000ed90
    a158:	00016344 	.word	0x00016344
    a15c:	0001634c 	.word	0x0001634c
    a160:	000187f0 	.word	0x000187f0
    a164:	00018813 	.word	0x00018813

0000a168 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    a168:	4b03      	ldr	r3, [pc, #12]	; (a178 <arm_core_mpu_enable+0x10>)
    a16a:	2205      	movs	r2, #5
    a16c:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    a16e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    a172:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    a176:	4770      	bx	lr
    a178:	e000ed90 	.word	0xe000ed90

0000a17c <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    a17c:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    a180:	4b01      	ldr	r3, [pc, #4]	; (a188 <arm_core_mpu_disable+0xc>)
    a182:	2200      	movs	r2, #0
    a184:	605a      	str	r2, [r3, #4]
}
    a186:	4770      	bx	lr
    a188:	e000ed90 	.word	0xe000ed90

0000a18c <arm_mpu_init>:
 */
static int arm_mpu_init(struct device *arg)
{
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    a18c:	4913      	ldr	r1, [pc, #76]	; (a1dc <arm_mpu_init+0x50>)
    a18e:	6808      	ldr	r0, [r1, #0]
    a190:	2808      	cmp	r0, #8
{
    a192:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    a194:	d81e      	bhi.n	a1d4 <arm_mpu_init+0x48>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    a196:	f7ff fff1 	bl	a17c <arm_core_mpu_disable>
	MPU->RNR = index;
    a19a:	4c11      	ldr	r4, [pc, #68]	; (a1e0 <arm_mpu_init+0x54>)
    a19c:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    a19e:	2200      	movs	r2, #0
    a1a0:	4290      	cmp	r0, r2
    a1a2:	f101 010c 	add.w	r1, r1, #12
    a1a6:	d105      	bne.n	a1b4 <arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    a1a8:	4b0e      	ldr	r3, [pc, #56]	; (a1e4 <arm_mpu_init+0x58>)
    a1aa:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    a1ac:	f7ff ffdc 	bl	a168 <arm_core_mpu_enable>
	defined(CONFIG_CPU_CORTEX_M4)
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos == 8,
		"Invalid number of MPU regions\n");
#endif
	return 0;
    a1b0:	2000      	movs	r0, #0
}
    a1b2:	bd10      	pop	{r4, pc}
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    a1b4:	f851 3c0c 	ldr.w	r3, [r1, #-12]
	MPU->RNR = index;
    a1b8:	60a2      	str	r2, [r4, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    a1ba:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    a1be:	4313      	orrs	r3, r2
    a1c0:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    a1c4:	60e3      	str	r3, [r4, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    a1c6:	f851 3c04 	ldr.w	r3, [r1, #-4]
    a1ca:	f043 0301 	orr.w	r3, r3, #1
    a1ce:	6123      	str	r3, [r4, #16]
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    a1d0:	3201      	adds	r2, #1
    a1d2:	e7e5      	b.n	a1a0 <arm_mpu_init+0x14>
		return -1;
    a1d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a1d8:	e7eb      	b.n	a1b2 <arm_mpu_init+0x26>
    a1da:	bf00      	nop
    a1dc:	00016618 	.word	0x00016618
    a1e0:	e000ed90 	.word	0xe000ed90
    a1e4:	20005b00 	.word	0x20005b00

0000a1e8 <arm_core_mpu_configure_static_mpu_regions>:
{
    a1e8:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    a1ea:	4c03      	ldr	r4, [pc, #12]	; (a1f8 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    a1ec:	2301      	movs	r3, #1
    a1ee:	7822      	ldrb	r2, [r4, #0]
    a1f0:	f7ff ff52 	bl	a098 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    a1f4:	7020      	strb	r0, [r4, #0]
}
    a1f6:	bd10      	pop	{r4, pc}
    a1f8:	20005b00 	.word	0x20005b00

0000a1fc <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    a1fc:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    a1fe:	4a08      	ldr	r2, [pc, #32]	; (a220 <arm_core_mpu_configure_dynamic_mpu_regions+0x24>)
    a200:	2300      	movs	r3, #0
    a202:	7812      	ldrb	r2, [r2, #0]
    a204:	f7ff ff48 	bl	a098 <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    a208:	f110 0f16 	cmn.w	r0, #22
    a20c:	d003      	beq.n	a216 <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    a20e:	4b05      	ldr	r3, [pc, #20]	; (a224 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
  MPU->RASR = 0U;
    a210:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    a212:	2807      	cmp	r0, #7
    a214:	dd00      	ble.n	a218 <arm_core_mpu_configure_dynamic_mpu_regions+0x1c>
}
    a216:	bd08      	pop	{r3, pc}
  MPU->RNR = rnr;
    a218:	6098      	str	r0, [r3, #8]
  MPU->RASR = 0U;
    a21a:	611a      	str	r2, [r3, #16]
    a21c:	3001      	adds	r0, #1
    a21e:	e7f8      	b.n	a212 <arm_core_mpu_configure_dynamic_mpu_regions+0x16>
    a220:	20005b00 	.word	0x20005b00
    a224:	e000ed90 	.word	0xe000ed90

0000a228 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    a228:	4b01      	ldr	r3, [pc, #4]	; (a230 <__stdout_hook_install+0x8>)
    a22a:	6018      	str	r0, [r3, #0]
}
    a22c:	4770      	bx	lr
    a22e:	bf00      	nop
    a230:	20010cf0 	.word	0x20010cf0

0000a234 <z_impl_zephyr_read_stdin>:
{
	_stdin_hook = hook;
}

int z_impl_zephyr_read_stdin(char *buf, int nbytes)
{
    a234:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int i = 0;

	for (i = 0; i < nbytes; i++) {
		*(buf + i) = _stdin_hook();
    a236:	4f08      	ldr	r7, [pc, #32]	; (a258 <z_impl_zephyr_read_stdin+0x24>)
{
    a238:	4606      	mov	r6, r0
    a23a:	460d      	mov	r5, r1
	for (i = 0; i < nbytes; i++) {
    a23c:	2400      	movs	r4, #0
    a23e:	42ac      	cmp	r4, r5
    a240:	da08      	bge.n	a254 <z_impl_zephyr_read_stdin+0x20>
		*(buf + i) = _stdin_hook();
    a242:	683b      	ldr	r3, [r7, #0]
    a244:	4798      	blx	r3
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
    a246:	280a      	cmp	r0, #10
		*(buf + i) = _stdin_hook();
    a248:	5530      	strb	r0, [r6, r4]
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
    a24a:	f104 0401 	add.w	r4, r4, #1
    a24e:	d001      	beq.n	a254 <z_impl_zephyr_read_stdin+0x20>
    a250:	280d      	cmp	r0, #13
    a252:	d1f4      	bne.n	a23e <z_impl_zephyr_read_stdin+0xa>
			i++;
			break;
		}
	}
	return i;
}
    a254:	4620      	mov	r0, r4
    a256:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a258:	20010cec 	.word	0x20010cec

0000a25c <z_impl_zephyr_write_stdout>:
	return z_impl_zephyr_read_stdin((char *)buf, nbytes);
}
#endif

int z_impl_zephyr_write_stdout(const void *buffer, int nbytes)
{
    a25c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a25e:	4f0a      	ldr	r7, [pc, #40]	; (a288 <z_impl_zephyr_write_stdout+0x2c>)
    a260:	460e      	mov	r6, r1
    a262:	1e44      	subs	r4, r0, #1
	const char *buf = buffer;
	int i;

	for (i = 0; i < nbytes; i++) {
    a264:	f1c0 0501 	rsb	r5, r0, #1
    a268:	192b      	adds	r3, r5, r4
    a26a:	429e      	cmp	r6, r3
    a26c:	dc01      	bgt.n	a272 <z_impl_zephyr_write_stdout+0x16>
			_stdout_hook('\r');
		}
		_stdout_hook(*(buf + i));
	}
	return nbytes;
}
    a26e:	4630      	mov	r0, r6
    a270:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (*(buf + i) == '\n') {
    a272:	7863      	ldrb	r3, [r4, #1]
    a274:	2b0a      	cmp	r3, #10
    a276:	d102      	bne.n	a27e <z_impl_zephyr_write_stdout+0x22>
			_stdout_hook('\r');
    a278:	683b      	ldr	r3, [r7, #0]
    a27a:	200d      	movs	r0, #13
    a27c:	4798      	blx	r3
		_stdout_hook(*(buf + i));
    a27e:	683b      	ldr	r3, [r7, #0]
    a280:	f814 0f01 	ldrb.w	r0, [r4, #1]!
    a284:	4798      	blx	r3
    a286:	e7ef      	b.n	a268 <z_impl_zephyr_write_stdout+0xc>
    a288:	20010cf0 	.word	0x20010cf0

0000a28c <_exit>:
	return 0;
}
FUNC_ALIAS(_fstat, fstat, int);

void _exit(int status)
{
    a28c:	b508      	push	{r3, lr}
	return z_impl_zephyr_write_stdout(buf, nbytes);
    a28e:	2105      	movs	r1, #5
    a290:	4801      	ldr	r0, [pc, #4]	; (a298 <_exit+0xc>)
    a292:	f7ff ffe3 	bl	a25c <z_impl_zephyr_write_stdout>
	_write(1, "exit\n", 5);
	while (1) {
		;
    a296:	e7fe      	b.n	a296 <_exit+0xa>
    a298:	00018839 	.word	0x00018839

0000a29c <_sbrk>:
void *_sbrk(int count)
{
#if CONFIG_NEWLIB_LIBC_ALIGNED_HEAP_SIZE
	void *ptr = heap_base + heap_sz;
#else
	void *ptr = _end + heap_sz;
    a29c:	4907      	ldr	r1, [pc, #28]	; (a2bc <_sbrk+0x20>)
    a29e:	680b      	ldr	r3, [r1, #0]
{
    a2a0:	b510      	push	{r4, lr}
#endif

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
    a2a2:	18c4      	adds	r4, r0, r3
    a2a4:	4806      	ldr	r0, [pc, #24]	; (a2c0 <_sbrk+0x24>)
    a2a6:	f1c0 5200 	rsb	r2, r0, #536870912	; 0x20000000
    a2aa:	f502 2280 	add.w	r2, r2, #262144	; 0x40000
    a2ae:	4294      	cmp	r4, r2
	void *ptr = _end + heap_sz;
    a2b0:	bf3a      	itte	cc
    a2b2:	18c0      	addcc	r0, r0, r3
		heap_sz += count;
    a2b4:	600c      	strcc	r4, [r1, #0]
		return ptr;
	} else {
		return (void *)-1;
    a2b6:	f04f 30ff 	movcs.w	r0, #4294967295	; 0xffffffff
	}
}
    a2ba:	bd10      	pop	{r4, pc}
    a2bc:	200039e8 	.word	0x200039e8
    a2c0:	20011f68 	.word	0x20011f68

0000a2c4 <net_buf_id>:
	return pool - _net_buf_pool_list;
}

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    a2c4:	7982      	ldrb	r2, [r0, #6]

	return buf - pool->__bufs;
    a2c6:	4b04      	ldr	r3, [pc, #16]	; (a2d8 <net_buf_id+0x14>)
    a2c8:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    a2cc:	69db      	ldr	r3, [r3, #28]
    a2ce:	1ac0      	subs	r0, r0, r3
}
    a2d0:	4b02      	ldr	r3, [pc, #8]	; (a2dc <net_buf_id+0x18>)
	return buf - pool->__bufs;
    a2d2:	10c0      	asrs	r0, r0, #3
}
    a2d4:	4358      	muls	r0, r3
    a2d6:	4770      	bx	lr
    a2d8:	20011dfc 	.word	0x20011dfc
    a2dc:	aaaaaaab 	.word	0xaaaaaaab

0000a2e0 <fixed_data_alloc>:
	.ref   = generic_data_ref,
	.unref = mem_pool_data_unref,
};

static u8_t *fixed_data_alloc(struct net_buf *buf, size_t *size, s32_t timeout)
{
    a2e0:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    a2e2:	4b09      	ldr	r3, [pc, #36]	; (a308 <fixed_data_alloc+0x28>)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    a2e4:	7982      	ldrb	r2, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    a2e6:	eb03 1342 	add.w	r3, r3, r2, lsl #5

	*size = MIN(fixed->data_size, *size);
    a2ea:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    a2ec:	699b      	ldr	r3, [r3, #24]
    a2ee:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
    a2f0:	6823      	ldr	r3, [r4, #0]
    a2f2:	429a      	cmp	r2, r3
    a2f4:	bf94      	ite	ls
    a2f6:	600a      	strls	r2, [r1, #0]
    a2f8:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    a2fa:	f7ff ffe3 	bl	a2c4 <net_buf_id>
    a2fe:	e9d4 2300 	ldrd	r2, r3, [r4]
}
    a302:	fb02 3000 	mla	r0, r2, r0, r3
    a306:	bd10      	pop	{r4, pc}
    a308:	20011dfc 	.word	0x20011dfc

0000a30c <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  s32_t timeout)
#endif
{
    a30c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    a310:	4605      	mov	r5, r0
    a312:	9101      	str	r1, [sp, #4]
    a314:	4616      	mov	r6, r2
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
    a316:	f00b fe3f 	bl	15f98 <z_impl_k_uptime_get>
    a31a:	4607      	mov	r7, r0
    a31c:	f04f 0320 	mov.w	r3, #32
    a320:	f3ef 8811 	mrs	r8, BASEPRI
    a324:	f383 8811 	msr	BASEPRI, r3
    a328:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
    a32c:	8a6b      	ldrh	r3, [r5, #18]
    a32e:	2b00      	cmp	r3, #0
    a330:	d041      	beq.n	a3b6 <net_buf_alloc_len+0xaa>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
    a332:	8a2a      	ldrh	r2, [r5, #16]
    a334:	429a      	cmp	r2, r3
    a336:	d92c      	bls.n	a392 <net_buf_alloc_len+0x86>
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
    a338:	2100      	movs	r1, #0
    a33a:	4628      	mov	r0, r5
    a33c:	f00b fbe1 	bl	15b02 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
    a340:	4604      	mov	r4, r0
    a342:	b330      	cbz	r0, a392 <net_buf_alloc_len+0x86>
	__asm__ volatile(
    a344:	f388 8811 	msr	BASEPRI, r8
    a348:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
    a34c:	9b01      	ldr	r3, [sp, #4]
    a34e:	2b00      	cmp	r3, #0
    a350:	d040      	beq.n	a3d4 <net_buf_alloc_len+0xc8>
		if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
    a352:	1c73      	adds	r3, r6, #1
    a354:	2b01      	cmp	r3, #1
    a356:	d906      	bls.n	a366 <net_buf_alloc_len+0x5a>
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
    a358:	f00b fe1e 	bl	15f98 <z_impl_k_uptime_get>
			u32_t diff = k_uptime_get_32() - alloc_start;
    a35c:	1bc0      	subs	r0, r0, r7

			timeout -= MIN(timeout, diff);
    a35e:	42b0      	cmp	r0, r6
    a360:	bf94      	ite	ls
    a362:	1a36      	subls	r6, r6, r0
    a364:	1bb6      	subhi	r6, r6, r6
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    a366:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
    a368:	4f20      	ldr	r7, [pc, #128]	; (a3ec <net_buf_alloc_len+0xe0>)
    a36a:	eb07 1343 	add.w	r3, r7, r3, lsl #5
    a36e:	4632      	mov	r2, r6
    a370:	699b      	ldr	r3, [r3, #24]
    a372:	681b      	ldr	r3, [r3, #0]
    a374:	a901      	add	r1, sp, #4
    a376:	681b      	ldr	r3, [r3, #0]
    a378:	4620      	mov	r0, r4
    a37a:	4798      	blx	r3
    a37c:	4605      	mov	r5, r0
		}

		buf->__buf = data_alloc(buf, &size, timeout);
    a37e:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
    a380:	bb48      	cbnz	r0, a3d6 <net_buf_alloc_len+0xca>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
    a382:	79a0      	ldrb	r0, [r4, #6]
    a384:	4621      	mov	r1, r4
    a386:	eb07 1040 	add.w	r0, r7, r0, lsl #5
    a38a:	f00b fbb5 	bl	15af8 <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
    a38e:	462c      	mov	r4, r5
    a390:	e01c      	b.n	a3cc <net_buf_alloc_len+0xc0>
		uninit_count = pool->uninit_count--;
    a392:	8a6b      	ldrh	r3, [r5, #18]
    a394:	1e5a      	subs	r2, r3, #1
    a396:	826a      	strh	r2, [r5, #18]
    a398:	f388 8811 	msr	BASEPRI, r8
    a39c:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
    a3a0:	8a2c      	ldrh	r4, [r5, #16]
    a3a2:	1ae4      	subs	r4, r4, r3
    a3a4:	69eb      	ldr	r3, [r5, #28]
    a3a6:	2218      	movs	r2, #24
    a3a8:	fb02 3404 	mla	r4, r2, r4, r3
	return pool - _net_buf_pool_list;
    a3ac:	4b0f      	ldr	r3, [pc, #60]	; (a3ec <net_buf_alloc_len+0xe0>)
    a3ae:	1aed      	subs	r5, r5, r3
    a3b0:	116d      	asrs	r5, r5, #5
	buf->pool_id = pool_id(pool);
    a3b2:	71a5      	strb	r5, [r4, #6]
		goto success;
    a3b4:	e7ca      	b.n	a34c <net_buf_alloc_len+0x40>
    a3b6:	f388 8811 	msr	BASEPRI, r8
    a3ba:	f3bf 8f6f 	isb	sy
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
    a3be:	4631      	mov	r1, r6
    a3c0:	4628      	mov	r0, r5
    a3c2:	f00b fb9e 	bl	15b02 <z_impl_k_queue_get>
	if (!buf) {
    a3c6:	4604      	mov	r4, r0
    a3c8:	2800      	cmp	r0, #0
    a3ca:	d1bf      	bne.n	a34c <net_buf_alloc_len+0x40>
	pool->avail_count--;
	NET_BUF_ASSERT(pool->avail_count >= 0);
#endif

	return buf;
}
    a3cc:	4620      	mov	r0, r4
    a3ce:	b002      	add	sp, #8
    a3d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		buf->__buf = NULL;
    a3d4:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
    a3d6:	2300      	movs	r3, #0
	buf->ref   = 1U;
    a3d8:	2201      	movs	r2, #1
	buf->frags = NULL;
    a3da:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
    a3dc:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
    a3de:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
    a3e0:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
    a3e2:	6923      	ldr	r3, [r4, #16]
    a3e4:	81e2      	strh	r2, [r4, #14]
    a3e6:	60a3      	str	r3, [r4, #8]
	return buf;
    a3e8:	e7f0      	b.n	a3cc <net_buf_alloc_len+0xc0>
    a3ea:	bf00      	nop
    a3ec:	20011dfc 	.word	0x20011dfc

0000a3f0 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
    a3f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a3f2:	4d15      	ldr	r5, [pc, #84]	; (a448 <net_buf_unref+0x58>)
    a3f4:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
    a3f6:	2600      	movs	r6, #0
	while (buf) {
    a3f8:	b904      	cbnz	r4, a3fc <net_buf_unref+0xc>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
    a3fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (--buf->ref > 0) {
    a3fc:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
    a3fe:	6827      	ldr	r7, [r4, #0]
		if (--buf->ref > 0) {
    a400:	3b01      	subs	r3, #1
    a402:	b2db      	uxtb	r3, r3
    a404:	7123      	strb	r3, [r4, #4]
    a406:	2b00      	cmp	r3, #0
    a408:	d1f7      	bne.n	a3fa <net_buf_unref+0xa>
		if (buf->__buf) {
    a40a:	6921      	ldr	r1, [r4, #16]
    a40c:	b159      	cbz	r1, a426 <net_buf_unref+0x36>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
    a40e:	7963      	ldrb	r3, [r4, #5]
    a410:	079b      	lsls	r3, r3, #30
    a412:	d407      	bmi.n	a424 <net_buf_unref+0x34>
	pool->alloc->cb->unref(buf, data);
    a414:	79a3      	ldrb	r3, [r4, #6]
    a416:	eb05 1343 	add.w	r3, r5, r3, lsl #5
    a41a:	4620      	mov	r0, r4
    a41c:	699b      	ldr	r3, [r3, #24]
    a41e:	681b      	ldr	r3, [r3, #0]
    a420:	689b      	ldr	r3, [r3, #8]
    a422:	4798      	blx	r3
			buf->__buf = NULL;
    a424:	6126      	str	r6, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
    a426:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
    a428:	60a6      	str	r6, [r4, #8]
		if (pool->destroy) {
    a42a:	eb05 1340 	add.w	r3, r5, r0, lsl #5
		buf->frags = NULL;
    a42e:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
    a430:	695b      	ldr	r3, [r3, #20]
    a432:	b11b      	cbz	r3, a43c <net_buf_unref+0x4c>
			pool->destroy(buf);
    a434:	4620      	mov	r0, r4
    a436:	4798      	blx	r3
{
    a438:	463c      	mov	r4, r7
    a43a:	e7dd      	b.n	a3f8 <net_buf_unref+0x8>
	k_lifo_put(&pool->free, buf);
    a43c:	4621      	mov	r1, r4
    a43e:	eb05 1040 	add.w	r0, r5, r0, lsl #5
    a442:	f00b fb59 	bl	15af8 <k_queue_prepend>
    a446:	e7f7      	b.n	a438 <net_buf_unref+0x48>
    a448:	20011dfc 	.word	0x20011dfc

0000a44c <arp_request_timeout>:
				      ARP_REQUEST_TIMEOUT);
	}
}

static void arp_request_timeout(struct k_work *work)
{
    a44c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
    a450:	f00b fda2 	bl	15f98 <z_impl_k_uptime_get>
	s64_t current = k_uptime_get();
	struct arp_entry *entry, *next;

	ARG_UNUSED(work);

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
    a454:	4a1f      	ldr	r2, [pc, #124]	; (a4d4 <arp_request_timeout+0x88>)
    a456:	6814      	ldr	r4, [r2, #0]
    a458:	4606      	mov	r6, r0
    a45a:	2c00      	cmp	r4, #0
    a45c:	d037      	beq.n	a4ce <arp_request_timeout+0x82>
					  entry, next, node) {
		if ((entry->req_start + ARP_REQUEST_TIMEOUT - current) > 0) {
    a45e:	f44f 65fa 	mov.w	r5, #2000	; 0x7d0
    a462:	1a2d      	subs	r5, r5, r0
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    a464:	6827      	ldr	r7, [r4, #0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    a466:	f8df b078 	ldr.w	fp, [pc, #120]	; a4e0 <arp_request_timeout+0x94>
    a46a:	eb61 0341 	sbc.w	r3, r1, r1, lsl #1
			break;
		}

		arp_entry_cleanup(entry, true);

		sys_slist_remove(&arp_pending_entries, NULL, &entry->node);
    a46e:	4692      	mov	sl, r2
		if ((entry->req_start + ARP_REQUEST_TIMEOUT - current) > 0) {
    a470:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
    a474:	eb15 0802 	adds.w	r8, r5, r2
    a478:	eb43 0901 	adc.w	r9, r3, r1
    a47c:	f1b8 0f01 	cmp.w	r8, #1
    a480:	9301      	str	r3, [sp, #4]
    a482:	f179 0300 	sbcs.w	r3, r9, #0
    a486:	da18      	bge.n	a4ba <arp_request_timeout+0x6e>
		arp_entry_cleanup(entry, true);
    a488:	2101      	movs	r1, #1
    a48a:	4620      	mov	r0, r4
    a48c:	f008 fe4f 	bl	1312e <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, NULL, &entry->node);
    a490:	4622      	mov	r2, r4
    a492:	2100      	movs	r1, #0
    a494:	4650      	mov	r0, sl
    a496:	f008 fe15 	bl	130c4 <sys_slist_remove>
	parent->next = child;
    a49a:	2200      	movs	r2, #0
    a49c:	6022      	str	r2, [r4, #0]
Z_GENLIST_APPEND(slist, snode)
    a49e:	f8db 2004 	ldr.w	r2, [fp, #4]
    a4a2:	9b01      	ldr	r3, [sp, #4]
    a4a4:	b92a      	cbnz	r2, a4b2 <arp_request_timeout+0x66>
	list->head = node;
    a4a6:	e9cb 4400 	strd	r4, r4, [fp]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
    a4aa:	b187      	cbz	r7, a4ce <arp_request_timeout+0x82>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    a4ac:	463c      	mov	r4, r7
    a4ae:	683f      	ldr	r7, [r7, #0]
    a4b0:	e7de      	b.n	a470 <arp_request_timeout+0x24>
	parent->next = child;
    a4b2:	6014      	str	r4, [r2, #0]
	list->tail = node;
    a4b4:	f8cb 4004 	str.w	r4, [fp, #4]
    a4b8:	e7f7      	b.n	a4aa <arp_request_timeout+0x5e>

		entry = NULL;
	}

	if (entry) {
		k_delayed_work_submit(&arp_request_timer,
    a4ba:	f5c6 66fa 	rsb	r6, r6, #2000	; 0x7d0
 * @req K-DWORK-001
 */
static inline int k_delayed_work_submit(struct k_delayed_work *work,
					s32_t delay)
{
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    a4be:	4906      	ldr	r1, [pc, #24]	; (a4d8 <arp_request_timeout+0x8c>)
    a4c0:	4806      	ldr	r0, [pc, #24]	; (a4dc <arp_request_timeout+0x90>)
    a4c2:	4432      	add	r2, r6
				      entry->req_start +
				      ARP_REQUEST_TIMEOUT - current);
	}
}
    a4c4:	b003      	add	sp, #12
    a4c6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a4ca:	f005 ba27 	b.w	f91c <k_delayed_work_submit_to_queue>
    a4ce:	b003      	add	sp, #12
    a4d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a4d4:	200039f4 	.word	0x200039f4
    a4d8:	200039fc 	.word	0x200039fc
    a4dc:	20005620 	.word	0x20005620
    a4e0:	200039ec 	.word	0x200039ec

0000a4e4 <arp_update>:
static void arp_update(struct net_if *iface,
		       struct in_addr *src,
		       struct net_eth_addr *hwaddr,
		       bool gratuitous,
		       bool force)
{
    a4e4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    a4e8:	469a      	mov	sl, r3
	sys_snode_t *prev = NULL;
    a4ea:	2300      	movs	r3, #0
    a4ec:	9301      	str	r3, [sp, #4]
{
    a4ee:	4606      	mov	r6, r0
    a4f0:	460f      	mov	r7, r1
    a4f2:	4615      	mov	r5, r2
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
    a4f4:	ab01      	add	r3, sp, #4
    a4f6:	460a      	mov	r2, r1
    a4f8:	4601      	mov	r1, r0
    a4fa:	4828      	ldr	r0, [pc, #160]	; (a59c <arp_update+0xb8>)
{
    a4fc:	f89d 9028 	ldrb.w	r9, [sp, #40]	; 0x28
    a500:	f8df 8098 	ldr.w	r8, [pc, #152]	; a59c <arp_update+0xb8>
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
    a504:	f008 fdee 	bl	130e4 <arp_entry_find>
	if (entry) {
    a508:	4604      	mov	r4, r0
    a50a:	b120      	cbz	r0, a516 <arp_update+0x32>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
    a50c:	4602      	mov	r2, r0
    a50e:	9901      	ldr	r1, [sp, #4]
    a510:	4640      	mov	r0, r8
    a512:	f008 fdd7 	bl	130c4 <sys_slist_remove>
	if (sys_slist_is_empty(&arp_pending_entries)) {
    a516:	f8d8 3000 	ldr.w	r3, [r8]
    a51a:	b913      	cbnz	r3, a522 <arp_update+0x3e>
		k_delayed_work_cancel(&arp_request_timer);
    a51c:	4820      	ldr	r0, [pc, #128]	; (a5a0 <arp_update+0xbc>)
    a51e:	f00b fce2 	bl	15ee6 <k_delayed_work_cancel>
	struct net_pkt *pkt;

	NET_DBG("src %s", log_strdup(net_sprint_ipv4_addr(src)));

	entry = arp_entry_get_pending(iface, src);
	if (!entry) {
    a522:	bb0c      	cbnz	r4, a568 <arp_update+0x84>
		if (IS_ENABLED(CONFIG_NET_ARP_GRATUITOUS) && gratuitous) {
    a524:	f1ba 0f00 	cmp.w	sl, #0
    a528:	d00b      	beq.n	a542 <arp_update+0x5e>
	entry = arp_entry_find(&arp_table, iface, src, &prev);
    a52a:	ab01      	add	r3, sp, #4
    a52c:	463a      	mov	r2, r7
    a52e:	4631      	mov	r1, r6
    a530:	481c      	ldr	r0, [pc, #112]	; (a5a4 <arp_update+0xc0>)
	sys_snode_t *prev = NULL;
    a532:	9401      	str	r4, [sp, #4]
	entry = arp_entry_find(&arp_table, iface, src, &prev);
    a534:	f008 fdd6 	bl	130e4 <arp_entry_find>
	if (entry) {
    a538:	b118      	cbz	r0, a542 <arp_update+0x5e>
    a53a:	682b      	ldr	r3, [r5, #0]
    a53c:	6183      	str	r3, [r0, #24]
    a53e:	88ab      	ldrh	r3, [r5, #4]
    a540:	8383      	strh	r3, [r0, #28]
			arp_gratuitous(iface, src, hwaddr);
		}

		if (force) {
    a542:	f1b9 0f00 	cmp.w	r9, #0
    a546:	d00c      	beq.n	a562 <arp_update+0x7e>
			sys_snode_t *prev = NULL;
    a548:	2300      	movs	r3, #0
    a54a:	9301      	str	r3, [sp, #4]
			struct arp_entry *entry;

			entry = arp_entry_find(&arp_table, iface, src, &prev);
    a54c:	463a      	mov	r2, r7
    a54e:	ab01      	add	r3, sp, #4
    a550:	4631      	mov	r1, r6
    a552:	4814      	ldr	r0, [pc, #80]	; (a5a4 <arp_update+0xc0>)
    a554:	f008 fdc6 	bl	130e4 <arp_entry_find>
			if (entry) {
    a558:	b118      	cbz	r0, a562 <arp_update+0x7e>
    a55a:	682b      	ldr	r3, [r5, #0]
    a55c:	6183      	str	r3, [r0, #24]
    a55e:	88ab      	ldrh	r3, [r5, #4]
    a560:	8383      	strh	r3, [r0, #28]

	/* Inserting entry into the table */
	sys_slist_prepend(&arp_table, &entry->node);

	net_if_queue_tx(iface, pkt);
}
    a562:	b002      	add	sp, #8
    a564:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	net_pkt_lladdr_dst(entry->pending)->len = sizeof(struct net_eth_addr);
    a568:	69a1      	ldr	r1, [r4, #24]
    a56a:	2306      	movs	r3, #6
    a56c:	f881 3038 	strb.w	r3, [r1, #56]	; 0x38
	return net_buf_frags_len(pkt->frags);
}

static inline u8_t *net_pkt_data(struct net_pkt *pkt)
{
	return pkt->frags->data;
    a570:	694b      	ldr	r3, [r1, #20]
	net_pkt_lladdr_dst(entry->pending)->addr =
    a572:	689b      	ldr	r3, [r3, #8]
    a574:	634b      	str	r3, [r1, #52]	; 0x34
	entry->pending = NULL;
    a576:	4623      	mov	r3, r4
    a578:	2200      	movs	r2, #0
    a57a:	f843 2f18 	str.w	r2, [r3, #24]!
    a57e:	682a      	ldr	r2, [r5, #0]
    a580:	61a2      	str	r2, [r4, #24]
    a582:	88aa      	ldrh	r2, [r5, #4]
    a584:	809a      	strh	r2, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
    a586:	4b07      	ldr	r3, [pc, #28]	; (a5a4 <arp_update+0xc0>)
    a588:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
    a58a:	6022      	str	r2, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
    a58c:	685a      	ldr	r2, [r3, #4]
	list->head = node;
    a58e:	601c      	str	r4, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
    a590:	b902      	cbnz	r2, a594 <arp_update+0xb0>
	list->tail = node;
    a592:	605c      	str	r4, [r3, #4]
	net_if_queue_tx(iface, pkt);
    a594:	4630      	mov	r0, r6
    a596:	f000 fd4d 	bl	b034 <net_if_queue_tx>
    a59a:	e7e2      	b.n	a562 <arp_update+0x7e>
    a59c:	200039f4 	.word	0x200039f4
    a5a0:	200039fc 	.word	0x200039fc
    a5a4:	20003a1c 	.word	0x20003a1c

0000a5a8 <net_arp_prepare>:
{
    a5a8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    a5ac:	4689      	mov	r9, r1
    a5ae:	4690      	mov	r8, r2
	if (!pkt || !pkt->buffer) {
    a5b0:	4607      	mov	r7, r0
    a5b2:	b920      	cbnz	r0, a5be <net_arp_prepare+0x16>
		return NULL;
    a5b4:	2500      	movs	r5, #0
}
    a5b6:	4628      	mov	r0, r5
    a5b8:	b004      	add	sp, #16
    a5ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!pkt || !pkt->buffer) {
    a5be:	6943      	ldr	r3, [r0, #20]
    a5c0:	2b00      	cmp	r3, #0
    a5c2:	d0f7      	beq.n	a5b4 <net_arp_prepare+0xc>
	if (!current_ip &&
    a5c4:	b9ca      	cbnz	r2, a5fa <net_arp_prepare+0x52>
	    !net_if_ipv4_addr_mask_cmp(net_pkt_iface(pkt), request_ip)) {
    a5c6:	6a40      	ldr	r0, [r0, #36]	; 0x24
    a5c8:	f009 fab0 	bl	13b2c <net_if_ipv4_addr_mask_cmp>
	if (!current_ip &&
    a5cc:	b9a8      	cbnz	r0, a5fa <net_arp_prepare+0x52>
		struct net_if_ipv4 *ipv4 = net_pkt_iface(pkt)->config.ip.ipv4;
    a5ce:	6a79      	ldr	r1, [r7, #36]	; 0x24
    a5d0:	684b      	ldr	r3, [r1, #4]
		if (ipv4) {
    a5d2:	b193      	cbz	r3, a5fa <net_arp_prepare+0x52>
 *
 *  @return True if the address is unspecified, false otherwise.
 */
static inline bool net_ipv4_is_addr_unspecified(const struct in_addr *addr)
{
	return UNALIGNED_GET(&addr->s_addr) == 0;
    a5d4:	699d      	ldr	r5, [r3, #24]
			addr = &ipv4->gw;
    a5d6:	f103 0918 	add.w	r9, r3, #24
			if (net_ipv4_is_addr_unspecified(addr)) {
    a5da:	b975      	cbnz	r5, a5fa <net_arp_prepare+0x52>
				NET_ERR("Gateway not set for iface %p",
    a5dc:	2301      	movs	r3, #1
    a5de:	f04f 0200 	mov.w	r2, #0
    a5e2:	f363 0207 	bfi	r2, r3, #0, #8
    a5e6:	4868      	ldr	r0, [pc, #416]	; (a788 <net_arp_prepare+0x1e0>)
    a5e8:	4b68      	ldr	r3, [pc, #416]	; (a78c <net_arp_prepare+0x1e4>)
    a5ea:	1a1b      	subs	r3, r3, r0
    a5ec:	08db      	lsrs	r3, r3, #3
    a5ee:	f363 128f 	bfi	r2, r3, #6, #10
    a5f2:	4867      	ldr	r0, [pc, #412]	; (a790 <net_arp_prepare+0x1e8>)
    a5f4:	f007 fccb 	bl	11f8e <log_1>
				return NULL;
    a5f8:	e7dd      	b.n	a5b6 <net_arp_prepare+0xe>
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
    a5fa:	4d66      	ldr	r5, [pc, #408]	; (a794 <net_arp_prepare+0x1ec>)
    a5fc:	6a79      	ldr	r1, [r7, #36]	; 0x24
	sys_snode_t *prev = NULL;
    a5fe:	2300      	movs	r3, #0
    a600:	9303      	str	r3, [sp, #12]
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
    a602:	464a      	mov	r2, r9
    a604:	ab03      	add	r3, sp, #12
    a606:	4628      	mov	r0, r5
    a608:	f008 fd6c 	bl	130e4 <arp_entry_find>
	if (entry) {
    a60c:	4604      	mov	r4, r0
    a60e:	2800      	cmp	r0, #0
    a610:	d03a      	beq.n	a688 <net_arp_prepare+0xe0>
		if (&entry->node != sys_slist_peek_head(&arp_table)) {
    a612:	682b      	ldr	r3, [r5, #0]
    a614:	4298      	cmp	r0, r3
    a616:	d00a      	beq.n	a62e <net_arp_prepare+0x86>
			sys_slist_remove(&arp_table, prev, &entry->node);
    a618:	4602      	mov	r2, r0
    a61a:	9903      	ldr	r1, [sp, #12]
    a61c:	4628      	mov	r0, r5
    a61e:	f008 fd51 	bl	130c4 <sys_slist_remove>
Z_GENLIST_PREPEND(slist, snode)
    a622:	682b      	ldr	r3, [r5, #0]
	parent->next = child;
    a624:	6023      	str	r3, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
    a626:	686b      	ldr	r3, [r5, #4]
	list->head = node;
    a628:	602c      	str	r4, [r5, #0]
Z_GENLIST_PREPEND(slist, snode)
    a62a:	b903      	cbnz	r3, a62e <net_arp_prepare+0x86>
	list->tail = node;
    a62c:	606c      	str	r4, [r5, #4]
		(u8_t *)net_if_get_link_addr(entry->iface)->addr;
    a62e:	6923      	ldr	r3, [r4, #16]
    a630:	681b      	ldr	r3, [r3, #0]
    a632:	691b      	ldr	r3, [r3, #16]
	net_pkt_lladdr_src(pkt)->addr =
    a634:	62fb      	str	r3, [r7, #44]	; 0x2c
	net_pkt_lladdr_dst(pkt)->addr = (u8_t *)&entry->eth;
    a636:	3418      	adds	r4, #24
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
    a638:	2306      	movs	r3, #6
    a63a:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
	net_pkt_lladdr_dst(pkt)->addr = (u8_t *)&entry->eth;
    a63e:	637c      	str	r4, [r7, #52]	; 0x34
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
    a640:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
	return pkt;
    a644:	463d      	mov	r5, r7
    a646:	e7b6      	b.n	a5b6 <net_arp_prepare+0xe>
	sys_slist_remove(&arp_free_entries, NULL, node);
    a648:	4621      	mov	r1, r4
    a64a:	4632      	mov	r2, r6
    a64c:	f008 fd3a 	bl	130c4 <sys_slist_remove>
			if (!entry) {
    a650:	4634      	mov	r4, r6
    a652:	e026      	b.n	a6a2 <net_arp_prepare+0xfa>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    a654:	682b      	ldr	r3, [r5, #0]
    a656:	b323      	cbz	r3, a6a2 <net_arp_prepare+0xfa>
    a658:	429c      	cmp	r4, r3
    a65a:	d105      	bne.n	a668 <net_arp_prepare+0xc0>
    a65c:	4622      	mov	r2, r4
    a65e:	4631      	mov	r1, r6
    a660:	484c      	ldr	r0, [pc, #304]	; (a794 <net_arp_prepare+0x1ec>)
    a662:	f008 fd2f 	bl	130c4 <sys_slist_remove>
    a666:	e01c      	b.n	a6a2 <net_arp_prepare+0xfa>
    a668:	461e      	mov	r6, r3
    a66a:	681b      	ldr	r3, [r3, #0]
    a66c:	e7f3      	b.n	a656 <net_arp_prepare+0xae>
	if (current_ip) {
    a66e:	463d      	mov	r5, r7
    a670:	e028      	b.n	a6c4 <net_arp_prepare+0x11c>
	parent->next = child;
    a672:	6014      	str	r4, [r2, #0]
	list->tail = node;
    a674:	605c      	str	r4, [r3, #4]
    a676:	e043      	b.n	a700 <net_arp_prepare+0x158>
			(u8_t *)net_if_get_link_addr(iface)->addr;
    a678:	f8da 3000 	ldr.w	r3, [sl]
    a67c:	691b      	ldr	r3, [r3, #16]
		net_pkt_lladdr_src(pkt)->addr =
    a67e:	62eb      	str	r3, [r5, #44]	; 0x2c
    a680:	e054      	b.n	a72c <net_arp_prepare+0x184>
__ssp_bos_icheck3(memset, void *, int)
    a682:	f8c6 800e 	str.w	r8, [r6, #14]
    a686:	e796      	b.n	a5b6 <net_arp_prepare+0xe>
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
    a688:	4603      	mov	r3, r0
    a68a:	6a79      	ldr	r1, [r7, #36]	; 0x24
    a68c:	4842      	ldr	r0, [pc, #264]	; (a798 <net_arp_prepare+0x1f0>)
    a68e:	f008 fd29 	bl	130e4 <arp_entry_find>
		if (!entry) {
    a692:	b930      	cbnz	r0, a6a2 <net_arp_prepare+0xfa>
	node = sys_slist_peek_head(&arp_free_entries);
    a694:	4841      	ldr	r0, [pc, #260]	; (a79c <net_arp_prepare+0x1f4>)
    a696:	6806      	ldr	r6, [r0, #0]
	if (!node) {
    a698:	2e00      	cmp	r6, #0
    a69a:	d1d5      	bne.n	a648 <net_arp_prepare+0xa0>
	node = sys_slist_peek_tail(&arp_table);
    a69c:	686c      	ldr	r4, [r5, #4]
	if (!node) {
    a69e:	2c00      	cmp	r4, #0
    a6a0:	d1d8      	bne.n	a654 <net_arp_prepare+0xac>
		req = arp_prepare(net_pkt_iface(pkt), addr, entry, pkt,
    a6a2:	f8d7 a024 	ldr.w	sl, [r7, #36]	; 0x24
	if (current_ip) {
    a6a6:	f1b8 0f00 	cmp.w	r8, #0
    a6aa:	d1e0      	bne.n	a66e <net_arp_prepare+0xc6>
		pkt = net_pkt_alloc_with_buffer(iface,
    a6ac:	2364      	movs	r3, #100	; 0x64
    a6ae:	9300      	str	r3, [sp, #0]
    a6b0:	4642      	mov	r2, r8
    a6b2:	4643      	mov	r3, r8
    a6b4:	211c      	movs	r1, #28
    a6b6:	4650      	mov	r0, sl
    a6b8:	f001 f864 	bl	b784 <net_pkt_alloc_with_buffer>
		if (!pkt) {
    a6bc:	4605      	mov	r5, r0
    a6be:	2800      	cmp	r0, #0
    a6c0:	f43f af78 	beq.w	a5b4 <net_arp_prepare+0xc>
	net_buf_add(pkt->buffer, sizeof(struct net_arp_hdr));
    a6c4:	6968      	ldr	r0, [r5, #20]
    a6c6:	211c      	movs	r1, #28
    a6c8:	3008      	adds	r0, #8
    a6ca:	f008 fced 	bl	130a8 <net_buf_simple_add>
    a6ce:	696b      	ldr	r3, [r5, #20]
    a6d0:	689e      	ldr	r6, [r3, #8]
	if (entry) {
    a6d2:	2c00      	cmp	r4, #0
    a6d4:	d0d0      	beq.n	a678 <net_arp_prepare+0xd0>
		entry->pending = net_pkt_ref(pending);
    a6d6:	4638      	mov	r0, r7
    a6d8:	f009 fb1d 	bl	13d16 <net_pkt_ref>
		entry->iface = net_pkt_iface(pkt);
    a6dc:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    a6de:	6123      	str	r3, [r4, #16]
		net_ipaddr_copy(&entry->ip, next_addr);
    a6e0:	f8d9 3000 	ldr.w	r3, [r9]
		entry->pending = net_pkt_ref(pending);
    a6e4:	61a0      	str	r0, [r4, #24]
		net_ipaddr_copy(&entry->ip, next_addr);
    a6e6:	6163      	str	r3, [r4, #20]
			(u8_t *)net_if_get_link_addr(entry->iface)->addr;
    a6e8:	6923      	ldr	r3, [r4, #16]
    a6ea:	681b      	ldr	r3, [r3, #0]
    a6ec:	691b      	ldr	r3, [r3, #16]
		net_pkt_lladdr_src(pkt)->addr =
    a6ee:	62eb      	str	r3, [r5, #44]	; 0x2c
	parent->next = child;
    a6f0:	2300      	movs	r3, #0
    a6f2:	6023      	str	r3, [r4, #0]
Z_GENLIST_APPEND(slist, snode)
    a6f4:	4b28      	ldr	r3, [pc, #160]	; (a798 <net_arp_prepare+0x1f0>)
    a6f6:	685a      	ldr	r2, [r3, #4]
    a6f8:	2a00      	cmp	r2, #0
    a6fa:	d1ba      	bne.n	a672 <net_arp_prepare+0xca>
	list->head = node;
    a6fc:	e9c3 4400 	strd	r4, r4, [r3]
    a700:	f00b fc4a 	bl	15f98 <z_impl_k_uptime_get>
	entry->req_start = k_uptime_get();
    a704:	e9c4 0102 	strd	r0, r1, [r4, #8]
 * @return Remaining time (in milliseconds).
 * @req K-DWORK-001
 */
static inline s32_t k_delayed_work_remaining_get(struct k_delayed_work *work)
{
	return __ticks_to_ms(z_timeout_remaining(&work->timeout));
    a708:	4825      	ldr	r0, [pc, #148]	; (a7a0 <net_arp_prepare+0x1f8>)
    a70a:	f005 f9d3 	bl	fab4 <z_timeout_remaining>
{
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NEED_PRECISE_TICK_MS_CONVERSION
	/* use 64-bit math to keep precision */
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    a70e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    a712:	2264      	movs	r2, #100	; 0x64
    a714:	2300      	movs	r3, #0
    a716:	fb80 0101 	smull	r0, r1, r0, r1
    a71a:	f7f6 f815 	bl	748 <__aeabi_uldivmod>
	if (!k_delayed_work_remaining_get(&arp_request_timer)) {
    a71e:	b928      	cbnz	r0, a72c <net_arp_prepare+0x184>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    a720:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
    a724:	491f      	ldr	r1, [pc, #124]	; (a7a4 <net_arp_prepare+0x1fc>)
    a726:	4820      	ldr	r0, [pc, #128]	; (a7a8 <net_arp_prepare+0x200>)
    a728:	f005 f8f8 	bl	f91c <k_delayed_work_submit_to_queue>
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
    a72c:	2706      	movs	r7, #6
    a72e:	f885 7030 	strb.w	r7, [r5, #48]	; 0x30
	net_pkt_lladdr_dst(pkt)->addr = (u8_t *)net_eth_broadcast_addr();
    a732:	f000 f96b 	bl	aa0c <net_eth_broadcast_addr>
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
    a736:	2108      	movs	r1, #8
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
    a738:	f885 7038 	strb.w	r7, [r5, #56]	; 0x38
	net_pkt_lladdr_dst(pkt)->addr = (u8_t *)net_eth_broadcast_addr();
    a73c:	6368      	str	r0, [r5, #52]	; 0x34
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
    a73e:	2300      	movs	r3, #0
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
    a740:	70b1      	strb	r1, [r6, #2]
	hdr->protolen = sizeof(struct in_addr);
    a742:	2104      	movs	r1, #4
	hdr->hwlen = sizeof(struct net_eth_addr);
    a744:	7137      	strb	r7, [r6, #4]
	hdr->protolen = sizeof(struct in_addr);
    a746:	7171      	strb	r1, [r6, #5]
    a748:	f8c6 3012 	str.w	r3, [r6, #18]
    a74c:	82f3      	strh	r3, [r6, #22]
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
    a74e:	2201      	movs	r2, #1
    a750:	7033      	strb	r3, [r6, #0]
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
    a752:	70f3      	strb	r3, [r6, #3]
	hdr->opcode = htons(NET_ARP_REQUEST);
    a754:	71b3      	strb	r3, [r6, #6]
	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
    a756:	f8d9 3000 	ldr.w	r3, [r9]
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
    a75a:	7072      	strb	r2, [r6, #1]
	hdr->opcode = htons(NET_ARP_REQUEST);
    a75c:	71f2      	strb	r2, [r6, #7]
	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
    a75e:	61b3      	str	r3, [r6, #24]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    a760:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    a762:	681a      	ldr	r2, [r3, #0]
    a764:	60b2      	str	r2, [r6, #8]
    a766:	889b      	ldrh	r3, [r3, #4]
    a768:	81b3      	strh	r3, [r6, #12]
	if (!entry || (pkt != NULL && net_pkt_ipv4_auto(pkt))) {
    a76a:	b12c      	cbz	r4, a778 <net_arp_prepare+0x1d0>
		my_addr = if_get_addr(entry->iface, current_ip);
    a76c:	6923      	ldr	r3, [r4, #16]
    a76e:	4641      	mov	r1, r8
    a770:	6858      	ldr	r0, [r3, #4]
    a772:	f008 fcc7 	bl	13104 <if_get_addr.isra.16>
    a776:	4680      	mov	r8, r0
	if (my_addr) {
    a778:	f1b8 0f00 	cmp.w	r8, #0
    a77c:	d081      	beq.n	a682 <net_arp_prepare+0xda>
		net_ipaddr_copy(&hdr->src_ipaddr, my_addr);
    a77e:	f8d8 3000 	ldr.w	r3, [r8]
    a782:	f8c6 300e 	str.w	r3, [r6, #14]
    a786:	e716      	b.n	a5b6 <net_arp_prepare+0xe>
    a788:	00016344 	.word	0x00016344
    a78c:	00016354 	.word	0x00016354
    a790:	00018847 	.word	0x00018847
    a794:	20003a1c 	.word	0x20003a1c
    a798:	200039f4 	.word	0x200039f4
    a79c:	200039ec 	.word	0x200039ec
    a7a0:	20003a08 	.word	0x20003a08
    a7a4:	200039fc 	.word	0x200039fc
    a7a8:	20005620 	.word	0x20005620

0000a7ac <net_arp_clear_cache>:

	return NET_OK;
}

void net_arp_clear_cache(struct net_if *iface)
{
    a7ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a7b0:	4607      	mov	r7, r0
	sys_snode_t *prev = NULL;
	struct arp_entry *entry, *next;

	NET_DBG("Flushing ARP table");

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
    a7b2:	4829      	ldr	r0, [pc, #164]	; (a858 <net_arp_clear_cache+0xac>)
    a7b4:	6804      	ldr	r4, [r0, #0]
    a7b6:	b93c      	cbnz	r4, a7c8 <net_arp_clear_cache+0x1c>

	prev = NULL;

	NET_DBG("Flushing ARP pending requests");

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
    a7b8:	4d28      	ldr	r5, [pc, #160]	; (a85c <net_arp_clear_cache+0xb0>)
    a7ba:	682c      	ldr	r4, [r5, #0]
    a7bc:	bb1c      	cbnz	r4, a806 <net_arp_clear_cache+0x5a>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
		sys_slist_prepend(&arp_free_entries, &entry->node);
	}

	if (sys_slist_is_empty(&arp_pending_entries)) {
		k_delayed_work_cancel(&arp_request_timer);
    a7be:	4828      	ldr	r0, [pc, #160]	; (a860 <net_arp_clear_cache+0xb4>)
	}
}
    a7c0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		k_delayed_work_cancel(&arp_request_timer);
    a7c4:	f00b bb8f 	b.w	15ee6 <k_delayed_work_cancel>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    a7c8:	6825      	ldr	r5, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
    a7ca:	4e26      	ldr	r6, [pc, #152]	; (a864 <net_arp_clear_cache+0xb8>)
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    a7cc:	f04f 0900 	mov.w	r9, #0
		sys_slist_remove(&arp_table, prev, &entry->node);
    a7d0:	4680      	mov	r8, r0
		if (iface && iface != entry->iface) {
    a7d2:	b117      	cbz	r7, a7da <net_arp_clear_cache+0x2e>
    a7d4:	6923      	ldr	r3, [r4, #16]
    a7d6:	42bb      	cmp	r3, r7
    a7d8:	d113      	bne.n	a802 <net_arp_clear_cache+0x56>
		arp_entry_cleanup(entry, false);
    a7da:	2100      	movs	r1, #0
    a7dc:	4620      	mov	r0, r4
    a7de:	f008 fca6 	bl	1312e <arp_entry_cleanup>
		sys_slist_remove(&arp_table, prev, &entry->node);
    a7e2:	4622      	mov	r2, r4
    a7e4:	4649      	mov	r1, r9
    a7e6:	4640      	mov	r0, r8
    a7e8:	f008 fc6c 	bl	130c4 <sys_slist_remove>
Z_GENLIST_PREPEND(slist, snode)
    a7ec:	6833      	ldr	r3, [r6, #0]
	parent->next = child;
    a7ee:	6023      	str	r3, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
    a7f0:	6873      	ldr	r3, [r6, #4]
	list->head = node;
    a7f2:	6034      	str	r4, [r6, #0]
Z_GENLIST_PREPEND(slist, snode)
    a7f4:	b903      	cbnz	r3, a7f8 <net_arp_clear_cache+0x4c>
	list->tail = node;
    a7f6:	6074      	str	r4, [r6, #4]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
    a7f8:	2d00      	cmp	r5, #0
    a7fa:	d0dd      	beq.n	a7b8 <net_arp_clear_cache+0xc>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    a7fc:	462c      	mov	r4, r5
    a7fe:	682d      	ldr	r5, [r5, #0]
    a800:	e7e7      	b.n	a7d2 <net_arp_clear_cache+0x26>
			prev = &entry->node;
    a802:	46a1      	mov	r9, r4
    a804:	e7f8      	b.n	a7f8 <net_arp_clear_cache+0x4c>
    a806:	6826      	ldr	r6, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
    a808:	f8df 8058 	ldr.w	r8, [pc, #88]	; a864 <net_arp_clear_cache+0xb8>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    a80c:	f04f 0900 	mov.w	r9, #0
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
    a810:	46aa      	mov	sl, r5
		if (iface && iface != entry->iface) {
    a812:	b117      	cbz	r7, a81a <net_arp_clear_cache+0x6e>
    a814:	6923      	ldr	r3, [r4, #16]
    a816:	42bb      	cmp	r3, r7
    a818:	d116      	bne.n	a848 <net_arp_clear_cache+0x9c>
		arp_entry_cleanup(entry, true);
    a81a:	2101      	movs	r1, #1
    a81c:	4620      	mov	r0, r4
    a81e:	f008 fc86 	bl	1312e <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
    a822:	4622      	mov	r2, r4
    a824:	4649      	mov	r1, r9
    a826:	4650      	mov	r0, sl
    a828:	f008 fc4c 	bl	130c4 <sys_slist_remove>
Z_GENLIST_PREPEND(slist, snode)
    a82c:	f8d8 3000 	ldr.w	r3, [r8]
	parent->next = child;
    a830:	6023      	str	r3, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
    a832:	f8d8 3004 	ldr.w	r3, [r8, #4]
	list->head = node;
    a836:	f8c8 4000 	str.w	r4, [r8]
Z_GENLIST_PREPEND(slist, snode)
    a83a:	b90b      	cbnz	r3, a840 <net_arp_clear_cache+0x94>
	list->tail = node;
    a83c:	f8c8 4004 	str.w	r4, [r8, #4]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
    a840:	b126      	cbz	r6, a84c <net_arp_clear_cache+0xa0>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    a842:	4634      	mov	r4, r6
    a844:	6836      	ldr	r6, [r6, #0]
    a846:	e7e4      	b.n	a812 <net_arp_clear_cache+0x66>
			prev = &entry->node;
    a848:	46a1      	mov	r9, r4
    a84a:	e7f9      	b.n	a840 <net_arp_clear_cache+0x94>
	if (sys_slist_is_empty(&arp_pending_entries)) {
    a84c:	682b      	ldr	r3, [r5, #0]
    a84e:	2b00      	cmp	r3, #0
    a850:	d0b5      	beq.n	a7be <net_arp_clear_cache+0x12>
}
    a852:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a856:	bf00      	nop
    a858:	20003a1c 	.word	0x20003a1c
    a85c:	200039f4 	.word	0x200039f4
    a860:	200039fc 	.word	0x200039fc
    a864:	200039ec 	.word	0x200039ec

0000a868 <net_arp_init>:

	return ret;
}

void net_arp_init(void)
{
    a868:	b510      	push	{r4, lr}
	int i;

	if (arp_cache_initialized) {
    a86a:	4c0b      	ldr	r4, [pc, #44]	; (a898 <net_arp_init+0x30>)
    a86c:	7822      	ldrb	r2, [r4, #0]
    a86e:	b992      	cbnz	r2, a896 <net_arp_init+0x2e>
	list->head = NULL;
    a870:	4b0a      	ldr	r3, [pc, #40]	; (a89c <net_arp_init+0x34>)
	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
		/* Inserting entry as free */
		sys_slist_prepend(&arp_free_entries, &arp_entries[i].node);
	}

	k_delayed_work_init(&arp_request_timer, arp_request_timeout);
    a872:	490b      	ldr	r1, [pc, #44]	; (a8a0 <net_arp_init+0x38>)
    a874:	480b      	ldr	r0, [pc, #44]	; (a8a4 <net_arp_init+0x3c>)
	list->tail = NULL;
    a876:	e9c3 2200 	strd	r2, r2, [r3]
	list->head = NULL;
    a87a:	4b0b      	ldr	r3, [pc, #44]	; (a8a8 <net_arp_init+0x40>)
	list->tail = NULL;
    a87c:	e9c3 2200 	strd	r2, r2, [r3]
	parent->next = child;
    a880:	4b0a      	ldr	r3, [pc, #40]	; (a8ac <net_arp_init+0x44>)
    a882:	601a      	str	r2, [r3, #0]
	list->tail = node;
    a884:	4a0a      	ldr	r2, [pc, #40]	; (a8b0 <net_arp_init+0x48>)
	parent->next = child;
    a886:	621b      	str	r3, [r3, #32]
	list->tail = node;
    a888:	6053      	str	r3, [r2, #4]
	list->head = node;
    a88a:	3320      	adds	r3, #32
    a88c:	6013      	str	r3, [r2, #0]
    a88e:	f00b fb22 	bl	15ed6 <k_delayed_work_init>

	arp_cache_initialized = true;
    a892:	2301      	movs	r3, #1
    a894:	7023      	strb	r3, [r4, #0]
}
    a896:	bd10      	pop	{r4, pc}
    a898:	20005b01 	.word	0x20005b01
    a89c:	200039f4 	.word	0x200039f4
    a8a0:	0000a44d 	.word	0x0000a44d
    a8a4:	200039fc 	.word	0x200039fc
    a8a8:	20003a1c 	.word	0x20003a1c
    a8ac:	20002010 	.word	0x20002010
    a8b0:	200039ec 	.word	0x200039ec

0000a8b4 <ethernet_send>:

	net_pkt_frag_unref(buf);
}

static int ethernet_send(struct net_if *iface, struct net_pkt *pkt)
{
    a8b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 *
 * @return a pointer to the device driver instance
 */
static inline struct device *net_if_get_device(struct net_if *iface)
{
	return iface->if_dev->dev;
    a8b8:	6803      	ldr	r3, [r0, #0]
	const struct ethernet_api *api = net_if_get_device(iface)->driver_api;
    a8ba:	681b      	ldr	r3, [r3, #0]
    a8bc:	685f      	ldr	r7, [r3, #4]
	return pkt->family;
    a8be:	f891 3043 	ldrb.w	r3, [r1, #67]	; 0x43
	struct ethernet_context *ctx = net_if_l2_data(iface);
	u16_t ptype;
	int ret;

	if (IS_ENABLED(CONFIG_NET_IPV4) &&
    a8c2:	f3c3 0842 	ubfx	r8, r3, #1, #3
    a8c6:	f1b8 0f01 	cmp.w	r8, #1
{
    a8ca:	4606      	mov	r6, r0
    a8cc:	460d      	mov	r5, r1
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
    a8ce:	d17b      	bne.n	a9c8 <ethernet_send+0x114>
}

static inline u8_t *net_pkt_ip_data(struct net_pkt *pkt)
{
	return pkt->frags->data;
    a8d0:	694b      	ldr	r3, [r1, #20]
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
    a8d2:	f8d1 9024 	ldr.w	r9, [r1, #36]	; 0x24
    a8d6:	689c      	ldr	r4, [r3, #8]
 * @return True if address is a broadcast address, false otherwise.
 */
static inline bool net_ipv4_is_addr_bcast(struct net_if *iface,
					  const struct in_addr *addr)
{
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    a8d8:	f001 f93c 	bl	bb54 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
    a8dc:	6922      	ldr	r2, [r4, #16]
    a8de:	6803      	ldr	r3, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    a8e0:	429a      	cmp	r2, r3
    a8e2:	f000 808d 	beq.w	aa00 <ethernet_send+0x14c>
		return true;
	}

	return net_if_ipv4_is_addr_bcast(iface, addr);
    a8e6:	f104 0110 	add.w	r1, r4, #16
    a8ea:	4648      	mov	r0, r9
    a8ec:	f000 fbd4 	bl	b098 <net_if_ipv4_is_addr_bcast>
    a8f0:	4602      	mov	r2, r0
    a8f2:	2800      	cmp	r0, #0
    a8f4:	f040 8084 	bne.w	aa00 <ethernet_send+0x14c>
    a8f8:	696b      	ldr	r3, [r5, #20]
    a8fa:	6899      	ldr	r1, [r3, #8]
				   &NET_IPV4_HDR(pkt)->dst) ||
    a8fc:	7c0b      	ldrb	r3, [r1, #16]
    a8fe:	2be0      	cmp	r3, #224	; 0xe0
    a900:	d07e      	beq.n	aa00 <ethernet_send+0x14c>
		arp_pkt = net_arp_prepare(pkt, &NET_IPV4_HDR(pkt)->dst, NULL);
    a902:	3110      	adds	r1, #16
    a904:	4628      	mov	r0, r5
    a906:	f7ff fe4f 	bl	a5a8 <net_arp_prepare>
		if (!arp_pkt) {
    a90a:	4604      	mov	r4, r0
    a90c:	b920      	cbnz	r0, a918 <ethernet_send+0x64>
		if (net_pkt_ipv4_auto(pkt)) {
			ptype = htons(NET_ETH_PTYPE_ARP);
		} else {
			tmp = ethernet_ll_prepare_on_ipv4(iface, pkt);
			if (!tmp) {
				ret = -ENOMEM;
    a90e:	f06f 050b 	mvn.w	r5, #11
	ethernet_remove_l2_header(pkt);

	net_pkt_unref(pkt);
error:
	return ret;
}
    a912:	4628      	mov	r0, r5
    a914:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (pkt != arp_pkt) {
    a918:	4285      	cmp	r5, r0
    a91a:	d072      	beq.n	aa02 <ethernet_send+0x14e>
			net_pkt_unref(pkt);
    a91c:	4628      	mov	r0, r5
    a91e:	f009 fa1a 	bl	13d56 <net_pkt_unref>
	pkt->family = family;
    a922:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    a926:	f368 0343 	bfi	r3, r8, #1, #3
    a92a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
		ptype = htons(NET_ETH_PTYPE_ARP);
    a92e:	f44f 68c1 	mov.w	r8, #1544	; 0x608
	if (!net_pkt_lladdr_dst(pkt)->addr) {
    a932:	6b63      	ldr	r3, [r4, #52]	; 0x34
    a934:	b923      	cbnz	r3, a940 <ethernet_send+0x8c>
		net_pkt_lladdr_dst(pkt)->addr = (u8_t *)broadcast_eth_addr.addr;
    a936:	4b34      	ldr	r3, [pc, #208]	; (aa08 <ethernet_send+0x154>)
    a938:	6363      	str	r3, [r4, #52]	; 0x34
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
    a93a:	2306      	movs	r3, #6
    a93c:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
	hdr_frag = net_pkt_get_frag(pkt, NET_BUF_TIMEOUT);
    a940:	2164      	movs	r1, #100	; 0x64
    a942:	4620      	mov	r0, r4
    a944:	f000 fe52 	bl	b5ec <net_pkt_get_frag>
	if (!hdr_frag) {
    a948:	4605      	mov	r5, r0
    a94a:	2800      	cmp	r0, #0
    a94c:	d0df      	beq.n	a90e <ethernet_send+0x5a>
	return pkt->family;
    a94e:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
		hdr = (struct net_eth_hdr *)(hdr_frag->data);
    a952:	6883      	ldr	r3, [r0, #8]
    a954:	f3c1 0142 	ubfx	r1, r1, #1, #3
	if (net_pkt_family(pkt) == AF_INET &&
    a958:	b2ca      	uxtb	r2, r1
    a95a:	2a01      	cmp	r2, #1
    a95c:	d13b      	bne.n	a9d6 <ethernet_send+0x122>
	return pkt->frags->data;
    a95e:	6962      	ldr	r2, [r4, #20]
    a960:	6892      	ldr	r2, [r2, #8]
    a962:	7c10      	ldrb	r0, [r2, #16]
    a964:	28e0      	cmp	r0, #224	; 0xe0
    a966:	d136      	bne.n	a9d6 <ethernet_send+0x122>
		dst->addr[0] = 0x01;
    a968:	7019      	strb	r1, [r3, #0]
		dst->addr[1] = 0x00;
    a96a:	2100      	movs	r1, #0
    a96c:	7059      	strb	r1, [r3, #1]
		dst->addr[2] = 0x5e;
    a96e:	215e      	movs	r1, #94	; 0x5e
    a970:	7099      	strb	r1, [r3, #2]
		dst->addr[4] = NET_IPV4_HDR(pkt)->dst.s4_addr[2];
    a972:	7c90      	ldrb	r0, [r2, #18]
		dst->addr[3] = NET_IPV4_HDR(pkt)->dst.s4_addr[1];
    a974:	7c51      	ldrb	r1, [r2, #17]
		dst->addr[4] = NET_IPV4_HDR(pkt)->dst.s4_addr[2];
    a976:	7118      	strb	r0, [r3, #4]
		dst->addr[5] = NET_IPV4_HDR(pkt)->dst.s4_addr[3];
    a978:	7cd2      	ldrb	r2, [r2, #19]
    a97a:	715a      	strb	r2, [r3, #5]
		dst->addr[3] &= 0x7f;
    a97c:	f001 027f 	and.w	r2, r1, #127	; 0x7f
    a980:	70da      	strb	r2, [r3, #3]
    a982:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    a984:	6811      	ldr	r1, [r2, #0]
    a986:	f8c3 1006 	str.w	r1, [r3, #6]
    a98a:	8892      	ldrh	r2, [r2, #4]
    a98c:	815a      	strh	r2, [r3, #10]
		hdr->type = ptype;
    a98e:	f8a3 800c 	strh.w	r8, [r3, #12]
		net_buf_add(hdr_frag, sizeof(struct net_eth_hdr));
    a992:	210e      	movs	r1, #14
    a994:	f105 0008 	add.w	r0, r5, #8
    a998:	f008 fb86 	bl	130a8 <net_buf_simple_add>
	net_pkt_frag_insert(pkt, hdr_frag);
    a99c:	4629      	mov	r1, r5
    a99e:	4620      	mov	r0, r4
    a9a0:	f009 fa03 	bl	13daa <net_pkt_frag_insert>
	net_pkt_cursor_init(pkt);
    a9a4:	4620      	mov	r0, r4
    a9a6:	f009 fa4a 	bl	13e3e <net_pkt_cursor_init>
    a9aa:	6832      	ldr	r2, [r6, #0]
	ret = api->send(net_if_get_device(iface), pkt);
    a9ac:	69bb      	ldr	r3, [r7, #24]
    a9ae:	6810      	ldr	r0, [r2, #0]
    a9b0:	4621      	mov	r1, r4
    a9b2:	4798      	blx	r3
	if (ret != 0) {
    a9b4:	4605      	mov	r5, r0
	buf = pkt->buffer;
    a9b6:	6960      	ldr	r0, [r4, #20]
	if (ret != 0) {
    a9b8:	b19d      	cbz	r5, a9e2 <ethernet_send+0x12e>
	pkt->buffer = buf->frags;
    a9ba:	6803      	ldr	r3, [r0, #0]
    a9bc:	6163      	str	r3, [r4, #20]
	buf->frags = NULL;
    a9be:	2300      	movs	r3, #0
    a9c0:	6003      	str	r3, [r0, #0]
	net_pkt_frag_unref(buf);
    a9c2:	f009 f9c4 	bl	13d4e <net_pkt_frag_unref>
    a9c6:	e7a4      	b.n	a912 <ethernet_send+0x5e>
	pkt->family = family;
    a9c8:	2201      	movs	r2, #1
    a9ca:	f362 0343 	bfi	r3, r2, #1, #3
    a9ce:	f881 3043 	strb.w	r3, [r1, #67]	; 0x43
    a9d2:	460c      	mov	r4, r1
    a9d4:	e7ab      	b.n	a92e <ethernet_send+0x7a>
    a9d6:	6b62      	ldr	r2, [r4, #52]	; 0x34
    a9d8:	6811      	ldr	r1, [r2, #0]
    a9da:	6019      	str	r1, [r3, #0]
    a9dc:	8892      	ldrh	r2, [r2, #4]
    a9de:	809a      	strh	r2, [r3, #4]
    a9e0:	e7cf      	b.n	a982 <ethernet_send+0xce>
	ret = net_pkt_get_len(pkt);
    a9e2:	4603      	mov	r3, r0
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;

	while (buf) {
    a9e4:	b943      	cbnz	r3, a9f8 <ethernet_send+0x144>
	pkt->buffer = buf->frags;
    a9e6:	6802      	ldr	r2, [r0, #0]
    a9e8:	6162      	str	r2, [r4, #20]
	buf->frags = NULL;
    a9ea:	6003      	str	r3, [r0, #0]
	net_pkt_frag_unref(buf);
    a9ec:	f009 f9af 	bl	13d4e <net_pkt_frag_unref>
	net_pkt_unref(pkt);
    a9f0:	4620      	mov	r0, r4
    a9f2:	f009 f9b0 	bl	13d56 <net_pkt_unref>
	return ret;
    a9f6:	e78c      	b.n	a912 <ethernet_send+0x5e>
		bytes += buf->len;
    a9f8:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
    a9fa:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
    a9fc:	4415      	add	r5, r2
		buf = buf->frags;
    a9fe:	e7f1      	b.n	a9e4 <ethernet_send+0x130>
				ret = -ENOMEM;
    aa00:	462c      	mov	r4, r5
				ptype = htons(NET_ETH_PTYPE_IP);
    aa02:	f04f 0808 	mov.w	r8, #8
    aa06:	e794      	b.n	a932 <ethernet_send+0x7e>
    aa08:	0001886c 	.word	0x0001886c

0000aa0c <net_eth_broadcast_addr>:
}
    aa0c:	4800      	ldr	r0, [pc, #0]	; (aa10 <net_eth_broadcast_addr+0x4>)
    aa0e:	4770      	bx	lr
    aa10:	0001886c 	.word	0x0001886c

0000aa14 <check_used_port>:
#if defined(CONFIG_NET_UDP) || defined(CONFIG_NET_TCP)
static int check_used_port(enum net_ip_protocol ip_proto,
			   u16_t local_port,
			   const struct sockaddr *local_addr)

{
    aa14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    aa18:	4c15      	ldr	r4, [pc, #84]	; (aa70 <check_used_port+0x5c>)
    aa1a:	460f      	mov	r7, r1
    aa1c:	4615      	mov	r5, r2
    aa1e:	f504 762e 	add.w	r6, r4, #696	; 0x2b8
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
		if (!net_context_is_used(&contexts[i])) {
			continue;
		}

		if (!(net_context_get_ip_proto(&contexts[i]) == ip_proto &&
    aa22:	4680      	mov	r8, r0

		if (local_addr->sa_family == AF_INET6) {
			if (net_ipv6_addr_cmp(
				    net_sin6_ptr(&contexts[i].local)->
							     sin6_addr,
				    &((struct sockaddr_in6 *)
    aa24:	f102 0904 	add.w	r9, r2, #4
		if (!net_context_is_used(&contexts[i])) {
    aa28:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
    aa2c:	07db      	lsls	r3, r3, #31
    aa2e:	d405      	bmi.n	aa3c <check_used_port+0x28>
    aa30:	3474      	adds	r4, #116	; 0x74
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    aa32:	42a6      	cmp	r6, r4
    aa34:	d1f8      	bne.n	aa28 <check_used_port+0x14>
				return -EEXIST;
			}
		}
	}

	return 0;
    aa36:	2000      	movs	r0, #0
}
    aa38:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (!(net_context_get_ip_proto(&contexts[i]) == ip_proto &&
    aa3c:	f8b4 306c 	ldrh.w	r3, [r4, #108]	; 0x6c
    aa40:	4543      	cmp	r3, r8
    aa42:	d1f5      	bne.n	aa30 <check_used_port+0x1c>
    aa44:	8be3      	ldrh	r3, [r4, #30]
    aa46:	42bb      	cmp	r3, r7
    aa48:	d1f2      	bne.n	aa30 <check_used_port+0x1c>
		if (local_addr->sa_family == AF_INET6) {
    aa4a:	882b      	ldrh	r3, [r5, #0]
    aa4c:	6a20      	ldr	r0, [r4, #32]
    aa4e:	2b02      	cmp	r3, #2
    aa50:	d108      	bne.n	aa64 <check_used_port+0x50>
	return !memcmp(addr1, addr2, sizeof(struct in6_addr));
    aa52:	2210      	movs	r2, #16
    aa54:	4649      	mov	r1, r9
    aa56:	f7f7 fb7f 	bl	2158 <memcmp>
			if (net_ipv6_addr_cmp(
    aa5a:	2800      	cmp	r0, #0
    aa5c:	d1e8      	bne.n	aa30 <check_used_port+0x1c>
				return -EEXIST;
    aa5e:	f06f 0010 	mvn.w	r0, #16
    aa62:	e7e9      	b.n	aa38 <check_used_port+0x24>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
    aa64:	686a      	ldr	r2, [r5, #4]
    aa66:	6803      	ldr	r3, [r0, #0]
			if (net_ipv4_addr_cmp(
    aa68:	429a      	cmp	r2, r3
    aa6a:	d1e1      	bne.n	aa30 <check_used_port+0x1c>
    aa6c:	e7f7      	b.n	aa5e <check_used_port+0x4a>
    aa6e:	bf00      	nop
    aa70:	20003a24 	.word	0x20003a24

0000aa74 <find_available_port>:

static u16_t find_available_port(struct net_context *context,
				    const struct sockaddr *addr)
{
    aa74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u16_t local_port;

	do {
		local_port = sys_rand32_get() | 0x8000;
    aa76:	4f09      	ldr	r7, [pc, #36]	; (aa9c <find_available_port+0x28>)
{
    aa78:	4605      	mov	r5, r0
    aa7a:	460e      	mov	r6, r1
		local_port = sys_rand32_get() | 0x8000;
    aa7c:	f7fd fdac 	bl	85d8 <sys_rand32_get>
    aa80:	ea40 0407 	orr.w	r4, r0, r7
    aa84:	ba64      	rev16	r4, r4
    aa86:	b2a4      	uxth	r4, r4
		if (local_port <= 1023U) {
			/* 0 - 1023 ports are reserved */
			continue;
		}
	} while (check_used_port(
    aa88:	4632      	mov	r2, r6
    aa8a:	4621      	mov	r1, r4
    aa8c:	f895 006c 	ldrb.w	r0, [r5, #108]	; 0x6c
    aa90:	f7ff ffc0 	bl	aa14 <check_used_port>
				net_context_get_ip_proto(context),
				htons(local_port), addr) == -EEXIST);
    aa94:	3011      	adds	r0, #17
    aa96:	d0f1      	beq.n	aa7c <find_available_port+0x8>

	return htons(local_port);
}
    aa98:	4620      	mov	r0, r4
    aa9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    aa9c:	ffff8000 	.word	0xffff8000

0000aaa0 <net_context_packet_received>:
enum net_verdict net_context_packet_received(struct net_conn *conn,
					     struct net_pkt *pkt,
					     union net_ip_header *ip_hdr,
					     union net_proto_header *proto_hdr,
					     void *user_data)
{
    aaa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aaa4:	4c24      	ldr	r4, [pc, #144]	; (ab38 <net_context_packet_received+0x98>)
    aaa6:	460f      	mov	r7, r1
    aaa8:	b085      	sub	sp, #20
    aaaa:	4693      	mov	fp, r2
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    aaac:	2100      	movs	r1, #0
    aaae:	46a1      	mov	r9, r4
    aab0:	2574      	movs	r5, #116	; 0x74
		if (!net_context_is_used(&contexts[i])) {
    aab2:	f8b4 206e 	ldrh.w	r2, [r4, #110]	; 0x6e
    aab6:	07d2      	lsls	r2, r2, #31
    aab8:	fb05 f601 	mul.w	r6, r5, r1
    aabc:	d502      	bpl.n	aac4 <net_context_packet_received+0x24>
		if (contexts[i].conn_handler == conn_handler) {
    aabe:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    aac0:	4290      	cmp	r0, r2
    aac2:	d00e      	beq.n	aae2 <net_context_packet_received+0x42>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    aac4:	3101      	adds	r1, #1
    aac6:	2906      	cmp	r1, #6
    aac8:	f104 0474 	add.w	r4, r4, #116	; 0x74
    aacc:	d1f1      	bne.n	aab2 <net_context_packet_received+0x12>
	enum net_verdict verdict = NET_DROP;

	NET_ASSERT(context);
	NET_ASSERT(net_pkt_iface(pkt));

	k_mutex_lock(&context->lock, K_FOREVER);
    aace:	2008      	movs	r0, #8
    aad0:	f008 fcf5 	bl	134be <k_mutex_lock.constprop.26>
static inline void net_context_set_iface(struct net_context *context,
					 struct net_if *iface)
{
	NET_ASSERT(iface);

	context->iface = net_if_get_by_iface(iface);
    aad4:	6a78      	ldr	r0, [r7, #36]	; 0x24
    aad6:	f000 fcb7 	bl	b448 <net_if_get_by_iface>
    aada:	2300      	movs	r3, #0
    aadc:	f883 3070 	strb.w	r3, [r3, #112]	; 0x70
    aae0:	deff      	udf	#255	; 0xff
    aae2:	f106 0808 	add.w	r8, r6, #8
    aae6:	44c8      	add	r8, r9
    aae8:	4640      	mov	r0, r8
    aaea:	9303      	str	r3, [sp, #12]
    aaec:	f008 fce7 	bl	134be <k_mutex_lock.constprop.26>
    aaf0:	6a78      	ldr	r0, [r7, #36]	; 0x24
    aaf2:	f000 fca9 	bl	b448 <net_if_get_by_iface>
	net_pkt_set_context(pkt, context);

	/* If there is no callback registered, then we can only drop
	 * the packet.
	 */
	if (!context->recv_cb) {
    aaf6:	eb09 0206 	add.w	r2, r9, r6
    aafa:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
	pkt->context = ctx;
    aafe:	623c      	str	r4, [r7, #32]
    ab00:	f8d2 a030 	ldr.w	sl, [r2, #48]	; 0x30
    ab04:	f1ba 0f00 	cmp.w	sl, #0
    ab08:	d014      	beq.n	ab34 <net_context_packet_received+0x94>
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
		net_stats_update_tcp_recv(net_pkt_iface(pkt),
					  net_pkt_remaining_data(pkt));
	}

	context->recv_cb(context, pkt, ip_hdr, proto_hdr, 0, user_data);
    ab0a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    ab0c:	9201      	str	r2, [sp, #4]
    ab0e:	2500      	movs	r5, #0
    ab10:	4620      	mov	r0, r4
    ab12:	9500      	str	r5, [sp, #0]
    ab14:	9b03      	ldr	r3, [sp, #12]
    ab16:	465a      	mov	r2, fp
    ab18:	4639      	mov	r1, r7
    ab1a:	47d0      	blx	sl

#if defined(CONFIG_NET_CONTEXT_SYNC_RECV)
	k_sem_give(&context->recv_data_wait);
    ab1c:	f106 0040 	add.w	r0, r6, #64	; 0x40
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    ab20:	4448      	add	r0, r9
    ab22:	f004 fd71 	bl	f608 <z_impl_k_sem_give>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    ab26:	4640      	mov	r0, r8
    ab28:	f004 fa10 	bl	ef4c <z_impl_k_mutex_unlock>

unlock:
	k_mutex_unlock(&context->lock);

	return verdict;
}
    ab2c:	4628      	mov	r0, r5
    ab2e:	b005      	add	sp, #20
    ab30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	enum net_verdict verdict = NET_DROP;
    ab34:	2502      	movs	r5, #2
    ab36:	e7f6      	b.n	ab26 <net_context_packet_received+0x86>
    ab38:	20003a24 	.word	0x20003a24

0000ab3c <net_context_get>:
	if (family == AF_INET6) {
    ab3c:	2802      	cmp	r0, #2
{
    ab3e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ab42:	4607      	mov	r7, r0
    ab44:	468b      	mov	fp, r1
    ab46:	4691      	mov	r9, r2
    ab48:	469a      	mov	sl, r3
	if (family == AF_INET6) {
    ab4a:	f000 80a5 	beq.w	ac98 <net_context_get+0x15c>
	if (!IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == AF_CAN) {
    ab4e:	2804      	cmp	r0, #4
    ab50:	f000 80a2 	beq.w	ac98 <net_context_get+0x15c>
	if (type == SOCK_RAW) {
    ab54:	2903      	cmp	r1, #3
    ab56:	d003      	beq.n	ab60 <net_context_get+0x24>
		if (family == AF_PACKET || family == AF_CAN) {
    ab58:	1ec3      	subs	r3, r0, #3
    ab5a:	2b01      	cmp	r3, #1
    ab5c:	f240 80a2 	bls.w	aca4 <net_context_get+0x168>
	if (family != AF_INET && family != AF_INET6 && family != AF_PACKET &&
    ab60:	1e7b      	subs	r3, r7, #1
    ab62:	2b03      	cmp	r3, #3
    ab64:	f200 809b 	bhi.w	ac9e <net_context_get+0x162>
	if (type != SOCK_DGRAM && type != SOCK_STREAM && type != SOCK_RAW) {
    ab68:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    ab6c:	2b02      	cmp	r3, #2
    ab6e:	f200 8099 	bhi.w	aca4 <net_context_get+0x168>
	if (type != SOCK_RAW && ip_proto != IPPROTO_UDP &&
    ab72:	f1bb 0f03 	cmp.w	fp, #3
    ab76:	d00a      	beq.n	ab8e <net_context_get+0x52>
    ab78:	f1b9 0f11 	cmp.w	r9, #17
    ab7c:	f000 8098 	beq.w	acb0 <net_context_get+0x174>
    ab80:	f1b9 0f06 	cmp.w	r9, #6
    ab84:	f000 809b 	beq.w	acbe <net_context_get+0x182>
		return -EPROTONOSUPPORT;
    ab88:	f06f 047a 	mvn.w	r4, #122	; 0x7a
    ab8c:	e020      	b.n	abd0 <net_context_get+0x94>
	if (!context) {
    ab8e:	f1ba 0f00 	cmp.w	sl, #0
    ab92:	f000 808a 	beq.w	acaa <net_context_get+0x16e>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    ab96:	4c4b      	ldr	r4, [pc, #300]	; (acc4 <net_context_get+0x188>)
    ab98:	484b      	ldr	r0, [pc, #300]	; (acc8 <net_context_get+0x18c>)
    ab9a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ab9e:	f004 fd5f 	bl	f660 <z_impl_k_sem_take>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    aba2:	f04f 0800 	mov.w	r8, #0
    aba6:	4625      	mov	r5, r4
    aba8:	2374      	movs	r3, #116	; 0x74
		if (net_context_is_used(&contexts[i])) {
    abaa:	f8b4 106e 	ldrh.w	r1, [r4, #110]	; 0x6e
    abae:	f011 0101 	ands.w	r1, r1, #1
    abb2:	fb03 f608 	mul.w	r6, r3, r8
    abb6:	d00e      	beq.n	abd6 <net_context_get+0x9a>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
    abb8:	f108 0801 	add.w	r8, r8, #1
    abbc:	f1b8 0f06 	cmp.w	r8, #6
    abc0:	f104 0474 	add.w	r4, r4, #116	; 0x74
    abc4:	d1f1      	bne.n	abaa <net_context_get+0x6e>
	int i, ret = -ENOENT;
    abc6:	f06f 0401 	mvn.w	r4, #1
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    abca:	483f      	ldr	r0, [pc, #252]	; (acc8 <net_context_get+0x18c>)
    abcc:	f004 fd1c 	bl	f608 <z_impl_k_sem_give>
}
    abd0:	4620      	mov	r0, r4
    abd2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
__ssp_bos_icheck3(memset, void *, int)
    abd6:	2274      	movs	r2, #116	; 0x74
    abd8:	4620      	mov	r0, r4
    abda:	f7f7 fb06 	bl	21ea <memset>
		if (ip_proto == IPPROTO_TCP) {
    abde:	f1b9 0f06 	cmp.w	r9, #6
    abe2:	d039      	beq.n	ac58 <net_context_get+0x11c>
		contexts[i].iface = -1;
    abe4:	2274      	movs	r2, #116	; 0x74
    abe6:	fb02 5208 	mla	r2, r2, r8, r5
    abea:	23ff      	movs	r3, #255	; 0xff
    abec:	f882 3070 	strb.w	r3, [r2, #112]	; 0x70
		contexts[i].flags = 0U;
    abf0:	2300      	movs	r3, #0
    abf2:	f8a2 306e 	strh.w	r3, [r2, #110]	; 0x6e
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    abf6:	19aa      	adds	r2, r5, r6
    abf8:	3204      	adds	r2, #4
    abfa:	2101      	movs	r1, #1
    abfc:	f3bf 8f5b 	dmb	ish
    ac00:	e852 0f00 	ldrex	r0, [r2]
    ac04:	e842 1c00 	strex	ip, r1, [r2]
    ac08:	f1bc 0f00 	cmp.w	ip, #0
    ac0c:	d1f8      	bne.n	ac00 <net_context_get+0xc4>
    ac0e:	f3bf 8f5b 	dmb	ish
		flag = family << 3;
    ac12:	00f9      	lsls	r1, r7, #3
	context->flags |= flag;
    ac14:	f8b4 206e 	ldrh.w	r2, [r4, #110]	; 0x6e
	context->proto = proto;
    ac18:	f8a4 906c 	strh.w	r9, [r4, #108]	; 0x6c
	context->flags |= flag;
    ac1c:	b2c9      	uxtb	r1, r1
	context->flags |= flag;
    ac1e:	ea41 118b 	orr.w	r1, r1, fp, lsl #6
    ac22:	4311      	orrs	r1, r2
		(void)memset(&contexts[i].remote, 0, sizeof(struct sockaddr));
    ac24:	f106 0224 	add.w	r2, r6, #36	; 0x24
    ac28:	f8a4 106e 	strh.w	r1, [r4, #110]	; 0x6e
    ac2c:	50ab      	str	r3, [r5, r2]
    ac2e:	18a9      	adds	r1, r5, r2
		(void)memset(&contexts[i].local, 0,
    ac30:	f106 021c 	add.w	r2, r6, #28
    ac34:	eb05 0902 	add.w	r9, r5, r2
		if (family == AF_INET) {
    ac38:	2f01      	cmp	r7, #1
    ac3a:	604b      	str	r3, [r1, #4]
    ac3c:	50ab      	str	r3, [r5, r2]
    ac3e:	f8c9 3004 	str.w	r3, [r9, #4]
    ac42:	d10f      	bne.n	ac64 <net_context_get+0x128>
			addr->sin_port = find_available_port(&contexts[i],
    ac44:	4649      	mov	r1, r9
    ac46:	4620      	mov	r0, r4
    ac48:	f7ff ff14 	bl	aa74 <find_available_port>
    ac4c:	f8a9 0002 	strh.w	r0, [r9, #2]
			if (!addr->sin_port) {
    ac50:	b940      	cbnz	r0, ac64 <net_context_get+0x128>
				ret = -EADDRINUSE;
    ac52:	f06f 046f 	mvn.w	r4, #111	; 0x6f
    ac56:	e7b8      	b.n	abca <net_context_get+0x8e>
			if (net_tcp_get(&contexts[i]) < 0) {
    ac58:	4620      	mov	r0, r4
    ac5a:	f002 f9a5 	bl	cfa8 <net_tcp_get>
    ac5e:	2800      	cmp	r0, #0
    ac60:	dac0      	bge.n	abe4 <net_context_get+0xa8>
    ac62:	e7b0      	b.n	abc6 <net_context_get+0x8a>
		k_sem_init(&contexts[i].recv_data_wait, 1, UINT_MAX);
    ac64:	f106 0040 	add.w	r0, r6, #64	; 0x40
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    ac68:	4428      	add	r0, r5
    ac6a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    ac6e:	2101      	movs	r1, #1
    ac70:	f00b f896 	bl	15da0 <z_impl_k_sem_init>
		k_mutex_init(&contexts[i].lock);
    ac74:	f106 0008 	add.w	r0, r6, #8
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_INIT, k_mutex_init, struct k_mutex *, mutex)
    ac78:	4428      	add	r0, r5
    ac7a:	f00a feb8 	bl	159ee <z_impl_k_mutex_init>
		contexts[i].flags |= NET_CONTEXT_IN_USE;
    ac7e:	2374      	movs	r3, #116	; 0x74
    ac80:	fb03 5508 	mla	r5, r3, r8, r5
    ac84:	f8b5 306e 	ldrh.w	r3, [r5, #110]	; 0x6e
    ac88:	f043 0301 	orr.w	r3, r3, #1
    ac8c:	f8a5 306e 	strh.w	r3, [r5, #110]	; 0x6e
		*context = &contexts[i];
    ac90:	f8ca 4000 	str.w	r4, [sl]
		ret = 0;
    ac94:	2400      	movs	r4, #0
		break;
    ac96:	e798      	b.n	abca <net_context_get+0x8e>
		return -EPFNOSUPPORT;
    ac98:	f06f 045f 	mvn.w	r4, #95	; 0x5f
    ac9c:	e798      	b.n	abd0 <net_context_get+0x94>
		return -EAFNOSUPPORT;
    ac9e:	f06f 0469 	mvn.w	r4, #105	; 0x69
    aca2:	e795      	b.n	abd0 <net_context_get+0x94>
			return -EPROTOTYPE;
    aca4:	f06f 046a 	mvn.w	r4, #106	; 0x6a
    aca8:	e792      	b.n	abd0 <net_context_get+0x94>
		return -EINVAL;
    acaa:	f06f 0415 	mvn.w	r4, #21
    acae:	e78f      	b.n	abd0 <net_context_get+0x94>
	if ((type == SOCK_STREAM && ip_proto == IPPROTO_UDP) ||
    acb0:	f1bb 0f01 	cmp.w	fp, #1
    acb4:	f47f af6b 	bne.w	ab8e <net_context_get+0x52>
		return -EOPNOTSUPP;
    acb8:	f06f 045e 	mvn.w	r4, #94	; 0x5e
    acbc:	e788      	b.n	abd0 <net_context_get+0x94>
	if ((type == SOCK_STREAM && ip_proto == IPPROTO_UDP) ||
    acbe:	f1bb 0f02 	cmp.w	fp, #2
    acc2:	e7f7      	b.n	acb4 <net_context_get+0x178>
    acc4:	20003a24 	.word	0x20003a24
    acc8:	20003cdc 	.word	0x20003cdc

0000accc <net_context_put>:
{
    accc:	b570      	push	{r4, r5, r6, lr}
	if (!PART_OF_ARRAY(contexts, context)) {
    acce:	4605      	mov	r5, r0
    acd0:	b1d0      	cbz	r0, ad08 <net_context_put+0x3c>
    acd2:	4b0f      	ldr	r3, [pc, #60]	; (ad10 <net_context_put+0x44>)
    acd4:	4298      	cmp	r0, r3
    acd6:	d317      	bcc.n	ad08 <net_context_put+0x3c>
    acd8:	f503 732e 	add.w	r3, r3, #696	; 0x2b8
    acdc:	4298      	cmp	r0, r3
    acde:	d213      	bcs.n	ad08 <net_context_put+0x3c>
	k_mutex_lock(&context->lock, K_FOREVER);
    ace0:	f100 0608 	add.w	r6, r0, #8
	context->connect_cb = NULL;
    ace4:	2400      	movs	r4, #0
	k_mutex_lock(&context->lock, K_FOREVER);
    ace6:	4630      	mov	r0, r6
    ace8:	f008 fbe9 	bl	134be <k_mutex_lock.constprop.26>
	context->connect_cb = NULL;
    acec:	63ac      	str	r4, [r5, #56]	; 0x38
	context->send_cb = NULL;
    acee:	e9c5 440c 	strd	r4, r4, [r5, #48]	; 0x30
	net_context_unref(context);
    acf2:	4628      	mov	r0, r5
    acf4:	f008 fbf5 	bl	134e2 <net_context_unref>
	net_tcp_put(context);
    acf8:	4628      	mov	r0, r5
    acfa:	f00a f907 	bl	14f0c <net_tcp_put>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    acfe:	4630      	mov	r0, r6
    ad00:	f004 f924 	bl	ef4c <z_impl_k_mutex_unlock>
	return ret;
    ad04:	4620      	mov	r0, r4
}
    ad06:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
    ad08:	f06f 0015 	mvn.w	r0, #21
    ad0c:	e7fb      	b.n	ad06 <net_context_put+0x3a>
    ad0e:	bf00      	nop
    ad10:	20003a24 	.word	0x20003a24

0000ad14 <net_context_bind>:
	if (context->conn_handler) {
    ad14:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
{
    ad16:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    ad18:	4606      	mov	r6, r0
    ad1a:	460d      	mov	r5, r1
	if (context->conn_handler) {
    ad1c:	2b00      	cmp	r3, #0
    ad1e:	d172      	bne.n	ae06 <net_context_bind+0xf2>
	if (addr->sa_family == AF_INET) {
    ad20:	8809      	ldrh	r1, [r1, #0]
    ad22:	2901      	cmp	r1, #1
    ad24:	d172      	bne.n	ae0c <net_context_bind+0xf8>
		if (addrlen < sizeof(struct sockaddr_in)) {
    ad26:	2a07      	cmp	r2, #7
		struct net_if *iface = NULL;
    ad28:	9301      	str	r3, [sp, #4]
		if (addrlen < sizeof(struct sockaddr_in)) {
    ad2a:	d96f      	bls.n	ae0c <net_context_bind+0xf8>
		if (net_ipv4_is_addr_mcast(&addr4->sin_addr)) {
    ad2c:	1d2f      	adds	r7, r5, #4
    ad2e:	4638      	mov	r0, r7
    ad30:	f008 fbbc 	bl	134ac <net_ipv4_is_addr_mcast>
    ad34:	b148      	cbz	r0, ad4a <net_context_bind+0x36>
			maddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,
    ad36:	a901      	add	r1, sp, #4
    ad38:	4638      	mov	r0, r7
    ad3a:	f000 fa8b 	bl	b254 <net_if_ipv4_maddr_lookup>
			if (!maddr) {
    ad3e:	bb70      	cbnz	r0, ad9e <net_context_bind+0x8a>
				return -ENOENT;
    ad40:	f06f 0401 	mvn.w	r4, #1
}
    ad44:	4620      	mov	r0, r4
    ad46:	b003      	add	sp, #12
    ad48:	bdf0      	pop	{r4, r5, r6, r7, pc}
		} else if (addr4->sin_addr.s_addr == INADDR_ANY) {
    ad4a:	686b      	ldr	r3, [r5, #4]
    ad4c:	bb13      	cbnz	r3, ad94 <net_context_bind+0x80>
			iface = net_if_ipv4_select_src_iface(
    ad4e:	f106 0028 	add.w	r0, r6, #40	; 0x28
    ad52:	f000 f9b9 	bl	b0c8 <net_if_ipv4_select_src_iface>
    ad56:	9001      	str	r0, [sp, #4]
			ptr = (struct in_addr *)net_ipv4_unspecified_address();
    ad58:	f000 fef8 	bl	bb4c <net_ipv4_unspecified_address>
    ad5c:	4604      	mov	r4, r0
		if (!iface) {
    ad5e:	9b01      	ldr	r3, [sp, #4]
    ad60:	b9fb      	cbnz	r3, ada2 <net_context_bind+0x8e>
			NET_ERR("Cannot bind to %s",
    ad62:	2301      	movs	r3, #1
    ad64:	f04f 0400 	mov.w	r4, #0
    ad68:	4a2a      	ldr	r2, [pc, #168]	; (ae14 <net_context_bind+0x100>)
    ad6a:	f363 0407 	bfi	r4, r3, #0, #8
    ad6e:	4b2a      	ldr	r3, [pc, #168]	; (ae18 <net_context_bind+0x104>)
    ad70:	1a9b      	subs	r3, r3, r2
    ad72:	08db      	lsrs	r3, r3, #3
    ad74:	4639      	mov	r1, r7
    ad76:	2001      	movs	r0, #1
    ad78:	f363 148f 	bfi	r4, r3, #6, #10
    ad7c:	f000 fe74 	bl	ba68 <net_sprint_addr>
    ad80:	f7fc f8fe 	bl	6f80 <log_strdup>
    ad84:	4622      	mov	r2, r4
    ad86:	4601      	mov	r1, r0
    ad88:	4824      	ldr	r0, [pc, #144]	; (ae1c <net_context_bind+0x108>)
    ad8a:	f007 f900 	bl	11f8e <log_1>
			return -EADDRNOTAVAIL;
    ad8e:	f06f 047c 	mvn.w	r4, #124	; 0x7c
    ad92:	e7d7      	b.n	ad44 <net_context_bind+0x30>
			ifaddr = net_if_ipv4_addr_lookup(&addr4->sin_addr,
    ad94:	a901      	add	r1, sp, #4
    ad96:	4638      	mov	r0, r7
    ad98:	f000 f9fe 	bl	b198 <net_if_ipv4_addr_lookup>
    ad9c:	e7cf      	b.n	ad3e <net_context_bind+0x2a>
			ptr = &ifaddr->address.in_addr;
    ad9e:	1d04      	adds	r4, r0, #4
    ada0:	e7dd      	b.n	ad5e <net_context_bind+0x4a>
		k_mutex_lock(&context->lock, K_FOREVER);
    ada2:	f106 0708 	add.w	r7, r6, #8
    ada6:	4638      	mov	r0, r7
    ada8:	f008 fb89 	bl	134be <k_mutex_lock.constprop.26>
	context->iface = net_if_get_by_iface(iface);
    adac:	9801      	ldr	r0, [sp, #4]
    adae:	f000 fb4b 	bl	b448 <net_if_get_by_iface>
    adb2:	f886 0070 	strb.w	r0, [r6, #112]	; 0x70
		if (addr4->sin_port) {
    adb6:	8869      	ldrh	r1, [r5, #2]
		net_sin_ptr(&context->local)->sin_addr = ptr;
    adb8:	6234      	str	r4, [r6, #32]
		net_sin_ptr(&context->local)->sin_family = AF_INET;
    adba:	2001      	movs	r0, #1
    adbc:	83b0      	strh	r0, [r6, #28]
		if (addr4->sin_port) {
    adbe:	b1f1      	cbz	r1, adfe <net_context_bind+0xea>
			ret = check_used_port(AF_INET, addr4->sin_port,
    adc0:	462a      	mov	r2, r5
    adc2:	f7ff fe27 	bl	aa14 <check_used_port>
			if (!ret) {
    adc6:	4604      	mov	r4, r0
    adc8:	b928      	cbnz	r0, add6 <net_context_bind+0xc2>
				net_sin_ptr(&context->local)->sin_port =
    adca:	886b      	ldrh	r3, [r5, #2]
    adcc:	83f3      	strh	r3, [r6, #30]
    adce:	4638      	mov	r0, r7
    add0:	f004 f8bc 	bl	ef4c <z_impl_k_mutex_unlock>
		return ret;
    add4:	e7b6      	b.n	ad44 <net_context_bind+0x30>
				NET_ERR("Port %d is in use!",
    add6:	2301      	movs	r3, #1
    add8:	f04f 0200 	mov.w	r2, #0
    addc:	f363 0207 	bfi	r2, r3, #0, #8
    ade0:	490c      	ldr	r1, [pc, #48]	; (ae14 <net_context_bind+0x100>)
    ade2:	4b0d      	ldr	r3, [pc, #52]	; (ae18 <net_context_bind+0x104>)
    ade4:	480e      	ldr	r0, [pc, #56]	; (ae20 <net_context_bind+0x10c>)
    ade6:	1a5b      	subs	r3, r3, r1
    ade8:	08db      	lsrs	r3, r3, #3
    adea:	f363 128f 	bfi	r2, r3, #6, #10
    adee:	886b      	ldrh	r3, [r5, #2]
    adf0:	0219      	lsls	r1, r3, #8
    adf2:	ea41 2113 	orr.w	r1, r1, r3, lsr #8
    adf6:	b289      	uxth	r1, r1
    adf8:	f007 f8c9 	bl	11f8e <log_1>
				goto unlock;
    adfc:	e7e7      	b.n	adce <net_context_bind+0xba>
			addr4->sin_port =
    adfe:	8bf3      	ldrh	r3, [r6, #30]
    ae00:	806b      	strh	r3, [r5, #2]
    ae02:	460c      	mov	r4, r1
    ae04:	e7e3      	b.n	adce <net_context_bind+0xba>
		return -EISCONN;
    ae06:	f06f 047e 	mvn.w	r4, #126	; 0x7e
    ae0a:	e79b      	b.n	ad44 <net_context_bind+0x30>
	return -EINVAL;
    ae0c:	f06f 0415 	mvn.w	r4, #21
    ae10:	e798      	b.n	ad44 <net_context_bind+0x30>
    ae12:	bf00      	nop
    ae14:	00016344 	.word	0x00016344
    ae18:	00016384 	.word	0x00016384
    ae1c:	0001887f 	.word	0x0001887f
    ae20:	00018891 	.word	0x00018891

0000ae24 <net_context_recv>:

int net_context_recv(struct net_context *context,
		     net_context_recv_cb_t cb,
		     s32_t timeout,
		     void *user_data)
{
    ae24:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ae28:	4698      	mov	r8, r3
	int ret;
	NET_ASSERT(context);

	if (!net_context_is_used(context)) {
    ae2a:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
    ae2e:	07db      	lsls	r3, r3, #31
{
    ae30:	b089      	sub	sp, #36	; 0x24
    ae32:	4604      	mov	r4, r0
    ae34:	4689      	mov	r9, r1
    ae36:	4617      	mov	r7, r2
	if (!net_context_is_used(context)) {
    ae38:	d570      	bpl.n	af1c <net_context_recv+0xf8>
		return -EBADF;
	}

	k_mutex_lock(&context->lock, K_FOREVER);
    ae3a:	f100 0608 	add.w	r6, r0, #8
    ae3e:	4630      	mov	r0, r6
    ae40:	f008 fb3d 	bl	134be <k_mutex_lock.constprop.26>
			context, cb, timeout, user_data);
		goto unlock;
	}
#endif /* CONFIG_NET_OFFLOAD */

	switch (net_context_get_ip_proto(context)) {
    ae44:	f8b4 306c 	ldrh.w	r3, [r4, #108]	; 0x6c
    ae48:	2b06      	cmp	r3, #6
    ae4a:	d05e      	beq.n	af0a <net_context_recv+0xe6>
    ae4c:	2b11      	cmp	r3, #17
    ae4e:	d162      	bne.n	af16 <net_context_recv+0xf2>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
    ae50:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
	if (context->conn_handler) {
    ae54:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	struct sockaddr local_addr = {
    ae56:	2500      	movs	r5, #0
    ae58:	f3c3 03c2 	ubfx	r3, r3, #3, #3
    ae5c:	f8cd 501a 	str.w	r5, [sp, #26]
    ae60:	f8ad 501e 	strh.w	r5, [sp, #30]
    ae64:	f8ad 3018 	strh.w	r3, [sp, #24]
	if (context->conn_handler) {
    ae68:	b110      	cbz	r0, ae70 <net_context_recv+0x4c>
		net_conn_unregister(context->conn_handler);
    ae6a:	f001 f847 	bl	befc <net_conn_unregister>
		context->conn_handler = NULL;
    ae6e:	62e5      	str	r5, [r4, #44]	; 0x2c
	ret = bind_default(context);
    ae70:	4620      	mov	r0, r4
    ae72:	f008 fb61 	bl	13538 <bind_default>
	if (ret) {
    ae76:	4605      	mov	r5, r0
    ae78:	bb70      	cbnz	r0, aed8 <net_context_recv+0xb4>
    ae7a:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
	if (net_context_get_family(context) == AF_INET) {
    ae7e:	f3c3 03c2 	ubfx	r3, r3, #3, #3
    ae82:	2b01      	cmp	r3, #1
    ae84:	d13f      	bne.n	af06 <net_context_recv+0xe2>
		if (net_sin_ptr(&context->local)->sin_addr) {
    ae86:	6a23      	ldr	r3, [r4, #32]
    ae88:	b113      	cbz	r3, ae90 <net_context_recv+0x6c>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
    ae8a:	681b      	ldr	r3, [r3, #0]
    ae8c:	9307      	str	r3, [sp, #28]
			laddr = &local_addr;
    ae8e:	ab06      	add	r3, sp, #24
		lport = net_sin((struct sockaddr *)&context->local)->sin_port;
    ae90:	8be5      	ldrh	r5, [r4, #30]
				ntohs(net_sin(&context->remote)->sin_port),
    ae92:	f8b4 c026 	ldrh.w	ip, [r4, #38]	; 0x26
				net_context_get_family(context),
    ae96:	f8b4 206e 	ldrh.w	r2, [r4, #110]	; 0x6e
	context->recv_cb = cb;
    ae9a:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
	ret = net_conn_register(net_context_get_ip_proto(context),
    ae9e:	ba6d      	rev16	r5, r5
    aea0:	b2ad      	uxth	r5, r5
    aea2:	9501      	str	r5, [sp, #4]
				ntohs(net_sin(&context->remote)->sin_port),
    aea4:	ea4f 250c 	mov.w	r5, ip, lsl #8
	ret = net_conn_register(net_context_get_ip_proto(context),
    aea8:	f104 0e2c 	add.w	lr, r4, #44	; 0x2c
				ntohs(net_sin(&context->remote)->sin_port),
    aeac:	ea45 251c 	orr.w	r5, r5, ip, lsr #8
	ret = net_conn_register(net_context_get_ip_proto(context),
    aeb0:	f3c2 01c2 	ubfx	r1, r2, #3, #3
    aeb4:	e9cd 8e03 	strd	r8, lr, [sp, #12]
    aeb8:	f412 7280 	ands.w	r2, r2, #256	; 0x100
    aebc:	f8df e064 	ldr.w	lr, [pc, #100]	; af24 <net_context_recv+0x100>
    aec0:	f8b4 006c 	ldrh.w	r0, [r4, #108]	; 0x6c
    aec4:	f8cd e008 	str.w	lr, [sp, #8]
    aec8:	b2ad      	uxth	r5, r5
    aeca:	bf18      	it	ne
    aecc:	f104 0224 	addne.w	r2, r4, #36	; 0x24
    aed0:	9500      	str	r5, [sp, #0]
    aed2:	f001 f82b 	bl	bf2c <net_conn_register>
		ret = recv_udp(context, cb, timeout, user_data);
		break;
#endif /* CONFIG_NET_UDP */

	case IPPROTO_TCP:
		ret = net_tcp_recv(context, cb, user_data);
    aed6:	4605      	mov	r5, r0

		ret = -EPROTOTYPE;
		break;
	}

	if (ret < 0) {
    aed8:	2d00      	cmp	r5, #0
    aeda:	db0d      	blt.n	aef8 <net_context_recv+0xd4>
		goto unlock;
	}

#if defined(CONFIG_NET_CONTEXT_SYNC_RECV)
	if (timeout) {
    aedc:	b167      	cbz	r7, aef8 <net_context_recv+0xd4>
/**
 * @internal
 */
static inline void z_impl_k_sem_reset(struct k_sem *sem)
{
	sem->count = 0U;
    aede:	2300      	movs	r3, #0
    aee0:	64a3      	str	r3, [r4, #72]	; 0x48
    aee2:	4630      	mov	r0, r6
    aee4:	f004 f832 	bl	ef4c <z_impl_k_mutex_unlock>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    aee8:	4639      	mov	r1, r7
    aeea:	f104 0040 	add.w	r0, r4, #64	; 0x40
    aeee:	f004 fbb7 	bl	f660 <z_impl_k_sem_take>

		k_mutex_unlock(&context->lock);

		ret = k_sem_take(&context->recv_data_wait, timeout);

		k_mutex_lock(&context->lock, K_FOREVER);
    aef2:	4630      	mov	r0, r6
    aef4:	f008 fae3 	bl	134be <k_mutex_lock.constprop.26>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    aef8:	4630      	mov	r0, r6
    aefa:	f004 f827 	bl	ef4c <z_impl_k_mutex_unlock>

unlock:
	k_mutex_unlock(&context->lock);

	return ret;
}
    aefe:	4628      	mov	r0, r5
    af00:	b009      	add	sp, #36	; 0x24
    af02:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	struct sockaddr *laddr = NULL;
    af06:	4603      	mov	r3, r0
    af08:	e7c3      	b.n	ae92 <net_context_recv+0x6e>
		ret = net_tcp_recv(context, cb, user_data);
    af0a:	4642      	mov	r2, r8
    af0c:	4649      	mov	r1, r9
    af0e:	4620      	mov	r0, r4
    af10:	f009 ffe3 	bl	14eda <net_tcp_recv>
    af14:	e7df      	b.n	aed6 <net_context_recv+0xb2>
		ret = -EPROTOTYPE;
    af16:	f06f 056a 	mvn.w	r5, #106	; 0x6a
    af1a:	e7ed      	b.n	aef8 <net_context_recv+0xd4>
		return -EBADF;
    af1c:	f06f 0508 	mvn.w	r5, #8
    af20:	e7ed      	b.n	aefe <net_context_recv+0xda>
    af22:	bf00      	nop
    af24:	0000aaa1 	.word	0x0000aaa1

0000af28 <net_context_init>:
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    af28:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    af2c:	2101      	movs	r1, #1
    af2e:	4801      	ldr	r0, [pc, #4]	; (af34 <net_context_init+0xc>)
    af30:	f00a bf36 	b.w	15da0 <z_impl_k_sem_init>
    af34:	20003cdc 	.word	0x20003cdc

0000af38 <net_recv_data>:
	net_tc_submit_to_rx_queue(tc, pkt);
}

/* Called by driver when an IP packet has been received */
int net_recv_data(struct net_if *iface, struct net_pkt *pkt)
{
    af38:	b538      	push	{r3, r4, r5, lr}
    af3a:	4605      	mov	r5, r0
	if (!pkt || !iface) {
    af3c:	460c      	mov	r4, r1
    af3e:	b351      	cbz	r1, af96 <net_recv_data+0x5e>
    af40:	b348      	cbz	r0, af96 <net_recv_data+0x5e>
		return -EINVAL;
	}

	if (!pkt->frags) {
    af42:	694b      	ldr	r3, [r1, #20]
    af44:	b353      	cbz	r3, af9c <net_recv_data+0x64>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    af46:	6803      	ldr	r3, [r0, #0]
    af48:	f3bf 8f5b 	dmb	ish
    af4c:	68db      	ldr	r3, [r3, #12]
    af4e:	f3bf 8f5b 	dmb	ish
		return -ENODATA;
	}

	if (!atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    af52:	07db      	lsls	r3, r3, #31
    af54:	d525      	bpl.n	afa2 <net_recv_data+0x6a>
				    &NET_IPV6_HDR(pkt)->src);
}

static inline void net_pkt_set_overwrite(struct net_pkt *pkt, bool overwrite)
{
	pkt->overwrite = overwrite;
    af56:	f891 3041 	ldrb.w	r3, [r1, #65]	; 0x41
    af5a:	f043 0301 	orr.w	r3, r3, #1
    af5e:	f881 3041 	strb.w	r3, [r1, #65]	; 0x41
		return -ENETDOWN;
	}

	net_pkt_set_overwrite(pkt, true);
	net_pkt_cursor_init(pkt);
    af62:	4608      	mov	r0, r1
    af64:	f008 ff6b 	bl	13e3e <net_pkt_cursor_init>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    af68:	682b      	ldr	r3, [r5, #0]
	pkt->iface = iface;
    af6a:	6265      	str	r5, [r4, #36]	; 0x24
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
    af6c:	7d5b      	ldrb	r3, [r3, #21]
    af6e:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
    af72:	682b      	ldr	r3, [r5, #0]
    af74:	7d5b      	ldrb	r3, [r3, #21]
    af76:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
	u8_t tc = net_rx_priority2tc(prio);
    af7a:	2000      	movs	r0, #0
    af7c:	f009 f8bf 	bl	140fe <net_rx_priority2tc>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    af80:	4b09      	ldr	r3, [pc, #36]	; (afa8 <net_recv_data+0x70>)
    af82:	2500      	movs	r5, #0
	net_tc_submit_to_rx_queue(tc, pkt);
    af84:	b2c0      	uxtb	r0, r0
    af86:	6065      	str	r5, [r4, #4]
    af88:	e9c4 3502 	strd	r3, r5, [r4, #8]
    af8c:	4621      	mov	r1, r4
    af8e:	f000 fc4b 	bl	b828 <net_tc_submit_to_rx_queue>

	net_pkt_set_iface(pkt, iface);

	net_queue_rx(iface, pkt);

	return 0;
    af92:	4628      	mov	r0, r5
}
    af94:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    af96:	f06f 0015 	mvn.w	r0, #21
    af9a:	e7fb      	b.n	af94 <net_recv_data+0x5c>
		return -ENODATA;
    af9c:	f06f 003c 	mvn.w	r0, #60	; 0x3c
    afa0:	e7f8      	b.n	af94 <net_recv_data+0x5c>
		return -ENETDOWN;
    afa2:	f06f 0072 	mvn.w	r0, #114	; 0x72
    afa6:	e7f5      	b.n	af94 <net_recv_data+0x5c>
    afa8:	000139a9 	.word	0x000139a9

0000afac <net_ipv4_is_ll_addr>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xA9FE0000) == 0xA9FE0000;
    afac:	6803      	ldr	r3, [r0, #0]
    afae:	4a04      	ldr	r2, [pc, #16]	; (afc0 <net_ipv4_is_ll_addr+0x14>)
    afb0:	ba1b      	rev	r3, r3
    afb2:	ea32 0303 	bics.w	r3, r2, r3
}
    afb6:	bf0c      	ite	eq
    afb8:	2001      	moveq	r0, #1
    afba:	2000      	movne	r0, #0
    afbc:	4770      	bx	lr
    afbe:	bf00      	nop
    afc0:	a9fe0000 	.word	0xa9fe0000

0000afc4 <net_if_ipv4_get_best_match.isra.14>:
	}

	return false;
}

static struct in_addr *net_if_ipv4_get_best_match(struct net_if *iface,
    afc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    afc6:	4617      	mov	r7, r2
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
	struct in_addr *src = NULL;
	u8_t len;
	int i;

	if (!ipv4) {
    afc8:	4604      	mov	r4, r0
    afca:	b330      	cbz	r0, b01a <net_if_ipv4_get_best_match.isra.14+0x56>
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
    afcc:	6882      	ldr	r2, [r0, #8]
    afce:	4b17      	ldr	r3, [pc, #92]	; (b02c <net_if_ipv4_get_best_match.isra.14+0x68>)
    afd0:	4013      	ands	r3, r2
    afd2:	4a17      	ldr	r2, [pc, #92]	; (b030 <net_if_ipv4_get_best_match.isra.14+0x6c>)
    afd4:	4293      	cmp	r3, r2
    afd6:	d126      	bne.n	b026 <net_if_ipv4_get_best_match.isra.14+0x62>
    afd8:	8803      	ldrh	r3, [r0, #0]
    afda:	2b01      	cmp	r3, #1
    afdc:	d123      	bne.n	b026 <net_if_ipv4_get_best_match.isra.14+0x62>
	    !net_ipv4_is_ll_addr(&addr->address.in_addr)) {
    afde:	1d06      	adds	r6, r0, #4
    afe0:	4630      	mov	r0, r6
    afe2:	f7ff ffe3 	bl	afac <net_ipv4_is_ll_addr>
	    addr->address.family == AF_INET &&
    afe6:	b9f0      	cbnz	r0, b026 <net_if_ipv4_get_best_match.isra.14+0x62>
    afe8:	3901      	subs	r1, #1
    afea:	3403      	adds	r4, #3
		if (src[j] == dst[j]) {
    afec:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    aff0:	f814 2f01 	ldrb.w	r2, [r4, #1]!
    aff4:	4293      	cmp	r3, r2
    aff6:	f100 0508 	add.w	r5, r0, #8
    affa:	d010      	beq.n	b01e <net_if_ipv4_get_best_match.isra.14+0x5a>
			xor = src[j] ^ dst[j];
    affc:	4053      	eors	r3, r2
			for (k = 0U; k < 8; k++) {
    affe:	b2ed      	uxtb	r5, r5
				if (!(xor & 0x80)) {
    b000:	061a      	lsls	r2, r3, #24
    b002:	d405      	bmi.n	b010 <net_if_ipv4_get_best_match.isra.14+0x4c>
					len++;
    b004:	3001      	adds	r0, #1
    b006:	b2c0      	uxtb	r0, r0
					xor <<= 1;
    b008:	005b      	lsls	r3, r3, #1
			for (k = 0U; k < 8; k++) {
    b00a:	4285      	cmp	r5, r0
					xor <<= 1;
    b00c:	b2db      	uxtb	r3, r3
			for (k = 0U; k < 8; k++) {
    b00e:	d1f7      	bne.n	b000 <net_if_ipv4_get_best_match.isra.14+0x3c>
		if (!is_proper_ipv4_address(&ipv4->unicast[i])) {
			continue;
		}

		len = get_diff_ipv4(dst, &ipv4->unicast[i].address.in_addr);
		if (len >= *best_so_far) {
    b010:	783b      	ldrb	r3, [r7, #0]
    b012:	4283      	cmp	r3, r0
    b014:	d807      	bhi.n	b026 <net_if_ipv4_get_best_match.isra.14+0x62>
			*best_so_far = len;
    b016:	7038      	strb	r0, [r7, #0]
    b018:	4634      	mov	r4, r6
			src = &ipv4->unicast[i].address.in_addr;
		}
	}

	return src;
}
    b01a:	4620      	mov	r0, r4
    b01c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			len += 8U;
    b01e:	b2e8      	uxtb	r0, r5
	for (j = 0U; j < addr_len; j++) {
    b020:	2820      	cmp	r0, #32
    b022:	d1e3      	bne.n	afec <net_if_ipv4_get_best_match.isra.14+0x28>
    b024:	e7f4      	b.n	b010 <net_if_ipv4_get_best_match.isra.14+0x4c>
		if (len >= *best_so_far) {
    b026:	2400      	movs	r4, #0
    b028:	e7f7      	b.n	b01a <net_if_ipv4_get_best_match.isra.14+0x56>
    b02a:	bf00      	nop
    b02c:	0002ff00 	.word	0x0002ff00
    b030:	00020100 	.word	0x00020100

0000b034 <net_if_queue_tx>:
{
    b034:	b510      	push	{r4, lr}
	u8_t tc = net_tx_priority2tc(prio);
    b036:	2000      	movs	r0, #0
{
    b038:	460c      	mov	r4, r1
	u8_t tc = net_tx_priority2tc(prio);
    b03a:	f000 fbff 	bl	b83c <net_tx_priority2tc>
    b03e:	4a05      	ldr	r2, [pc, #20]	; (b054 <net_if_queue_tx+0x20>)
    b040:	2300      	movs	r3, #0
    b042:	6063      	str	r3, [r4, #4]
    b044:	e9c4 2302 	strd	r2, r3, [r4, #8]
	net_tc_submit_to_tx_queue(tc, pkt);
    b048:	4621      	mov	r1, r4
    b04a:	b2c0      	uxtb	r0, r0
}
    b04c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	net_tc_submit_to_tx_queue(tc, pkt);
    b050:	f000 bbe0 	b.w	b814 <net_tc_submit_to_tx_queue>
    b054:	0000b2c1 	.word	0x0000b2c1

0000b058 <net_if_get_default>:
}
    b058:	4b02      	ldr	r3, [pc, #8]	; (b064 <net_if_get_default+0xc>)
	if (__net_if_start == __net_if_end) {
    b05a:	4803      	ldr	r0, [pc, #12]	; (b068 <net_if_get_default+0x10>)
}
    b05c:	4298      	cmp	r0, r3
    b05e:	bf08      	it	eq
    b060:	2000      	moveq	r0, #0
    b062:	4770      	bx	lr
    b064:	20011e60 	.word	0x20011e60
    b068:	20011e40 	.word	0x20011e40

0000b06c <net_if_config_ipv4_get>:
	if (iface->config.ip.ipv4) {
    b06c:	6843      	ldr	r3, [r0, #4]
    b06e:	b153      	cbz	r3, b086 <net_if_config_ipv4_get+0x1a>
		if (ipv4) {
    b070:	b909      	cbnz	r1, b076 <net_if_config_ipv4_get+0xa>
		return 0;
    b072:	2000      	movs	r0, #0
    b074:	4770      	bx	lr
			*ipv4 = iface->config.ip.ipv4;
    b076:	600b      	str	r3, [r1, #0]
    b078:	e7fb      	b.n	b072 <net_if_config_ipv4_get+0x6>
		iface->config.ip.ipv4 = &ipv4_addresses[i].ipv4;
    b07a:	6042      	str	r2, [r0, #4]
		ipv4_addresses[i].iface = iface;
    b07c:	6250      	str	r0, [r2, #36]	; 0x24
		if (ipv4) {
    b07e:	2900      	cmp	r1, #0
    b080:	d0f7      	beq.n	b072 <net_if_config_ipv4_get+0x6>
			*ipv4 = &ipv4_addresses[i].ipv4;
    b082:	600a      	str	r2, [r1, #0]
    b084:	e7f5      	b.n	b072 <net_if_config_ipv4_get+0x6>
		if (ipv4_addresses[i].iface) {
    b086:	4a03      	ldr	r2, [pc, #12]	; (b094 <net_if_config_ipv4_get+0x28>)
    b088:	6a53      	ldr	r3, [r2, #36]	; 0x24
    b08a:	2b00      	cmp	r3, #0
    b08c:	d0f5      	beq.n	b07a <net_if_config_ipv4_get+0xe>
	return -ESRCH;
    b08e:	f06f 0002 	mvn.w	r0, #2
}
    b092:	4770      	bx	lr
    b094:	20003cf4 	.word	0x20003cf4

0000b098 <net_if_ipv4_is_addr_bcast>:
{
    b098:	b570      	push	{r4, r5, r6, lr}
    b09a:	460e      	mov	r6, r1
	if (iface) {
    b09c:	b168      	cbz	r0, b0ba <net_if_ipv4_is_addr_bcast+0x22>
}
    b09e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return ipv4_is_broadcast_address(iface, addr);
    b0a2:	f008 bd57 	b.w	13b54 <ipv4_is_broadcast_address>
		ret = ipv4_is_broadcast_address(iface, addr);
    b0a6:	4631      	mov	r1, r6
    b0a8:	4620      	mov	r0, r4
    b0aa:	f008 fd53 	bl	13b54 <ipv4_is_broadcast_address>
		if (ret) {
    b0ae:	b918      	cbnz	r0, b0b8 <net_if_ipv4_is_addr_bcast+0x20>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b0b0:	3420      	adds	r4, #32
    b0b2:	42ac      	cmp	r4, r5
    b0b4:	d1f7      	bne.n	b0a6 <net_if_ipv4_is_addr_bcast+0xe>
	return false;
    b0b6:	2000      	movs	r0, #0
}
    b0b8:	bd70      	pop	{r4, r5, r6, pc}
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b0ba:	4c01      	ldr	r4, [pc, #4]	; (b0c0 <net_if_ipv4_is_addr_bcast+0x28>)
    b0bc:	4d01      	ldr	r5, [pc, #4]	; (b0c4 <net_if_ipv4_is_addr_bcast+0x2c>)
    b0be:	e7f8      	b.n	b0b2 <net_if_ipv4_is_addr_bcast+0x1a>
    b0c0:	20011e40 	.word	0x20011e40
    b0c4:	20011e60 	.word	0x20011e60

0000b0c8 <net_if_ipv4_select_src_iface>:
{
    b0c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b0ca:	4c0a      	ldr	r4, [pc, #40]	; (b0f4 <net_if_ipv4_select_src_iface+0x2c>)
    b0cc:	4e0a      	ldr	r6, [pc, #40]	; (b0f8 <net_if_ipv4_select_src_iface+0x30>)
{
    b0ce:	4607      	mov	r7, r0
    b0d0:	4625      	mov	r5, r4
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b0d2:	42b4      	cmp	r4, r6
    b0d4:	d106      	bne.n	b0e4 <net_if_ipv4_select_src_iface+0x1c>
		return NULL;
    b0d6:	4b07      	ldr	r3, [pc, #28]	; (b0f4 <net_if_ipv4_select_src_iface+0x2c>)
    b0d8:	42a5      	cmp	r5, r4
    b0da:	bf14      	ite	ne
    b0dc:	461c      	movne	r4, r3
    b0de:	2400      	moveq	r4, #0
}
    b0e0:	4620      	mov	r0, r4
    b0e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		ret = net_if_ipv4_addr_mask_cmp(iface, dst);
    b0e4:	4639      	mov	r1, r7
    b0e6:	4620      	mov	r0, r4
    b0e8:	f008 fd20 	bl	13b2c <net_if_ipv4_addr_mask_cmp>
		if (ret) {
    b0ec:	2800      	cmp	r0, #0
    b0ee:	d1f7      	bne.n	b0e0 <net_if_ipv4_select_src_iface+0x18>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b0f0:	3420      	adds	r4, #32
    b0f2:	e7ee      	b.n	b0d2 <net_if_ipv4_select_src_iface+0xa>
    b0f4:	20011e40 	.word	0x20011e40
    b0f8:	20011e60 	.word	0x20011e60

0000b0fc <net_if_ipv4_select_src_addr>:
	return if_ipv4_get_addr(iface, addr_state, false);
}

const struct in_addr *net_if_ipv4_select_src_addr(struct net_if *dst_iface,
						  const struct in_addr *dst)
{
    b0fc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
#if defined(CONFIG_NET_IPV4)
	struct in_addr *src = NULL;
	u8_t best_match = 0U;
    b100:	2300      	movs	r3, #0
{
    b102:	4605      	mov	r5, r0
	struct net_if *iface;

	if (!net_ipv4_is_ll_addr(dst) && !net_ipv4_is_addr_mcast(dst)) {
    b104:	4608      	mov	r0, r1
{
    b106:	460e      	mov	r6, r1
	u8_t best_match = 0U;
    b108:	f88d 3007 	strb.w	r3, [sp, #7]
	if (!net_ipv4_is_ll_addr(dst) && !net_ipv4_is_addr_mcast(dst)) {
    b10c:	f7ff ff4e 	bl	afac <net_ipv4_is_ll_addr>
    b110:	bba8      	cbnz	r0, b17e <net_if_ipv4_select_src_addr+0x82>
    b112:	4608      	mov	r0, r1
    b114:	f008 fcc0 	bl	13a98 <net_ipv4_is_addr_mcast>
    b118:	bb88      	cbnz	r0, b17e <net_if_ipv4_select_src_addr+0x82>

		for (iface = __net_if_start;
    b11a:	4f1d      	ldr	r7, [pc, #116]	; (b190 <net_if_ipv4_select_src_addr+0x94>)
		     !dst_iface && iface != __net_if_end;
    b11c:	f8df 8074 	ldr.w	r8, [pc, #116]	; b194 <net_if_ipv4_select_src_addr+0x98>
	struct in_addr *src = NULL;
    b120:	4604      	mov	r4, r0
		for (iface = __net_if_start;
    b122:	b185      	cbz	r5, b146 <net_if_ipv4_select_src_addr+0x4a>
			}
		}

		/* If caller has supplied interface, then use that */
		if (dst_iface) {
			src = net_if_ipv4_get_best_match(dst_iface, dst,
    b124:	f10d 0207 	add.w	r2, sp, #7
    b128:	6868      	ldr	r0, [r5, #4]
    b12a:	f7ff ff4b 	bl	afc4 <net_if_ipv4_get_best_match.isra.14>
				break;
			}
		}

		if (dst_iface) {
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
    b12e:	4604      	mov	r4, r0
    b130:	e00b      	b.n	b14a <net_if_ipv4_select_src_addr+0x4e>
			addr = net_if_ipv4_get_best_match(iface, dst,
    b132:	6878      	ldr	r0, [r7, #4]
    b134:	f10d 0207 	add.w	r2, sp, #7
    b138:	4631      	mov	r1, r6
    b13a:	f7ff ff43 	bl	afc4 <net_if_ipv4_get_best_match.isra.14>
		     iface++) {
    b13e:	3720      	adds	r7, #32
			if (addr) {
    b140:	2800      	cmp	r0, #0
    b142:	bf18      	it	ne
    b144:	4604      	movne	r4, r0
		     !dst_iface && iface != __net_if_end;
    b146:	4547      	cmp	r7, r8
    b148:	d1f3      	bne.n	b132 <net_if_ipv4_select_src_addr+0x36>
		}
	}

	if (!src) {
    b14a:	b16c      	cbz	r4, b168 <net_if_ipv4_select_src_addr+0x6c>

	return src;
#else
	return NULL;
#endif
}
    b14c:	4620      	mov	r0, r4
    b14e:	b002      	add	sp, #8
    b150:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			addr = net_if_ipv4_get_ll(iface, NET_ADDR_PREFERRED);
    b154:	2101      	movs	r1, #1
    b156:	4630      	mov	r0, r6
    b158:	f008 fd0d 	bl	13b76 <net_if_ipv4_get_ll>
			if (addr) {
    b15c:	4604      	mov	r4, r0
    b15e:	2800      	cmp	r0, #0
    b160:	d1f4      	bne.n	b14c <net_if_ipv4_select_src_addr+0x50>
		     iface++) {
    b162:	3620      	adds	r6, #32
		     !dst_iface && iface != __net_if_end;
    b164:	42be      	cmp	r6, r7
    b166:	d1f5      	bne.n	b154 <net_if_ipv4_select_src_addr+0x58>
		src = net_if_ipv4_get_global_addr(dst_iface,
    b168:	2101      	movs	r1, #1
    b16a:	4628      	mov	r0, r5
    b16c:	f008 fd06 	bl	13b7c <net_if_ipv4_get_global_addr>
		if (src) {
    b170:	4604      	mov	r4, r0
    b172:	2800      	cmp	r0, #0
    b174:	d1ea      	bne.n	b14c <net_if_ipv4_select_src_addr+0x50>
		return net_ipv4_unspecified_address();
    b176:	f000 fce9 	bl	bb4c <net_ipv4_unspecified_address>
    b17a:	4604      	mov	r4, r0
    b17c:	e7e6      	b.n	b14c <net_if_ipv4_select_src_addr+0x50>
    b17e:	4e04      	ldr	r6, [pc, #16]	; (b190 <net_if_ipv4_select_src_addr+0x94>)
		     !dst_iface && iface != __net_if_end;
    b180:	4f04      	ldr	r7, [pc, #16]	; (b194 <net_if_ipv4_select_src_addr+0x98>)
		for (iface = __net_if_start;
    b182:	2d00      	cmp	r5, #0
    b184:	d0ee      	beq.n	b164 <net_if_ipv4_select_src_addr+0x68>
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
    b186:	2101      	movs	r1, #1
    b188:	4628      	mov	r0, r5
    b18a:	f008 fcf4 	bl	13b76 <net_if_ipv4_get_ll>
    b18e:	e7ce      	b.n	b12e <net_if_ipv4_select_src_addr+0x32>
    b190:	20011e40 	.word	0x20011e40
    b194:	20011e60 	.word	0x20011e60

0000b198 <net_if_ipv4_addr_lookup>:

struct net_if_addr *net_if_ipv4_addr_lookup(const struct in_addr *addr,
					    struct net_if **ret)
{
    b198:	b570      	push	{r4, r5, r6, lr}
#if defined(CONFIG_NET_IPV4)
	struct net_if *iface;

	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b19a:	4a0c      	ldr	r2, [pc, #48]	; (b1cc <net_if_ipv4_addr_lookup+0x34>)
    b19c:	4c0c      	ldr	r4, [pc, #48]	; (b1d0 <net_if_ipv4_addr_lookup+0x38>)
    b19e:	42a2      	cmp	r2, r4
    b1a0:	d101      	bne.n	b1a6 <net_if_ipv4_addr_lookup+0xe>
			}
		}
	}
#endif

	return NULL;
    b1a2:	2000      	movs	r0, #0
    b1a4:	e010      	b.n	b1c8 <net_if_ipv4_addr_lookup+0x30>
		struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
    b1a6:	6853      	ldr	r3, [r2, #4]
		if (!ipv4) {
    b1a8:	b14b      	cbz	r3, b1be <net_if_ipv4_addr_lookup+0x26>
			if (!ipv4->unicast[i].is_used ||
    b1aa:	7a9d      	ldrb	r5, [r3, #10]
    b1ac:	07ad      	lsls	r5, r5, #30
    b1ae:	d506      	bpl.n	b1be <net_if_ipv4_addr_lookup+0x26>
    b1b0:	881d      	ldrh	r5, [r3, #0]
    b1b2:	2d01      	cmp	r5, #1
    b1b4:	d103      	bne.n	b1be <net_if_ipv4_addr_lookup+0x26>
			if (UNALIGNED_GET(&addr->s4_addr32[0]) ==
    b1b6:	6806      	ldr	r6, [r0, #0]
    b1b8:	685d      	ldr	r5, [r3, #4]
    b1ba:	42ae      	cmp	r6, r5
    b1bc:	d001      	beq.n	b1c2 <net_if_ipv4_addr_lookup+0x2a>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b1be:	3220      	adds	r2, #32
    b1c0:	e7ed      	b.n	b19e <net_if_ipv4_addr_lookup+0x6>
				if (ret) {
    b1c2:	b101      	cbz	r1, b1c6 <net_if_ipv4_addr_lookup+0x2e>
					*ret = iface;
    b1c4:	600a      	str	r2, [r1, #0]
				return &ipv4->unicast[i];
    b1c6:	4618      	mov	r0, r3
}
    b1c8:	bd70      	pop	{r4, r5, r6, pc}
    b1ca:	bf00      	nop
    b1cc:	20011e40 	.word	0x20011e40
    b1d0:	20011e60 	.word	0x20011e60

0000b1d4 <net_if_ipv4_addr_add>:

struct net_if_addr *net_if_ipv4_addr_add(struct net_if *iface,
					 struct in_addr *addr,
					 enum net_addr_type addr_type,
					 u32_t vlifetime)
{
    b1d4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    b1d8:	460f      	mov	r7, r1
#if defined(CONFIG_NET_IPV4)
	struct net_if_addr *ifaddr;
	struct net_if_ipv4 *ipv4;
	int i;

	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
    b1da:	a901      	add	r1, sp, #4
{
    b1dc:	4606      	mov	r6, r0
    b1de:	4690      	mov	r8, r2
    b1e0:	461d      	mov	r5, r3
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
    b1e2:	f7ff ff43 	bl	b06c <net_if_config_ipv4_get>
    b1e6:	2800      	cmp	r0, #0
    b1e8:	db0b      	blt.n	b202 <net_if_ipv4_addr_add+0x2e>
		return NULL;
	}

	ifaddr = ipv4_addr_find(iface, addr);
    b1ea:	6874      	ldr	r4, [r6, #4]
		if (!ipv4->unicast[i].is_used) {
    b1ec:	7aa3      	ldrb	r3, [r4, #10]
    b1ee:	079a      	lsls	r2, r3, #30
    b1f0:	d509      	bpl.n	b206 <net_if_ipv4_addr_add+0x32>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
    b1f2:	683a      	ldr	r2, [r7, #0]
    b1f4:	6863      	ldr	r3, [r4, #4]
		if (net_ipv4_addr_cmp(addr,
    b1f6:	429a      	cmp	r2, r3
    b1f8:	d105      	bne.n	b206 <net_if_ipv4_addr_add+0x32>
		return ifaddr;
	}
#endif

	return NULL;
}
    b1fa:	4620      	mov	r0, r4
    b1fc:	b002      	add	sp, #8
    b1fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return NULL;
    b202:	2400      	movs	r4, #0
    b204:	e7f9      	b.n	b1fa <net_if_ipv4_addr_add+0x26>
		if (addr_type == NET_ADDR_DHCP
    b206:	f1b8 0f02 	cmp.w	r8, #2
		struct net_if_addr *cur = &ipv4->unicast[i];
    b20a:	9c01      	ldr	r4, [sp, #4]
		if (addr_type == NET_ADDR_DHCP
    b20c:	d102      	bne.n	b214 <net_if_ipv4_addr_add+0x40>
		    && cur->addr_type == NET_ADDR_OVERRIDABLE) {
    b20e:	7a23      	ldrb	r3, [r4, #8]
    b210:	2b04      	cmp	r3, #4
    b212:	d002      	beq.n	b21a <net_if_ipv4_addr_add+0x46>
		if (!ipv4->unicast[i].is_used) {
    b214:	7aa3      	ldrb	r3, [r4, #10]
    b216:	079b      	lsls	r3, r3, #30
    b218:	d4f3      	bmi.n	b202 <net_if_ipv4_addr_add+0x2e>
	if (ifaddr) {
    b21a:	2c00      	cmp	r4, #0
    b21c:	d0ed      	beq.n	b1fa <net_if_ipv4_addr_add+0x26>
		ifaddr->is_used = true;
    b21e:	7aa3      	ldrb	r3, [r4, #10]
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
    b220:	480b      	ldr	r0, [pc, #44]	; (b250 <net_if_ipv4_addr_add+0x7c>)
		ifaddr->address.family = AF_INET;
    b222:	2201      	movs	r2, #1
		ifaddr->is_used = true;
    b224:	f043 0302 	orr.w	r3, r3, #2
    b228:	72a3      	strb	r3, [r4, #10]
		ifaddr->address.family = AF_INET;
    b22a:	8022      	strh	r2, [r4, #0]
						addr->s4_addr32[0];
    b22c:	683b      	ldr	r3, [r7, #0]
    b22e:	7aa1      	ldrb	r1, [r4, #10]
		ifaddr->address.in_addr.s4_addr32[0] =
    b230:	6063      	str	r3, [r4, #4]
		if (vlifetime) {
    b232:	fab5 f385 	clz	r3, r5
    b236:	095b      	lsrs	r3, r3, #5
    b238:	f363 0100 	bfi	r1, r3, #0, #1
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
    b23c:	2304      	movs	r3, #4
    b23e:	72a1      	strb	r1, [r4, #10]
		ifaddr->addr_state = NET_ADDR_PREFERRED;
    b240:	7262      	strb	r2, [r4, #9]
		ifaddr->addr_type = addr_type;
    b242:	f884 8008 	strb.w	r8, [r4, #8]
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
    b246:	18e2      	adds	r2, r4, r3
    b248:	4631      	mov	r1, r6
    b24a:	f000 fdcb 	bl	bde4 <net_mgmt_event_notify_with_info>
		return ifaddr;
    b24e:	e7d4      	b.n	b1fa <net_if_ipv4_addr_add+0x26>
    b250:	f0040001 	.word	0xf0040001

0000b254 <net_if_ipv4_maddr_lookup>:
	return false;
}

struct net_if_mcast_addr *net_if_ipv4_maddr_lookup(const struct in_addr *maddr,
						   struct net_if **ret)
{
    b254:	b570      	push	{r4, r5, r6, lr}
#if defined(CONFIG_NET_IPV4)
	struct net_if_mcast_addr *addr;
	struct net_if *iface;

	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b256:	4a0e      	ldr	r2, [pc, #56]	; (b290 <net_if_ipv4_maddr_lookup+0x3c>)
    b258:	4c0e      	ldr	r4, [pc, #56]	; (b294 <net_if_ipv4_maddr_lookup+0x40>)
    b25a:	42a2      	cmp	r2, r4
    b25c:	d101      	bne.n	b262 <net_if_ipv4_maddr_lookup+0xe>
			return addr;
		}
	}
#endif

	return NULL;
    b25e:	2000      	movs	r0, #0
    b260:	e00d      	b.n	b27e <net_if_ipv4_maddr_lookup+0x2a>
		if (ret && *ret && iface != *ret) {
    b262:	b119      	cbz	r1, b26c <net_if_ipv4_maddr_lookup+0x18>
    b264:	680b      	ldr	r3, [r1, #0]
    b266:	b10b      	cbz	r3, b26c <net_if_ipv4_maddr_lookup+0x18>
    b268:	4293      	cmp	r3, r2
    b26a:	d10d      	bne.n	b288 <net_if_ipv4_maddr_lookup+0x34>
		addr = ipv4_maddr_find(iface, true, maddr);
    b26c:	6853      	ldr	r3, [r2, #4]
	if (!ipv4) {
    b26e:	b15b      	cbz	r3, b288 <net_if_ipv4_maddr_lookup+0x34>
		if ((is_used && !ipv4->mcast[i].is_used) ||
    b270:	7d1d      	ldrb	r5, [r3, #20]
    b272:	07ed      	lsls	r5, r5, #31
    b274:	d508      	bpl.n	b288 <net_if_ipv4_maddr_lookup+0x34>
		if (addr) {
    b276:	b918      	cbnz	r0, b280 <net_if_ipv4_maddr_lookup+0x2c>
		return &ipv4->mcast[i];
    b278:	f103 000c 	add.w	r0, r3, #12
			if (ret) {
    b27c:	b931      	cbnz	r1, b28c <net_if_ipv4_maddr_lookup+0x38>
}
    b27e:	bd70      	pop	{r4, r5, r6, pc}
    b280:	691e      	ldr	r6, [r3, #16]
    b282:	6805      	ldr	r5, [r0, #0]
			if (!net_ipv4_addr_cmp(&ipv4->mcast[i].address.in_addr,
    b284:	42ae      	cmp	r6, r5
    b286:	d0f7      	beq.n	b278 <net_if_ipv4_maddr_lookup+0x24>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b288:	3220      	adds	r2, #32
    b28a:	e7e6      	b.n	b25a <net_if_ipv4_maddr_lookup+0x6>
				*ret = iface;
    b28c:	600a      	str	r2, [r1, #0]
    b28e:	e7f6      	b.n	b27e <net_if_ipv4_maddr_lookup+0x2a>
    b290:	20011e40 	.word	0x20011e40
    b294:	20011e60 	.word	0x20011e60

0000b298 <net_if_call_link_cb>:
	sys_slist_find_and_remove(&link_callbacks, &link->node);
}

void net_if_call_link_cb(struct net_if *iface, struct net_linkaddr *lladdr,
			 int status)
{
    b298:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct net_if_link_cb *link, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    b29a:	4b08      	ldr	r3, [pc, #32]	; (b2bc <net_if_call_link_cb+0x24>)
    b29c:	681b      	ldr	r3, [r3, #0]
{
    b29e:	4605      	mov	r5, r0
    b2a0:	460e      	mov	r6, r1
    b2a2:	4617      	mov	r7, r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    b2a4:	b14b      	cbz	r3, b2ba <net_if_call_link_cb+0x22>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    b2a6:	681c      	ldr	r4, [r3, #0]
		link->cb(iface, lladdr, status);
    b2a8:	685b      	ldr	r3, [r3, #4]
    b2aa:	463a      	mov	r2, r7
    b2ac:	4631      	mov	r1, r6
    b2ae:	4628      	mov	r0, r5
    b2b0:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
    b2b2:	b114      	cbz	r4, b2ba <net_if_call_link_cb+0x22>
    b2b4:	4623      	mov	r3, r4
    b2b6:	6824      	ldr	r4, [r4, #0]
    b2b8:	e7f6      	b.n	b2a8 <net_if_call_link_cb+0x10>
	}
}
    b2ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b2bc:	20003d1c 	.word	0x20003d1c

0000b2c0 <process_tx_packet>:
{
    b2c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!pkt) {
    b2c4:	f1b0 0804 	subs.w	r8, r0, #4
{
    b2c8:	4604      	mov	r4, r0
	if (!pkt) {
    b2ca:	d044      	beq.n	b356 <process_tx_packet+0x96>
	context = net_pkt_context(pkt);
    b2cc:	e9d0 7507 	ldrd	r7, r5, [r0, #28]
	if (atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    b2d0:	6828      	ldr	r0, [r5, #0]
    b2d2:	2100      	movs	r1, #0
    b2d4:	300c      	adds	r0, #12
    b2d6:	f008 fc11 	bl	13afc <atomic_test_bit>
    b2da:	b350      	cbz	r0, b332 <process_tx_packet+0x72>
	return pkt->family;
    b2dc:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
		if (IS_ENABLED(CONFIG_NET_TCP) &&
    b2e0:	f013 0f0e 	tst.w	r3, #14
    b2e4:	d00b      	beq.n	b2fe <process_tx_packet+0x3e>
	pkt->sent_or_eof = sent;
    b2e6:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
    b2ea:	f043 0302 	orr.w	r3, r3, #2
    b2ee:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	pkt->pkt_queued = send;
    b2f2:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
    b2f6:	f36f 0300 	bfc	r3, #0, #1
    b2fa:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
	return iface->if_dev->l2;
    b2fe:	682b      	ldr	r3, [r5, #0]
		status = net_if_l2(iface)->send(iface, pkt);
    b300:	685b      	ldr	r3, [r3, #4]
    b302:	4641      	mov	r1, r8
    b304:	685b      	ldr	r3, [r3, #4]
    b306:	4628      	mov	r0, r5
    b308:	4798      	blx	r3
	if (status < 0) {
    b30a:	1e06      	subs	r6, r0, #0
    b30c:	da02      	bge.n	b314 <process_tx_packet+0x54>
		net_pkt_unref(pkt);
    b30e:	4640      	mov	r0, r8
    b310:	f008 fd21 	bl	13d56 <net_pkt_unref>
	if (context) {
    b314:	b11f      	cbz	r7, b31e <process_tx_packet+0x5e>
		net_context_send_cb(context, status);
    b316:	4631      	mov	r1, r6
    b318:	4638      	mov	r0, r7
    b31a:	f008 fbc6 	bl	13aaa <net_context_send_cb>
	if (dst->addr) {
    b31e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    b320:	b1cb      	cbz	r3, b356 <process_tx_packet+0x96>
		net_if_call_link_cb(iface, dst, status);
    b322:	4632      	mov	r2, r6
    b324:	f104 0130 	add.w	r1, r4, #48	; 0x30
    b328:	4628      	mov	r0, r5
}
    b32a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		net_if_call_link_cb(iface, dst, status);
    b32e:	f7ff bfb3 	b.w	b298 <net_if_call_link_cb>
		NET_WARN("iface %p is down", iface);
    b332:	2302      	movs	r3, #2
    b334:	f04f 0200 	mov.w	r2, #0
    b338:	f363 0207 	bfi	r2, r3, #0, #8
    b33c:	4907      	ldr	r1, [pc, #28]	; (b35c <process_tx_packet+0x9c>)
    b33e:	4b08      	ldr	r3, [pc, #32]	; (b360 <process_tx_packet+0xa0>)
    b340:	4808      	ldr	r0, [pc, #32]	; (b364 <process_tx_packet+0xa4>)
    b342:	1a5b      	subs	r3, r3, r1
    b344:	08db      	lsrs	r3, r3, #3
    b346:	f363 128f 	bfi	r2, r3, #6, #10
    b34a:	4629      	mov	r1, r5
    b34c:	f006 fe1f 	bl	11f8e <log_1>
		status = -ENETDOWN;
    b350:	f06f 0672 	mvn.w	r6, #114	; 0x72
    b354:	e7db      	b.n	b30e <process_tx_packet+0x4e>
}
    b356:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b35a:	bf00      	nop
    b35c:	00016344 	.word	0x00016344
    b360:	0001639c 	.word	0x0001639c
    b364:	00018956 	.word	0x00018956

0000b368 <net_if_send_data>:
{
    b368:	b570      	push	{r4, r5, r6, lr}
    b36a:	4605      	mov	r5, r0
	if (!atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    b36c:	6800      	ldr	r0, [r0, #0]
	struct net_context *context = net_pkt_context(pkt);
    b36e:	6a0e      	ldr	r6, [r1, #32]
{
    b370:	460c      	mov	r4, r1
	if (!atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    b372:	300c      	adds	r0, #12
    b374:	2100      	movs	r1, #0
    b376:	f008 fbc1 	bl	13afc <atomic_test_bit>
    b37a:	b9d0      	cbnz	r0, b3b2 <net_if_send_data+0x4a>
		NET_WARN("iface %p is down", iface);
    b37c:	2302      	movs	r3, #2
    b37e:	f04f 0200 	mov.w	r2, #0
    b382:	f363 0207 	bfi	r2, r3, #0, #8
    b386:	4918      	ldr	r1, [pc, #96]	; (b3e8 <net_if_send_data+0x80>)
    b388:	4b18      	ldr	r3, [pc, #96]	; (b3ec <net_if_send_data+0x84>)
    b38a:	4819      	ldr	r0, [pc, #100]	; (b3f0 <net_if_send_data+0x88>)
    b38c:	1a5b      	subs	r3, r3, r1
    b38e:	08db      	lsrs	r3, r3, #3
    b390:	f363 128f 	bfi	r2, r3, #6, #10
    b394:	4629      	mov	r1, r5
    b396:	f006 fdfa 	bl	11f8e <log_1>
		if (context) {
    b39a:	b9fe      	cbnz	r6, b3dc <net_if_send_data+0x74>
		if (dst->addr) {
    b39c:	6b63      	ldr	r3, [r4, #52]	; 0x34
    b39e:	b133      	cbz	r3, b3ae <net_if_send_data+0x46>
			net_if_call_link_cb(iface, dst, status);
    b3a0:	f06f 0272 	mvn.w	r2, #114	; 0x72
    b3a4:	f104 0134 	add.w	r1, r4, #52	; 0x34
    b3a8:	4628      	mov	r0, r5
    b3aa:	f7ff ff75 	bl	b298 <net_if_call_link_cb>
		verdict = NET_DROP;
    b3ae:	2002      	movs	r0, #2
    b3b0:	e013      	b.n	b3da <net_if_send_data+0x72>
	if (!atomic_test_bit(iface->if_dev->flags, NET_IF_POINTOPOINT) &&
    b3b2:	6828      	ldr	r0, [r5, #0]
    b3b4:	2101      	movs	r1, #1
    b3b6:	300c      	adds	r0, #12
    b3b8:	f008 fba0 	bl	13afc <atomic_test_bit>
    b3bc:	b940      	cbnz	r0, b3d0 <net_if_send_data+0x68>
    b3be:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    b3c0:	b933      	cbnz	r3, b3d0 <net_if_send_data+0x68>
	return net_if_get_link_addr(pkt->iface);
    b3c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    b3c4:	681b      	ldr	r3, [r3, #0]
		net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
    b3c6:	691a      	ldr	r2, [r3, #16]
    b3c8:	62e2      	str	r2, [r4, #44]	; 0x2c
		net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
    b3ca:	7d1b      	ldrb	r3, [r3, #20]
    b3cc:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
		net_if_queue_tx(iface, pkt);
    b3d0:	4628      	mov	r0, r5
    b3d2:	4621      	mov	r1, r4
    b3d4:	f7ff fe2e 	bl	b034 <net_if_queue_tx>
    b3d8:	2000      	movs	r0, #0
}
    b3da:	bd70      	pop	{r4, r5, r6, pc}
			net_context_send_cb(context, status);
    b3dc:	f06f 0172 	mvn.w	r1, #114	; 0x72
    b3e0:	4630      	mov	r0, r6
    b3e2:	f008 fb62 	bl	13aaa <net_context_send_cb>
    b3e6:	e7d9      	b.n	b39c <net_if_send_data+0x34>
    b3e8:	00016344 	.word	0x00016344
    b3ec:	0001639c 	.word	0x0001639c
    b3f0:	00018956 	.word	0x00018956

0000b3f4 <net_if_need_calc_tx_checksum>:
    b3f4:	6803      	ldr	r3, [r0, #0]

static bool need_calc_checksum(struct net_if *iface, enum ethernet_hw_caps caps)
{
#if defined(CONFIG_NET_L2_ETHERNET)
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
    b3f6:	685a      	ldr	r2, [r3, #4]
    b3f8:	4b03      	ldr	r3, [pc, #12]	; (b408 <net_if_need_calc_tx_checksum+0x14>)
    b3fa:	429a      	cmp	r2, r3
    b3fc:	d102      	bne.n	b404 <net_if_need_calc_tx_checksum+0x10>
    b3fe:	2101      	movs	r1, #1
    b400:	f008 bb85 	b.w	13b0e <need_calc_checksum.part.17>
}

bool net_if_need_calc_tx_checksum(struct net_if *iface)
{
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
}
    b404:	2001      	movs	r0, #1
    b406:	4770      	bx	lr
    b408:	00016334 	.word	0x00016334

0000b40c <net_if_need_calc_rx_checksum>:
    b40c:	6803      	ldr	r3, [r0, #0]
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
    b40e:	685a      	ldr	r2, [r3, #4]
    b410:	4b03      	ldr	r3, [pc, #12]	; (b420 <net_if_need_calc_rx_checksum+0x14>)
    b412:	429a      	cmp	r2, r3
    b414:	d102      	bne.n	b41c <net_if_need_calc_rx_checksum+0x10>
    b416:	2102      	movs	r1, #2
    b418:	f008 bb79 	b.w	13b0e <need_calc_checksum.part.17>

bool net_if_need_calc_rx_checksum(struct net_if *iface)
{
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
}
    b41c:	2001      	movs	r0, #1
    b41e:	4770      	bx	lr
    b420:	00016334 	.word	0x00016334

0000b424 <net_if_get_by_index>:

struct net_if *net_if_get_by_index(int index)
{
	if (index <= 0) {
    b424:	2800      	cmp	r0, #0
    b426:	dd08      	ble.n	b43a <net_if_get_by_index+0x16>
		return NULL;
	}

	if (&__net_if_start[index - 1] >= __net_if_end) {
    b428:	1e43      	subs	r3, r0, #1
    b42a:	4805      	ldr	r0, [pc, #20]	; (b440 <net_if_get_by_index+0x1c>)
    b42c:	eb00 1043 	add.w	r0, r0, r3, lsl #5
		return NULL;
    b430:	4b04      	ldr	r3, [pc, #16]	; (b444 <net_if_get_by_index+0x20>)
    b432:	4298      	cmp	r0, r3
    b434:	bf28      	it	cs
    b436:	2000      	movcs	r0, #0
    b438:	4770      	bx	lr
    b43a:	2000      	movs	r0, #0
		NET_DBG("Index %d is too large", index);
		return NULL;
	}

	return &__net_if_start[index - 1];
}
    b43c:	4770      	bx	lr
    b43e:	bf00      	nop
    b440:	20011e40 	.word	0x20011e40
    b444:	20011e60 	.word	0x20011e60

0000b448 <net_if_get_by_iface>:

int net_if_get_by_iface(struct net_if *iface)
{
	if (!(iface >= __net_if_start && iface < __net_if_end)) {
    b448:	4b06      	ldr	r3, [pc, #24]	; (b464 <net_if_get_by_iface+0x1c>)
    b44a:	4298      	cmp	r0, r3
    b44c:	d306      	bcc.n	b45c <net_if_get_by_iface+0x14>
    b44e:	4a06      	ldr	r2, [pc, #24]	; (b468 <net_if_get_by_iface+0x20>)
    b450:	4290      	cmp	r0, r2
    b452:	d203      	bcs.n	b45c <net_if_get_by_iface+0x14>
		return -1;
	}

	return (iface - __net_if_start) + 1;
    b454:	1ac0      	subs	r0, r0, r3
    b456:	1140      	asrs	r0, r0, #5
    b458:	3001      	adds	r0, #1
    b45a:	4770      	bx	lr
		return -1;
    b45c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    b460:	4770      	bx	lr
    b462:	bf00      	nop
    b464:	20011e40 	.word	0x20011e40
    b468:	20011e60 	.word	0x20011e60

0000b46c <net_if_up>:
		cb(iface, user_data);
	}
}

int net_if_up(struct net_if *iface)
{
    b46c:	b510      	push	{r4, lr}
    b46e:	4604      	mov	r4, r0
	int status;

	NET_DBG("iface %p", iface);

	if (atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    b470:	6800      	ldr	r0, [r0, #0]
    b472:	2100      	movs	r1, #0
    b474:	300c      	adds	r0, #12
    b476:	f008 fb41 	bl	13afc <atomic_test_bit>
    b47a:	b9b8      	cbnz	r0, b4ac <net_if_up+0x40>
    b47c:	6823      	ldr	r3, [r4, #0]
		goto done;
	}
#endif

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface)->enable) {
    b47e:	685b      	ldr	r3, [r3, #4]
    b480:	689b      	ldr	r3, [r3, #8]
    b482:	b9ab      	cbnz	r3, b4b0 <net_if_up+0x44>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    b484:	6823      	ldr	r3, [r4, #0]
    b486:	f3bf 8f5b 	dmb	ish
    b48a:	330c      	adds	r3, #12
    b48c:	e853 2f00 	ldrex	r2, [r3]
    b490:	f042 0201 	orr.w	r2, r2, #1
    b494:	e843 2100 	strex	r1, r2, [r3]
    b498:	2900      	cmp	r1, #0
    b49a:	d1f7      	bne.n	b48c <net_if_up+0x20>
    b49c:	f3bf 8f5b 	dmb	ish
void net_mgmt_event_notify_with_info(u32_t mgmt_event, struct net_if *iface,
				     void *info, size_t length);

static inline void net_mgmt_event_notify(u32_t mgmt_event, struct net_if *iface)
{
	net_mgmt_event_notify_with_info(mgmt_event, iface, NULL, 0);
    b4a0:	2300      	movs	r3, #0
    b4a2:	461a      	mov	r2, r3
    b4a4:	4621      	mov	r1, r4
    b4a6:	4805      	ldr	r0, [pc, #20]	; (b4bc <net_if_up+0x50>)
    b4a8:	f000 fc9c 	bl	bde4 <net_mgmt_event_notify_with_info>
		return 0;
    b4ac:	2000      	movs	r0, #0
    b4ae:	e004      	b.n	b4ba <net_if_up+0x4e>
		goto done;
	}

	/* Notify L2 to enable the interface */
	status = net_if_l2(iface)->enable(iface, true);
    b4b0:	2101      	movs	r1, #1
    b4b2:	4620      	mov	r0, r4
    b4b4:	4798      	blx	r3
	if (status < 0) {
    b4b6:	2800      	cmp	r0, #0
    b4b8:	dae4      	bge.n	b484 <net_if_up+0x18>
#endif

	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);

	return 0;
}
    b4ba:	bd10      	pop	{r4, pc}
    b4bc:	d0010002 	.word	0xd0010002

0000b4c0 <net_if_down>:
    b4c0:	6803      	ldr	r3, [r0, #0]
		goto done;
	}
#endif

	/* If the L2 does not support enable just clear the flag */
	if (!net_if_l2(iface)->enable) {
    b4c2:	685b      	ldr	r3, [r3, #4]
    b4c4:	689b      	ldr	r3, [r3, #8]
{
    b4c6:	b510      	push	{r4, lr}
    b4c8:	4604      	mov	r4, r0
	if (!net_if_l2(iface)->enable) {
    b4ca:	b9ab      	cbnz	r3, b4f8 <net_if_down+0x38>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    b4cc:	6823      	ldr	r3, [r4, #0]
    b4ce:	f3bf 8f5b 	dmb	ish
    b4d2:	330c      	adds	r3, #12
    b4d4:	e853 2f00 	ldrex	r2, [r3]
    b4d8:	f022 0201 	bic.w	r2, r2, #1
    b4dc:	e843 2100 	strex	r1, r2, [r3]
    b4e0:	2900      	cmp	r1, #0
    b4e2:	d1f7      	bne.n	b4d4 <net_if_down+0x14>
    b4e4:	f3bf 8f5b 	dmb	ish
    b4e8:	2300      	movs	r3, #0
    b4ea:	4806      	ldr	r0, [pc, #24]	; (b504 <net_if_down+0x44>)
    b4ec:	461a      	mov	r2, r3
    b4ee:	4621      	mov	r1, r4
    b4f0:	f000 fc78 	bl	bde4 <net_mgmt_event_notify_with_info>
done:
	atomic_clear_bit(iface->if_dev->flags, NET_IF_UP);

	net_mgmt_event_notify(NET_EVENT_IF_DOWN, iface);

	return 0;
    b4f4:	2000      	movs	r0, #0
}
    b4f6:	bd10      	pop	{r4, pc}
	status = net_if_l2(iface)->enable(iface, false);
    b4f8:	2100      	movs	r1, #0
    b4fa:	4798      	blx	r3
	if (status < 0) {
    b4fc:	2800      	cmp	r0, #0
    b4fe:	dae5      	bge.n	b4cc <net_if_down+0xc>
    b500:	e7f9      	b.n	b4f6 <net_if_down+0x36>
    b502:	bf00      	nop
    b504:	d0010001 	.word	0xd0010001

0000b508 <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP */

void net_if_init(void)
{
    b508:	b570      	push	{r4, r5, r6, lr}
	int i;
#endif

	NET_DBG("");

	net_tc_tx_init();
    b50a:	f000 f99f 	bl	b84c <net_tc_tx_init>
#if defined(CONFIG_NET_IPV6)
	k_delayed_work_init(&address_lifetime_timer, address_lifetime_timeout);
	k_delayed_work_init(&prefix_lifetime_timer, prefix_lifetime_timeout);
#endif

	for (iface = __net_if_start, if_count = 0; iface != __net_if_end;
    b50e:	4c21      	ldr	r4, [pc, #132]	; (b594 <net_if_init+0x8c>)
    b510:	4e21      	ldr	r6, [pc, #132]	; (b598 <net_if_init+0x90>)
    b512:	4625      	mov	r5, r4
    b514:	42b4      	cmp	r4, r6
    b516:	d114      	bne.n	b542 <net_if_init+0x3a>
    b518:	1b62      	subs	r2, r4, r5
	     iface++, if_count++) {
		init_iface(iface);
	}

	if (iface == __net_if_start) {
    b51a:	42ac      	cmp	r4, r5
    b51c:	ea4f 1252 	mov.w	r2, r2, lsr #5
    b520:	d117      	bne.n	b552 <net_if_init+0x4a>
		NET_ERR("There is no network interface to work with!");
    b522:	2301      	movs	r3, #1
    b524:	f04f 0100 	mov.w	r1, #0
    b528:	f363 0107 	bfi	r1, r3, #0, #8
    b52c:	4a1b      	ldr	r2, [pc, #108]	; (b59c <net_if_init+0x94>)
    b52e:	4b1c      	ldr	r3, [pc, #112]	; (b5a0 <net_if_init+0x98>)
    b530:	481c      	ldr	r0, [pc, #112]	; (b5a4 <net_if_init+0x9c>)
    b532:	1a9b      	subs	r3, r3, r2
    b534:	08db      	lsrs	r3, r3, #3
    b536:	f363 118f 	bfi	r1, r3, #6, #10
		NET_WARN("You have configured only %d VLAN interfaces"
			 " but you have %d network interfaces.",
			 CONFIG_NET_VLAN_COUNT, if_count);
	}
#endif
}
    b53a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		NET_ERR("There is no network interface to work with!");
    b53e:	f006 bd19 	b.w	11f74 <log_0>
	return iface->if_dev->dev;
    b542:	6823      	ldr	r3, [r4, #0]
	const struct net_if_api *api = net_if_get_device(iface)->driver_api;
    b544:	681b      	ldr	r3, [r3, #0]
	api->init(iface);
    b546:	685b      	ldr	r3, [r3, #4]
    b548:	4620      	mov	r0, r4
    b54a:	681b      	ldr	r3, [r3, #0]
    b54c:	4798      	blx	r3
	     iface++, if_count++) {
    b54e:	3420      	adds	r4, #32
    b550:	e7e0      	b.n	b514 <net_if_init+0xc>
	if (if_count > ARRAY_SIZE(ipv4_addresses)) {
    b552:	2a01      	cmp	r2, #1
    b554:	dd19      	ble.n	b58a <net_if_init+0x82>
		NET_WARN("You have %lu IPv4 net_if addresses but %d "
    b556:	2102      	movs	r1, #2
    b558:	f04f 0300 	mov.w	r3, #0
    b55c:	f361 0307 	bfi	r3, r1, #0, #8
    b560:	4c0f      	ldr	r4, [pc, #60]	; (b5a0 <net_if_init+0x98>)
    b562:	490e      	ldr	r1, [pc, #56]	; (b59c <net_if_init+0x94>)
    b564:	4810      	ldr	r0, [pc, #64]	; (b5a8 <net_if_init+0xa0>)
    b566:	1a64      	subs	r4, r4, r1
    b568:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    b56c:	f364 138f 	bfi	r3, r4, #6, #10
    b570:	2101      	movs	r1, #1
    b572:	f006 fd20 	bl	11fb6 <log_2>
		NET_WARN("Consider increasing CONFIG_NET_IF_MAX_IPV4_COUNT "
    b576:	f04f 0100 	mov.w	r1, #0
    b57a:	2302      	movs	r3, #2
    b57c:	f363 0107 	bfi	r1, r3, #0, #8
    b580:	f364 118f 	bfi	r1, r4, #6, #10
    b584:	4809      	ldr	r0, [pc, #36]	; (b5ac <net_if_init+0xa4>)
    b586:	f006 fcf5 	bl	11f74 <log_0>
		ipv4_addresses[i].ipv4.ttl = CONFIG_NET_INITIAL_TTL;
    b58a:	4b09      	ldr	r3, [pc, #36]	; (b5b0 <net_if_init+0xa8>)
    b58c:	2240      	movs	r2, #64	; 0x40
    b58e:	f883 2020 	strb.w	r2, [r3, #32]
}
    b592:	bd70      	pop	{r4, r5, r6, pc}
    b594:	20011e40 	.word	0x20011e40
    b598:	20011e60 	.word	0x20011e60
    b59c:	00016344 	.word	0x00016344
    b5a0:	0001639c 	.word	0x0001639c
    b5a4:	000188b5 	.word	0x000188b5
    b5a8:	000188e1 	.word	0x000188e1
    b5ac:	0001891e 	.word	0x0001891e
    b5b0:	20003cf4 	.word	0x20003cf4

0000b5b4 <net_if_post_init>:

void net_if_post_init(void)
{
    b5b4:	b538      	push	{r3, r4, r5, lr}
	struct net_if *iface;

	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b5b6:	4c05      	ldr	r4, [pc, #20]	; (b5cc <net_if_post_init+0x18>)
    b5b8:	4d05      	ldr	r5, [pc, #20]	; (b5d0 <net_if_post_init+0x1c>)
    b5ba:	42ac      	cmp	r4, r5
    b5bc:	d100      	bne.n	b5c0 <net_if_post_init+0xc>
		net_if_up(iface);
	}
}
    b5be:	bd38      	pop	{r3, r4, r5, pc}
		net_if_up(iface);
    b5c0:	4620      	mov	r0, r4
    b5c2:	f7ff ff53 	bl	b46c <net_if_up>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    b5c6:	3420      	adds	r4, #32
    b5c8:	e7f7      	b.n	b5ba <net_if_post_init+0x6>
    b5ca:	bf00      	nop
    b5cc:	20011e40 	.word	0x20011e40
    b5d0:	20011e60 	.word	0x20011e60

0000b5d4 <net_pkt_get_reserve_rx_data>:

#else /* NET_LOG_LEVEL >= LOG_LEVEL_DBG */

struct net_buf *net_pkt_get_reserve_rx_data(s32_t timeout)
{
	return net_pkt_get_reserve_data(&rx_bufs, timeout);
    b5d4:	4601      	mov	r1, r0
    b5d6:	4801      	ldr	r0, [pc, #4]	; (b5dc <net_pkt_get_reserve_rx_data+0x8>)
    b5d8:	f008 bb8f 	b.w	13cfa <net_pkt_get_reserve_data>
    b5dc:	20011dfc 	.word	0x20011dfc

0000b5e0 <net_pkt_get_reserve_tx_data>:
}

struct net_buf *net_pkt_get_reserve_tx_data(s32_t timeout)
{
	return net_pkt_get_reserve_data(&tx_bufs, timeout);
    b5e0:	4601      	mov	r1, r0
    b5e2:	4801      	ldr	r0, [pc, #4]	; (b5e8 <net_pkt_get_reserve_tx_data+0x8>)
    b5e4:	f008 bb89 	b.w	13cfa <net_pkt_get_reserve_data>
    b5e8:	20011e1c 	.word	0x20011e1c

0000b5ec <net_pkt_get_frag>:
	if (pkt->slab == &rx_pkts) {
    b5ec:	6902      	ldr	r2, [r0, #16]
    b5ee:	4b04      	ldr	r3, [pc, #16]	; (b600 <net_pkt_get_frag+0x14>)
    b5f0:	429a      	cmp	r2, r3
		return net_pkt_get_reserve_rx_data(timeout);
    b5f2:	4608      	mov	r0, r1
	if (pkt->slab == &rx_pkts) {
    b5f4:	d101      	bne.n	b5fa <net_pkt_get_frag+0xe>
		return net_pkt_get_reserve_rx_data(timeout);
    b5f6:	f7ff bfed 	b.w	b5d4 <net_pkt_get_reserve_rx_data>
	return net_pkt_get_reserve_tx_data(timeout);
    b5fa:	f7ff bff1 	b.w	b5e0 <net_pkt_get_reserve_tx_data>
    b5fe:	bf00      	nop
    b600:	20011d04 	.word	0x20011d04

0000b604 <net_pkt_alloc_buffer>:
int net_pkt_alloc_buffer(struct net_pkt *pkt,
			 size_t size,
			 enum net_ip_protocol proto,
			 s32_t timeout)
#endif
{
    b604:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b608:	4606      	mov	r6, r0
    b60a:	460c      	mov	r4, r1
    b60c:	4690      	mov	r8, r2
    b60e:	461d      	mov	r5, r3
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
    b610:	f00a fcc2 	bl	15f98 <z_impl_k_uptime_get>
    b614:	4607      	mov	r7, r0
	struct net_buf_pool *pool = NULL;
	size_t alloc_len = 0;
	size_t hdr_len = 0;
	struct net_buf *buf;

	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
    b616:	b944      	cbnz	r4, b62a <net_pkt_alloc_buffer+0x26>
    b618:	f1b8 0f00 	cmp.w	r8, #0
    b61c:	d105      	bne.n	b62a <net_pkt_alloc_buffer+0x26>
	return pkt->family;
    b61e:	f896 0043 	ldrb.w	r0, [r6, #67]	; 0x43
    b622:	f3c0 0042 	ubfx	r0, r0, #1, #3
    b626:	2800      	cmp	r0, #0
    b628:	d07b      	beq.n	b722 <net_pkt_alloc_buffer+0x11e>
		return 0;
	}

	if (k_is_in_isr()) {
    b62a:	f004 f855 	bl	f6d8 <k_is_in_isr>
		timeout = K_NO_WAIT;
    b62e:	2800      	cmp	r0, #0
	}

	/* Verifying existing buffer and take into account free space there */
	alloc_len = pkt_get_size(pkt) - net_pkt_get_len(pkt);
    b630:	6970      	ldr	r0, [r6, #20]
		timeout = K_NO_WAIT;
    b632:	bf18      	it	ne
    b634:	2500      	movne	r5, #0
	struct net_buf *buf = pkt->buffer;
    b636:	4681      	mov	r9, r0
	size_t size = 0;
    b638:	f04f 0a00 	mov.w	sl, #0
	while (buf) {
    b63c:	f1b9 0f00 	cmp.w	r9, #0
    b640:	d144      	bne.n	b6cc <net_pkt_alloc_buffer+0xc8>
	return net_buf_frags_len(pkt->frags);
    b642:	f008 faa2 	bl	13b8a <net_buf_frags_len>
    b646:	f896 b043 	ldrb.w	fp, [r6, #67]	; 0x43
	if (!alloc_len) {
    b64a:	4550      	cmp	r0, sl
    b64c:	4603      	mov	r3, r0
    b64e:	f3cb 0b42 	ubfx	fp, fp, #1, #3
    b652:	d141      	bne.n	b6d8 <net_pkt_alloc_buffer+0xd4>
		/* In case of no free space, it will account for header
		 * space estimation
		 */
		hdr_len = pkt_estimate_headers_length(pkt,
    b654:	fa1f f08b 	uxth.w	r0, fp
	if (family == AF_UNSPEC) {
    b658:	2800      	cmp	r0, #0
    b65a:	d03d      	beq.n	b6d8 <net_pkt_alloc_buffer+0xd4>
    b65c:	4641      	mov	r1, r8
    b65e:	f008 fada 	bl	13c16 <pkt_estimate_headers_length.isra.18.part.19>
	if (net_pkt_iface(pkt)) {
    b662:	6a71      	ldr	r1, [r6, #36]	; 0x24
						      net_pkt_family(pkt),
						      proto);
	}

	/* Calculate the maximum that can be allocated depending on size */
	alloc_len = pkt_buffer_length(pkt, size + hdr_len, proto, alloc_len);
    b664:	4420      	add	r0, r4
	if (net_pkt_iface(pkt)) {
    b666:	2900      	cmp	r1, #0
    b668:	d038      	beq.n	b6dc <net_pkt_alloc_buffer+0xd8>
 *
 * @return the MTU
 */
static inline u16_t net_if_get_mtu(struct net_if *iface)
{
	return iface->if_dev->mtu;
    b66a:	680a      	ldr	r2, [r1, #0]
		max_len = net_if_get_mtu(net_pkt_iface(pkt));
    b66c:	8b12      	ldrh	r2, [r2, #24]
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
    b66e:	f1bb 0f01 	cmp.w	fp, #1
    b672:	d135      	bne.n	b6e0 <net_pkt_alloc_buffer+0xdc>
		max_len = MAX(max_len, NET_IPV4_MTU);
    b674:	f5b2 7f10 	cmp.w	r2, #576	; 0x240
    b678:	bf38      	it	cc
    b67a:	f44f 7210 	movcc.w	r2, #576	; 0x240
	max_len -= existing;
    b67e:	eba3 030a 	sub.w	r3, r3, sl
    b682:	189c      	adds	r4, r3, r2
	return MIN(size, max_len);
    b684:	4284      	cmp	r4, r0
    b686:	bf28      	it	cs
    b688:	4604      	movcs	r4, r0
	if (pkt->context) {
		pool = get_data_pool(pkt->context);
	}

	if (!pool) {
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
    b68a:	4b37      	ldr	r3, [pc, #220]	; (b768 <net_pkt_alloc_buffer+0x164>)
    b68c:	6931      	ldr	r1, [r6, #16]
    b68e:	4837      	ldr	r0, [pc, #220]	; (b76c <net_pkt_alloc_buffer+0x168>)
    b690:	4a37      	ldr	r2, [pc, #220]	; (b770 <net_pkt_alloc_buffer+0x16c>)
    b692:	4281      	cmp	r1, r0
    b694:	bf0c      	ite	eq
    b696:	4690      	moveq	r8, r2
    b698:	4698      	movne	r8, r3
	}

	if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
    b69a:	1c6b      	adds	r3, r5, #1
    b69c:	2b01      	cmp	r3, #1
    b69e:	d906      	bls.n	b6ae <net_pkt_alloc_buffer+0xaa>
    b6a0:	f00a fc7a 	bl	15f98 <z_impl_k_uptime_get>
		u32_t diff = k_uptime_get_32() - alloc_start;
    b6a4:	1bc0      	subs	r0, r0, r7

		timeout -= MIN(timeout, diff);
    b6a6:	42a8      	cmp	r0, r5
    b6a8:	bf94      	ite	ls
    b6aa:	1a2d      	subls	r5, r5, r0
    b6ac:	1b6d      	subhi	r5, r5, r5
    b6ae:	f00a fc73 	bl	15f98 <z_impl_k_uptime_get>
	struct net_buf *current = NULL;
    b6b2:	f04f 0a00 	mov.w	sl, #0
    b6b6:	4683      	mov	fp, r0
	while (size) {
    b6b8:	b9d4      	cbnz	r4, b6f0 <net_pkt_alloc_buffer+0xec>
	buf = pkt_alloc_buffer(pool, alloc_len, timeout, caller, line);
#else
	buf = pkt_alloc_buffer(pool, alloc_len, timeout);
#endif

	if (!buf) {
    b6ba:	f1b9 0f00 	cmp.w	r9, #0
    b6be:	d020      	beq.n	b702 <net_pkt_alloc_buffer+0xfe>
		NET_ERR("Data buffer allocation failed.");
		return -ENOMEM;
	}

	net_pkt_append_buffer(pkt, buf);
    b6c0:	4630      	mov	r0, r6
    b6c2:	4649      	mov	r1, r9
    b6c4:	f008 fbf0 	bl	13ea8 <net_pkt_append_buffer>

	return 0;
    b6c8:	4620      	mov	r0, r4
    b6ca:	e02a      	b.n	b722 <net_pkt_alloc_buffer+0x11e>
		size += buf->size;
    b6cc:	f8b9 300e 	ldrh.w	r3, [r9, #14]
		buf = buf->frags;
    b6d0:	f8d9 9000 	ldr.w	r9, [r9]
		size += buf->size;
    b6d4:	449a      	add	sl, r3
		buf = buf->frags;
    b6d6:	e7b1      	b.n	b63c <net_pkt_alloc_buffer+0x38>
	size_t hdr_len = 0;
    b6d8:	4648      	mov	r0, r9
    b6da:	e7c2      	b.n	b662 <net_pkt_alloc_buffer+0x5e>
		max_len = 0;
    b6dc:	460a      	mov	r2, r1
    b6de:	e7c6      	b.n	b66e <net_pkt_alloc_buffer+0x6a>
	return iface->if_dev->l2;
    b6e0:	6809      	ldr	r1, [r1, #0]
		if (net_if_l2(net_pkt_iface(pkt)) ==
    b6e2:	684c      	ldr	r4, [r1, #4]
    b6e4:	4923      	ldr	r1, [pc, #140]	; (b774 <net_pkt_alloc_buffer+0x170>)
    b6e6:	428c      	cmp	r4, r1
			max_len += sizeof(struct net_eth_hdr);
    b6e8:	bf0c      	ite	eq
    b6ea:	320e      	addeq	r2, #14
			max_len = size;
    b6ec:	4602      	movne	r2, r0
    b6ee:	e7c6      	b.n	b67e <net_pkt_alloc_buffer+0x7a>
		new = net_buf_alloc_fixed(pool, timeout);
    b6f0:	4629      	mov	r1, r5
    b6f2:	4640      	mov	r0, r8
    b6f4:	f007 fcc2 	bl	1307c <net_buf_alloc_fixed>
		if (!new) {
    b6f8:	4607      	mov	r7, r0
    b6fa:	b9a0      	cbnz	r0, b726 <net_pkt_alloc_buffer+0x122>
	if (first) {
    b6fc:	f1b9 0f00 	cmp.w	r9, #0
    b700:	d12e      	bne.n	b760 <net_pkt_alloc_buffer+0x15c>
		NET_ERR("Data buffer allocation failed.");
    b702:	2301      	movs	r3, #1
    b704:	f04f 0100 	mov.w	r1, #0
    b708:	f363 0107 	bfi	r1, r3, #0, #8
    b70c:	4a1a      	ldr	r2, [pc, #104]	; (b778 <net_pkt_alloc_buffer+0x174>)
    b70e:	4b1b      	ldr	r3, [pc, #108]	; (b77c <net_pkt_alloc_buffer+0x178>)
    b710:	481b      	ldr	r0, [pc, #108]	; (b780 <net_pkt_alloc_buffer+0x17c>)
    b712:	1a9b      	subs	r3, r3, r2
    b714:	08db      	lsrs	r3, r3, #3
    b716:	f363 118f 	bfi	r1, r3, #6, #10
    b71a:	f006 fc2b 	bl	11f74 <log_0>
		return -ENOMEM;
    b71e:	f06f 000b 	mvn.w	r0, #11
}
    b722:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!first && !current) {
    b726:	f1b9 0f00 	cmp.w	r9, #0
    b72a:	d102      	bne.n	b732 <net_pkt_alloc_buffer+0x12e>
    b72c:	f1ba 0f00 	cmp.w	sl, #0
    b730:	d014      	beq.n	b75c <net_pkt_alloc_buffer+0x158>
			current->frags = new;
    b732:	f8ca 7000 	str.w	r7, [sl]
		if (current->size > size) {
    b736:	89fb      	ldrh	r3, [r7, #14]
    b738:	42a3      	cmp	r3, r4
			current->size = size;
    b73a:	bf88      	it	hi
    b73c:	81fc      	strhhi	r4, [r7, #14]
		size -= current->size;
    b73e:	89fb      	ldrh	r3, [r7, #14]
    b740:	1ae4      	subs	r4, r4, r3
		if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
    b742:	1c6b      	adds	r3, r5, #1
    b744:	2b01      	cmp	r3, #1
    b746:	d907      	bls.n	b758 <net_pkt_alloc_buffer+0x154>
    b748:	f00a fc26 	bl	15f98 <z_impl_k_uptime_get>
			u32_t diff = k_uptime_get_32() - alloc_start;
    b74c:	eba0 000b 	sub.w	r0, r0, fp
			timeout -= MIN(timeout, diff);
    b750:	42a8      	cmp	r0, r5
    b752:	bf94      	ite	ls
    b754:	1a2d      	subls	r5, r5, r0
    b756:	1b6d      	subhi	r5, r5, r5
		if (!first && !current) {
    b758:	46ba      	mov	sl, r7
    b75a:	e7ad      	b.n	b6b8 <net_pkt_alloc_buffer+0xb4>
    b75c:	4681      	mov	r9, r0
    b75e:	e7ea      	b.n	b736 <net_pkt_alloc_buffer+0x132>
		net_buf_unref(first);
    b760:	4648      	mov	r0, r9
    b762:	f7fe fe45 	bl	a3f0 <net_buf_unref>
	if (!buf) {
    b766:	e7cc      	b.n	b702 <net_pkt_alloc_buffer+0xfe>
    b768:	20011dfc 	.word	0x20011dfc
    b76c:	20011d20 	.word	0x20011d20
    b770:	20011e1c 	.word	0x20011e1c
    b774:	00016334 	.word	0x00016334
    b778:	00016344 	.word	0x00016344
    b77c:	000163e4 	.word	0x000163e4
    b780:	0001896e 	.word	0x0001896e

0000b784 <net_pkt_alloc_with_buffer>:
					  size_t size,
					  sa_family_t family,
					  enum net_ip_protocol proto,
					  s32_t timeout)
#endif
{
    b784:	b513      	push	{r0, r1, r4, lr}
#if NET_LOG_LEVEL >= LOG_LEVEL_DBG
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
				     proto, timeout, caller, line);
#else
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
    b786:	9c04      	ldr	r4, [sp, #16]
    b788:	e9cd 3400 	strd	r3, r4, [sp]
    b78c:	4613      	mov	r3, r2
    b78e:	460a      	mov	r2, r1
    b790:	4601      	mov	r1, r0
    b792:	4802      	ldr	r0, [pc, #8]	; (b79c <net_pkt_alloc_with_buffer+0x18>)
    b794:	f008 fb9a 	bl	13ecc <pkt_alloc_with_buffer>
				     proto, timeout);
#endif
}
    b798:	b002      	add	sp, #8
    b79a:	bd10      	pop	{r4, pc}
    b79c:	20011d20 	.word	0x20011d20

0000b7a0 <net_pkt_get_data>:
	return false;
}

void *net_pkt_get_data(struct net_pkt *pkt,
		       struct net_pkt_data_access *access)
{
    b7a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return NULL;
		}

		return pkt->cursor.pos;
	} else {
		if (net_pkt_is_contiguous(pkt, access->size)) {
    b7a4:	f8d1 a004 	ldr.w	sl, [r1, #4]
{
    b7a8:	460e      	mov	r6, r1
		if (net_pkt_is_contiguous(pkt, access->size)) {
    b7aa:	4651      	mov	r1, sl
{
    b7ac:	4604      	mov	r4, r0
		if (net_pkt_is_contiguous(pkt, access->size)) {
    b7ae:	f008 fc58 	bl	14062 <net_pkt_is_contiguous>
    b7b2:	4681      	mov	r9, r0
    b7b4:	b118      	cbz	r0, b7be <net_pkt_get_data+0x1e>
			access->data = pkt->cursor.pos;
    b7b6:	69e3      	ldr	r3, [r4, #28]
    b7b8:	6033      	str	r3, [r6, #0]
			}

			net_pkt_cursor_restore(pkt, &backup);
		}

		return access->data;
    b7ba:	6835      	ldr	r5, [r6, #0]
    b7bc:	e013      	b.n	b7e6 <net_pkt_get_data+0x46>
}

static inline bool net_pkt_is_being_overwritten(struct net_pkt *pkt)
{
	return pkt->overwrite;
    b7be:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		} else if (net_pkt_is_being_overwritten(pkt)) {
    b7c2:	07db      	lsls	r3, r3, #31
    b7c4:	d5f9      	bpl.n	b7ba <net_pkt_get_data+0x1a>
    b7c6:	6835      	ldr	r5, [r6, #0]
			if (!access->data) {
    b7c8:	b985      	cbnz	r5, b7ec <net_pkt_get_data+0x4c>
				NET_ERR("Uncontiguous data"
    b7ca:	2301      	movs	r3, #1
    b7cc:	f04f 0100 	mov.w	r1, #0
    b7d0:	f363 0107 	bfi	r1, r3, #0, #8
    b7d4:	4a0c      	ldr	r2, [pc, #48]	; (b808 <net_pkt_get_data+0x68>)
    b7d6:	4b0d      	ldr	r3, [pc, #52]	; (b80c <net_pkt_get_data+0x6c>)
    b7d8:	480d      	ldr	r0, [pc, #52]	; (b810 <net_pkt_get_data+0x70>)
    b7da:	1a9b      	subs	r3, r3, r2
    b7dc:	08db      	lsrs	r3, r3, #3
    b7de:	f363 118f 	bfi	r1, r3, #6, #10
    b7e2:	f006 fbc7 	bl	11f74 <log_0>
	}

	return NULL;
}
    b7e6:	4628      	mov	r0, r5
    b7e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (net_pkt_read(pkt, access->data, access->size)) {
    b7ec:	4652      	mov	r2, sl
    b7ee:	4629      	mov	r1, r5
    b7f0:	4620      	mov	r0, r4
 */
static inline void net_pkt_cursor_backup(struct net_pkt *pkt,
					 struct net_pkt_cursor *backup)
{
	backup->buf = pkt->cursor.buf;
	backup->pos = pkt->cursor.pos;
    b7f2:	e9d4 8706 	ldrd	r8, r7, [r4, #24]
    b7f6:	f008 fbaf 	bl	13f58 <net_pkt_read>
 */
static inline void net_pkt_cursor_restore(struct net_pkt *pkt,
					  struct net_pkt_cursor *backup)
{
	pkt->cursor.buf = backup->buf;
	pkt->cursor.pos = backup->pos;
    b7fa:	e9c4 8706 	strd	r8, r7, [r4, #24]
    b7fe:	2800      	cmp	r0, #0
    b800:	d0db      	beq.n	b7ba <net_pkt_get_data+0x1a>
				return NULL;
    b802:	464d      	mov	r5, r9
    b804:	e7ef      	b.n	b7e6 <net_pkt_get_data+0x46>
    b806:	bf00      	nop
    b808:	00016344 	.word	0x00016344
    b80c:	000163e4 	.word	0x000163e4
    b810:	0001898d 	.word	0x0001898d

0000b814 <net_tc_submit_to_tx_queue>:
static struct net_traffic_class tx_classes[NET_TC_TX_COUNT];
static struct net_traffic_class rx_classes[NET_TC_RX_COUNT];

void net_tc_submit_to_tx_queue(u8_t tc, struct net_pkt *pkt)
{
	k_work_submit_to_queue(&tx_classes[tc].work_q, net_pkt_work(pkt));
    b814:	4b03      	ldr	r3, [pc, #12]	; (b824 <net_tc_submit_to_tx_queue+0x10>)
    b816:	eb00 1040 	add.w	r0, r0, r0, lsl #5
    b81a:	3104      	adds	r1, #4
    b81c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    b820:	f008 bc55 	b.w	140ce <k_work_submit_to_queue>
    b824:	20003da8 	.word	0x20003da8

0000b828 <net_tc_submit_to_rx_queue>:
}

void net_tc_submit_to_rx_queue(u8_t tc, struct net_pkt *pkt)
{
	k_work_submit_to_queue(&rx_classes[tc].work_q, net_pkt_work(pkt));
    b828:	4b03      	ldr	r3, [pc, #12]	; (b838 <net_tc_submit_to_rx_queue+0x10>)
    b82a:	eb00 1040 	add.w	r0, r0, r0, lsl #5
    b82e:	3104      	adds	r1, #4
    b830:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    b834:	f008 bc4b 	b.w	140ce <k_work_submit_to_queue>
    b838:	20003d24 	.word	0x20003d24

0000b83c <net_tx_priority2tc>:

int net_tx_priority2tc(enum net_priority prio)
{
	if (prio > NET_PRIORITY_NC) {
		/* Use default value suggested in 802.1Q */
		prio = NET_PRIORITY_BE;
    b83c:	2807      	cmp	r0, #7
    b83e:	bf88      	it	hi
    b840:	2000      	movhi	r0, #0
	}

	return tx_prio2tc_map[prio];
}
    b842:	4b01      	ldr	r3, [pc, #4]	; (b848 <net_tx_priority2tc+0xc>)
    b844:	5c18      	ldrb	r0, [r3, r0]
    b846:	4770      	bx	lr
    b848:	000189ce 	.word	0x000189ce

0000b84c <net_tc_tx_init>:
/* Create workqueue for each traffic class we are using. All the network
 * traffic goes through these classes. There needs to be at least one traffic
 * class in the system.
 */
void net_tc_tx_init(void)
{
    b84c:	b510      	push	{r4, lr}

	for (i = 0; i < NET_TC_TX_COUNT; i++) {
		u8_t thread_priority;

		thread_priority = tx_tc2thread(i);
		tx_classes[i].tc = thread_priority;
    b84e:	4c09      	ldr	r4, [pc, #36]	; (b874 <net_tc_tx_init+0x28>)
			"prio %d (%d)", i,
			&tx_classes[i].work_q.queue, TX_STACK(i),
			K_THREAD_STACK_SIZEOF(tx_stack[i]),
			thread_priority, K_PRIO_COOP(thread_priority));

		k_work_q_start(&tx_classes[i].work_q,
    b850:	4909      	ldr	r1, [pc, #36]	; (b878 <net_tc_tx_init+0x2c>)
		tx_classes[i].tc = thread_priority;
    b852:	2307      	movs	r3, #7
    b854:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
		k_work_q_start(&tx_classes[i].work_q,
    b858:	4620      	mov	r0, r4
    b85a:	f06f 0308 	mvn.w	r3, #8
    b85e:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
    b862:	f004 f837 	bl	f8d4 <k_work_q_start>
K_SYSCALL_DECLARE2(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, int, k_tid_t, thread_id, const char *, value)
    b866:	f104 0010 	add.w	r0, r4, #16
    b86a:	4904      	ldr	r1, [pc, #16]	; (b87c <net_tc_tx_init+0x30>)
			       tx_stack[i],
			       K_THREAD_STACK_SIZEOF(tx_stack[i]),
			       K_PRIO_COOP(thread_priority));
		k_thread_name_set(&tx_classes[i].work_q.thread, "tx_workq");
	}
}
    b86c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b870:	f00a baa8 	b.w	15dc4 <z_impl_k_thread_name_set>
    b874:	20003da8 	.word	0x20003da8
    b878:	20006f88 	.word	0x20006f88
    b87c:	000189c5 	.word	0x000189c5

0000b880 <net_tc_rx_init>:

void net_tc_rx_init(void)
{
    b880:	b510      	push	{r4, lr}

	for (i = 0; i < NET_TC_RX_COUNT; i++) {
		u8_t thread_priority;

		thread_priority = rx_tc2thread(i);
		rx_classes[i].tc = thread_priority;
    b882:	4c09      	ldr	r4, [pc, #36]	; (b8a8 <net_tc_rx_init+0x28>)
			"prio %d (%d)", i,
			&rx_classes[i].work_q.queue, RX_STACK(i),
			K_THREAD_STACK_SIZEOF(rx_stack[i]),
			thread_priority, K_PRIO_COOP(thread_priority));

		k_work_q_start(&rx_classes[i].work_q,
    b884:	4909      	ldr	r1, [pc, #36]	; (b8ac <net_tc_rx_init+0x2c>)
		rx_classes[i].tc = thread_priority;
    b886:	2307      	movs	r3, #7
    b888:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
		k_work_q_start(&rx_classes[i].work_q,
    b88c:	4620      	mov	r0, r4
    b88e:	f06f 0308 	mvn.w	r3, #8
    b892:	f240 52dc 	movw	r2, #1500	; 0x5dc
    b896:	f004 f81d 	bl	f8d4 <k_work_q_start>
    b89a:	f104 0010 	add.w	r0, r4, #16
    b89e:	4904      	ldr	r1, [pc, #16]	; (b8b0 <net_tc_rx_init+0x30>)
			       rx_stack[i],
			       K_THREAD_STACK_SIZEOF(rx_stack[i]),
			       K_PRIO_COOP(thread_priority));
		k_thread_name_set(&rx_classes[i].work_q.thread, "rx_workq");
	}
}
    b8a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    b8a4:	f00a ba8e 	b.w	15dc4 <z_impl_k_thread_name_set>
    b8a8:	20003d24 	.word	0x20003d24
    b8ac:	20007438 	.word	0x20007438
    b8b0:	000189bc 	.word	0x000189bc

0000b8b4 <net_addr_ntop>:
	return buf - start;
}

char *net_addr_ntop(sa_family_t family, const void *src,
		    char *dst, size_t size)
{
    b8b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct in6_addr *addr6;
	u16_t *w;
	u8_t i, bl, bh, longest = 1U;
	s8_t pos = -1;
	char delim = ':';
	unsigned char zeros[8] = { 0 };
    b8b8:	2300      	movs	r3, #0
{
    b8ba:	b089      	sub	sp, #36	; 0x24
	char *ptr = dst;
	int len = -1;
	u16_t value;
	bool needcolon = false;

	if (family == AF_INET6) {
    b8bc:	2802      	cmp	r0, #2
{
    b8be:	4681      	mov	r9, r0
    b8c0:	468a      	mov	sl, r1
    b8c2:	4690      	mov	r8, r2
	unsigned char zeros[8] = { 0 };
    b8c4:	e9cd 3306 	strd	r3, r3, [sp, #24]
	if (family == AF_INET6) {
    b8c8:	d13d      	bne.n	b946 <net_addr_ntop+0x92>
		addr6 = (struct in6_addr *)src;
		w = (u16_t *)addr6->s6_addr16;
    b8ca:	aa06      	add	r2, sp, #24
    b8cc:	9104      	str	r1, [sp, #16]
    b8ce:	4610      	mov	r0, r2
{
    b8d0:	4619      	mov	r1, r3
    b8d2:	e006      	b.n	b8e2 <net_addr_ntop+0x2e>
			for (j = i; j < 8; j++) {
				if (UNALIGNED_GET(&w[j]) != 0) {
					break;
				}

				zeros[i]++;
    b8d4:	7804      	ldrb	r4, [r0, #0]
    b8d6:	3101      	adds	r1, #1
    b8d8:	3401      	adds	r4, #1
    b8da:	7004      	strb	r4, [r0, #0]
			for (j = i; j < 8; j++) {
    b8dc:	b2cc      	uxtb	r4, r1
    b8de:	2c07      	cmp	r4, #7
    b8e0:	d803      	bhi.n	b8ea <net_addr_ntop+0x36>
				if (UNALIGNED_GET(&w[j]) != 0) {
    b8e2:	f83a 4011 	ldrh.w	r4, [sl, r1, lsl #1]
    b8e6:	2c00      	cmp	r4, #0
    b8e8:	d0f4      	beq.n	b8d4 <net_addr_ntop+0x20>
    b8ea:	3301      	adds	r3, #1
		for (i = 0U; i < 8; i++) {
    b8ec:	2b08      	cmp	r3, #8
    b8ee:	f100 0001 	add.w	r0, r0, #1
    b8f2:	d1ed      	bne.n	b8d0 <net_addr_ntop+0x1c>
	s8_t pos = -1;
    b8f4:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
	u8_t i, bl, bh, longest = 1U;
    b8f8:	2701      	movs	r7, #1
			}
		}

		for (i = 0U; i < 8; i++) {
    b8fa:	2300      	movs	r3, #0
			if (zeros[i] > longest) {
    b8fc:	f812 1b01 	ldrb.w	r1, [r2], #1
    b900:	42b9      	cmp	r1, r7
				longest = zeros[i];
				pos = i;
    b902:	bf88      	it	hi
    b904:	b25e      	sxtbhi	r6, r3
		for (i = 0U; i < 8; i++) {
    b906:	f103 0301 	add.w	r3, r3, #1
    b90a:	b2db      	uxtb	r3, r3
				pos = i;
    b90c:	bf88      	it	hi
    b90e:	460f      	movhi	r7, r1
		for (i = 0U; i < 8; i++) {
    b910:	2b08      	cmp	r3, #8
    b912:	d1f3      	bne.n	b8fc <net_addr_ntop+0x48>
		len = 8;
    b914:	9303      	str	r3, [sp, #12]
    b916:	2f01      	cmp	r7, #1
    b918:	f04f 033a 	mov.w	r3, #58	; 0x3a
    b91c:	9302      	str	r3, [sp, #8]
    b91e:	bf08      	it	eq
    b920:	f04f 36ff 	moveq.w	r6, #4294967295	; 0xffffffff
	bool needcolon = false;
    b924:	2200      	movs	r2, #0
		delim = '.';
	} else {
		return NULL;
	}

	for (i = 0U; i < len; i++) {
    b926:	4644      	mov	r4, r8
    b928:	4615      	mov	r5, r2
    b92a:	9b03      	ldr	r3, [sp, #12]
    b92c:	429d      	cmp	r5, r3
    b92e:	db1a      	blt.n	b966 <net_addr_ntop+0xb2>
		}

		needcolon = true;
	}

	if (!(ptr - dst)) {
    b930:	4544      	cmp	r4, r8
    b932:	d00a      	beq.n	b94a <net_addr_ntop+0x96>
		return NULL;
	}

	if (family == AF_INET) {
    b934:	f1b9 0f01 	cmp.w	r9, #1
    b938:	f04f 0300 	mov.w	r3, #0
		*(ptr - 1) = '\0';
    b93c:	bf0c      	ite	eq
    b93e:	f804 3c01 	strbeq.w	r3, [r4, #-1]
	} else {
		*ptr = '\0';
    b942:	7023      	strbne	r3, [r4, #0]
    b944:	e003      	b.n	b94e <net_addr_ntop+0x9a>
	} else if (family == AF_INET) {
    b946:	2801      	cmp	r0, #1
    b948:	d005      	beq.n	b956 <net_addr_ntop+0xa2>
		return NULL;
    b94a:	f04f 0800 	mov.w	r8, #0
	}

	return dst;
}
    b94e:	4640      	mov	r0, r8
    b950:	b009      	add	sp, #36	; 0x24
    b952:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		delim = '.';
    b956:	232e      	movs	r3, #46	; 0x2e
    b958:	2204      	movs	r2, #4
    b95a:	e9cd 3202 	strd	r3, r2, [sp, #8]
	s8_t pos = -1;
    b95e:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
	u8_t i, bl, bh, longest = 1U;
    b962:	4607      	mov	r7, r0
    b964:	e7de      	b.n	b924 <net_addr_ntop+0x70>
		if (len == 4) {
    b966:	9b03      	ldr	r3, [sp, #12]
    b968:	2b04      	cmp	r3, #4
    b96a:	d134      	bne.n	b9d6 <net_addr_ntop+0x122>
			value = (u32_t)addr->s4_addr[i];
    b96c:	f81a 1005 	ldrb.w	r1, [sl, r5]
			if (value == 0U) {
    b970:	b949      	cbnz	r1, b986 <net_addr_ntop+0xd2>
				*ptr++ = '0';
    b972:	4620      	mov	r0, r4
    b974:	2330      	movs	r3, #48	; 0x30
    b976:	f800 3b02 	strb.w	r3, [r0], #2
				*ptr++ = delim;
    b97a:	9b02      	ldr	r3, [sp, #8]
    b97c:	7063      	strb	r3, [r4, #1]
	for (i = 0U; i < len; i++) {
    b97e:	3501      	adds	r5, #1
    b980:	b2ed      	uxtb	r5, r5
    b982:	4604      	mov	r4, r0
    b984:	e7d1      	b.n	b92a <net_addr_ntop+0x76>
			l = net_value_to_udec(ptr, value, 0);
    b986:	f8df c0dc 	ldr.w	ip, [pc, #220]	; ba64 <net_addr_ntop+0x1b0>
    b98a:	9401      	str	r4, [sp, #4]
    b98c:	2009      	movs	r0, #9
    b98e:	f04f 0b00 	mov.w	fp, #0
		temp = value / divisor;
    b992:	fbb1 fefc 	udiv	lr, r1, ip
		if ((precision > i) || (temp != 0)) {
    b996:	4583      	cmp	fp, r0
		value = value % divisor;
    b998:	fb0c 131e 	mls	r3, ip, lr, r1
    b99c:	9305      	str	r3, [sp, #20]
		if ((precision > i) || (temp != 0)) {
    b99e:	dc01      	bgt.n	b9a4 <net_addr_ntop+0xf0>
    b9a0:	4561      	cmp	r1, ip
    b9a2:	d306      	bcc.n	b9b2 <net_addr_ntop+0xfe>
			*buf++ = (char) (temp + '0');
    b9a4:	9b01      	ldr	r3, [sp, #4]
    b9a6:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
    b9aa:	f803 eb01 	strb.w	lr, [r3], #1
    b9ae:	4683      	mov	fp, r0
    b9b0:	9301      	str	r3, [sp, #4]
	for (i = 9; i >= 0; i--, divisor /= 10U) {
    b9b2:	3801      	subs	r0, #1
    b9b4:	230a      	movs	r3, #10
    b9b6:	fbbc fcf3 	udiv	ip, ip, r3
    b9ba:	1c43      	adds	r3, r0, #1
		value = value % divisor;
    b9bc:	9905      	ldr	r1, [sp, #20]
	for (i = 9; i >= 0; i--, divisor /= 10U) {
    b9be:	d1e8      	bne.n	b992 <net_addr_ntop+0xde>
	*buf = 0;
    b9c0:	9901      	ldr	r1, [sp, #4]
    b9c2:	f04f 0300 	mov.w	r3, #0
    b9c6:	700b      	strb	r3, [r1, #0]
	return buf - start;
    b9c8:	1b0b      	subs	r3, r1, r4
			ptr += l;
    b9ca:	b2db      	uxtb	r3, r3
    b9cc:	18e0      	adds	r0, r4, r3
			*ptr++ = delim;
    b9ce:	9902      	ldr	r1, [sp, #8]
    b9d0:	54e1      	strb	r1, [r4, r3]
    b9d2:	3001      	adds	r0, #1
			continue;
    b9d4:	e7d3      	b.n	b97e <net_addr_ntop+0xca>
		if (i == pos) {
    b9d6:	42ae      	cmp	r6, r5
    b9d8:	d10d      	bne.n	b9f6 <net_addr_ntop+0x142>
			if (needcolon || i == 0U) {
    b9da:	b902      	cbnz	r2, b9de <net_addr_ntop+0x12a>
    b9dc:	b916      	cbnz	r6, b9e4 <net_addr_ntop+0x130>
				*ptr++ = ':';
    b9de:	233a      	movs	r3, #58	; 0x3a
    b9e0:	f804 3b01 	strb.w	r3, [r4], #1
			*ptr++ = ':';
    b9e4:	4620      	mov	r0, r4
    b9e6:	233a      	movs	r3, #58	; 0x3a
    b9e8:	f800 3b01 	strb.w	r3, [r0], #1
			i += longest - 1U;
    b9ec:	1e7b      	subs	r3, r7, #1
    b9ee:	441d      	add	r5, r3
    b9f0:	b2ed      	uxtb	r5, r5
			needcolon = false;
    b9f2:	2200      	movs	r2, #0
			continue;
    b9f4:	e7c3      	b.n	b97e <net_addr_ntop+0xca>
		if (needcolon) {
    b9f6:	b112      	cbz	r2, b9fe <net_addr_ntop+0x14a>
			*ptr++ = ':';
    b9f8:	233a      	movs	r3, #58	; 0x3a
    b9fa:	f804 3b01 	strb.w	r3, [r4], #1
		value = (u32_t)sys_be16_to_cpu(UNALIGNED_GET(&w[i]));
    b9fe:	9b04      	ldr	r3, [sp, #16]
    ba00:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
    ba04:	021a      	lsls	r2, r3, #8
    ba06:	ea42 2213 	orr.w	r2, r2, r3, lsr #8
    ba0a:	b212      	sxth	r2, r2
		bh = value >> 8;
    ba0c:	f3c2 2307 	ubfx	r3, r2, #8, #8
		bl = value & 0xff;
    ba10:	fa5f fb82 	uxtb.w	fp, r2
		if (bh) {
    ba14:	b1b3      	cbz	r3, ba44 <net_addr_ntop+0x190>
			if (bh > 0x0f) {
    ba16:	2b0f      	cmp	r3, #15
		bh = value >> 8;
    ba18:	b2d9      	uxtb	r1, r3
			if (bh > 0x0f) {
    ba1a:	d90b      	bls.n	ba34 <net_addr_ntop+0x180>
				ptr = net_byte_to_hex(ptr, bh, 'a', false);
    ba1c:	2300      	movs	r3, #0
    ba1e:	2261      	movs	r2, #97	; 0x61
    ba20:	4620      	mov	r0, r4
    ba22:	f008 fb8a 	bl	1413a <net_byte_to_hex>
			ptr = net_byte_to_hex(ptr, bl, 'a', true);
    ba26:	2301      	movs	r3, #1
    ba28:	2261      	movs	r2, #97	; 0x61
    ba2a:	4659      	mov	r1, fp
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
    ba2c:	f008 fb85 	bl	1413a <net_byte_to_hex>
		needcolon = true;
    ba30:	2201      	movs	r2, #1
    ba32:	e7a4      	b.n	b97e <net_addr_ntop+0xca>
				if (bh < 10) {
    ba34:	b25b      	sxtb	r3, r3
    ba36:	2909      	cmp	r1, #9
					*ptr++ = (char)(bh + '0');
    ba38:	bf94      	ite	ls
    ba3a:	3330      	addls	r3, #48	; 0x30
					*ptr++ = (char) (bh - 10 + 'a');
    ba3c:	3357      	addhi	r3, #87	; 0x57
    ba3e:	1c60      	adds	r0, r4, #1
    ba40:	7023      	strb	r3, [r4, #0]
    ba42:	e7f0      	b.n	ba26 <net_addr_ntop+0x172>
		} else if (bl > 0x0f) {
    ba44:	f1bb 0f0f 	cmp.w	fp, #15
    ba48:	d903      	bls.n	ba52 <net_addr_ntop+0x19e>
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
    ba4a:	2261      	movs	r2, #97	; 0x61
    ba4c:	4659      	mov	r1, fp
    ba4e:	4620      	mov	r0, r4
    ba50:	e7ec      	b.n	ba2c <net_addr_ntop+0x178>
			if (bl < 10) {
    ba52:	b252      	sxtb	r2, r2
    ba54:	f1bb 0f09 	cmp.w	fp, #9
				*ptr++ = (char)(bl + '0');
    ba58:	bf94      	ite	ls
    ba5a:	3230      	addls	r2, #48	; 0x30
				*ptr++ = (char) (bl - 10 + 'a');
    ba5c:	3257      	addhi	r2, #87	; 0x57
    ba5e:	1c60      	adds	r0, r4, #1
    ba60:	7022      	strb	r2, [r4, #0]
    ba62:	e7e5      	b.n	ba30 <net_addr_ntop+0x17c>
    ba64:	3b9aca00 	.word	0x3b9aca00

0000ba68 <net_sprint_addr>:
	char *s = buf[++i % NBUFS];
    ba68:	4b08      	ldr	r3, [pc, #32]	; (ba8c <net_sprint_addr+0x24>)
    ba6a:	681a      	ldr	r2, [r3, #0]
    ba6c:	3201      	adds	r2, #1
{
    ba6e:	b410      	push	{r4}
	char *s = buf[++i % NBUFS];
    ba70:	601a      	str	r2, [r3, #0]
	return net_addr_ntop(af, addr, s, NET_IPV6_ADDR_LEN);
    ba72:	4c07      	ldr	r4, [pc, #28]	; (ba90 <net_sprint_addr+0x28>)
	char *s = buf[++i % NBUFS];
    ba74:	2303      	movs	r3, #3
    ba76:	fb92 f3f3 	sdiv	r3, r2, r3
    ba7a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    ba7e:	1ad2      	subs	r2, r2, r3
	return net_addr_ntop(af, addr, s, NET_IPV6_ADDR_LEN);
    ba80:	2328      	movs	r3, #40	; 0x28
    ba82:	fb03 4202 	mla	r2, r3, r2, r4
}
    ba86:	bc10      	pop	{r4}
	return net_addr_ntop(af, addr, s, NET_IPV6_ADDR_LEN);
    ba88:	f7ff bf14 	b.w	b8b4 <net_addr_ntop>
    ba8c:	20003e2c 	.word	0x20003e2c
    ba90:	20005b02 	.word	0x20005b02

0000ba94 <net_icmpv4_register_handler>:
Z_GENLIST_PREPEND(slist, snode)
    ba94:	4b03      	ldr	r3, [pc, #12]	; (baa4 <net_icmpv4_register_handler+0x10>)
    ba96:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
    ba98:	6002      	str	r2, [r0, #0]
Z_GENLIST_PREPEND(slist, snode)
    ba9a:	685a      	ldr	r2, [r3, #4]
	list->head = node;
    ba9c:	6018      	str	r0, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
    ba9e:	b902      	cbnz	r2, baa2 <net_icmpv4_register_handler+0xe>
	list->tail = node;
    baa0:	6058      	str	r0, [r3, #4]
}

void net_icmpv4_register_handler(struct net_icmpv4_handler *handler)
{
	sys_slist_prepend(&handlers, &handler->node);
}
    baa2:	4770      	bx	lr
    baa4:	20003e30 	.word	0x20003e30

0000baa8 <net_icmpv4_input>:
	sys_slist_find_and_remove(&handlers, &handler->node);
}

enum net_verdict net_icmpv4_input(struct net_pkt *pkt,
				  struct net_ipv4_hdr *ip_hdr)
{
    baa8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
    baaa:	2304      	movs	r3, #4
    baac:	2200      	movs	r2, #0
{
    baae:	460e      	mov	r6, r1
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv4_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    bab0:	4669      	mov	r1, sp
{
    bab2:	4604      	mov	r4, r0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
    bab4:	e9cd 2300 	strd	r2, r3, [sp]
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
    bab8:	f7ff fe72 	bl	b7a0 <net_pkt_get_data>
	if (!icmp_hdr) {
    babc:	4605      	mov	r5, r0
    babe:	b910      	cbnz	r0, bac6 <net_icmpv4_input+0x1e>
		NET_DBG("DROP: NULL ICMPv4 header");
		return NET_DROP;
    bac0:	2002      	movs	r0, #2

drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
    bac2:	b003      	add	sp, #12
    bac4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
}

static inline u16_t net_calc_chksum_icmpv4(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_ICMP);
    bac6:	2101      	movs	r1, #1
    bac8:	4620      	mov	r0, r4
    baca:	f008 fc12 	bl	142f2 <net_calc_chksum>
	if (net_calc_chksum_icmpv4(pkt) != 0U) {
    bace:	2800      	cmp	r0, #0
    bad0:	d1f6      	bne.n	bac0 <net_icmpv4_input+0x18>
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &ip_hdr->dst) &&
    bad2:	6a67      	ldr	r7, [r4, #36]	; 0x24
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    bad4:	f000 f83e 	bl	bb54 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
    bad8:	6932      	ldr	r2, [r6, #16]
    bada:	6803      	ldr	r3, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    badc:	429a      	cmp	r2, r3
    bade:	d0ef      	beq.n	bac0 <net_icmpv4_input+0x18>
	return net_if_ipv4_is_addr_bcast(iface, addr);
    bae0:	f106 0110 	add.w	r1, r6, #16
    bae4:	4638      	mov	r0, r7
    bae6:	f7ff fad7 	bl	b098 <net_if_ipv4_is_addr_bcast>
    baea:	2800      	cmp	r0, #0
    baec:	d1e8      	bne.n	bac0 <net_icmpv4_input+0x18>
 * Packet needs to be set to overwrite mode.
 */
static inline int net_pkt_acknowledge_data(struct net_pkt *pkt,
					   struct net_pkt_data_access *access)
{
	return net_pkt_skip(pkt, access->size);
    baee:	9901      	ldr	r1, [sp, #4]
    baf0:	4620      	mov	r0, r4
    baf2:	f008 fa1b 	bl	13f2c <net_pkt_skip>
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
    baf6:	4b0b      	ldr	r3, [pc, #44]	; (bb24 <net_icmpv4_input+0x7c>)
    baf8:	681b      	ldr	r3, [r3, #0]
    bafa:	2b00      	cmp	r3, #0
    bafc:	d0e0      	beq.n	bac0 <net_icmpv4_input+0x18>
		if (cb->type == icmp_hdr->type &&
    bafe:	7829      	ldrb	r1, [r5, #0]
    bb00:	7a1a      	ldrb	r2, [r3, #8]
    bb02:	428a      	cmp	r2, r1
    bb04:	d109      	bne.n	bb1a <net_icmpv4_input+0x72>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
    bb06:	7a5a      	ldrb	r2, [r3, #9]
		if (cb->type == icmp_hdr->type &&
    bb08:	7868      	ldrb	r0, [r5, #1]
    bb0a:	4290      	cmp	r0, r2
    bb0c:	d000      	beq.n	bb10 <net_icmpv4_input+0x68>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
    bb0e:	b922      	cbnz	r2, bb1a <net_icmpv4_input+0x72>
			return cb->handler(pkt, ip_hdr);
    bb10:	685b      	ldr	r3, [r3, #4]
    bb12:	4631      	mov	r1, r6
    bb14:	4620      	mov	r0, r4
    bb16:	4798      	blx	r3
    bb18:	e7d3      	b.n	bac2 <net_icmpv4_input+0x1a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    bb1a:	681b      	ldr	r3, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
    bb1c:	2b00      	cmp	r3, #0
    bb1e:	d1ef      	bne.n	bb00 <net_icmpv4_input+0x58>
    bb20:	e7ce      	b.n	bac0 <net_icmpv4_input+0x18>
    bb22:	bf00      	nop
    bb24:	20003e30 	.word	0x20003e30

0000bb28 <net_icmpv4_init>:
	.handler = icmpv4_handle_echo_request,
};

void net_icmpv4_init(void)
{
	net_icmpv4_register_handler(&echo_request_handler);
    bb28:	4801      	ldr	r0, [pc, #4]	; (bb30 <net_icmpv4_init+0x8>)
    bb2a:	f7ff bfb3 	b.w	ba94 <net_icmpv4_register_handler>
    bb2e:	bf00      	nop
    bb30:	20010cf4 	.word	0x20010cf4

0000bb34 <net_ipv4_is_addr_bcast>:
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    bb34:	4a04      	ldr	r2, [pc, #16]	; (bb48 <net_ipv4_is_addr_bcast+0x14>)
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
    bb36:	680b      	ldr	r3, [r1, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    bb38:	6812      	ldr	r2, [r2, #0]
    bb3a:	429a      	cmp	r2, r3
    bb3c:	d001      	beq.n	bb42 <net_ipv4_is_addr_bcast+0xe>
	return net_if_ipv4_is_addr_bcast(iface, addr);
    bb3e:	f7ff baab 	b.w	b098 <net_if_ipv4_is_addr_bcast>
}
    bb42:	2001      	movs	r0, #1
    bb44:	4770      	bx	lr
    bb46:	bf00      	nop
    bb48:	00016760 	.word	0x00016760

0000bb4c <net_ipv4_unspecified_address>:
const struct in_addr *net_ipv4_unspecified_address(void)
{
	static const struct in_addr addr;

	return &addr;
}
    bb4c:	4800      	ldr	r0, [pc, #0]	; (bb50 <net_ipv4_unspecified_address+0x4>)
    bb4e:	4770      	bx	lr
    bb50:	0001675c 	.word	0x0001675c

0000bb54 <net_ipv4_broadcast_address>:
const struct in_addr *net_ipv4_broadcast_address(void)
{
	static const struct in_addr addr = { { { 255, 255, 255, 255 } } };

	return &addr;
}
    bb54:	4800      	ldr	r0, [pc, #0]	; (bb58 <net_ipv4_broadcast_address+0x4>)
    bb56:	4770      	bx	lr
    bb58:	00016760 	.word	0x00016760

0000bb5c <net_ipv4_input>:

enum net_verdict net_ipv4_input(struct net_pkt *pkt)
{
    bb5c:	b5f0      	push	{r4, r5, r6, r7, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
    bb5e:	2314      	movs	r3, #20
{
    bb60:	b091      	sub	sp, #68	; 0x44
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
    bb62:	eb0d 0203 	add.w	r2, sp, r3
    bb66:	9207      	str	r2, [sp, #28]
    bb68:	2208      	movs	r2, #8
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
    bb6a:	2700      	movs	r7, #0
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
    bb6c:	9208      	str	r2, [sp, #32]
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    bb6e:	aa0b      	add	r2, sp, #44	; 0x2c
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
    bb70:	e9cd 7303 	strd	r7, r3, [sp, #12]
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    bb74:	e9cd 2309 	strd	r2, r3, [sp, #36]	; 0x24
	int real_len = net_pkt_get_len(pkt);
    bb78:	6943      	ldr	r3, [r0, #20]
{
    bb7a:	4604      	mov	r4, r0
	while (buf) {
    bb7c:	b943      	cbnz	r3, bb90 <net_ipv4_input+0x34>
	u8_t hdr_len;
	int pkt_len;

	net_stats_update_ipv4_recv(net_pkt_iface(pkt));

	hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
    bb7e:	a903      	add	r1, sp, #12
    bb80:	4620      	mov	r0, r4
    bb82:	f7ff fe0d 	bl	b7a0 <net_pkt_get_data>
	if (!hdr) {
    bb86:	4605      	mov	r5, r0
    bb88:	b930      	cbnz	r0, bb98 <net_ipv4_input+0x3c>
	if (verdict != NET_DROP) {
		return verdict;
	}
drop:
	net_stats_update_ipv4_drop(net_pkt_iface(pkt));
	return NET_DROP;
    bb8a:	2002      	movs	r0, #2
}
    bb8c:	b011      	add	sp, #68	; 0x44
    bb8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bytes += buf->len;
    bb90:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
    bb92:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
    bb94:	4417      	add	r7, r2
		buf = buf->frags;
    bb96:	e7f1      	b.n	bb7c <net_ipv4_input+0x20>
	hdr_len = (hdr->vhl & NET_IPV4_IHL_MASK) * 4U;
    bb98:	7806      	ldrb	r6, [r0, #0]
    bb9a:	f006 060f 	and.w	r6, r6, #15
    bb9e:	00b6      	lsls	r6, r6, #2
	if (hdr_len < sizeof(struct net_ipv4_hdr)) {
    bba0:	2e13      	cmp	r6, #19
    bba2:	d9f2      	bls.n	bb8a <net_ipv4_input+0x2e>
	pkt->ip_hdr_len = len;
    bba4:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
	pkt_len = ntohs(hdr->len);
    bba8:	8843      	ldrh	r3, [r0, #2]
    bbaa:	0219      	lsls	r1, r3, #8
    bbac:	ea41 2113 	orr.w	r1, r1, r3, lsr #8
    bbb0:	b289      	uxth	r1, r1
	if (real_len < pkt_len) {
    bbb2:	428f      	cmp	r7, r1
    bbb4:	dbe9      	blt.n	bb8a <net_ipv4_input+0x2e>
	} else if (real_len > pkt_len) {
    bbb6:	dd02      	ble.n	bbbe <net_ipv4_input+0x62>
		net_pkt_update_length(pkt, pkt_len);
    bbb8:	4620      	mov	r0, r4
    bbba:	f008 fa42 	bl	14042 <net_pkt_update_length>
	if (net_ipv4_is_addr_mcast(&hdr->src)) {
    bbbe:	f105 010c 	add.w	r1, r5, #12
    bbc2:	4608      	mov	r0, r1
    bbc4:	f008 fd27 	bl	14616 <net_ipv4_is_addr_mcast>
    bbc8:	2800      	cmp	r0, #0
    bbca:	d1de      	bne.n	bb8a <net_ipv4_input+0x2e>
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &hdr->src)) {
    bbcc:	6a60      	ldr	r0, [r4, #36]	; 0x24
    bbce:	f7ff ffb1 	bl	bb34 <net_ipv4_is_addr_bcast>
    bbd2:	2800      	cmp	r0, #0
    bbd4:	d1d9      	bne.n	bb8a <net_ipv4_input+0x2e>
	return UNALIGNED_GET(&addr->s_addr) == 0;
    bbd6:	68eb      	ldr	r3, [r5, #12]
	if (net_ipv4_is_addr_unspecified(&hdr->src)) {
    bbd8:	2b00      	cmp	r3, #0
    bbda:	d0d6      	beq.n	bb8a <net_ipv4_input+0x2e>
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
    bbdc:	6a60      	ldr	r0, [r4, #36]	; 0x24
    bbde:	f7ff fc15 	bl	b40c <net_if_need_calc_rx_checksum>
    bbe2:	2800      	cmp	r0, #0
    bbe4:	d14b      	bne.n	bc7e <net_ipv4_input+0x122>
	if ((!net_ipv4_is_my_addr(&hdr->dst) &&
    bbe6:	f105 0710 	add.w	r7, r5, #16
 */
static inline bool net_ipv4_is_my_addr(const struct in_addr *addr)
{
	bool ret;

	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
    bbea:	2100      	movs	r1, #0
    bbec:	4638      	mov	r0, r7
    bbee:	f7ff fad3 	bl	b198 <net_if_ipv4_addr_lookup>
    bbf2:	2800      	cmp	r0, #0
    bbf4:	bf14      	ite	ne
    bbf6:	2301      	movne	r3, #1
    bbf8:	2300      	moveq	r3, #0
	if (!ret) {
    bbfa:	d103      	bne.n	bc04 <net_ipv4_input+0xa8>
		ret = net_ipv4_is_addr_bcast(NULL, addr);
    bbfc:	4639      	mov	r1, r7
    bbfe:	f7ff ff99 	bl	bb34 <net_ipv4_is_addr_bcast>
    bc02:	4603      	mov	r3, r0
	}

	return ret;
    bc04:	7a6a      	ldrb	r2, [r5, #9]
    bc06:	2b00      	cmp	r3, #0
    bc08:	d13f      	bne.n	bc8a <net_ipv4_input+0x12e>
	     !net_ipv4_is_addr_mcast(&hdr->dst) &&
    bc0a:	4638      	mov	r0, r7
    bc0c:	f008 fd03 	bl	14616 <net_ipv4_is_addr_mcast>
	if ((!net_ipv4_is_my_addr(&hdr->dst) &&
    bc10:	2800      	cmp	r0, #0
    bc12:	d13a      	bne.n	bc8a <net_ipv4_input+0x12e>
	     !net_ipv4_is_addr_mcast(&hdr->dst) &&
    bc14:	2a11      	cmp	r2, #17
    bc16:	d1b8      	bne.n	bb8a <net_ipv4_input+0x2e>
	     !(hdr->proto == IPPROTO_UDP &&
    bc18:	4a28      	ldr	r2, [pc, #160]	; (bcbc <net_ipv4_input+0x160>)
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
    bc1a:	692b      	ldr	r3, [r5, #16]
    bc1c:	6812      	ldr	r2, [r2, #0]
    bc1e:	429a      	cmp	r2, r3
    bc20:	d1b3      	bne.n	bb8a <net_ipv4_input+0x2e>
	return net_pkt_skip(pkt, access->size);
    bc22:	9904      	ldr	r1, [sp, #16]
    bc24:	4620      	mov	r0, r4
    bc26:	f008 f981 	bl	13f2c <net_pkt_skip>
	if (hdr_len > sizeof(struct net_ipv4_hdr)) {
    bc2a:	2e14      	cmp	r6, #20
    bc2c:	d006      	beq.n	bc3c <net_ipv4_input+0xe0>
		if (net_pkt_skip(pkt, hdr_len - sizeof(struct net_ipv4_hdr))) {
    bc2e:	f1a6 0114 	sub.w	r1, r6, #20
    bc32:	4620      	mov	r0, r4
    bc34:	f008 f97a 	bl	13f2c <net_pkt_skip>
    bc38:	2800      	cmp	r0, #0
    bc3a:	d1a6      	bne.n	bb8a <net_ipv4_input+0x2e>
	net_pkt_set_ipv4_ttl(pkt, hdr->ttl);
    bc3c:	7a2b      	ldrb	r3, [r5, #8]
	pkt->ipv4_ttl = ttl;
    bc3e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	pkt->family = family;
    bc42:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    bc46:	2201      	movs	r2, #1
    bc48:	f362 0343 	bfi	r3, r2, #1, #3
    bc4c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	switch (hdr->proto) {
    bc50:	7a6b      	ldrb	r3, [r5, #9]
    bc52:	2b06      	cmp	r3, #6
    bc54:	d022      	beq.n	bc9c <net_ipv4_input+0x140>
    bc56:	2b11      	cmp	r3, #17
    bc58:	d02a      	beq.n	bcb0 <net_ipv4_input+0x154>
    bc5a:	4293      	cmp	r3, r2
    bc5c:	d195      	bne.n	bb8a <net_ipv4_input+0x2e>
		verdict = net_icmpv4_input(pkt, hdr);
    bc5e:	4629      	mov	r1, r5
    bc60:	4620      	mov	r0, r4
    bc62:	f7ff ff21 	bl	baa8 <net_icmpv4_input>
	if (verdict == NET_DROP) {
    bc66:	2802      	cmp	r0, #2
    bc68:	d08f      	beq.n	bb8a <net_ipv4_input+0x2e>
	} else if (hdr->proto == IPPROTO_ICMP) {
    bc6a:	7a6a      	ldrb	r2, [r5, #9]
    bc6c:	2a01      	cmp	r2, #1
    bc6e:	d08d      	beq.n	bb8c <net_ipv4_input+0x30>
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
    bc70:	ab01      	add	r3, sp, #4
    bc72:	a902      	add	r1, sp, #8
    bc74:	4620      	mov	r0, r4
	ip.ipv4 = hdr;
    bc76:	9502      	str	r5, [sp, #8]
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
    bc78:	f000 fa5a 	bl	c130 <net_conn_input>
	if (verdict != NET_DROP) {
    bc7c:	e786      	b.n	bb8c <net_ipv4_input+0x30>
	    net_calc_chksum_ipv4(pkt) != 0U) {
    bc7e:	4620      	mov	r0, r4
    bc80:	f008 fbb9 	bl	143f6 <net_calc_chksum_ipv4>
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
    bc84:	2800      	cmp	r0, #0
    bc86:	d0ae      	beq.n	bbe6 <net_ipv4_input+0x8a>
    bc88:	e77f      	b.n	bb8a <net_ipv4_input+0x2e>
				   net_ipv4_unspecified_address()))))) ||
    bc8a:	2a06      	cmp	r2, #6
    bc8c:	d1c9      	bne.n	bc22 <net_ipv4_input+0xc6>
	     net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &hdr->dst))) {
    bc8e:	4639      	mov	r1, r7
    bc90:	6a60      	ldr	r0, [r4, #36]	; 0x24
    bc92:	f7ff ff4f 	bl	bb34 <net_ipv4_is_addr_bcast>
	    (hdr->proto == IPPROTO_TCP &&
    bc96:	2800      	cmp	r0, #0
    bc98:	d0c3      	beq.n	bc22 <net_ipv4_input+0xc6>
    bc9a:	e776      	b.n	bb8a <net_ipv4_input+0x2e>
		proto_hdr.tcp = net_tcp_input(pkt, &tcp_access);
    bc9c:	a909      	add	r1, sp, #36	; 0x24
    bc9e:	4620      	mov	r0, r4
    bca0:	f009 f98c 	bl	14fbc <net_tcp_input>
    bca4:	9001      	str	r0, [sp, #4]
		if (proto_hdr.tcp) {
    bca6:	2800      	cmp	r0, #0
    bca8:	f43f af6f 	beq.w	bb8a <net_ipv4_input+0x2e>
			verdict = NET_OK;
    bcac:	2000      	movs	r0, #0
    bcae:	e7dc      	b.n	bc6a <net_ipv4_input+0x10e>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
    bcb0:	a907      	add	r1, sp, #28
    bcb2:	4620      	mov	r0, r4
    bcb4:	f009 f9ed 	bl	15092 <net_udp_input>
    bcb8:	e7f4      	b.n	bca4 <net_ipv4_input+0x148>
    bcba:	bf00      	nop
    bcbc:	00016760 	.word	0x00016760

0000bcc0 <mgmt_thread>:
			  K_THREAD_STACK_SIZEOF(mgmt_stack));
#endif
}

static void mgmt_thread(void)
{
    bcc0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (out_event < 0 || !events[out_event].event) {
    bcc4:	4f41      	ldr	r7, [pc, #260]	; (bdcc <mgmt_thread+0x10c>)
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    bcc6:	4842      	ldr	r0, [pc, #264]	; (bdd0 <mgmt_thread+0x110>)
    bcc8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    bccc:	f003 fcc8 	bl	f660 <z_impl_k_sem_take>
    bcd0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    bcd4:	483f      	ldr	r0, [pc, #252]	; (bdd4 <mgmt_thread+0x114>)
    bcd6:	f003 fcc3 	bl	f660 <z_impl_k_sem_take>
    bcda:	4b3f      	ldr	r3, [pc, #252]	; (bdd8 <mgmt_thread+0x118>)
    bcdc:	f9b3 5000 	ldrsh.w	r5, [r3]
    bce0:	2d00      	cmp	r5, #0
    bce2:	db21      	blt.n	bd28 <mgmt_thread+0x68>
    bce4:	f857 2035 	ldr.w	r2, [r7, r5, lsl #3]
    bce8:	b1f2      	cbz	r2, bd28 <mgmt_thread+0x68>
	if (o_idx == in_event) {
    bcea:	493c      	ldr	r1, [pc, #240]	; (bddc <mgmt_thread+0x11c>)
    bcec:	f9b1 0000 	ldrsh.w	r0, [r1]
	out_event++;
    bcf0:	1c6a      	adds	r2, r5, #1
    bcf2:	b212      	sxth	r2, r2
	if (o_idx == in_event) {
    bcf4:	42a8      	cmp	r0, r5
	out_event++;
    bcf6:	801a      	strh	r2, [r3, #0]
	if (o_idx == in_event) {
    bcf8:	d112      	bne.n	bd20 <mgmt_thread+0x60>
		in_event = -1;
    bcfa:	f64f 72ff 	movw	r2, #65535	; 0xffff
    bcfe:	800a      	strh	r2, [r1, #0]
		out_event = 0;
    bd00:	801a      	strh	r2, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
    bd02:	4e37      	ldr	r6, [pc, #220]	; (bde0 <mgmt_thread+0x120>)
    bd04:	6834      	ldr	r4, [r6, #0]
    bd06:	b9cc      	cbnz	r4, bd3c <mgmt_thread+0x7c>
	mgmt_event->event = 0U;
    bd08:	2300      	movs	r3, #0
    bd0a:	f847 3035 	str.w	r3, [r7, r5, lsl #3]
	mgmt_event->iface = NULL;
    bd0e:	eb07 05c5 	add.w	r5, r7, r5, lsl #3
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    bd12:	4830      	ldr	r0, [pc, #192]	; (bdd4 <mgmt_thread+0x114>)
    bd14:	606b      	str	r3, [r5, #4]
    bd16:	f003 fc77 	bl	f608 <z_impl_k_sem_give>
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)
    bd1a:	f003 fbb3 	bl	f484 <z_impl_k_yield>
    bd1e:	e7d2      	b.n	bcc6 <mgmt_thread+0x6>
	} else if (out_event == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
    bd20:	2a02      	cmp	r2, #2
    bd22:	d1ee      	bne.n	bd02 <mgmt_thread+0x42>
		out_event = 0;
    bd24:	2200      	movs	r2, #0
    bd26:	e7eb      	b.n	bd00 <mgmt_thread+0x40>
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    bd28:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    bd2c:	2100      	movs	r1, #0
    bd2e:	4828      	ldr	r0, [pc, #160]	; (bdd0 <mgmt_thread+0x110>)
    bd30:	f00a f836 	bl	15da0 <z_impl_k_sem_init>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    bd34:	4827      	ldr	r0, [pc, #156]	; (bdd4 <mgmt_thread+0x114>)
    bd36:	f003 fc67 	bl	f608 <z_impl_k_sem_give>
				k_sem_count_get(&network_event));

			k_sem_init(&network_event, 0, UINT_MAX);
			k_sem_give(&net_mgmt_lock);

			continue;
    bd3a:	e7c4      	b.n	bcc6 <mgmt_thread+0x6>
    bd3c:	f04f 0b00 	mov.w	fp, #0
    bd40:	f8d4 8000 	ldr.w	r8, [r4]
	return node->next;
    bd44:	eb07 09c5 	add.w	r9, r7, r5, lsl #3
	parent->next = child;
    bd48:	46da      	mov	sl, fp
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
    bd4a:	f857 1035 	ldr.w	r1, [r7, r5, lsl #3]
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
    bd4e:	68a0      	ldr	r0, [r4, #8]
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
    bd50:	ea81 0200 	eor.w	r2, r1, r0
		    !(NET_MGMT_GET_LAYER_CODE(mgmt_event->event) ==
    bd54:	ea81 0300 	eor.w	r3, r1, r0
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
    bd58:	f3c2 7201 	ubfx	r2, r2, #28, #2
		    !(NET_MGMT_GET_LAYER_CODE(mgmt_event->event) ==
    bd5c:	f3c3 430a 	ubfx	r3, r3, #16, #11
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
    bd60:	4313      	orrs	r3, r2
    bd62:	d120      	bne.n	bda6 <mgmt_thread+0xe6>
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
    bd64:	b28b      	uxth	r3, r1
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
    bd66:	b12b      	cbz	r3, bd74 <mgmt_thread+0xb4>
		     NET_MGMT_GET_COMMAND(cb->event_mask) &&
    bd68:	b283      	uxth	r3, r0
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
    bd6a:	b11b      	cbz	r3, bd74 <mgmt_thread+0xb4>
		     !(NET_MGMT_GET_COMMAND(mgmt_event->event) &
    bd6c:	ea01 0300 	and.w	r3, r1, r0
    bd70:	b29b      	uxth	r3, r3
		     NET_MGMT_GET_COMMAND(cb->event_mask) &&
    bd72:	b1c3      	cbz	r3, bda6 <mgmt_thread+0xe6>
		if (NET_MGMT_EVENT_SYNCHRONOUS(cb->event_mask)) {
    bd74:	0100      	lsls	r0, r0, #4
    bd76:	6863      	ldr	r3, [r4, #4]
    bd78:	f8d9 2004 	ldr.w	r2, [r9, #4]
    bd7c:	d522      	bpl.n	bdc4 <mgmt_thread+0x104>
			if (sync_data->iface &&
    bd7e:	6998      	ldr	r0, [r3, #24]
    bd80:	b108      	cbz	r0, bd86 <mgmt_thread+0xc6>
    bd82:	4290      	cmp	r0, r2
    bd84:	d10f      	bne.n	bda6 <mgmt_thread+0xe6>
			cb->raised_event = mgmt_event->event;
    bd86:	60a1      	str	r1, [r4, #8]
			sync_data->iface = mgmt_event->iface;
    bd88:	619a      	str	r2, [r3, #24]
Z_GENLIST_REMOVE(slist, snode)
    bd8a:	6822      	ldr	r2, [r4, #0]
    bd8c:	f1bb 0f00 	cmp.w	fp, #0
    bd90:	d110      	bne.n	bdb4 <mgmt_thread+0xf4>
    bd92:	6871      	ldr	r1, [r6, #4]
	list->head = node;
    bd94:	6032      	str	r2, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
    bd96:	428c      	cmp	r4, r1
    bd98:	d100      	bne.n	bd9c <mgmt_thread+0xdc>
	list->tail = node;
    bd9a:	6072      	str	r2, [r6, #4]
	parent->next = child;
    bd9c:	f8c4 a000 	str.w	sl, [r4]
    bda0:	4618      	mov	r0, r3
    bda2:	f003 fc31 	bl	f608 <z_impl_k_sem_give>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
    bda6:	f1b8 0f00 	cmp.w	r8, #0
    bdaa:	d0ad      	beq.n	bd08 <mgmt_thread+0x48>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    bdac:	4644      	mov	r4, r8
    bdae:	f8d8 8000 	ldr.w	r8, [r8]
    bdb2:	e7ca      	b.n	bd4a <mgmt_thread+0x8a>
	parent->next = child;
    bdb4:	f8cb 2000 	str.w	r2, [fp]
Z_GENLIST_REMOVE(slist, snode)
    bdb8:	6872      	ldr	r2, [r6, #4]
    bdba:	4294      	cmp	r4, r2
	list->tail = node;
    bdbc:	bf08      	it	eq
    bdbe:	f8c6 b004 	streq.w	fp, [r6, #4]
    bdc2:	e7eb      	b.n	bd9c <mgmt_thread+0xdc>
			cb->handler(cb, mgmt_event->event, mgmt_event->iface);
    bdc4:	4620      	mov	r0, r4
    bdc6:	4798      	blx	r3
			prev = &cb->node;
    bdc8:	46a3      	mov	fp, r4
    bdca:	e7ec      	b.n	bda6 <mgmt_thread+0xe6>
    bdcc:	20003e40 	.word	0x20003e40
    bdd0:	20011da8 	.word	0x20011da8
    bdd4:	20011d90 	.word	0x20011d90
    bdd8:	200056aa 	.word	0x200056aa
    bddc:	200056a8 	.word	0x200056a8
    bde0:	20003e38 	.word	0x20003e38

0000bde4 <net_mgmt_event_notify_with_info>:
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
    bde4:	4b21      	ldr	r3, [pc, #132]	; (be6c <net_mgmt_event_notify_with_info+0x88>)
    bde6:	681b      	ldr	r3, [r3, #0]
	k_sem_give(&net_mgmt_lock);
}

void net_mgmt_event_notify_with_info(u32_t mgmt_event, struct net_if *iface,
				     void *info, size_t length)
{
    bde8:	b570      	push	{r4, r5, r6, lr}
	return (((NET_MGMT_GET_LAYER(mgmt_event) &
    bdea:	0f02      	lsrs	r2, r0, #28
{
    bdec:	460d      	mov	r5, r1
		((NET_MGMT_GET_LAYER_CODE(mgmt_event) &
    bdee:	0c01      	lsrs	r1, r0, #16
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
    bdf0:	ea22 7213 	bic.w	r2, r2, r3, lsr #28
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
    bdf4:	ea21 4113 	bic.w	r1, r1, r3, lsr #16
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
    bdf8:	f002 0203 	and.w	r2, r2, #3
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
    bdfc:	f3c1 010a 	ubfx	r1, r1, #0, #11
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
    be00:	ea20 0303 	bic.w	r3, r0, r3
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
    be04:	430a      	orrs	r2, r1
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
    be06:	b29b      	uxth	r3, r3
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
    be08:	4313      	orrs	r3, r2
{
    be0a:	4604      	mov	r4, r0
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
    be0c:	d12c      	bne.n	be68 <net_mgmt_event_notify_with_info+0x84>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    be0e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    be12:	4817      	ldr	r0, [pc, #92]	; (be70 <net_mgmt_event_notify_with_info+0x8c>)
	events[i_idx].event = mgmt_event;
    be14:	4e17      	ldr	r6, [pc, #92]	; (be74 <net_mgmt_event_notify_with_info+0x90>)
    be16:	f003 fc23 	bl	f660 <z_impl_k_sem_take>
	i_idx = in_event + 1;
    be1a:	4917      	ldr	r1, [pc, #92]	; (be78 <net_mgmt_event_notify_with_info+0x94>)
	if (i_idx == out_event) {
    be1c:	4817      	ldr	r0, [pc, #92]	; (be7c <net_mgmt_event_notify_with_info+0x98>)
	i_idx = in_event + 1;
    be1e:	880b      	ldrh	r3, [r1, #0]
    be20:	3301      	adds	r3, #1
    be22:	b21b      	sxth	r3, r3
		i_idx = 0;
    be24:	2b02      	cmp	r3, #2
    be26:	bf08      	it	eq
    be28:	2300      	moveq	r3, #0
	events[i_idx].iface = iface;
    be2a:	eb06 02c3 	add.w	r2, r6, r3, lsl #3
	events[i_idx].event = mgmt_event;
    be2e:	f846 4033 	str.w	r4, [r6, r3, lsl #3]
	events[i_idx].iface = iface;
    be32:	6055      	str	r5, [r2, #4]
	if (i_idx == out_event) {
    be34:	f9b0 2000 	ldrsh.w	r2, [r0]
    be38:	4293      	cmp	r3, r2
    be3a:	d111      	bne.n	be60 <net_mgmt_event_notify_with_info+0x7c>
		u16_t o_idx = out_event + 1;
    be3c:	1c5a      	adds	r2, r3, #1
    be3e:	b292      	uxth	r2, r2
			o_idx = 0U;
    be40:	2a02      	cmp	r2, #2
    be42:	bf08      	it	eq
    be44:	2200      	moveq	r2, #0
		if (events[o_idx].event) {
    be46:	f856 4032 	ldr.w	r4, [r6, r2, lsl #3]
    be4a:	b104      	cbz	r4, be4e <net_mgmt_event_notify_with_info+0x6a>
			out_event = o_idx;
    be4c:	8002      	strh	r2, [r0, #0]
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    be4e:	4808      	ldr	r0, [pc, #32]	; (be70 <net_mgmt_event_notify_with_info+0x8c>)
	in_event = i_idx;
    be50:	800b      	strh	r3, [r1, #0]
    be52:	f003 fbd9 	bl	f608 <z_impl_k_sem_give>
    be56:	480a      	ldr	r0, [pc, #40]	; (be80 <net_mgmt_event_notify_with_info+0x9c>)
			NET_MGMT_GET_COMMAND(mgmt_event));

		mgmt_push_event(mgmt_event, iface, info, length);
		k_sem_give(&network_event);
	}
}
    be58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    be5c:	f003 bbd4 	b.w	f608 <z_impl_k_sem_give>
	} else if (out_event < 0) {
    be60:	2a00      	cmp	r2, #0
		out_event = i_idx;
    be62:	bfb8      	it	lt
    be64:	8003      	strhlt	r3, [r0, #0]
    be66:	e7f2      	b.n	be4e <net_mgmt_event_notify_with_info+0x6a>
}
    be68:	bd70      	pop	{r4, r5, r6, pc}
    be6a:	bf00      	nop
    be6c:	20003e50 	.word	0x20003e50
    be70:	20011d90 	.word	0x20011d90
    be74:	20003e40 	.word	0x20003e40
    be78:	200056a8 	.word	0x200056a8
    be7c:	200056aa 	.word	0x200056aa
    be80:	20011da8 	.word	0x20011da8

0000be84 <net_mgmt_event_init>:
	list->head = NULL;
    be84:	4b14      	ldr	r3, [pc, #80]	; (bed8 <net_mgmt_event_init+0x54>)
void net_mgmt_event_init(void)
{
	sys_slist_init(&event_callbacks);
	global_event_mask = 0U;

	in_event = -1;
    be86:	4a15      	ldr	r2, [pc, #84]	; (bedc <net_mgmt_event_init+0x58>)
	out_event = -1;

	(void)memset(events, 0, CONFIG_NET_MGMT_EVENT_QUEUE_SIZE *
    be88:	4815      	ldr	r0, [pc, #84]	; (bee0 <net_mgmt_event_init+0x5c>)
{
    be8a:	b530      	push	{r4, r5, lr}
    be8c:	2400      	movs	r4, #0
	list->tail = NULL;
    be8e:	e9c3 4400 	strd	r4, r4, [r3]
	global_event_mask = 0U;
    be92:	4b14      	ldr	r3, [pc, #80]	; (bee4 <net_mgmt_event_init+0x60>)
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
    be94:	4d14      	ldr	r5, [pc, #80]	; (bee8 <net_mgmt_event_init+0x64>)
    be96:	601c      	str	r4, [r3, #0]
	in_event = -1;
    be98:	f64f 73ff 	movw	r3, #65535	; 0xffff
    be9c:	8013      	strh	r3, [r2, #0]
	out_event = -1;
    be9e:	4a13      	ldr	r2, [pc, #76]	; (beec <net_mgmt_event_init+0x68>)
{
    bea0:	b087      	sub	sp, #28
	out_event = -1;
    bea2:	8013      	strh	r3, [r2, #0]
	(void)memset(events, 0, CONFIG_NET_MGMT_EVENT_QUEUE_SIZE *
    bea4:	4621      	mov	r1, r4
    bea6:	2210      	movs	r2, #16
    bea8:	f7f6 f99f 	bl	21ea <memset>
    beac:	f06f 0308 	mvn.w	r3, #8
    beb0:	e9cd 4302 	strd	r4, r3, [sp, #8]
    beb4:	e9cd 4404 	strd	r4, r4, [sp, #16]
    beb8:	e9cd 4400 	strd	r4, r4, [sp]
    bebc:	4b0c      	ldr	r3, [pc, #48]	; (bef0 <net_mgmt_event_init+0x6c>)
    bebe:	490d      	ldr	r1, [pc, #52]	; (bef4 <net_mgmt_event_init+0x70>)
    bec0:	f44f 7240 	mov.w	r2, #768	; 0x300
    bec4:	4628      	mov	r0, r5
    bec6:	f003 fc65 	bl	f794 <z_impl_k_thread_create>
K_SYSCALL_DECLARE2(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, int, k_tid_t, thread_id, const char *, value)
    beca:	490b      	ldr	r1, [pc, #44]	; (bef8 <net_mgmt_event_init+0x74>)
    becc:	4628      	mov	r0, r5
	k_thread_name_set(&mgmt_thread_data, "net_mgmt");

	NET_DBG("Net MGMT initialized: queue of %u entries, stack size of %u",
		CONFIG_NET_MGMT_EVENT_QUEUE_SIZE,
		CONFIG_NET_MGMT_EVENT_STACK_SIZE);
}
    bece:	b007      	add	sp, #28
    bed0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    bed4:	f009 bf76 	b.w	15dc4 <z_impl_k_thread_name_set>
    bed8:	20003e38 	.word	0x20003e38
    bedc:	200056a8 	.word	0x200056a8
    bee0:	20003e40 	.word	0x20003e40
    bee4:	20003e50 	.word	0x20003e50
    bee8:	20003e54 	.word	0x20003e54
    beec:	200056aa 	.word	0x200056aa
    bef0:	0000bcc1 	.word	0x0000bcc1
    bef4:	20007a18 	.word	0x20007a18
    bef8:	000189fb 	.word	0x000189fb

0000befc <net_conn_unregister>:
#define cache_check(...) NET_CONTINUE
#define cache_remove(...)
#endif /* CONFIG_NET_CONN_CACHE */

int net_conn_unregister(struct net_conn_handle *handle)
{
    befc:	b508      	push	{r3, lr}
	struct net_conn *conn = (struct net_conn *)handle;

	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
    befe:	4b0a      	ldr	r3, [pc, #40]	; (bf28 <net_conn_unregister+0x2c>)
    bf00:	4298      	cmp	r0, r3
    bf02:	d30b      	bcc.n	bf1c <net_conn_unregister+0x20>
    bf04:	3380      	adds	r3, #128	; 0x80
    bf06:	4298      	cmp	r0, r3
    bf08:	d808      	bhi.n	bf1c <net_conn_unregister+0x20>
		return -EINVAL;
	}

	if (!(conn->flags & NET_CONN_IN_USE)) {
    bf0a:	7ec3      	ldrb	r3, [r0, #27]
    bf0c:	07db      	lsls	r3, r3, #31
    bf0e:	d508      	bpl.n	bf22 <net_conn_unregister+0x26>
    bf10:	2220      	movs	r2, #32
    bf12:	2100      	movs	r1, #0
    bf14:	f7f6 f969 	bl	21ea <memset>
	NET_DBG("[%zu] connection handler %p removed",
		conn - conns, conn);

	(void)memset(conn, 0, sizeof(*conn));

	return 0;
    bf18:	2000      	movs	r0, #0
}
    bf1a:	bd08      	pop	{r3, pc}
		return -EINVAL;
    bf1c:	f06f 0015 	mvn.w	r0, #21
    bf20:	e7fb      	b.n	bf1a <net_conn_unregister+0x1e>
		return -ENOENT;
    bf22:	f06f 0001 	mvn.w	r0, #1
    bf26:	e7f8      	b.n	bf1a <net_conn_unregister+0x1e>
    bf28:	20003ec0 	.word	0x20003ec0

0000bf2c <net_conn_register>:
		      u16_t remote_port,
		      u16_t local_port,
		      net_conn_cb_t cb,
		      void *user_data,
		      struct net_conn_handle **handle)
{
    bf2c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bf30:	f8bd a030 	ldrh.w	sl, [sp, #48]	; 0x30
    bf34:	4e77      	ldr	r6, [pc, #476]	; (c114 <net_conn_register+0x1e8>)
    bf36:	468c      	mov	ip, r1
    bf38:	fa9a f99a 	rev16.w	r9, sl
    bf3c:	f8bd 1034 	ldrh.w	r1, [sp, #52]	; 0x34
    bf40:	9100      	str	r1, [sp, #0]
    bf42:	fa1f f189 	uxth.w	r1, r9
    bf46:	9101      	str	r1, [sp, #4]
    bf48:	9900      	ldr	r1, [sp, #0]
    bf4a:	fa91 f891 	rev16.w	r8, r1
    bf4e:	4686      	mov	lr, r0
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
    bf50:	fa1f fb88 	uxth.w	fp, r8
{
    bf54:	4630      	mov	r0, r6
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
    bf56:	2500      	movs	r5, #0
		if (!(conns[i].flags & NET_CONN_IN_USE)) {
    bf58:	7ec4      	ldrb	r4, [r0, #27]
    bf5a:	07e1      	lsls	r1, r4, #31
    bf5c:	d513      	bpl.n	bf86 <net_conn_register+0x5a>
		if (conns[i].proto != proto) {
    bf5e:	8b01      	ldrh	r1, [r0, #24]
    bf60:	4571      	cmp	r1, lr
    bf62:	d110      	bne.n	bf86 <net_conn_register+0x5a>
		if (conns[i].family != family) {
    bf64:	7e81      	ldrb	r1, [r0, #26]
    bf66:	4561      	cmp	r1, ip
    bf68:	d10d      	bne.n	bf86 <net_conn_register+0x5a>
		if (remote_addr) {
    bf6a:	f004 0102 	and.w	r1, r4, #2
    bf6e:	b1f2      	cbz	r2, bfae <net_conn_register+0x82>
			if (!(conns[i].flags & NET_CONN_REMOTE_ADDR_SET)) {
    bf70:	b149      	cbz	r1, bf86 <net_conn_register+0x5a>
			if (remote_addr->sa_family == AF_INET &&
    bf72:	8811      	ldrh	r1, [r2, #0]
    bf74:	2901      	cmp	r1, #1
    bf76:	d106      	bne.n	bf86 <net_conn_register+0x5a>
    bf78:	8801      	ldrh	r1, [r0, #0]
    bf7a:	2901      	cmp	r1, #1
    bf7c:	d103      	bne.n	bf86 <net_conn_register+0x5a>
    bf7e:	6857      	ldr	r7, [r2, #4]
				if (!net_ipv4_addr_cmp(
    bf80:	6841      	ldr	r1, [r0, #4]
    bf82:	428f      	cmp	r7, r1
    bf84:	d015      	beq.n	bfb2 <net_conn_register+0x86>
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
    bf86:	3501      	adds	r5, #1
    bf88:	2d04      	cmp	r5, #4
    bf8a:	f100 0020 	add.w	r0, r0, #32
    bf8e:	d1e3      	bne.n	bf58 <net_conn_register+0x2c>
		NET_ERR("Identical connection handler %p already found.",
			&conns[i]);
		return -EALREADY;
	}

	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
    bf90:	2500      	movs	r5, #0
		if (conns[i].flags & NET_CONN_IN_USE) {
    bf92:	7ef4      	ldrb	r4, [r6, #27]
    bf94:	f014 0401 	ands.w	r4, r4, #1
    bf98:	d037      	beq.n	c00a <net_conn_register+0xde>
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
    bf9a:	3501      	adds	r5, #1
    bf9c:	2d04      	cmp	r5, #4
    bf9e:	f106 0620 	add.w	r6, r6, #32
    bfa2:	d1f6      	bne.n	bf92 <net_conn_register+0x66>
		}

		return 0;
	}

	return -ENOENT;
    bfa4:	f06f 0001 	mvn.w	r0, #1
}
    bfa8:	b003      	add	sp, #12
    bfaa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (conns[i].flags & NET_CONN_REMOTE_ADDR_SET) {
    bfae:	2900      	cmp	r1, #0
    bfb0:	d1e9      	bne.n	bf86 <net_conn_register+0x5a>
		if (local_addr) {
    bfb2:	f004 0404 	and.w	r4, r4, #4
    bfb6:	b32b      	cbz	r3, c004 <net_conn_register+0xd8>
			if (!(conns[i].flags & NET_CONN_LOCAL_ADDR_SET)) {
    bfb8:	2c00      	cmp	r4, #0
    bfba:	d0e4      	beq.n	bf86 <net_conn_register+0x5a>
			if (local_addr->sa_family == AF_INET &&
    bfbc:	8819      	ldrh	r1, [r3, #0]
    bfbe:	2901      	cmp	r1, #1
    bfc0:	d1e1      	bne.n	bf86 <net_conn_register+0x5a>
    bfc2:	8901      	ldrh	r1, [r0, #8]
    bfc4:	2901      	cmp	r1, #1
    bfc6:	d1de      	bne.n	bf86 <net_conn_register+0x5a>
    bfc8:	685c      	ldr	r4, [r3, #4]
				if (!net_ipv4_addr_cmp(
    bfca:	68c1      	ldr	r1, [r0, #12]
    bfcc:	428c      	cmp	r4, r1
    bfce:	d1da      	bne.n	bf86 <net_conn_register+0x5a>
		if (net_sin(&conns[i].remote_addr)->sin_port !=
    bfd0:	8844      	ldrh	r4, [r0, #2]
    bfd2:	9f01      	ldr	r7, [sp, #4]
    bfd4:	42bc      	cmp	r4, r7
    bfd6:	eb06 1145 	add.w	r1, r6, r5, lsl #5
    bfda:	d1d4      	bne.n	bf86 <net_conn_register+0x5a>
		if (net_sin(&conns[i].local_addr)->sin_port !=
    bfdc:	8944      	ldrh	r4, [r0, #10]
    bfde:	455c      	cmp	r4, fp
    bfe0:	d1d1      	bne.n	bf86 <net_conn_register+0x5a>
		NET_ERR("Identical connection handler %p already found.",
    bfe2:	2301      	movs	r3, #1
    bfe4:	f04f 0200 	mov.w	r2, #0
    bfe8:	f363 0207 	bfi	r2, r3, #0, #8
    bfec:	484a      	ldr	r0, [pc, #296]	; (c118 <net_conn_register+0x1ec>)
    bfee:	4b4b      	ldr	r3, [pc, #300]	; (c11c <net_conn_register+0x1f0>)
    bff0:	1a1b      	subs	r3, r3, r0
    bff2:	08db      	lsrs	r3, r3, #3
    bff4:	484a      	ldr	r0, [pc, #296]	; (c120 <net_conn_register+0x1f4>)
    bff6:	f363 128f 	bfi	r2, r3, #6, #10
    bffa:	f005 ffc8 	bl	11f8e <log_1>
		return -EALREADY;
    bffe:	f06f 0077 	mvn.w	r0, #119	; 0x77
    c002:	e7d1      	b.n	bfa8 <net_conn_register+0x7c>
			if (conns[i].flags & NET_CONN_LOCAL_ADDR_SET) {
    c004:	2c00      	cmp	r4, #0
    c006:	d0e3      	beq.n	bfd0 <net_conn_register+0xa4>
    c008:	e7bd      	b.n	bf86 <net_conn_register+0x5a>
		if (remote_addr) {
    c00a:	b192      	cbz	r2, c032 <net_conn_register+0x106>
			if (remote_addr->sa_family == AF_INET) {
    c00c:	8811      	ldrh	r1, [r2, #0]
    c00e:	2901      	cmp	r1, #1
    c010:	d13a      	bne.n	c088 <net_conn_register+0x15c>
				memcpy(&conns[i].remote_addr, remote_addr,
    c012:	4e40      	ldr	r6, [pc, #256]	; (c114 <net_conn_register+0x1e8>)
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    c014:	6851      	ldr	r1, [r2, #4]
    c016:	6810      	ldr	r0, [r2, #0]
    c018:	eb06 1645 	add.w	r6, r6, r5, lsl #5
    c01c:	4634      	mov	r4, r6
    c01e:	c403      	stmia	r4!, {r0, r1}
				if (!net_sin(remote_addr)->
    c020:	6851      	ldr	r1, [r2, #4]
					rank |= NET_RANK_REMOTE_SPEC_ADDR;
    c022:	2900      	cmp	r1, #0
			conns[i].flags |= NET_CONN_REMOTE_ADDR_SET;
    c024:	7ef1      	ldrb	r1, [r6, #27]
    c026:	f041 0102 	orr.w	r1, r1, #2
					rank |= NET_RANK_REMOTE_SPEC_ADDR;
    c02a:	bf0c      	ite	eq
    c02c:	2408      	moveq	r4, #8
    c02e:	2420      	movne	r4, #32
			conns[i].flags |= NET_CONN_REMOTE_ADDR_SET;
    c030:	76f1      	strb	r1, [r6, #27]
		if (local_addr) {
    c032:	2b00      	cmp	r3, #0
    c034:	d049      	beq.n	c0ca <net_conn_register+0x19e>
			if (local_addr->sa_family == AF_INET) {
    c036:	8819      	ldrh	r1, [r3, #0]
    c038:	2901      	cmp	r1, #1
    c03a:	d139      	bne.n	c0b0 <net_conn_register+0x184>
				memcpy(&conns[i].local_addr, local_addr,
    c03c:	4e35      	ldr	r6, [pc, #212]	; (c114 <net_conn_register+0x1e8>)
    c03e:	6859      	ldr	r1, [r3, #4]
    c040:	6818      	ldr	r0, [r3, #0]
    c042:	ea4f 1b45 	mov.w	fp, r5, lsl #5
    c046:	f10b 0708 	add.w	r7, fp, #8
    c04a:	4437      	add	r7, r6
    c04c:	c703      	stmia	r7!, {r0, r1}
				if (!net_sin(local_addr)->sin_addr.s_addr) {
    c04e:	6859      	ldr	r1, [r3, #4]
    c050:	bb59      	cbnz	r1, c0aa <net_conn_register+0x17e>
					rank |= NET_RANK_LOCAL_UNSPEC_ADDR;
    c052:	f044 0404 	orr.w	r4, r4, #4
			conns[i].flags |= NET_CONN_LOCAL_ADDR_SET;
    c056:	44b3      	add	fp, r6
    c058:	f89b 101b 	ldrb.w	r1, [fp, #27]
    c05c:	f041 0104 	orr.w	r1, r1, #4
    c060:	f88b 101b 	strb.w	r1, [fp, #27]
		if (remote_addr && local_addr) {
    c064:	b38a      	cbz	r2, c0ca <net_conn_register+0x19e>
			if (remote_addr->sa_family != local_addr->sa_family) {
    c066:	8812      	ldrh	r2, [r2, #0]
    c068:	881b      	ldrh	r3, [r3, #0]
    c06a:	429a      	cmp	r2, r3
    c06c:	d02d      	beq.n	c0ca <net_conn_register+0x19e>
				NET_ERR("Address families different");
    c06e:	2301      	movs	r3, #1
    c070:	f04f 0100 	mov.w	r1, #0
    c074:	f363 0107 	bfi	r1, r3, #0, #8
    c078:	4a27      	ldr	r2, [pc, #156]	; (c118 <net_conn_register+0x1ec>)
    c07a:	4b28      	ldr	r3, [pc, #160]	; (c11c <net_conn_register+0x1f0>)
    c07c:	4829      	ldr	r0, [pc, #164]	; (c124 <net_conn_register+0x1f8>)
    c07e:	1a9b      	subs	r3, r3, r2
    c080:	08db      	lsrs	r3, r3, #3
    c082:	f363 118f 	bfi	r1, r3, #6, #10
    c086:	e00b      	b.n	c0a0 <net_conn_register+0x174>
				NET_ERR("Remote address family not set");
    c088:	2301      	movs	r3, #1
    c08a:	f04f 0100 	mov.w	r1, #0
    c08e:	f363 0107 	bfi	r1, r3, #0, #8
    c092:	4a21      	ldr	r2, [pc, #132]	; (c118 <net_conn_register+0x1ec>)
    c094:	4b21      	ldr	r3, [pc, #132]	; (c11c <net_conn_register+0x1f0>)
    c096:	4824      	ldr	r0, [pc, #144]	; (c128 <net_conn_register+0x1fc>)
    c098:	1a9b      	subs	r3, r3, r2
    c09a:	08db      	lsrs	r3, r3, #3
    c09c:	f363 118f 	bfi	r1, r3, #6, #10
				NET_ERR("Local address family not set");
    c0a0:	f005 ff68 	bl	11f74 <log_0>
				return -EINVAL;
    c0a4:	f06f 0015 	mvn.w	r0, #21
    c0a8:	e77e      	b.n	bfa8 <net_conn_register+0x7c>
					rank |= NET_RANK_LOCAL_SPEC_ADDR;
    c0aa:	f044 0410 	orr.w	r4, r4, #16
    c0ae:	e7d2      	b.n	c056 <net_conn_register+0x12a>
				NET_ERR("Local address family not set");
    c0b0:	2301      	movs	r3, #1
    c0b2:	f04f 0100 	mov.w	r1, #0
    c0b6:	f363 0107 	bfi	r1, r3, #0, #8
    c0ba:	4a17      	ldr	r2, [pc, #92]	; (c118 <net_conn_register+0x1ec>)
    c0bc:	4b17      	ldr	r3, [pc, #92]	; (c11c <net_conn_register+0x1f0>)
    c0be:	481b      	ldr	r0, [pc, #108]	; (c12c <net_conn_register+0x200>)
    c0c0:	1a9b      	subs	r3, r3, r2
    c0c2:	08db      	lsrs	r3, r3, #3
    c0c4:	f363 118f 	bfi	r1, r3, #6, #10
    c0c8:	e7ea      	b.n	c0a0 <net_conn_register+0x174>
		if (remote_port) {
    c0ca:	4b12      	ldr	r3, [pc, #72]	; (c114 <net_conn_register+0x1e8>)
    c0cc:	016d      	lsls	r5, r5, #5
    c0ce:	f1ba 0f00 	cmp.w	sl, #0
    c0d2:	d004      	beq.n	c0de <net_conn_register+0x1b2>
			net_sin(&conns[i].remote_addr)->sin_port =
    c0d4:	195a      	adds	r2, r3, r5
			rank |= NET_RANK_REMOTE_PORT;
    c0d6:	f044 0402 	orr.w	r4, r4, #2
			net_sin(&conns[i].remote_addr)->sin_port =
    c0da:	f8a2 9002 	strh.w	r9, [r2, #2]
		if (local_port) {
    c0de:	9a00      	ldr	r2, [sp, #0]
    c0e0:	b122      	cbz	r2, c0ec <net_conn_register+0x1c0>
			net_sin(&conns[i].local_addr)->sin_port =
    c0e2:	195a      	adds	r2, r3, r5
			rank |= NET_RANK_LOCAL_PORT;
    c0e4:	f044 0401 	orr.w	r4, r4, #1
			net_sin(&conns[i].local_addr)->sin_port =
    c0e8:	f8a2 800a 	strh.w	r8, [r2, #10]
		conns[i].flags |= NET_CONN_IN_USE;
    c0ec:	441d      	add	r5, r3
    c0ee:	7eeb      	ldrb	r3, [r5, #27]
		conns[i].rank = rank;
    c0f0:	772c      	strb	r4, [r5, #28]
		conns[i].flags |= NET_CONN_IN_USE;
    c0f2:	f043 0301 	orr.w	r3, r3, #1
    c0f6:	76eb      	strb	r3, [r5, #27]
		conns[i].cb = cb;
    c0f8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    c0fa:	612b      	str	r3, [r5, #16]
		conns[i].user_data = user_data;
    c0fc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    c0fe:	616b      	str	r3, [r5, #20]
		if (handle) {
    c100:	9b10      	ldr	r3, [sp, #64]	; 0x40
		conns[i].proto = proto;
    c102:	f8a5 e018 	strh.w	lr, [r5, #24]
		conns[i].family = family;
    c106:	f885 c01a 	strb.w	ip, [r5, #26]
		if (handle) {
    c10a:	b103      	cbz	r3, c10e <net_conn_register+0x1e2>
			*handle = (struct net_conn_handle *)&conns[i];
    c10c:	601d      	str	r5, [r3, #0]
		return 0;
    c10e:	2000      	movs	r0, #0
    c110:	e74a      	b.n	bfa8 <net_conn_register+0x7c>
    c112:	bf00      	nop
    c114:	20003ec0 	.word	0x20003ec0
    c118:	00016344 	.word	0x00016344
    c11c:	00016374 	.word	0x00016374
    c120:	00018a5a 	.word	0x00018a5a
    c124:	00018a3f 	.word	0x00018a3f
    c128:	00018a04 	.word	0x00018a04
    c12c:	00018a22 	.word	0x00018a22

0000c130 <net_conn_input>:

enum net_verdict net_conn_input(struct net_pkt *pkt,
				union net_ip_header *ip_hdr,
				u8_t proto,
				union net_proto_header *proto_hdr)
{
    c130:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	enum net_verdict verdict;
	u32_t cache_value = 0U;
	s32_t pos;
#endif

	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
    c134:	2a11      	cmp	r2, #17
{
    c136:	b085      	sub	sp, #20
    c138:	4604      	mov	r4, r0
    c13a:	460d      	mov	r5, r1
    c13c:	4616      	mov	r6, r2
    c13e:	461f      	mov	r7, r3
	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
    c140:	d17b      	bne.n	c23a <net_conn_input+0x10a>
		src_port = proto_hdr->udp->src_port;
		dst_port = proto_hdr->udp->dst_port;
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
		src_port = proto_hdr->tcp->src_port;
    c142:	683b      	ldr	r3, [r7, #0]
    c144:	f8b3 8000 	ldrh.w	r8, [r3]
		dst_port = proto_hdr->tcp->dst_port;
    c148:	f8b3 9002 	ldrh.w	r9, [r3, #2]
	return pkt->family;
    c14c:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
    c150:	f3c3 0342 	ubfx	r3, r3, #1, #3
    c154:	2b01      	cmp	r3, #1
    c156:	d076      	beq.n	c246 <net_conn_input+0x116>
    c158:	4959      	ldr	r1, [pc, #356]	; (c2c0 <net_conn_input+0x190>)
{
    c15a:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
    c15e:	f04f 0c00 	mov.w	ip, #0
    c162:	4672      	mov	r2, lr
    c164:	4608      	mov	r0, r1
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
		if (!(conns[i].flags & NET_CONN_IN_USE)) {
			continue;
		}

		if (conns[i].proto != proto) {
    c166:	b2b6      	uxth	r6, r6
		if (!(conns[i].flags & NET_CONN_IN_USE)) {
    c168:	f891 a01b 	ldrb.w	sl, [r1, #27]
    c16c:	f01a 0f01 	tst.w	sl, #1
    c170:	d04d      	beq.n	c20e <net_conn_input+0xde>
		if (conns[i].proto != proto) {
    c172:	8b0b      	ldrh	r3, [r1, #24]
    c174:	42b3      	cmp	r3, r6
    c176:	d14a      	bne.n	c20e <net_conn_input+0xde>
			continue;
		}

		if (conns[i].family != AF_UNSPEC &&
    c178:	f891 b01a 	ldrb.w	fp, [r1, #26]
    c17c:	f1bb 0f00 	cmp.w	fp, #0
    c180:	d005      	beq.n	c18e <net_conn_input+0x5e>
    c182:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    c186:	f3c3 0342 	ubfx	r3, r3, #1, #3
    c18a:	455b      	cmp	r3, fp
    c18c:	d13f      	bne.n	c20e <net_conn_input+0xde>
			continue;
		}

		if (IS_ENABLED(CONFIG_NET_UDP) ||
		    IS_ENABLED(CONFIG_NET_TCP)) {
			if (net_sin(&conns[i].remote_addr)->sin_port) {
    c18e:	884b      	ldrh	r3, [r1, #2]
    c190:	b10b      	cbz	r3, c196 <net_conn_input+0x66>
				if (net_sin(&conns[i].remote_addr)->sin_port !=
    c192:	4598      	cmp	r8, r3
    c194:	d13b      	bne.n	c20e <net_conn_input+0xde>
				    src_port) {
					continue;
				}
			}

			if (net_sin(&conns[i].local_addr)->sin_port) {
    c196:	894b      	ldrh	r3, [r1, #10]
    c198:	b10b      	cbz	r3, c19e <net_conn_input+0x6e>
				if (net_sin(&conns[i].local_addr)->sin_port !=
    c19a:	4599      	cmp	r9, r3
    c19c:	d137      	bne.n	c20e <net_conn_input+0xde>
				    dst_port) {
					continue;
				}
			}

			if (conns[i].flags & NET_CONN_REMOTE_ADDR_SET) {
    c19e:	f01a 0f02 	tst.w	sl, #2
    c1a2:	d012      	beq.n	c1ca <net_conn_input+0x9a>
    c1a4:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
	if (addr->sa_family != net_pkt_family(pkt)) {
    c1a8:	f8b1 b000 	ldrh.w	fp, [r1]
    c1ac:	f3c3 0342 	ubfx	r3, r3, #1, #3
    c1b0:	459b      	cmp	fp, r3
    c1b2:	d12c      	bne.n	c20e <net_conn_input+0xde>
	if (net_pkt_family(pkt) == AF_INET && addr->sa_family == AF_INET) {
    c1b4:	2b01      	cmp	r3, #1
    c1b6:	d108      	bne.n	c1ca <net_conn_input+0x9a>
		if (net_sin(addr)->sin_addr.s_addr) {
    c1b8:	f8d1 b004 	ldr.w	fp, [r1, #4]
    c1bc:	f1bb 0f00 	cmp.w	fp, #0
    c1c0:	d003      	beq.n	c1ca <net_conn_input+0x9a>
    c1c2:	682b      	ldr	r3, [r5, #0]
    c1c4:	68db      	ldr	r3, [r3, #12]
			if (!net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
    c1c6:	459b      	cmp	fp, r3
    c1c8:	d121      	bne.n	c20e <net_conn_input+0xde>
						true)) {
					continue;
				}
			}

			if (conns[i].flags & NET_CONN_LOCAL_ADDR_SET) {
    c1ca:	f01a 0f04 	tst.w	sl, #4
    c1ce:	d012      	beq.n	c1f6 <net_conn_input+0xc6>
    c1d0:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
	if (addr->sa_family != net_pkt_family(pkt)) {
    c1d4:	f8b1 a008 	ldrh.w	sl, [r1, #8]
    c1d8:	f3c3 0342 	ubfx	r3, r3, #1, #3
    c1dc:	459a      	cmp	sl, r3
    c1de:	d116      	bne.n	c20e <net_conn_input+0xde>
	if (net_pkt_family(pkt) == AF_INET && addr->sa_family == AF_INET) {
    c1e0:	2b01      	cmp	r3, #1
    c1e2:	d108      	bne.n	c1f6 <net_conn_input+0xc6>
		if (net_sin(addr)->sin_addr.s_addr) {
    c1e4:	f8d1 a00c 	ldr.w	sl, [r1, #12]
    c1e8:	f1ba 0f00 	cmp.w	sl, #0
    c1ec:	d003      	beq.n	c1f6 <net_conn_input+0xc6>
    c1ee:	682b      	ldr	r3, [r5, #0]
    c1f0:	691b      	ldr	r3, [r3, #16]
			if (!net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
    c1f2:	459a      	cmp	sl, r3
    c1f4:	d10b      	bne.n	c20e <net_conn_input+0xde>

			/* If we have an existing best_match, and that one
			 * specifies a remote port, then we've matched to a
			 * LISTENING connection that should not override.
			 */
			if (best_match >= 0 &&
    c1f6:	1c53      	adds	r3, r2, #1
    c1f8:	d003      	beq.n	c202 <net_conn_input+0xd2>
			    net_sin(&conns[best_match].remote_addr)->sin_port) {
    c1fa:	eb00 1342 	add.w	r3, r0, r2, lsl #5
			if (best_match >= 0 &&
    c1fe:	885b      	ldrh	r3, [r3, #2]
    c200:	b92b      	cbnz	r3, c20e <net_conn_input+0xde>
				continue;
			}

			if (best_rank < conns[i].rank) {
    c202:	7f0b      	ldrb	r3, [r1, #28]
    c204:	459e      	cmp	lr, r3
				best_rank = conns[i].rank;
    c206:	bfbc      	itt	lt
    c208:	fa0f fe83 	sxthlt.w	lr, r3
    c20c:	4662      	movlt	r2, ip
	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
    c20e:	f10c 0c01 	add.w	ip, ip, #1
    c212:	f1bc 0f04 	cmp.w	ip, #4
    c216:	f101 0120 	add.w	r1, r1, #32
    c21a:	d1a5      	bne.n	c168 <net_conn_input+0x38>
			best_rank = 0;
			best_match = i;
		}
	}

	if (best_match >= 0) {
    c21c:	1c53      	adds	r3, r2, #1
    c21e:	d039      	beq.n	c294 <net_conn_input+0x164>
			conns[best_match].cb,
			conns[best_match].user_data,
			conns[best_match].rank);
#endif /* CONFIG_NET_CONN_CACHE */

		if (conns[best_match].cb(&conns[best_match], pkt, ip_hdr,
    c220:	eb00 1042 	add.w	r0, r0, r2, lsl #5
    c224:	4621      	mov	r1, r4
    c226:	6943      	ldr	r3, [r0, #20]
    c228:	9300      	str	r3, [sp, #0]
    c22a:	6906      	ldr	r6, [r0, #16]
    c22c:	463b      	mov	r3, r7
    c22e:	462a      	mov	r2, r5
    c230:	47b0      	blx	r6
    c232:	2802      	cmp	r0, #2
    c234:	d003      	beq.n	c23e <net_conn_input+0x10e>
			goto drop;
		}

		net_stats_update_per_proto_recv(pkt_iface, proto);

		return NET_OK;
    c236:	2000      	movs	r0, #0
    c238:	e002      	b.n	c240 <net_conn_input+0x110>
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
    c23a:	2a06      	cmp	r2, #6
    c23c:	d081      	beq.n	c142 <net_conn_input+0x12>
	}

drop:
	net_stats_update_per_proto_drop(pkt_iface, proto);

	return NET_DROP;
    c23e:	2002      	movs	r0, #2
}
    c240:	b005      	add	sp, #20
    c242:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (net_ipv4_addr_cmp(&ip_hdr->ipv4->src,
    c246:	f8d5 a000 	ldr.w	sl, [r5]
    c24a:	f8da 200c 	ldr.w	r2, [sl, #12]
    c24e:	f8da 3010 	ldr.w	r3, [sl, #16]
    c252:	429a      	cmp	r2, r3
    c254:	d102      	bne.n	c25c <net_conn_input+0x12c>
	if (!is_valid_packet(pkt, ip_hdr, src_port, dst_port)) {
    c256:	45c8      	cmp	r8, r9
    c258:	d0f1      	beq.n	c23e <net_conn_input+0x10e>
    c25a:	e77d      	b.n	c158 <net_conn_input+0x28>
		    net_ipv4_is_my_addr(&ip_hdr->ipv4->src)) {
    c25c:	f10a 0b0c 	add.w	fp, sl, #12
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
    c260:	2100      	movs	r1, #0
    c262:	4658      	mov	r0, fp
    c264:	f7fe ff98 	bl	b198 <net_if_ipv4_addr_lookup>
    c268:	1e03      	subs	r3, r0, #0
    c26a:	bf14      	ite	ne
    c26c:	2001      	movne	r0, #1
    c26e:	2000      	moveq	r0, #0
	if (!ret) {
    c270:	d10c      	bne.n	c28c <net_conn_input+0x15c>
    c272:	9303      	str	r3, [sp, #12]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    c274:	f7ff fc6e 	bl	bb54 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
    c278:	f8da 100c 	ldr.w	r1, [sl, #12]
    c27c:	6802      	ldr	r2, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
    c27e:	4291      	cmp	r1, r2
    c280:	d0e9      	beq.n	c256 <net_conn_input+0x126>
	return net_if_ipv4_is_addr_bcast(iface, addr);
    c282:	9b03      	ldr	r3, [sp, #12]
    c284:	4659      	mov	r1, fp
    c286:	4618      	mov	r0, r3
    c288:	f7fe ff06 	bl	b098 <net_if_ipv4_is_addr_bcast>
				      &ip_hdr->ipv4->dst) ||
    c28c:	2800      	cmp	r0, #0
    c28e:	f43f af63 	beq.w	c158 <net_conn_input+0x28>
    c292:	e7e0      	b.n	c256 <net_conn_input+0x126>
    c294:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    c298:	f3c3 0342 	ubfx	r3, r3, #1, #3
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
    c29c:	2b01      	cmp	r3, #1
    c29e:	d10d      	bne.n	c2bc <net_conn_input+0x18c>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
    c2a0:	682b      	ldr	r3, [r5, #0]
    c2a2:	691b      	ldr	r3, [r3, #16]
    c2a4:	ba1b      	rev	r3, r3
    c2a6:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
		   net_pkt_family(pkt) == AF_INET &&
    c2aa:	f1b3 4f60 	cmp.w	r3, #3758096384	; 0xe0000000
	if (net_pkt_family(pkt) == AF_INET6) {
    c2ae:	d0c6      	beq.n	c23e <net_conn_input+0x10e>
		net_icmpv4_send_error(pkt, NET_ICMPV4_DST_UNREACH,
    c2b0:	2203      	movs	r2, #3
    c2b2:	4611      	mov	r1, r2
    c2b4:	4620      	mov	r0, r4
    c2b6:	f008 f93b 	bl	14530 <net_icmpv4_send_error>
    c2ba:	e7c0      	b.n	c23e <net_conn_input+0x10e>
	if (net_pkt_family(pkt) == AF_INET6) {
    c2bc:	2b02      	cmp	r3, #2
    c2be:	e7f6      	b.n	c2ae <net_conn_input+0x17e>
    c2c0:	20003ec0 	.word	0x20003ec0

0000c2c4 <k_delayed_work_submit>:
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
    c2c4:	460a      	mov	r2, r1
    c2c6:	4601      	mov	r1, r0
    c2c8:	4801      	ldr	r0, [pc, #4]	; (c2d0 <k_delayed_work_submit+0xc>)
    c2ca:	f003 bb27 	b.w	f91c <k_delayed_work_submit_to_queue>
    c2ce:	bf00      	nop
    c2d0:	20005620 	.word	0x20005620

0000c2d4 <tcp_backlog_find.isra.31>:
		addr6->sin6_port = port;
		addr->sa_family = AF_INET6;
	}
}

static int tcp_backlog_find(struct net_pkt *pkt,
    c2d4:	b570      	push	{r4, r5, r6, lr}
			    int *empty_slot)
{
	int i, empty = -1;

	for (i = 0; i < CONFIG_NET_TCP_BACKLOG_SIZE; i++) {
		if (tcp_backlog[i].tcp == NULL && empty < 0) {
    c2d6:	4d12      	ldr	r5, [pc, #72]	; (c320 <tcp_backlog_find.isra.31+0x4c>)
    c2d8:	682c      	ldr	r4, [r5, #0]
static int tcp_backlog_find(struct net_pkt *pkt,
    c2da:	461e      	mov	r6, r3
		if (tcp_backlog[i].tcp == NULL && empty < 0) {
    c2dc:	b144      	cbz	r4, c2f0 <tcp_backlog_find.isra.31+0x1c>
    c2de:	f890 0043 	ldrb.w	r0, [r0, #67]	; 0x43
			empty = i;
			continue;
		}

		if (net_pkt_family(pkt) != tcp_backlog[i].remote.sa_family) {
    c2e2:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    c2e4:	f3c0 0042 	ubfx	r0, r0, #1, #3
    c2e8:	4283      	cmp	r3, r0
    c2ea:	d006      	beq.n	c2fa <tcp_backlog_find.isra.31+0x26>
	int i, empty = -1;
    c2ec:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		}

		return i;
	}

	if (empty_slot) {
    c2f0:	b106      	cbz	r6, c2f4 <tcp_backlog_find.isra.31+0x20>
		*empty_slot = empty;
    c2f2:	6034      	str	r4, [r6, #0]
	}

	return -EADDRNOTAVAIL;
    c2f4:	f06f 007c 	mvn.w	r0, #124	; 0x7c
    c2f8:	e002      	b.n	c300 <tcp_backlog_find.isra.31+0x2c>
		if (IS_ENABLED(CONFIG_NET_IPV4) &&
    c2fa:	2801      	cmp	r0, #1
    c2fc:	d001      	beq.n	c302 <tcp_backlog_find.isra.31+0x2e>
	return -EADDRNOTAVAIL;
    c2fe:	2000      	movs	r0, #0
}
    c300:	bd70      	pop	{r4, r5, r6, pc}
			if (net_sin(&tcp_backlog[i].remote)->sin_port !=
    c302:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
    c304:	8813      	ldrh	r3, [r2, #0]
    c306:	4298      	cmp	r0, r3
    c308:	d1f0      	bne.n	c2ec <tcp_backlog_find.isra.31+0x18>
				   &ip_hdr->ipv4->src,
    c30a:	6809      	ldr	r1, [r1, #0]
			if (memcmp(&net_sin(&tcp_backlog[i].remote)->sin_addr,
    c30c:	2204      	movs	r2, #4
    c30e:	310c      	adds	r1, #12
    c310:	f105 0030 	add.w	r0, r5, #48	; 0x30
    c314:	f7f5 ff20 	bl	2158 <memcmp>
    c318:	2800      	cmp	r0, #0
    c31a:	d0f0      	beq.n	c2fe <tcp_backlog_find.isra.31+0x2a>
    c31c:	e7e6      	b.n	c2ec <tcp_backlog_find.isra.31+0x18>
    c31e:	bf00      	nop
    c320:	20003f40 	.word	0x20003f40

0000c324 <net_tcp_alloc>:
{
    c324:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c326:	4607      	mov	r7, r0
	__asm__ volatile(
    c328:	f04f 0320 	mov.w	r3, #32
    c32c:	f3ef 8511 	mrs	r5, BASEPRI
    c330:	f383 8811 	msr	BASEPRI, r3
    c334:	f3bf 8f6f 	isb	sy

static inline bool net_tcp_is_used(struct net_tcp *tcp)
{
	NET_ASSERT(tcp);

	return tcp->flags & NET_TCP_IN_USE;
    c338:	4c26      	ldr	r4, [pc, #152]	; (c3d4 <net_tcp_alloc+0xb0>)
	for (i = 0; i < NET_MAX_TCP_CONTEXT; i++) {
    c33a:	2000      	movs	r0, #0
    c33c:	f04f 0cc0 	mov.w	ip, #192	; 0xc0
    c340:	4626      	mov	r6, r4
    c342:	fb0c 4200 	mla	r2, ip, r0, r4
    c346:	32b8      	adds	r2, #184	; 0xb8
    c348:	8893      	ldrh	r3, [r2, #4]
    c34a:	f3c3 1147 	ubfx	r1, r3, #5, #8
		if (!net_tcp_is_used(&tcp_context[i])) {
    c34e:	f011 0f01 	tst.w	r1, #1
    c352:	d138      	bne.n	c3c6 <net_tcp_alloc+0xa2>
			tcp_context[i].flags |= NET_TCP_IN_USE;
    c354:	f041 0101 	orr.w	r1, r1, #1
    c358:	f361 134c 	bfi	r3, r1, #5, #8
    c35c:	8093      	strh	r3, [r2, #4]
	__asm__ volatile(
    c35e:	f385 8811 	msr	BASEPRI, r5
    c362:	f3bf 8f6f 	isb	sy
	if (i >= NET_MAX_TCP_CONTEXT) {
    c366:	2806      	cmp	r0, #6
    c368:	d031      	beq.n	c3ce <net_tcp_alloc+0xaa>
	(void)memset(&tcp_context[i], 0, sizeof(struct net_tcp));
    c36a:	22c0      	movs	r2, #192	; 0xc0
    c36c:	fb02 f400 	mul.w	r4, r2, r0
    c370:	1935      	adds	r5, r6, r4
__ssp_bos_icheck3(memset, void *, int)
    c372:	2100      	movs	r1, #0
    c374:	4628      	mov	r0, r5
    c376:	f7f5 ff38 	bl	21ea <memset>
	tcp_context[i].state = NET_TCP_CLOSED;
    c37a:	f104 02b8 	add.w	r2, r4, #184	; 0xb8
    c37e:	4432      	add	r2, r6
	tcp_context[i].flags = NET_TCP_IN_USE;
    c380:	6853      	ldr	r3, [r2, #4]
    c382:	f423 33ff 	bic.w	r3, r3, #130560	; 0x1fe00
    c386:	f423 73f0 	bic.w	r3, r3, #480	; 0x1e0
    c38a:	f043 0320 	orr.w	r3, r3, #32
    c38e:	6053      	str	r3, [r2, #4]
	tcp_context[i].context = context;
    c390:	5137      	str	r7, [r6, r4]
 * @return Return a random TCP sequence number
 */
static inline u32_t tcp_init_isn(void)
{
	/* Randomise initial seq number */
	return sys_rand32_get();
    c392:	f7fc f921 	bl	85d8 <sys_rand32_get>
	tcp_context[i].accept_cb = NULL;
    c396:	2700      	movs	r7, #0
	tcp_context[i].send_seq = tcp_init_isn();
    c398:	f8c5 0090 	str.w	r0, [r5, #144]	; 0x90
	tcp_context[i].recv_wnd = MIN(NET_TCP_MAX_WIN, NET_TCP_BUF_MAX_LEN);
    c39c:	4b0e      	ldr	r3, [pc, #56]	; (c3d8 <net_tcp_alloc+0xb4>)
	k_delayed_work_init(&tcp_context[i].retry_timer, tcp_retry_expired);
    c39e:	490f      	ldr	r1, [pc, #60]	; (c3dc <net_tcp_alloc+0xb8>)
	tcp_context[i].recv_wnd = MIN(NET_TCP_MAX_WIN, NET_TCP_BUF_MAX_LEN);
    c3a0:	f8c5 30b8 	str.w	r3, [r5, #184]	; 0xb8
	k_delayed_work_init(&tcp_context[i].retry_timer, tcp_retry_expired);
    c3a4:	f104 0048 	add.w	r0, r4, #72	; 0x48
    c3a8:	4430      	add	r0, r6
	tcp_context[i].accept_cb = NULL;
    c3aa:	f8c5 709c 	str.w	r7, [r5, #156]	; 0x9c
	k_delayed_work_init(&tcp_context[i].retry_timer, tcp_retry_expired);
    c3ae:	f009 fd92 	bl	15ed6 <k_delayed_work_init>
	k_sem_init(&tcp_context[i].connect_wait, 0, UINT_MAX);
    c3b2:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    c3b6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    c3ba:	4639      	mov	r1, r7
    c3bc:	4430      	add	r0, r6
    c3be:	f009 fcef 	bl	15da0 <z_impl_k_sem_init>
}
    c3c2:	4628      	mov	r0, r5
    c3c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (i = 0; i < NET_MAX_TCP_CONTEXT; i++) {
    c3c6:	3001      	adds	r0, #1
    c3c8:	2806      	cmp	r0, #6
    c3ca:	d1ba      	bne.n	c342 <net_tcp_alloc+0x1e>
    c3cc:	e7c7      	b.n	c35e <net_tcp_alloc+0x3a>
		return NULL;
    c3ce:	2500      	movs	r5, #0
    c3d0:	e7f7      	b.n	c3c2 <net_tcp_alloc+0x9e>
    c3d2:	bf00      	nop
    c3d4:	20003f78 	.word	0x20003f78
    c3d8:	02180500 	.word	0x02180500
    c3dc:	00014a7d 	.word	0x00014a7d

0000c3e0 <net_tcp_send_pkt>:
{
    c3e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    c3e2:	b089      	sub	sp, #36	; 0x24
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    c3e4:	ab03      	add	r3, sp, #12
	struct net_context *ctx = net_pkt_context(pkt);
    c3e6:	6a07      	ldr	r7, [r0, #32]
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    c3e8:	9301      	str	r3, [sp, #4]
    c3ea:	2314      	movs	r3, #20
{
    c3ec:	4604      	mov	r4, r0
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    c3ee:	9302      	str	r3, [sp, #8]
	if (!ctx || !ctx->tcp) {
    c3f0:	b10f      	cbz	r7, c3f6 <net_tcp_send_pkt+0x16>
    c3f2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    c3f4:	b9bb      	cbnz	r3, c426 <net_tcp_send_pkt+0x46>
		NET_ERR("%scontext is not set on pkt %p",
    c3f6:	2201      	movs	r2, #1
    c3f8:	f04f 0300 	mov.w	r3, #0
    c3fc:	f362 0307 	bfi	r3, r2, #0, #8
    c400:	4941      	ldr	r1, [pc, #260]	; (c508 <net_tcp_send_pkt+0x128>)
    c402:	4a42      	ldr	r2, [pc, #264]	; (c50c <net_tcp_send_pkt+0x12c>)
    c404:	4842      	ldr	r0, [pc, #264]	; (c510 <net_tcp_send_pkt+0x130>)
    c406:	1a52      	subs	r2, r2, r1
    c408:	4942      	ldr	r1, [pc, #264]	; (c514 <net_tcp_send_pkt+0x134>)
    c40a:	08d2      	lsrs	r2, r2, #3
    c40c:	f362 138f 	bfi	r3, r2, #6, #10
    c410:	2f00      	cmp	r7, #0
    c412:	bf18      	it	ne
    c414:	4601      	movne	r1, r0
    c416:	4622      	mov	r2, r4
    c418:	483f      	ldr	r0, [pc, #252]	; (c518 <net_tcp_send_pkt+0x138>)
    c41a:	f005 fdcc 	bl	11fb6 <log_2>
		return -EINVAL;
    c41e:	f06f 0015 	mvn.w	r0, #21
}
    c422:	b009      	add	sp, #36	; 0x24
    c424:	bdf0      	pop	{r4, r5, r6, r7, pc}
	net_pkt_cursor_init(pkt);
    c426:	f007 fd0a 	bl	13e3e <net_pkt_cursor_init>
	pkt->overwrite = overwrite;
    c42a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
	if (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +
    c42e:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
    c432:	f043 0301 	orr.w	r3, r3, #1
    c436:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    c43a:	4620      	mov	r0, r4
    c43c:	f007 fd76 	bl	13f2c <net_pkt_skip>
    c440:	4606      	mov	r6, r0
    c442:	b9a0      	cbnz	r0, c46e <net_tcp_send_pkt+0x8e>
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
    c444:	a901      	add	r1, sp, #4
    c446:	4620      	mov	r0, r4
    c448:	f7ff f9aa 	bl	b7a0 <net_pkt_get_data>
	if (!tcp_hdr) {
    c44c:	4605      	mov	r5, r0
    c44e:	b988      	cbnz	r0, c474 <net_tcp_send_pkt+0x94>
		NET_ERR("Packet %p does not contain TCP header", pkt);
    c450:	2301      	movs	r3, #1
    c452:	f04f 0200 	mov.w	r2, #0
    c456:	f363 0207 	bfi	r2, r3, #0, #8
    c45a:	492b      	ldr	r1, [pc, #172]	; (c508 <net_tcp_send_pkt+0x128>)
    c45c:	4b2b      	ldr	r3, [pc, #172]	; (c50c <net_tcp_send_pkt+0x12c>)
    c45e:	482f      	ldr	r0, [pc, #188]	; (c51c <net_tcp_send_pkt+0x13c>)
    c460:	1a5b      	subs	r3, r3, r1
    c462:	08db      	lsrs	r3, r3, #3
    c464:	f363 128f 	bfi	r2, r3, #6, #10
    c468:	4621      	mov	r1, r4
    c46a:	f005 fd90 	bl	11f8e <log_1>
		return -EMSGSIZE;
    c46e:	f06f 0079 	mvn.w	r0, #121	; 0x79
    c472:	e7d6      	b.n	c422 <net_tcp_send_pkt+0x42>
	if (sys_get_be32(tcp_hdr->ack) != ctx->tcp->send_ack) {
    c474:	3008      	adds	r0, #8
    c476:	f008 f94b 	bl	14710 <sys_get_be32>
    c47a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    c47c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    c480:	4298      	cmp	r0, r3
    c482:	d00a      	beq.n	c49a <net_tcp_send_pkt+0xba>
	sys_put_be16(val >> 16, dst);
    c484:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val >> 8;
    c486:	0a11      	lsrs	r1, r2, #8
	dst[1] = val;
    c488:	726a      	strb	r2, [r5, #9]
	dst[0] = val >> 8;
    c48a:	f3c3 2207 	ubfx	r2, r3, #8, #8
		tcp_hdr->chksum = 0U;
    c48e:	742e      	strb	r6, [r5, #16]
    c490:	746e      	strb	r6, [r5, #17]
    c492:	7229      	strb	r1, [r5, #8]
    c494:	72aa      	strb	r2, [r5, #10]
	dst[1] = val;
    c496:	72eb      	strb	r3, [r5, #11]
		calc_chksum = true;
    c498:	2601      	movs	r6, #1
	if (ctx->tcp->sent_ack != ctx->tcp->send_ack &&
    c49a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    c49c:	e9d3 3225 	ldrd	r3, r2, [r3, #148]	; 0x94
    c4a0:	429a      	cmp	r2, r3
    c4a2:	d009      	beq.n	c4b8 <net_tcp_send_pkt+0xd8>
		(tcp_hdr->flags & NET_TCP_ACK) == 0U) {
    c4a4:	7b6b      	ldrb	r3, [r5, #13]
	if (ctx->tcp->sent_ack != ctx->tcp->send_ack &&
    c4a6:	f013 0210 	ands.w	r2, r3, #16
    c4aa:	d105      	bne.n	c4b8 <net_tcp_send_pkt+0xd8>
		tcp_hdr->flags |= NET_TCP_ACK;
    c4ac:	f043 0310 	orr.w	r3, r3, #16
    c4b0:	736b      	strb	r3, [r5, #13]
		tcp_hdr->chksum = 0U;
    c4b2:	742a      	strb	r2, [r5, #16]
    c4b4:	746a      	strb	r2, [r5, #17]
		calc_chksum = true;
    c4b6:	2601      	movs	r6, #1
	net_pkt_set_data(pkt, &tcp_access);
    c4b8:	a901      	add	r1, sp, #4
    c4ba:	4620      	mov	r0, r4
    c4bc:	f007 fe02 	bl	140c4 <net_pkt_set_data>
	if (calc_chksum) {
    c4c0:	b186      	cbz	r6, c4e4 <net_tcp_send_pkt+0x104>
		net_pkt_cursor_init(pkt);
    c4c2:	4620      	mov	r0, r4
    c4c4:	f007 fcbb 	bl	13e3e <net_pkt_cursor_init>
		net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +
    c4c8:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
    c4cc:	4620      	mov	r0, r4
    c4ce:	f007 fd2d 	bl	13f2c <net_pkt_skip>
	return net_calc_chksum(pkt, IPPROTO_UDP);
}

static inline u16_t net_calc_chksum_tcp(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_TCP);
    c4d2:	2106      	movs	r1, #6
    c4d4:	4620      	mov	r0, r4
    c4d6:	f007 ff0c 	bl	142f2 <net_calc_chksum>
		net_pkt_set_data(pkt, &tcp_access);
    c4da:	a901      	add	r1, sp, #4
		tcp_hdr->chksum = net_calc_chksum_tcp(pkt);
    c4dc:	8228      	strh	r0, [r5, #16]
		net_pkt_set_data(pkt, &tcp_access);
    c4de:	4620      	mov	r0, r4
    c4e0:	f007 fdf0 	bl	140c4 <net_pkt_set_data>
	if (tcp_hdr->flags & NET_TCP_FIN) {
    c4e4:	7b6a      	ldrb	r2, [r5, #13]
    c4e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    c4e8:	07d2      	lsls	r2, r2, #31
		ctx->tcp->fin_sent = 1U;
    c4ea:	bf42      	ittt	mi
    c4ec:	f893 20be 	ldrbmi.w	r2, [r3, #190]	; 0xbe
    c4f0:	f042 0202 	orrmi.w	r2, r2, #2
    c4f4:	f883 20be 	strbmi.w	r2, [r3, #190]	; 0xbe
	ctx->tcp->sent_ack = ctx->tcp->send_ack;
    c4f8:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    c4fc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
	return net_send_data(pkt);
    c500:	4620      	mov	r0, r4
    c502:	f007 fa59 	bl	139b8 <net_send_data>
    c506:	e78c      	b.n	c422 <net_tcp_send_pkt+0x42>
    c508:	00016344 	.word	0x00016344
    c50c:	00016404 	.word	0x00016404
    c510:	00018ae3 	.word	0x00018ae3
    c514:	00017028 	.word	0x00017028
    c518:	00018ae8 	.word	0x00018ae8
    c51c:	00018b07 	.word	0x00018b07

0000c520 <net_tcp_release>:
{
    c520:	b570      	push	{r4, r5, r6, lr}
	if (!PART_OF_ARRAY(tcp_context, tcp)) {
    c522:	4604      	mov	r4, r0
    c524:	2800      	cmp	r0, #0
    c526:	d055      	beq.n	c5d4 <net_tcp_release+0xb4>
    c528:	4b2c      	ldr	r3, [pc, #176]	; (c5dc <net_tcp_release+0xbc>)
    c52a:	4298      	cmp	r0, r3
    c52c:	d352      	bcc.n	c5d4 <net_tcp_release+0xb4>
    c52e:	f503 6390 	add.w	r3, r3, #1152	; 0x480
    c532:	4298      	cmp	r0, r3
    c534:	d24e      	bcs.n	c5d4 <net_tcp_release+0xb4>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp->sent_list, pkt, tmp,
    c536:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
    c53a:	b1db      	cbz	r3, c574 <net_tcp_release+0x54>
    c53c:	f1b3 003c 	subs.w	r0, r3, #60	; 0x3c
    c540:	d018      	beq.n	c574 <net_tcp_release+0x54>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    c542:	681d      	ldr	r5, [r3, #0]
    c544:	b105      	cbz	r5, c548 <net_tcp_release+0x28>
    c546:	3d3c      	subs	r5, #60	; 0x3c
	parent->next = child;
    c548:	2600      	movs	r6, #0
Z_GENLIST_REMOVE(slist, snode)
    c54a:	4603      	mov	r3, r0
    c54c:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
    c550:	f853 2f3c 	ldr.w	r2, [r3, #60]!
	list->head = node;
    c554:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
Z_GENLIST_REMOVE(slist, snode)
    c558:	4299      	cmp	r1, r3
	list->tail = node;
    c55a:	bf08      	it	eq
    c55c:	f8c4 208c 	streq.w	r2, [r4, #140]	; 0x8c
	parent->next = child;
    c560:	63c6      	str	r6, [r0, #60]	; 0x3c
		net_pkt_unref(pkt);
    c562:	f007 fbf8 	bl	13d56 <net_pkt_unref>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp->sent_list, pkt, tmp,
    c566:	b12d      	cbz	r5, c574 <net_tcp_release+0x54>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    c568:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    c56a:	b103      	cbz	r3, c56e <net_tcp_release+0x4e>
    c56c:	3b3c      	subs	r3, #60	; 0x3c
{
    c56e:	4628      	mov	r0, r5
    c570:	461d      	mov	r5, r3
    c572:	e7ea      	b.n	c54a <net_tcp_release+0x2a>
	sem->count = 0U;
    c574:	2500      	movs	r5, #0
	k_delayed_work_cancel(&tcp->retry_timer);
    c576:	f104 0048 	add.w	r0, r4, #72	; 0x48
    c57a:	f009 fcb4 	bl	15ee6 <k_delayed_work_cancel>
    c57e:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
	k_delayed_work_cancel(&tcp->ack_timer);
    c582:	f104 0008 	add.w	r0, r4, #8
    c586:	f009 fcae 	bl	15ee6 <k_delayed_work_cancel>
	k_delayed_work_cancel(&tcp->fin_timer);
    c58a:	f104 0028 	add.w	r0, r4, #40	; 0x28
    c58e:	f009 fcaa 	bl	15ee6 <k_delayed_work_cancel>
	k_delayed_work_cancel(&tcp->timewait_timer);
    c592:	f104 0068 	add.w	r0, r4, #104	; 0x68
    c596:	f009 fca6 	bl	15ee6 <k_delayed_work_cancel>
	net_tcp_change_state(tcp, NET_TCP_CLOSED);
    c59a:	4629      	mov	r1, r5
    c59c:	4620      	mov	r0, r4
    c59e:	f008 faee 	bl	14b7e <net_tcp_change_state>
	tcp->context = NULL;
    c5a2:	6025      	str	r5, [r4, #0]
	__asm__ volatile(
    c5a4:	f04f 0320 	mov.w	r3, #32
    c5a8:	f3ef 8111 	mrs	r1, BASEPRI
    c5ac:	f383 8811 	msr	BASEPRI, r3
    c5b0:	f3bf 8f6f 	isb	sy
	tcp->flags &= ~(NET_TCP_IN_USE | NET_TCP_RECV_MSS_SET);
    c5b4:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
    c5b8:	f3c3 1247 	ubfx	r2, r3, #5, #8
    c5bc:	f022 0221 	bic.w	r2, r2, #33	; 0x21
    c5c0:	f362 134c 	bfi	r3, r2, #5, #8
    c5c4:	f8a4 30bc 	strh.w	r3, [r4, #188]	; 0xbc
	__asm__ volatile(
    c5c8:	f381 8811 	msr	BASEPRI, r1
    c5cc:	f3bf 8f6f 	isb	sy
	return 0;
    c5d0:	4628      	mov	r0, r5
}
    c5d2:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
    c5d4:	f06f 0015 	mvn.w	r0, #21
    c5d8:	e7fb      	b.n	c5d2 <net_tcp_release+0xb2>
    c5da:	bf00      	nop
    c5dc:	20003f78 	.word	0x20003f78

0000c5e0 <net_tcp_ack_received>:
{
    c5e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c5e4:	4b67      	ldr	r3, [pc, #412]	; (c784 <net_tcp_ack_received+0x1a4>)
	struct net_tcp *tcp = ctx->tcp;
    c5e6:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
 *
 * @return < 0 if seq1 < seq2, 0 if seq1 == seq2, > 0 if seq > seq2
 */
static inline s32_t net_tcp_seq_cmp(u32_t seq1, u32_t seq2)
{
	return (s32_t)(seq1 - seq2);
    c5e8:	4f67      	ldr	r7, [pc, #412]	; (c788 <net_tcp_ack_received+0x1a8>)
    c5ea:	1aff      	subs	r7, r7, r3
    c5ec:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
    c5f0:	1acb      	subs	r3, r1, r3
	if (net_tcp_seq_greater(ack, ctx->tcp->send_seq)) {
    c5f2:	2b00      	cmp	r3, #0
{
    c5f4:	b08b      	sub	sp, #44	; 0x2c
    c5f6:	4681      	mov	r9, r0
    c5f8:	468b      	mov	fp, r1
    c5fa:	f3c7 07c9 	ubfx	r7, r7, #3, #10
	if (net_tcp_seq_greater(ack, ctx->tcp->send_seq)) {
    c5fe:	f340 80a1 	ble.w	c744 <net_tcp_ack_received+0x164>
		NET_ERR("ctx %p: ACK for unsent data", ctx);
    c602:	2301      	movs	r3, #1
    c604:	f04f 0200 	mov.w	r2, #0
    c608:	f363 0207 	bfi	r2, r3, #0, #8
    c60c:	4601      	mov	r1, r0
    c60e:	f367 128f 	bfi	r2, r7, #6, #10
    c612:	485e      	ldr	r0, [pc, #376]	; (c78c <net_tcp_ack_received+0x1ac>)
    c614:	f005 fcbb 	bl	11f8e <log_1>
		return false;
    c618:	f04f 0800 	mov.w	r8, #0
}
    c61c:	4640      	mov	r0, r8
    c61e:	b00b      	add	sp, #44	; 0x2c
    c620:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    c624:	ab05      	add	r3, sp, #20
		pkt = CONTAINER_OF(head, struct net_pkt, sent_list);
    c626:	f1a4 063c 	sub.w	r6, r4, #60	; 0x3c
		NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    c62a:	9303      	str	r3, [sp, #12]
		net_pkt_cursor_init(pkt);
    c62c:	4630      	mov	r0, r6
		NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
    c62e:	2314      	movs	r3, #20
    c630:	9304      	str	r3, [sp, #16]
		net_pkt_cursor_init(pkt);
    c632:	f007 fc04 	bl	13e3e <net_pkt_cursor_init>
    c636:	7963      	ldrb	r3, [r4, #5]
		if (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +
    c638:	7921      	ldrb	r1, [r4, #4]
    c63a:	f043 0301 	orr.w	r3, r3, #1
    c63e:	7163      	strb	r3, [r4, #5]
    c640:	4630      	mov	r0, r6
    c642:	f007 fc73 	bl	13f2c <net_pkt_skip>
    c646:	b358      	cbz	r0, c6a0 <net_tcp_ack_received+0xc0>
Z_GENLIST_REMOVE(slist, snode)
    c648:	f8d5 208c 	ldr.w	r2, [r5, #140]	; 0x8c
    c64c:	6823      	ldr	r3, [r4, #0]
	list->head = node;
    c64e:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
Z_GENLIST_REMOVE(slist, snode)
    c652:	4294      	cmp	r4, r2
	list->tail = node;
    c654:	bf08      	it	eq
    c656:	f8c5 308c 	streq.w	r3, [r5, #140]	; 0x8c
	parent->next = child;
    c65a:	2300      	movs	r3, #0
    c65c:	6023      	str	r3, [r4, #0]
			net_pkt_unref(pkt);
    c65e:	4630      	mov	r0, r6
    c660:	f007 fb79 	bl	13d56 <net_pkt_unref>
Z_GENLIST_IS_EMPTY(slist)
    c664:	f8d5 4088 	ldr.w	r4, [r5, #136]	; 0x88
	while (!sys_slist_is_empty(list)) {
    c668:	2c00      	cmp	r4, #0
    c66a:	d1db      	bne.n	c624 <net_tcp_ack_received+0x44>
	if (valid_ack) {
    c66c:	f1b8 0f00 	cmp.w	r8, #0
    c670:	f000 8085 	beq.w	c77e <net_tcp_ack_received+0x19e>
		restart_timer(ctx->tcp);
    c674:	f8d9 403c 	ldr.w	r4, [r9, #60]	; 0x3c
	if (!sys_slist_is_empty(&tcp->sent_list)) {
    c678:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    c67c:	f104 0048 	add.w	r0, r4, #72	; 0x48
    c680:	2b00      	cmp	r3, #0
    c682:	d062      	beq.n	c74a <net_tcp_ack_received+0x16a>
		tcp->flags |= NET_TCP_RETRYING;
    c684:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
    c688:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    c68c:	f8a4 30bc 	strh.w	r3, [r4, #188]	; 0xbc
		tcp->retry_timeout_shift = 0U;
    c690:	f36f 0304 	bfc	r3, #0, #5
    c694:	f884 30bc 	strb.w	r3, [r4, #188]	; 0xbc
		k_delayed_work_submit(&tcp->retry_timer, retry_timeout(tcp));
    c698:	21c8      	movs	r1, #200	; 0xc8
    c69a:	f7ff fe13 	bl	c2c4 <k_delayed_work_submit>
    c69e:	e7bd      	b.n	c61c <net_tcp_ack_received+0x3c>
		tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt,
    c6a0:	a903      	add	r1, sp, #12
    c6a2:	4630      	mov	r0, r6
    c6a4:	f7ff f87c 	bl	b7a0 <net_pkt_get_data>
		if (!tcp_hdr) {
    c6a8:	b968      	cbnz	r0, c6c6 <net_tcp_ack_received+0xe6>
			NET_ERR("pkt %p has no TCP header", pkt);
    c6aa:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
    c6ae:	f043 0301 	orr.w	r3, r3, #1
    c6b2:	f363 0a07 	bfi	sl, r3, #0, #8
    c6b6:	f367 1a8f 	bfi	sl, r7, #6, #10
    c6ba:	4652      	mov	r2, sl
    c6bc:	4631      	mov	r1, r6
    c6be:	4834      	ldr	r0, [pc, #208]	; (c790 <net_tcp_ack_received+0x1b0>)
    c6c0:	f005 fc65 	bl	11f8e <log_1>
    c6c4:	e7c0      	b.n	c648 <net_tcp_ack_received+0x68>
	return net_pkt_skip(pkt, access->size);
    c6c6:	9904      	ldr	r1, [sp, #16]
    c6c8:	9000      	str	r0, [sp, #0]
    c6ca:	4630      	mov	r0, r6
    c6cc:	f007 fc2e 	bl	13f2c <net_pkt_skip>
		seq_len = net_pkt_remaining_data(pkt);
    c6d0:	4630      	mov	r0, r6
    c6d2:	f007 fca5 	bl	14020 <net_pkt_remaining_data>
		if (tcp_hdr->flags & NET_TCP_SYN) {
    c6d6:	9a00      	ldr	r2, [sp, #0]
    c6d8:	7b53      	ldrb	r3, [r2, #13]
		seq_len = net_pkt_remaining_data(pkt);
    c6da:	4601      	mov	r1, r0
		if (tcp_hdr->flags & NET_TCP_SYN) {
    c6dc:	0798      	lsls	r0, r3, #30
			seq_len += 1U;
    c6de:	bf48      	it	mi
    c6e0:	3101      	addmi	r1, #1
		if (tcp_hdr->flags & NET_TCP_FIN) {
    c6e2:	f013 0301 	ands.w	r3, r3, #1
			seq_len += 1U;
    c6e6:	bf18      	it	ne
    c6e8:	3101      	addne	r1, #1
		last_seq = sys_get_be32(tcp_hdr->seq) + seq_len - 1;
    c6ea:	1d10      	adds	r0, r2, #4
    c6ec:	e9cd 1300 	strd	r1, r3, [sp]
    c6f0:	f008 f80e 	bl	14710 <sys_get_be32>
    c6f4:	9900      	ldr	r1, [sp, #0]
    c6f6:	f10b 0201 	add.w	r2, fp, #1
    c6fa:	1a51      	subs	r1, r2, r1
    c6fc:	1a09      	subs	r1, r1, r0
		if (!net_tcp_seq_greater(ack, last_seq)) {
    c6fe:	2900      	cmp	r1, #0
    c700:	ddb4      	ble.n	c66c <net_tcp_ack_received+0x8c>
		if (tcp_hdr->flags & NET_TCP_FIN) {
    c702:	9b01      	ldr	r3, [sp, #4]
    c704:	b14b      	cbz	r3, c71a <net_tcp_ack_received+0x13a>
 * @param tcp TCP context
 */
#if defined(CONFIG_NET_TCP)
static inline enum net_tcp_state net_tcp_get_state(const struct net_tcp *tcp)
{
	return (enum net_tcp_state)tcp->state;
    c706:	f8d5 30bc 	ldr.w	r3, [r5, #188]	; 0xbc
    c70a:	f3c3 3343 	ubfx	r3, r3, #13, #4
			if (s == NET_TCP_FIN_WAIT_1) {
    c70e:	2b07      	cmp	r3, #7
    c710:	d114      	bne.n	c73c <net_tcp_ack_received+0x15c>
				net_tcp_change_state(tcp, NET_TCP_FIN_WAIT_2);
    c712:	2108      	movs	r1, #8
				net_tcp_change_state(tcp, NET_TCP_TIME_WAIT);
    c714:	4628      	mov	r0, r5
    c716:	f008 fa32 	bl	14b7e <net_tcp_change_state>
Z_GENLIST_REMOVE(slist, snode)
    c71a:	f8d5 208c 	ldr.w	r2, [r5, #140]	; 0x8c
    c71e:	6823      	ldr	r3, [r4, #0]
	list->head = node;
    c720:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
Z_GENLIST_REMOVE(slist, snode)
    c724:	4294      	cmp	r4, r2
	list->tail = node;
    c726:	bf08      	it	eq
    c728:	f8c5 308c 	streq.w	r3, [r5, #140]	; 0x8c
	parent->next = child;
    c72c:	2300      	movs	r3, #0
    c72e:	6023      	str	r3, [r4, #0]
		net_pkt_unref(pkt);
    c730:	4630      	mov	r0, r6
    c732:	f007 fb10 	bl	13d56 <net_pkt_unref>
		valid_ack = true;
    c736:	f04f 0801 	mov.w	r8, #1
    c73a:	e793      	b.n	c664 <net_tcp_ack_received+0x84>
			} else if (s == NET_TCP_CLOSING) {
    c73c:	2b0a      	cmp	r3, #10
    c73e:	d1ec      	bne.n	c71a <net_tcp_ack_received+0x13a>
				net_tcp_change_state(tcp, NET_TCP_TIME_WAIT);
    c740:	2109      	movs	r1, #9
    c742:	e7e7      	b.n	c714 <net_tcp_ack_received+0x134>
	bool valid_ack = false;
    c744:	f04f 0800 	mov.w	r8, #0
    c748:	e78c      	b.n	c664 <net_tcp_ack_received+0x84>
			(tcp->fin_sent && tcp->fin_rcvd)) {
    c74a:	f894 30be 	ldrb.w	r3, [r4, #190]	; 0xbe
	} else if (CONFIG_NET_TCP_TIME_WAIT_DELAY != 0 &&
    c74e:	f003 0306 	and.w	r3, r3, #6
    c752:	2b06      	cmp	r3, #6
    c754:	d106      	bne.n	c764 <net_tcp_ack_received+0x184>
		k_delayed_work_submit(&tcp->retry_timer,
    c756:	21fa      	movs	r1, #250	; 0xfa
    c758:	f7ff fdb4 	bl	c2c4 <k_delayed_work_submit>
		net_context_ref(tcp->context);
    c75c:	6820      	ldr	r0, [r4, #0]
    c75e:	f006 feb2 	bl	134c6 <net_context_ref>
    c762:	e75b      	b.n	c61c <net_tcp_ack_received+0x3c>
		k_delayed_work_cancel(&tcp->retry_timer);
    c764:	f009 fbbf 	bl	15ee6 <k_delayed_work_cancel>
		tcp->flags &= ~NET_TCP_RETRYING;
    c768:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
    c76c:	f3c3 1247 	ubfx	r2, r3, #5, #8
    c770:	f022 0210 	bic.w	r2, r2, #16
    c774:	f362 134c 	bfi	r3, r2, #5, #8
    c778:	f8a4 30bc 	strh.w	r3, [r4, #188]	; 0xbc
    c77c:	e74e      	b.n	c61c <net_tcp_ack_received+0x3c>
	return true;
    c77e:	f04f 0801 	mov.w	r8, #1
    c782:	e74b      	b.n	c61c <net_tcp_ack_received+0x3c>
    c784:	00016344 	.word	0x00016344
    c788:	00016404 	.word	0x00016404
    c78c:	00018a92 	.word	0x00018a92
    c790:	00018aae 	.word	0x00018aae

0000c794 <tcp_established>:
 *				    union net_ip_header *ip_hdr,
 *				    union net_proto_header *proto_hdr,
 *				    struct net_pkt *pkt,
 *                                  void *user_data)
 */
NET_CONN_CB(tcp_established)
    c794:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c798:	b087      	sub	sp, #28
    c79a:	4681      	mov	r9, r0
    c79c:	9c10      	ldr	r4, [sp, #64]	; 0x40
    c79e:	9204      	str	r2, [sp, #16]
    c7a0:	4620      	mov	r0, r4
    c7a2:	469b      	mov	fp, r3
    c7a4:	460f      	mov	r7, r1
    c7a6:	f006 fe8e 	bl	134c6 <net_context_ref>
	struct net_tcp_hdr *tcp_hdr = proto_hdr->tcp;
	enum net_verdict ret = NET_OK;
	u8_t tcp_flags;
	u16_t data_len;

	k_mutex_lock(&context->lock, K_FOREVER);
    c7aa:	f104 0308 	add.w	r3, r4, #8
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
    c7ae:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    c7b2:	4618      	mov	r0, r3
	struct net_tcp_hdr *tcp_hdr = proto_hdr->tcp;
    c7b4:	f8db 8000 	ldr.w	r8, [fp]
	k_mutex_lock(&context->lock, K_FOREVER);
    c7b8:	9303      	str	r3, [sp, #12]
    c7ba:	f002 fb57 	bl	ee6c <z_impl_k_mutex_lock>

	NET_ASSERT(context && context->tcp);

	if (net_tcp_get_state(context->tcp) < NET_TCP_ESTABLISHED) {
    c7be:	f8d4 a03c 	ldr.w	sl, [r4, #60]	; 0x3c
    c7c2:	f8da 00bc 	ldr.w	r0, [sl, #188]	; 0xbc
    c7c6:	f3c0 3043 	ubfx	r0, r0, #13, #4
    c7ca:	2803      	cmp	r0, #3
    c7cc:	d81a      	bhi.n	c804 <tcp_established+0x70>
		NET_ERR("Context %p in wrong state %d",
    c7ce:	2201      	movs	r2, #1
    c7d0:	f04f 0300 	mov.w	r3, #0
    c7d4:	f362 0307 	bfi	r3, r2, #0, #8
    c7d8:	4978      	ldr	r1, [pc, #480]	; (c9bc <tcp_established+0x228>)
    c7da:	4a79      	ldr	r2, [pc, #484]	; (c9c0 <tcp_established+0x22c>)
    c7dc:	1a89      	subs	r1, r1, r2
    c7de:	08c9      	lsrs	r1, r1, #3
    c7e0:	f361 138f 	bfi	r3, r1, #6, #10
    c7e4:	4602      	mov	r2, r0
    c7e6:	4621      	mov	r1, r4
    c7e8:	4876      	ldr	r0, [pc, #472]	; (c9c4 <tcp_established+0x230>)
    c7ea:	f005 fbe4 	bl	11fb6 <log_2>
		/* RFC793 specifies that "highest" (i.e. current from our PoV)
		 * ack # value can/should be sent, so we just force resend.
		 */
resend_ack:
		send_ack(context, &conn->remote_addr, true);
		ret = NET_DROP;
    c7ee:	2602      	movs	r6, #2
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    c7f0:	9803      	ldr	r0, [sp, #12]
    c7f2:	f002 fbab 	bl	ef4c <z_impl_k_mutex_unlock>
NET_CONN_CB(tcp_established)
    c7f6:	4620      	mov	r0, r4
    c7f8:	f006 fe73 	bl	134e2 <net_context_unref>
    c7fc:	4630      	mov	r0, r6
    c7fe:	b007      	add	sp, #28
    c800:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (net_tcp_seq_cmp(sys_get_be32(tcp_hdr->seq),
    c804:	f108 0004 	add.w	r0, r8, #4
    c808:	f007 ff82 	bl	14710 <sys_get_be32>
    c80c:	f8da 3094 	ldr.w	r3, [sl, #148]	; 0x94
    c810:	1ac3      	subs	r3, r0, r3
    c812:	2b00      	cmp	r3, #0
    c814:	da05      	bge.n	c822 <tcp_established+0x8e>
		send_ack(context, &conn->remote_addr, true);
    c816:	2201      	movs	r2, #1
    c818:	4649      	mov	r1, r9
    c81a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    c81c:	f008 fa6b 	bl	14cf6 <send_ack.isra.37>
    c820:	e7e5      	b.n	c7ee <tcp_established+0x5a>
		goto unlock;
	}

	if (net_tcp_seq_cmp(sys_get_be32(tcp_hdr->seq),
    c822:	d1e4      	bne.n	c7ee <tcp_established+0x5a>
	tcp_flags = NET_TCP_FLAGS(tcp_hdr);
    c824:	f898 500d 	ldrb.w	r5, [r8, #13]

	/*
	 * If we receive RST here, we close the socket. See RFC 793 chapter
	 * called "Reset Processing" for details.
	 */
	if (tcp_flags & NET_TCP_RST) {
    c828:	9305      	str	r3, [sp, #20]
    c82a:	f015 0604 	ands.w	r6, r5, #4
    c82e:	d016      	beq.n	c85e <tcp_established+0xca>
		/* We only accept RST packet that has valid seq field. */
		if (!net_tcp_validate_seq(context->tcp, tcp_hdr)) {
    c830:	4641      	mov	r1, r8
    c832:	4650      	mov	r0, sl
    c834:	f008 fb1e 	bl	14e74 <net_tcp_validate_seq>
    c838:	2800      	cmp	r0, #0
    c83a:	d0d8      	beq.n	c7ee <tcp_established+0x5a>

		net_stats_update_tcp_seg_rst(net_pkt_iface(pkt));

		net_tcp_print_recv_info("RST", pkt, tcp_hdr->src_port);

		if (context->recv_cb) {
    c83c:	6b25      	ldr	r5, [r4, #48]	; 0x30
    c83e:	b155      	cbz	r5, c856 <tcp_established+0xc2>
			context->recv_cb(context, NULL, NULL, NULL, -ECONNRESET,
    c840:	f8da 2004 	ldr.w	r2, [sl, #4]
    c844:	9b05      	ldr	r3, [sp, #20]
    c846:	9201      	str	r2, [sp, #4]
    c848:	f06f 0267 	mvn.w	r2, #103	; 0x67
    c84c:	9200      	str	r2, [sp, #0]
    c84e:	4619      	mov	r1, r3
    c850:	461a      	mov	r2, r3
    c852:	4620      	mov	r0, r4
    c854:	47a8      	blx	r5
					 context->tcp->recv_user_data);
		}

		net_context_unref(context);
    c856:	4620      	mov	r0, r4
    c858:	f006 fe43 	bl	134e2 <net_context_unref>

		ret = NET_DROP;
		goto unlock;
    c85c:	e7c7      	b.n	c7ee <tcp_established+0x5a>
	}

	/* Handle TCP state transition */
	if (tcp_flags & NET_TCP_ACK) {
    c85e:	06eb      	lsls	r3, r5, #27
    c860:	d513      	bpl.n	c88a <tcp_established+0xf6>
		if (!net_tcp_ack_received(context,
    c862:	f108 0008 	add.w	r0, r8, #8
    c866:	f007 ff53 	bl	14710 <sys_get_be32>
    c86a:	4601      	mov	r1, r0
    c86c:	4620      	mov	r0, r4
    c86e:	f7ff feb7 	bl	c5e0 <net_tcp_ack_received>
    c872:	2800      	cmp	r0, #0
    c874:	d0bb      	beq.n	c7ee <tcp_established+0x5a>

		/* TCP state might be changed after maintaining the sent pkt
		 * list, e.g., an ack of FIN is received.
		 */

		if (net_tcp_get_state(context->tcp)
    c876:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    c878:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
    c87c:	f3c3 3343 	ubfx	r3, r3, #13, #4
    c880:	2b07      	cmp	r3, #7
    c882:	d13b      	bne.n	c8fc <tcp_established+0x168>
			   == NET_TCP_FIN_WAIT_1) {
			/* Active close: step to FIN_WAIT_2 */
			net_tcp_change_state(context->tcp, NET_TCP_FIN_WAIT_2);
    c884:	2108      	movs	r1, #8
    c886:	f008 f97a 	bl	14b7e <net_tcp_change_state>
			net_pkt_unref(pkt);
			goto clean_up;
		}
	}

	if (tcp_flags & NET_TCP_FIN) {
    c88a:	f015 0301 	ands.w	r3, r5, #1
    c88e:	469a      	mov	sl, r3
    c890:	d016      	beq.n	c8c0 <tcp_established+0x12c>
		if (net_tcp_get_state(context->tcp) == NET_TCP_ESTABLISHED) {
    c892:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    c894:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
    c898:	f3c3 3343 	ubfx	r3, r3, #13, #4
    c89c:	2b04      	cmp	r3, #4
    c89e:	d155      	bne.n	c94c <tcp_established+0x1b8>
			/* Passive close: step to CLOSE_WAIT */
			net_tcp_change_state(context->tcp, NET_TCP_CLOSE_WAIT);
    c8a0:	2105      	movs	r1, #5
    c8a2:	f008 f96c 	bl	14b7e <net_tcp_change_state>
			/* We should receive ACK next in order to get rid of
			 * LAST_ACK state that we are entering in a short while.
			 * But we need to be prepared to NOT to receive it as
			 * otherwise the connection would be stuck forever.
			 */
			k_delayed_work_submit(&context->tcp->ack_timer,
    c8a6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    c8a8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    c8ac:	3008      	adds	r0, #8
    c8ae:	f7ff fd09 	bl	c2c4 <k_delayed_work_submit>
			k_delayed_work_cancel(&context->tcp->fin_timer);
			/* Active close: step to TIME_WAIT */
			net_tcp_change_state(context->tcp, NET_TCP_TIME_WAIT);
		}

		context->tcp->fin_rcvd = 1U;
    c8b2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    c8b4:	f892 30be 	ldrb.w	r3, [r2, #190]	; 0xbe
    c8b8:	f043 0304 	orr.w	r3, r3, #4
    c8bc:	f882 30be 	strb.w	r3, [r2, #190]	; 0xbe
	}

	data_len = net_pkt_remaining_data(pkt);
    c8c0:	4638      	mov	r0, r7
    c8c2:	f007 fbad 	bl	14020 <net_pkt_remaining_data>
	return tcp->recv_wnd;
    c8c6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    c8c8:	f8b2 20b8 	ldrh.w	r2, [r2, #184]	; 0xb8
	data_len = net_pkt_remaining_data(pkt);
    c8cc:	b285      	uxth	r5, r0
	if (data_len > net_tcp_get_recv_wnd(context->tcp)) {
    c8ce:	4295      	cmp	r5, r2
    c8d0:	462b      	mov	r3, r5
    c8d2:	d945      	bls.n	c960 <tcp_established+0x1cc>
		 * for net_tcp_get_recv_wnd(context->tcp) == 0, but
		 * given the if above, we know that if data_len == 1,
		 * then net_tcp_get_recv_wnd(context->tcp) can be only 0
		 * here.
		 */
		if (data_len == 1U) {
    c8d4:	2d01      	cmp	r5, #1
    c8d6:	d09e      	beq.n	c816 <tcp_established+0x82>
			goto resend_ack;
		}

		NET_ERR("Context %p: overflow of recv window (%d vs %d), "
    c8d8:	2101      	movs	r1, #1
    c8da:	f04f 0000 	mov.w	r0, #0
    c8de:	f361 0007 	bfi	r0, r1, #0, #8
    c8e2:	4d37      	ldr	r5, [pc, #220]	; (c9c0 <tcp_established+0x22c>)
    c8e4:	4935      	ldr	r1, [pc, #212]	; (c9bc <tcp_established+0x228>)
    c8e6:	1b49      	subs	r1, r1, r5
    c8e8:	08c9      	lsrs	r1, r1, #3
    c8ea:	f361 108f 	bfi	r0, r1, #6, #10
    c8ee:	f8ad 0000 	strh.w	r0, [sp]
    c8f2:	4621      	mov	r1, r4
    c8f4:	4834      	ldr	r0, [pc, #208]	; (c9c8 <tcp_established+0x234>)
    c8f6:	f005 fb76 	bl	11fe6 <log_3>
			"pkt dropped",
			context, net_tcp_get_recv_wnd(context->tcp), data_len);
		ret = NET_DROP;
		goto unlock;
    c8fa:	e778      	b.n	c7ee <tcp_established+0x5a>
		} else if (net_tcp_get_state(context->tcp)
    c8fc:	2b06      	cmp	r3, #6
    c8fe:	d1c4      	bne.n	c88a <tcp_established+0xf6>
			net_tcp_change_state(context->tcp, NET_TCP_CLOSED);
    c900:	4631      	mov	r1, r6
    c902:	f008 f93c 	bl	14b7e <net_tcp_change_state>
			net_pkt_unref(pkt);
    c906:	4638      	mov	r0, r7
    c908:	f007 fa25 	bl	13d56 <net_pkt_unref>
	}

	send_ack(context, &conn->remote_addr, false);

clean_up:
	if (net_tcp_get_state(context->tcp) == NET_TCP_TIME_WAIT) {
    c90c:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    c90e:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
    c912:	f3c3 3343 	ubfx	r3, r3, #13, #4
    c916:	2b09      	cmp	r3, #9
    c918:	d103      	bne.n	c922 <tcp_established+0x18e>
		k_delayed_work_submit(&context->tcp->timewait_timer,
    c91a:	21fa      	movs	r1, #250	; 0xfa
    c91c:	3068      	adds	r0, #104	; 0x68
    c91e:	f7ff fcd1 	bl	c2c4 <k_delayed_work_submit>
				      CONFIG_NET_TCP_TIME_WAIT_DELAY);
	}

	if (net_tcp_get_state(context->tcp) == NET_TCP_CLOSED) {
    c922:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    c924:	f8d2 30bc 	ldr.w	r3, [r2, #188]	; 0xbc
    c928:	f3c3 3343 	ubfx	r3, r3, #13, #4
    c92c:	2b00      	cmp	r3, #0
    c92e:	f47f af5f 	bne.w	c7f0 <tcp_established+0x5c>
		if (context->recv_cb) {
    c932:	6b25      	ldr	r5, [r4, #48]	; 0x30
    c934:	b135      	cbz	r5, c944 <tcp_established+0x1b0>
			context->recv_cb(context, NULL, NULL, NULL, 0,
    c936:	6852      	ldr	r2, [r2, #4]
    c938:	4619      	mov	r1, r3
    c93a:	e9cd 3200 	strd	r3, r2, [sp]
    c93e:	4620      	mov	r0, r4
    c940:	461a      	mov	r2, r3
    c942:	47a8      	blx	r5
					 context->tcp->recv_user_data);
		}

		net_context_unref(context);
    c944:	4620      	mov	r0, r4
    c946:	f006 fdcc 	bl	134e2 <net_context_unref>
    c94a:	e751      	b.n	c7f0 <tcp_established+0x5c>
		} else if (net_tcp_get_state(context->tcp)
    c94c:	2b08      	cmp	r3, #8
    c94e:	d1b0      	bne.n	c8b2 <tcp_established+0x11e>
			k_delayed_work_cancel(&context->tcp->fin_timer);
    c950:	3028      	adds	r0, #40	; 0x28
    c952:	f009 fac8 	bl	15ee6 <k_delayed_work_cancel>
			net_tcp_change_state(context->tcp, NET_TCP_TIME_WAIT);
    c956:	2109      	movs	r1, #9
    c958:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    c95a:	f008 f910 	bl	14b7e <net_tcp_change_state>
    c95e:	e7a8      	b.n	c8b2 <tcp_established+0x11e>
	if (data_len > 0) {
    c960:	b32d      	cbz	r5, c9ae <tcp_established+0x21a>
	u8_t offset = tcp_hdr->offset >> 4;
    c962:	f898 600c 	ldrb.w	r6, [r8, #12]
    c966:	0936      	lsrs	r6, r6, #4
	if ((offset << 2) > sizeof(struct net_tcp_hdr)) {
    c968:	00b6      	lsls	r6, r6, #2
    c96a:	2e14      	cmp	r6, #20
    c96c:	dd08      	ble.n	c980 <tcp_established+0x1ec>
		net_pkt_skip(pkt, (offset << 2) -
    c96e:	f1a6 0114 	sub.w	r1, r6, #20
    c972:	4638      	mov	r0, r7
		data_len -= (offset << 2) - sizeof(struct net_tcp_hdr);
    c974:	f1c6 0614 	rsb	r6, r6, #20
		net_pkt_skip(pkt, (offset << 2) -
    c978:	f007 fad8 	bl	13f2c <net_pkt_skip>
		data_len -= (offset << 2) - sizeof(struct net_tcp_hdr);
    c97c:	4435      	add	r5, r6
    c97e:	b2ad      	uxth	r5, r5
		ret = net_context_packet_received(conn, pkt, ip_hdr, proto_hdr,
    c980:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c982:	9a04      	ldr	r2, [sp, #16]
    c984:	685b      	ldr	r3, [r3, #4]
    c986:	9300      	str	r3, [sp, #0]
    c988:	4639      	mov	r1, r7
    c98a:	465b      	mov	r3, fp
    c98c:	4648      	mov	r0, r9
    c98e:	f7fe f887 	bl	aaa0 <net_context_packet_received>
    c992:	4606      	mov	r6, r0
	context->tcp->send_ack += data_len;
    c994:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    c996:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
    c99a:	441d      	add	r5, r3
	if (tcp_flags & NET_TCP_FIN) {
    c99c:	4653      	mov	r3, sl
    c99e:	b953      	cbnz	r3, c9b6 <tcp_established+0x222>
		context->tcp->send_ack += 1U;
    c9a0:	f8c0 5094 	str.w	r5, [r0, #148]	; 0x94
	send_ack(context, &conn->remote_addr, false);
    c9a4:	2200      	movs	r2, #0
    c9a6:	4649      	mov	r1, r9
    c9a8:	f008 f9a5 	bl	14cf6 <send_ack.isra.37>
    c9ac:	e7ae      	b.n	c90c <tcp_established+0x178>
		net_pkt_unref(pkt);
    c9ae:	4638      	mov	r0, r7
    c9b0:	f007 f9d1 	bl	13d56 <net_pkt_unref>
    c9b4:	e7ee      	b.n	c994 <tcp_established+0x200>
		context->tcp->send_ack += 1U;
    c9b6:	3501      	adds	r5, #1
    c9b8:	e7f2      	b.n	c9a0 <tcp_established+0x20c>
    c9ba:	bf00      	nop
    c9bc:	00016404 	.word	0x00016404
    c9c0:	00016344 	.word	0x00016344
    c9c4:	00018b4a 	.word	0x00018b4a
    c9c8:	00018b67 	.word	0x00018b67

0000c9cc <tcp_synack_received>:
 *					struct net_pkt *pkt,
 *				        union net_ip_header *ip_hdr,
 *				        union net_proto_header *proto_hdr,
 *					void *user_data)
 */
NET_CONN_CB(tcp_synack_received)
    c9cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c9d0:	b08a      	sub	sp, #40	; 0x28
    c9d2:	4690      	mov	r8, r2
    c9d4:	9c10      	ldr	r4, [sp, #64]	; 0x40
    c9d6:	4620      	mov	r0, r4
    c9d8:	461d      	mov	r5, r3
    c9da:	460e      	mov	r6, r1
    c9dc:	f006 fd73 	bl	134c6 <net_context_ref>
    c9e0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c9e2:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
	struct net_tcp_hdr *tcp_hdr = proto_hdr->tcp;
	int ret;

	NET_ASSERT(context && context->tcp);

	switch (net_tcp_get_state(context->tcp)) {
    c9e6:	f3c2 3243 	ubfx	r2, r2, #13, #4
    c9ea:	2a02      	cmp	r2, #2
    c9ec:	d16d      	bne.n	caca <tcp_synack_received+0xfe>
	context->iface = net_if_get_by_iface(iface);
    c9ee:	6a70      	ldr	r0, [r6, #36]	; 0x24
NET_CONN_CB(tcp_synack_received)
    c9f0:	682d      	ldr	r5, [r5, #0]
    c9f2:	f7fe fd29 	bl	b448 <net_if_get_by_iface>
    c9f6:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
	pkt->context = ctx;
    c9fa:	6234      	str	r4, [r6, #32]

	net_pkt_set_context(pkt, context);

	NET_ASSERT(net_pkt_iface(pkt));

	if (NET_TCP_FLAGS(tcp_hdr) & NET_TCP_RST) {
    c9fc:	7b6f      	ldrb	r7, [r5, #13]
    c9fe:	077a      	lsls	r2, r7, #29
    ca00:	d513      	bpl.n	ca2a <tcp_synack_received+0x5e>
		/* We only accept RST packet that has valid seq field. */
		if (!net_tcp_validate_seq(context->tcp, tcp_hdr)) {
    ca02:	6be6      	ldr	r6, [r4, #60]	; 0x3c
    ca04:	4629      	mov	r1, r5
    ca06:	4630      	mov	r0, r6
    ca08:	f008 fa34 	bl	14e74 <net_tcp_validate_seq>
    ca0c:	2800      	cmp	r0, #0
    ca0e:	d05c      	beq.n	caca <tcp_synack_received+0xfe>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    ca10:	f106 00a0 	add.w	r0, r6, #160	; 0xa0
    ca14:	f002 fdf8 	bl	f608 <z_impl_k_sem_give>

		net_stats_update_tcp_seg_rst(net_pkt_iface(pkt));

		k_sem_give(&context->tcp->connect_wait);

		if (context->connect_cb) {
    ca18:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    ca1a:	2b00      	cmp	r3, #0
    ca1c:	d055      	beq.n	caca <tcp_synack_received+0xfe>
			context->connect_cb(context, -ECONNREFUSED,
    ca1e:	6822      	ldr	r2, [r4, #0]
    ca20:	f06f 016e 	mvn.w	r1, #110	; 0x6e
		send_ack(context, &remote_addr, false);

		k_sem_give(&context->tcp->connect_wait);

		if (context->connect_cb) {
			context->connect_cb(context, 0, context->user_data);
    ca24:	4620      	mov	r0, r4
    ca26:	4798      	blx	r3
    ca28:	e04f      	b.n	caca <tcp_synack_received+0xfe>
	if (NET_TCP_FLAGS(tcp_hdr) & NET_TCP_SYN) {
    ca2a:	07bb      	lsls	r3, r7, #30
    ca2c:	d506      	bpl.n	ca3c <tcp_synack_received+0x70>
			sys_get_be32(tcp_hdr->seq) + 1;
    ca2e:	1d28      	adds	r0, r5, #4
    ca30:	f007 fe6e 	bl	14710 <sys_get_be32>
		context->tcp->send_ack =
    ca34:	6be3      	ldr	r3, [r4, #60]	; 0x3c
			sys_get_be32(tcp_hdr->seq) + 1;
    ca36:	3001      	adds	r0, #1
		context->tcp->send_ack =
    ca38:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	if (NET_TCP_FLAGS(tcp_hdr) == (NET_TCP_SYN | NET_TCP_ACK)) {
    ca3c:	f007 073f 	and.w	r7, r7, #63	; 0x3f
    ca40:	2f12      	cmp	r7, #18
    ca42:	d142      	bne.n	caca <tcp_synack_received+0xfe>
	return pkt->family;
    ca44:	f896 3043 	ldrb.w	r3, [r6, #67]	; 0x43
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
    ca48:	f3c3 0342 	ubfx	r3, r3, #1, #3
    ca4c:	2b01      	cmp	r3, #1
    ca4e:	d117      	bne.n	ca80 <tcp_synack_received+0xb4>
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
    ca50:	f8d8 1000 	ldr.w	r1, [r8]
		port = tcp_hdr->src_port;
    ca54:	882a      	ldrh	r2, [r5, #0]
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
    ca56:	68c9      	ldr	r1, [r1, #12]
    ca58:	9109      	str	r1, [sp, #36]	; 0x24
		addr->sa_family = AF_INET;
    ca5a:	f8ad 3020 	strh.w	r3, [sp, #32]
    ca5e:	f896 3043 	ldrb.w	r3, [r6, #67]	; 0x43
		addr4->sin_port = port;
    ca62:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
    ca66:	f3c3 0342 	ubfx	r3, r3, #1, #3
    ca6a:	2b01      	cmp	r3, #1
    ca6c:	d108      	bne.n	ca80 <tcp_synack_received+0xb4>
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->dst);
    ca6e:	f8d8 1000 	ldr.w	r1, [r8]
		port = tcp_hdr->dst_port;
    ca72:	886a      	ldrh	r2, [r5, #2]
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->dst);
    ca74:	6909      	ldr	r1, [r1, #16]
    ca76:	9107      	str	r1, [sp, #28]
		addr4->sin_port = port;
    ca78:	f8ad 201a 	strh.w	r2, [sp, #26]
		addr->sa_family = AF_INET;
    ca7c:	f8ad 3018 	strh.w	r3, [sp, #24]
	return net_conn_unregister(handle);
    ca80:	4627      	mov	r7, r4
    ca82:	f857 0f2c 	ldr.w	r0, [r7, #44]!
    ca86:	f7ff fa39 	bl	befc <net_conn_unregister>
				       ntohs(tcp_hdr->dst_port),
    ca8a:	886b      	ldrh	r3, [r5, #2]
				       ntohs(tcp_hdr->src_port),
    ca8c:	8828      	ldrh	r0, [r5, #0]
	return net_conn_register(IPPROTO_TCP, family, remote_addr, local_addr,
    ca8e:	4a20      	ldr	r2, [pc, #128]	; (cb10 <tcp_synack_received+0x144>)
    ca90:	f896 1043 	ldrb.w	r1, [r6, #67]	; 0x43
    ca94:	9202      	str	r2, [sp, #8]
				       ntohs(tcp_hdr->dst_port),
    ca96:	021a      	lsls	r2, r3, #8
    ca98:	ea42 2213 	orr.w	r2, r2, r3, lsr #8
				       ntohs(tcp_hdr->src_port),
    ca9c:	0203      	lsls	r3, r0, #8
    ca9e:	ea43 2310 	orr.w	r3, r3, r0, lsr #8
    caa2:	b292      	uxth	r2, r2
    caa4:	b29b      	uxth	r3, r3
    caa6:	9201      	str	r2, [sp, #4]
    caa8:	9300      	str	r3, [sp, #0]
    caaa:	e9cd 4703 	strd	r4, r7, [sp, #12]
    caae:	ab06      	add	r3, sp, #24
    cab0:	aa08      	add	r2, sp, #32
    cab2:	f3c1 0142 	ubfx	r1, r1, #1, #3
    cab6:	2006      	movs	r0, #6
    cab8:	f7ff fa38 	bl	bf2c <net_conn_register>
		if (ret < 0) {
    cabc:	2800      	cmp	r0, #0
    cabe:	da0b      	bge.n	cad8 <tcp_synack_received+0x10c>
			send_reset(context, &local_addr, &remote_addr);
    cac0:	aa08      	add	r2, sp, #32
    cac2:	a906      	add	r1, sp, #24
    cac4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    cac6:	f007 ffb2 	bl	14a2e <send_reset.isra.33>
NET_CONN_CB(tcp_synack_received)
    caca:	4620      	mov	r0, r4
    cacc:	f006 fd09 	bl	134e2 <net_context_unref>
    cad0:	2002      	movs	r0, #2
    cad2:	b00a      	add	sp, #40	; 0x28
    cad4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_tcp_change_state(context->tcp, NET_TCP_ESTABLISHED);
    cad8:	2104      	movs	r1, #4
    cada:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    cadc:	f008 f84f 	bl	14b7e <net_tcp_change_state>
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
    cae0:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
		send_ack(context, &remote_addr, false);
    cae4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    cae6:	f023 0306 	bic.w	r3, r3, #6
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
    caea:	f043 0304 	orr.w	r3, r3, #4
    caee:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
    caf2:	2200      	movs	r2, #0
    caf4:	a908      	add	r1, sp, #32
    caf6:	f008 f8fe 	bl	14cf6 <send_ack.isra.37>
		k_sem_give(&context->tcp->connect_wait);
    cafa:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    cafc:	30a0      	adds	r0, #160	; 0xa0
    cafe:	f002 fd83 	bl	f608 <z_impl_k_sem_give>
		if (context->connect_cb) {
    cb02:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cb04:	2b00      	cmp	r3, #0
    cb06:	d0e0      	beq.n	caca <tcp_synack_received+0xfe>
			context->connect_cb(context, 0, context->user_data);
    cb08:	6822      	ldr	r2, [r4, #0]
    cb0a:	2100      	movs	r1, #0
    cb0c:	e78a      	b.n	ca24 <tcp_synack_received+0x58>
    cb0e:	bf00      	nop
    cb10:	0000c795 	.word	0x0000c795

0000cb14 <net_tcp_parse_opts>:
{
    cb14:	b573      	push	{r0, r1, r4, r5, r6, lr}
    cb16:	4605      	mov	r5, r0
    cb18:	460c      	mov	r4, r1
    cb1a:	4616      	mov	r6, r2
	while (opt_totlen) {
    cb1c:	b314      	cbz	r4, cb64 <net_tcp_parse_opts+0x50>
	return net_pkt_read(pkt, data, 1);
    cb1e:	2201      	movs	r2, #1
    cb20:	f10d 0106 	add.w	r1, sp, #6
    cb24:	4628      	mov	r0, r5
    cb26:	f007 fa17 	bl	13f58 <net_pkt_read>
		if (net_pkt_read_u8(pkt, &opt)) {
    cb2a:	b1b8      	cbz	r0, cb5c <net_tcp_parse_opts+0x48>
			optlen = 0U;
    cb2c:	2300      	movs	r3, #0
    cb2e:	f88d 3007 	strb.w	r3, [sp, #7]
	NET_ERR("Invalid TCP opt: %d len: %d", opt, optlen);
    cb32:	2201      	movs	r2, #1
    cb34:	f04f 0300 	mov.w	r3, #0
    cb38:	f362 0307 	bfi	r3, r2, #0, #8
    cb3c:	4921      	ldr	r1, [pc, #132]	; (cbc4 <net_tcp_parse_opts+0xb0>)
    cb3e:	4a22      	ldr	r2, [pc, #136]	; (cbc8 <net_tcp_parse_opts+0xb4>)
    cb40:	4822      	ldr	r0, [pc, #136]	; (cbcc <net_tcp_parse_opts+0xb8>)
    cb42:	1a52      	subs	r2, r2, r1
    cb44:	08d2      	lsrs	r2, r2, #3
    cb46:	f362 138f 	bfi	r3, r2, #6, #10
    cb4a:	f89d 1006 	ldrb.w	r1, [sp, #6]
    cb4e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    cb52:	f005 fa30 	bl	11fb6 <log_2>
	return -EINVAL;
    cb56:	f06f 0015 	mvn.w	r0, #21
    cb5a:	e004      	b.n	cb66 <net_tcp_parse_opts+0x52>
		if (opt == NET_TCP_END_OPT) {
    cb5c:	f89d 2006 	ldrb.w	r2, [sp, #6]
		opt_totlen--;
    cb60:	1e63      	subs	r3, r4, #1
		if (opt == NET_TCP_END_OPT) {
    cb62:	b912      	cbnz	r2, cb6a <net_tcp_parse_opts+0x56>
	return 0;
    cb64:	2000      	movs	r0, #0
}
    cb66:	b002      	add	sp, #8
    cb68:	bd70      	pop	{r4, r5, r6, pc}
		} else if (opt == NET_TCP_NOP_OPT) {
    cb6a:	2a01      	cmp	r2, #1
    cb6c:	d028      	beq.n	cbc0 <net_tcp_parse_opts+0xac>
		if (!opt_totlen) {
    cb6e:	2b00      	cmp	r3, #0
    cb70:	d0dc      	beq.n	cb2c <net_tcp_parse_opts+0x18>
    cb72:	2201      	movs	r2, #1
    cb74:	f10d 0107 	add.w	r1, sp, #7
    cb78:	4628      	mov	r0, r5
    cb7a:	f007 f9ed 	bl	13f58 <net_pkt_read>
		if (net_pkt_read_u8(pkt, &optlen) || optlen < 2) {
    cb7e:	2800      	cmp	r0, #0
    cb80:	d1d7      	bne.n	cb32 <net_tcp_parse_opts+0x1e>
    cb82:	f89d 1007 	ldrb.w	r1, [sp, #7]
    cb86:	f89d 3006 	ldrb.w	r3, [sp, #6]
    cb8a:	2901      	cmp	r1, #1
    cb8c:	d9d1      	bls.n	cb32 <net_tcp_parse_opts+0x1e>
		optlen -= 2U;
    cb8e:	3902      	subs	r1, #2
    cb90:	b2c9      	uxtb	r1, r1
		opt_totlen--;
    cb92:	3c02      	subs	r4, #2
		if (opt_totlen < optlen) {
    cb94:	42a1      	cmp	r1, r4
		optlen -= 2U;
    cb96:	f88d 1007 	strb.w	r1, [sp, #7]
		if (opt_totlen < optlen) {
    cb9a:	dcca      	bgt.n	cb32 <net_tcp_parse_opts+0x1e>
		switch (opt) {
    cb9c:	2b02      	cmp	r3, #2
    cb9e:	d10b      	bne.n	cbb8 <net_tcp_parse_opts+0xa4>
			if (optlen != 2U) {
    cba0:	2902      	cmp	r1, #2
    cba2:	d1c6      	bne.n	cb32 <net_tcp_parse_opts+0x1e>
			if (net_pkt_read_be16(pkt, &opts->mss)) {
    cba4:	4631      	mov	r1, r6
    cba6:	4628      	mov	r0, r5
    cba8:	f007 f9df 	bl	13f6a <net_pkt_read_be16>
    cbac:	2800      	cmp	r0, #0
    cbae:	d1c0      	bne.n	cb32 <net_tcp_parse_opts+0x1e>
		opt_totlen -= optlen;
    cbb0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    cbb4:	1ae4      	subs	r4, r4, r3
    cbb6:	e7b1      	b.n	cb1c <net_tcp_parse_opts+0x8>
			if (net_pkt_skip(pkt, optlen)) {
    cbb8:	4628      	mov	r0, r5
    cbba:	f007 f9b7 	bl	13f2c <net_pkt_skip>
    cbbe:	e7f5      	b.n	cbac <net_tcp_parse_opts+0x98>
		opt_totlen--;
    cbc0:	461c      	mov	r4, r3
    cbc2:	e7ab      	b.n	cb1c <net_tcp_parse_opts+0x8>
    cbc4:	00016344 	.word	0x00016344
    cbc8:	00016404 	.word	0x00016404
    cbcc:	00018ac7 	.word	0x00018ac7

0000cbd0 <tcp_syn_rcvd>:
 *			         struct net_pkt *pkt,
 *			         union net_ip_header *ip_hdr,
 *			         union net_proto_header *proto_hdr,
 *			         void *user_data)
 */
NET_CONN_CB(tcp_syn_rcvd)
    cbd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cbd4:	b08f      	sub	sp, #60	; 0x3c
    cbd6:	461e      	mov	r6, r3
    cbd8:	9c18      	ldr	r4, [sp, #96]	; 0x60
    cbda:	4620      	mov	r0, r4
    cbdc:	460d      	mov	r5, r1
    cbde:	4690      	mov	r8, r2
    cbe0:	f006 fc71 	bl	134c6 <net_context_ref>
	struct sockaddr local_addr;
	struct sockaddr remote_addr;

	NET_ASSERT(context && context->tcp);

	tcp = context->tcp;
    cbe4:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
NET_CONN_CB(tcp_syn_rcvd)
    cbe8:	6836      	ldr	r6, [r6, #0]
	return (enum net_tcp_state)tcp->state;
    cbea:	f8d9 30bc 	ldr.w	r3, [r9, #188]	; 0xbc
    cbee:	f3c3 3343 	ubfx	r3, r3, #13, #4

	switch (net_tcp_get_state(tcp)) {
    cbf2:	2b01      	cmp	r3, #1
    cbf4:	d004      	beq.n	cc00 <tcp_syn_rcvd+0x30>
    cbf6:	2b03      	cmp	r3, #3
    cbf8:	f000 80be 	beq.w	cd78 <tcp_syn_rcvd+0x1a8>
	net_stats_update_tcp_seg_conndrop(net_pkt_iface(pkt));

reset:
	send_reset(tcp->context, &local_addr, &remote_addr);

	return NET_DROP;
    cbfc:	2702      	movs	r7, #2
    cbfe:	e0b4      	b.n	cd6a <tcp_syn_rcvd+0x19a>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
    cc00:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
		if (net_context_get_state(context) != NET_CONTEXT_LISTENING) {
    cc04:	f3c3 0341 	ubfx	r3, r3, #1, #2
    cc08:	2b03      	cmp	r3, #3
    cc0a:	d1f7      	bne.n	cbfc <tcp_syn_rcvd+0x2c>
	context->iface = net_if_get_by_iface(iface);
    cc0c:	6a68      	ldr	r0, [r5, #36]	; 0x24
    cc0e:	f7fe fc1b 	bl	b448 <net_if_get_by_iface>
    cc12:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
	return pkt->family;
    cc16:	f895 3043 	ldrb.w	r3, [r5, #67]	; 0x43
	pkt->context = ctx;
    cc1a:	622c      	str	r4, [r5, #32]
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
    cc1c:	f3c3 0342 	ubfx	r3, r3, #1, #3
    cc20:	2b01      	cmp	r3, #1
    cc22:	d117      	bne.n	cc54 <tcp_syn_rcvd+0x84>
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
    cc24:	f8d8 1000 	ldr.w	r1, [r8]
		port = tcp_hdr->src_port;
    cc28:	8832      	ldrh	r2, [r6, #0]
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
    cc2a:	68c9      	ldr	r1, [r1, #12]
    cc2c:	910d      	str	r1, [sp, #52]	; 0x34
		addr->sa_family = AF_INET;
    cc2e:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
	return pkt->family;
    cc32:	f895 3043 	ldrb.w	r3, [r5, #67]	; 0x43
		addr4->sin_port = port;
    cc36:	f8ad 2032 	strh.w	r2, [sp, #50]	; 0x32
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
    cc3a:	f3c3 0342 	ubfx	r3, r3, #1, #3
    cc3e:	2b01      	cmp	r3, #1
    cc40:	d108      	bne.n	cc54 <tcp_syn_rcvd+0x84>
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->dst);
    cc42:	f8d8 1000 	ldr.w	r1, [r8]
		port = tcp_hdr->dst_port;
    cc46:	8872      	ldrh	r2, [r6, #2]
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->dst);
    cc48:	6909      	ldr	r1, [r1, #16]
    cc4a:	910b      	str	r1, [sp, #44]	; 0x2c
		addr4->sin_port = port;
    cc4c:	f8ad 202a 	strh.w	r2, [sp, #42]	; 0x2a
		addr->sa_family = AF_INET;
    cc50:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
	if (NET_TCP_FLAGS(tcp_hdr) == NET_TCP_SYN) {
    cc54:	7b73      	ldrb	r3, [r6, #13]
    cc56:	f003 073f 	and.w	r7, r3, #63	; 0x3f
    cc5a:	2f02      	cmp	r7, #2
    cc5c:	f040 8095 	bne.w	cd8a <tcp_syn_rcvd+0x1ba>
		struct net_tcp_options tcp_opts = {
    cc60:	f44f 7306 	mov.w	r3, #536	; 0x218
    cc64:	f8ad 301c 	strh.w	r3, [sp, #28]
		opt_totlen = NET_TCP_HDR_LEN(tcp_hdr)
    cc68:	7b33      	ldrb	r3, [r6, #12]
		if (net_tcp_parse_opts(pkt, opt_totlen, &tcp_opts) < 0) {
    cc6a:	f06f 0113 	mvn.w	r1, #19
			     - sizeof(struct net_tcp_hdr);
    cc6e:	091b      	lsrs	r3, r3, #4
		if (net_tcp_parse_opts(pkt, opt_totlen, &tcp_opts) < 0) {
    cc70:	aa07      	add	r2, sp, #28
    cc72:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    cc76:	4628      	mov	r0, r5
    cc78:	f7ff ff4c 	bl	cb14 <net_tcp_parse_opts>
    cc7c:	2800      	cmp	r0, #0
    cc7e:	db74      	blt.n	cd6a <tcp_syn_rcvd+0x19a>
		net_tcp_change_state(tcp, NET_TCP_SYN_RCVD);
    cc80:	2103      	movs	r1, #3
    cc82:	4648      	mov	r0, r9
    cc84:	f007 ff7b 	bl	14b7e <net_tcp_change_state>
		context->tcp->send_seq = tcp_init_isn();
    cc88:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
	return sys_rand32_get();
    cc8c:	f7fb fca4 	bl	85d8 <sys_rand32_get>
    cc90:	f8c9 0090 	str.w	r0, [r9, #144]	; 0x90
			sys_get_be32(tcp_hdr->seq) + 1;
    cc94:	1d30      	adds	r0, r6, #4
    cc96:	f007 fd3b 	bl	14710 <sys_get_be32>
		context->tcp->send_ack =
    cc9a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
		r = tcp_backlog_syn(pkt, ip_hdr, tcp_hdr,
    cc9c:	f8bd 901c 	ldrh.w	r9, [sp, #28]
			sys_get_be32(tcp_hdr->seq) + 1;
    cca0:	3001      	adds	r0, #1
		context->tcp->send_ack =
    cca2:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	int empty_slot = -1;
    cca6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    ccaa:	9308      	str	r3, [sp, #32]
	if (tcp_backlog_find(pkt, ip_hdr, tcp_hdr, &empty_slot) >= 0) {
    ccac:	4632      	mov	r2, r6
    ccae:	ab08      	add	r3, sp, #32
    ccb0:	4641      	mov	r1, r8
    ccb2:	4628      	mov	r0, r5
    ccb4:	f7ff fb0e 	bl	c2d4 <tcp_backlog_find.isra.31>
    ccb8:	2800      	cmp	r0, #0
    ccba:	da56      	bge.n	cd6a <tcp_syn_rcvd+0x19a>
	if (empty_slot < 0) {
    ccbc:	9a08      	ldr	r2, [sp, #32]
    ccbe:	2a00      	cmp	r2, #0
    ccc0:	db53      	blt.n	cd6a <tcp_syn_rcvd+0x19a>
	tcp_backlog[empty_slot].tcp = context->tcp;
    ccc2:	2338      	movs	r3, #56	; 0x38
    ccc4:	4353      	muls	r3, r2
    ccc6:	4fa2      	ldr	r7, [pc, #648]	; (cf50 <tcp_syn_rcvd+0x380>)
    ccc8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    ccca:	50fa      	str	r2, [r7, r3]
    cccc:	f895 2043 	ldrb.w	r2, [r5, #67]	; 0x43
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
    ccd0:	f3c2 0242 	ubfx	r2, r2, #1, #3
    ccd4:	2a01      	cmp	r2, #1
	tcp_backlog[empty_slot].tcp = context->tcp;
    ccd6:	eb07 0003 	add.w	r0, r7, r3
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
    ccda:	d10a      	bne.n	ccf2 <tcp_syn_rcvd+0x122>
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
    ccdc:	f8d8 1000 	ldr.w	r1, [r8]
		port = tcp_hdr->src_port;
    cce0:	f8b6 c000 	ldrh.w	ip, [r6]
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
    cce4:	68c9      	ldr	r1, [r1, #12]
	tcp_copy_ip_addr_from_hdr(net_pkt_family(pkt), ip_hdr, tcp_hdr,
    cce6:	332c      	adds	r3, #44	; 0x2c
    cce8:	443b      	add	r3, r7
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
    ccea:	6059      	str	r1, [r3, #4]
		addr4->sin_port = port;
    ccec:	f8a3 c002 	strh.w	ip, [r3, #2]
		addr->sa_family = AF_INET;
    ccf0:	8582      	strh	r2, [r0, #44]	; 0x2c
	tcp_backlog[empty_slot].send_seq = context->tcp->send_seq;
    ccf2:	9808      	ldr	r0, [sp, #32]
    ccf4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    ccf6:	f04f 0a38 	mov.w	sl, #56	; 0x38
    ccfa:	fb0a f000 	mul.w	r0, sl, r0
    ccfe:	183a      	adds	r2, r7, r0
    cd00:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
    cd04:	6053      	str	r3, [r2, #4]
	k_delayed_work_init(&tcp_backlog[empty_slot].ack_timer,
    cd06:	300c      	adds	r0, #12
	tcp_backlog[empty_slot].send_ack = context->tcp->send_ack;
    cd08:	f8d1 3094 	ldr.w	r3, [r1, #148]	; 0x94
    cd0c:	6093      	str	r3, [r2, #8]
	tcp_backlog[empty_slot].send_mss = send_mss;
    cd0e:	f8a2 9034 	strh.w	r9, [r2, #52]	; 0x34
	k_delayed_work_init(&tcp_backlog[empty_slot].ack_timer,
    cd12:	4990      	ldr	r1, [pc, #576]	; (cf54 <tcp_syn_rcvd+0x384>)
    cd14:	4438      	add	r0, r7
    cd16:	f009 f8de 	bl	15ed6 <k_delayed_work_init>
	k_delayed_work_submit(&tcp_backlog[empty_slot].ack_timer, ACK_TIMEOUT);
    cd1a:	9808      	ldr	r0, [sp, #32]
    cd1c:	fb0a 7000 	mla	r0, sl, r0, r7
    cd20:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    cd24:	300c      	adds	r0, #12
    cd26:	f7ff facd 	bl	c2c4 <k_delayed_work_submit>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
    cd2a:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
    cd2e:	f3c3 03c2 	ubfx	r3, r3, #3, #3
	(void)memset(addr, 0, sizeof(*addr));
    cd32:	2200      	movs	r2, #0
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
    cd34:	2b01      	cmp	r3, #1
	(void)memset(addr, 0, sizeof(*addr));
    cd36:	e9cd 2208 	strd	r2, r2, [sp, #32]
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
    cd3a:	d10b      	bne.n	cd54 <tcp_syn_rcvd+0x184>
		addr4->sin_family = AF_INET;
    cd3c:	f8ad 3020 	strh.w	r3, [sp, #32]
		addr4->sin_port = tcp_hdr->dst_port;
    cd40:	78b3      	ldrb	r3, [r6, #2]
    cd42:	78f2      	ldrb	r2, [r6, #3]
    cd44:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    cd48:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
		addr4->sin_addr = &ip_hdr->ipv4->dst;
    cd4c:	f8d8 3000 	ldr.w	r3, [r8]
    cd50:	3310      	adds	r3, #16
    cd52:	9309      	str	r3, [sp, #36]	; 0x24
	return send_syn_segment(context, local, remote,
    cd54:	2312      	movs	r3, #18
    cd56:	aa0c      	add	r2, sp, #48	; 0x30
    cd58:	a908      	add	r1, sp, #32
    cd5a:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    cd5e:	f008 f817 	bl	14d90 <send_syn_segment.isra.38>
		net_pkt_unref(pkt);
    cd62:	4628      	mov	r0, r5
    cd64:	f006 fff7 	bl	13d56 <net_pkt_unref>
		return NET_OK;
    cd68:	2700      	movs	r7, #0
NET_CONN_CB(tcp_syn_rcvd)
    cd6a:	4620      	mov	r0, r4
    cd6c:	f006 fbb9 	bl	134e2 <net_context_unref>
    cd70:	4638      	mov	r0, r7
    cd72:	b00f      	add	sp, #60	; 0x3c
    cd74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return net_if_get_by_index(context->iface);
    cd78:	f994 0070 	ldrsb.w	r0, [r4, #112]	; 0x70
		if (net_pkt_iface(pkt) != net_context_get_iface(context)) {
    cd7c:	6a6f      	ldr	r7, [r5, #36]	; 0x24
    cd7e:	f7fe fb51 	bl	b424 <net_if_get_by_index>
    cd82:	4287      	cmp	r7, r0
    cd84:	f43f af47 	beq.w	cc16 <tcp_syn_rcvd+0x46>
    cd88:	e738      	b.n	cbfc <tcp_syn_rcvd+0x2c>
	if (NET_TCP_FLAGS(tcp_hdr) & NET_TCP_RST) {
    cd8a:	f013 0704 	ands.w	r7, r3, #4
    cd8e:	d01f      	beq.n	cdd0 <tcp_syn_rcvd+0x200>
	r = tcp_backlog_find(pkt, ip_hdr, tcp_hdr, NULL);
    cd90:	4628      	mov	r0, r5
    cd92:	2300      	movs	r3, #0
    cd94:	4632      	mov	r2, r6
    cd96:	4641      	mov	r1, r8
    cd98:	f7ff fa9c 	bl	c2d4 <tcp_backlog_find.isra.31>
	if (r < 0) {
    cd9c:	1e05      	subs	r5, r0, #0
    cd9e:	f6ff af2d 	blt.w	cbfc <tcp_syn_rcvd+0x2c>
	if (tcp_backlog[r].send_ack != sys_get_be32(tcp_hdr->seq)) {
    cda2:	1d30      	adds	r0, r6, #4
    cda4:	f007 fcb4 	bl	14710 <sys_get_be32>
    cda8:	2638      	movs	r6, #56	; 0x38
    cdaa:	4a69      	ldr	r2, [pc, #420]	; (cf50 <tcp_syn_rcvd+0x380>)
    cdac:	fb06 f305 	mul.w	r3, r6, r5
    cdb0:	18d5      	adds	r5, r2, r3
    cdb2:	68a9      	ldr	r1, [r5, #8]
    cdb4:	4281      	cmp	r1, r0
    cdb6:	f47f af21 	bne.w	cbfc <tcp_syn_rcvd+0x2c>
	k_delayed_work_cancel(&tcp_backlog[r].ack_timer);
    cdba:	f103 000c 	add.w	r0, r3, #12
    cdbe:	4410      	add	r0, r2
    cdc0:	f009 f891 	bl	15ee6 <k_delayed_work_cancel>
    cdc4:	4632      	mov	r2, r6
    cdc6:	2100      	movs	r1, #0
    cdc8:	4628      	mov	r0, r5
    cdca:	f7f5 fa0e 	bl	21ea <memset>
    cdce:	e715      	b.n	cbfc <tcp_syn_rcvd+0x2c>
	if (NET_TCP_FLAGS(tcp_hdr) & NET_TCP_ACK) {
    cdd0:	06db      	lsls	r3, r3, #27
    cdd2:	f57f af13 	bpl.w	cbfc <tcp_syn_rcvd+0x2c>
		if (!context->tcp->accept_cb) {
    cdd6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cdd8:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
    cddc:	b93b      	cbnz	r3, cdee <tcp_syn_rcvd+0x21e>
	send_reset(tcp->context, &local_addr, &remote_addr);
    cdde:	f8d9 3000 	ldr.w	r3, [r9]
    cde2:	aa0c      	add	r2, sp, #48	; 0x30
    cde4:	a90a      	add	r1, sp, #40	; 0x28
    cde6:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
    cde8:	f007 fe21 	bl	14a2e <send_reset.isra.33>
    cdec:	e706      	b.n	cbfc <tcp_syn_rcvd+0x2c>
    cdee:	f895 0043 	ldrb.w	r0, [r5, #67]	; 0x43
		ret = net_context_get(net_pkt_family(pkt),
    cdf2:	ab08      	add	r3, sp, #32
    cdf4:	2206      	movs	r2, #6
    cdf6:	2101      	movs	r1, #1
    cdf8:	f3c0 0042 	ubfx	r0, r0, #1, #3
    cdfc:	f7fd fe9e 	bl	ab3c <net_context_get>
		if (ret < 0) {
    ce00:	2800      	cmp	r0, #0
    ce02:	dbec      	blt.n	cdde <tcp_syn_rcvd+0x20e>
	r = tcp_backlog_find(pkt, ip_hdr, tcp_hdr, NULL);
    ce04:	4641      	mov	r1, r8
    ce06:	463b      	mov	r3, r7
    ce08:	4632      	mov	r2, r6
    ce0a:	4628      	mov	r0, r5
		ret = tcp_backlog_ack(pkt, ip_hdr, tcp_hdr, new_context);
    ce0c:	f8dd a020 	ldr.w	sl, [sp, #32]
	r = tcp_backlog_find(pkt, ip_hdr, tcp_hdr, NULL);
    ce10:	f7ff fa60 	bl	c2d4 <tcp_backlog_find.isra.31>
	if (r < 0) {
    ce14:	f1b0 0800 	subs.w	r8, r0, #0
    ce18:	db37      	blt.n	ce8a <tcp_syn_rcvd+0x2ba>
	if (tcp_backlog[r].send_seq + 1 != sys_get_be32(tcp_hdr->ack)) {
    ce1a:	f106 0008 	add.w	r0, r6, #8
    ce1e:	f007 fc77 	bl	14710 <sys_get_be32>
    ce22:	f04f 0b38 	mov.w	fp, #56	; 0x38
    ce26:	4a4a      	ldr	r2, [pc, #296]	; (cf50 <tcp_syn_rcvd+0x380>)
    ce28:	fb0b f308 	mul.w	r3, fp, r8
    ce2c:	eb02 0803 	add.w	r8, r2, r3
    ce30:	f8d8 1004 	ldr.w	r1, [r8, #4]
    ce34:	3101      	adds	r1, #1
    ce36:	4281      	cmp	r1, r0
    ce38:	d127      	bne.n	ce8a <tcp_syn_rcvd+0x2ba>
	memcpy(&context->remote, &tcp_backlog[r].remote,
    ce3a:	f103 062c 	add.w	r6, r3, #44	; 0x2c
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    ce3e:	4416      	add	r6, r2
    ce40:	ce03      	ldmia	r6!, {r0, r1}
    ce42:	f8ca 1028 	str.w	r1, [sl, #40]	; 0x28
    ce46:	f8ca 0024 	str.w	r0, [sl, #36]	; 0x24
	context->tcp->send_seq = tcp_backlog[r].send_seq + 1;
    ce4a:	f8d8 0004 	ldr.w	r0, [r8, #4]
    ce4e:	f8da 103c 	ldr.w	r1, [sl, #60]	; 0x3c
    ce52:	3001      	adds	r0, #1
    ce54:	f8c1 0090 	str.w	r0, [r1, #144]	; 0x90
	context->tcp->send_ack = tcp_backlog[r].send_ack;
    ce58:	f8d8 0008 	ldr.w	r0, [r8, #8]
    ce5c:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
	context->tcp->send_mss = tcp_backlog[r].send_mss;
    ce60:	f8b8 0034 	ldrh.w	r0, [r8, #52]	; 0x34
    ce64:	f8a1 00ba 	strh.w	r0, [r1, #186]	; 0xba
	k_delayed_work_cancel(&tcp_backlog[r].ack_timer);
    ce68:	f103 000c 	add.w	r0, r3, #12
    ce6c:	4410      	add	r0, r2
    ce6e:	f009 f83a 	bl	15ee6 <k_delayed_work_cancel>
__ssp_bos_icheck3(memset, void *, int)
    ce72:	465a      	mov	r2, fp
    ce74:	4639      	mov	r1, r7
    ce76:	4640      	mov	r0, r8
    ce78:	f7f5 f9b7 	bl	21ea <memset>
		ret = net_context_bind(new_context, &local_addr,
    ce7c:	2208      	movs	r2, #8
    ce7e:	a90a      	add	r1, sp, #40	; 0x28
    ce80:	9808      	ldr	r0, [sp, #32]
    ce82:	f7fd ff47 	bl	ad14 <net_context_bind>
		if (ret < 0) {
    ce86:	2800      	cmp	r0, #0
    ce88:	da03      	bge.n	ce92 <tcp_syn_rcvd+0x2c2>
			net_context_unref(new_context);
    ce8a:	9808      	ldr	r0, [sp, #32]
    ce8c:	f006 fb29 	bl	134e2 <net_context_unref>
			goto conndrop;
    ce90:	e7a5      	b.n	cdde <tcp_syn_rcvd+0x20e>
		new_context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
    ce92:	9b08      	ldr	r3, [sp, #32]
    ce94:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    ce98:	ae0c      	add	r6, sp, #48	; 0x30
    ce9a:	ce03      	ldmia	r6!, {r0, r1}
    ce9c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    cea0:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e
		memcpy(&new_context->remote, &remote_addr,
    cea4:	f103 0224 	add.w	r2, r3, #36	; 0x24
    cea8:	6258      	str	r0, [r3, #36]	; 0x24
    ceaa:	6051      	str	r1, [r2, #4]
			       ntohs(net_sin(&new_context->remote)->sin_port),
    ceac:	8cde      	ldrh	r6, [r3, #38]	; 0x26
			       ntohs(net_sin(&local_addr)->sin_port),
    ceae:	f8bd c02a 	ldrh.w	ip, [sp, #42]	; 0x2a
    ceb2:	f895 1043 	ldrb.w	r1, [r5, #67]	; 0x43
		ret = net_tcp_register(net_pkt_family(pkt),
    ceb6:	f103 002c 	add.w	r0, r3, #44	; 0x2c
	return net_conn_register(IPPROTO_TCP, family, remote_addr, local_addr,
    ceba:	e9cd 3003 	strd	r3, r0, [sp, #12]
    cebe:	4b26      	ldr	r3, [pc, #152]	; (cf58 <tcp_syn_rcvd+0x388>)
    cec0:	9302      	str	r3, [sp, #8]
			       ntohs(net_sin(&local_addr)->sin_port),
    cec2:	ea4f 200c 	mov.w	r0, ip, lsl #8
			       ntohs(net_sin(&new_context->remote)->sin_port),
    cec6:	0233      	lsls	r3, r6, #8
			       ntohs(net_sin(&local_addr)->sin_port),
    cec8:	ea40 201c 	orr.w	r0, r0, ip, lsr #8
			       ntohs(net_sin(&new_context->remote)->sin_port),
    cecc:	ea43 2316 	orr.w	r3, r3, r6, lsr #8
    ced0:	b280      	uxth	r0, r0
    ced2:	b29b      	uxth	r3, r3
    ced4:	9001      	str	r0, [sp, #4]
    ced6:	9300      	str	r3, [sp, #0]
    ced8:	f3c1 0142 	ubfx	r1, r1, #1, #3
    cedc:	ab0a      	add	r3, sp, #40	; 0x28
    cede:	2006      	movs	r0, #6
    cee0:	f7ff f824 	bl	bf2c <net_conn_register>
		if (ret < 0) {
    cee4:	2800      	cmp	r0, #0
    cee6:	dbd0      	blt.n	ce8a <tcp_syn_rcvd+0x2ba>
		net_tcp_change_state(tcp, NET_TCP_LISTEN);
    cee8:	2101      	movs	r1, #1
    ceea:	4648      	mov	r0, r9
    ceec:	f007 fe47 	bl	14b7e <net_tcp_change_state>
		new_context->tcp->state = NET_TCP_ESTABLISHED;
    cef0:	9808      	ldr	r0, [sp, #32]
    cef2:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    cef4:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
    cef8:	2104      	movs	r1, #4
    cefa:	f361 3250 	bfi	r2, r1, #13, #4
    cefe:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
    cf02:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
    cf06:	f023 0306 	bic.w	r3, r3, #6
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
    cf0a:	430b      	orrs	r3, r1
    cf0c:	f8a0 306e 	strh.w	r3, [r0, #110]	; 0x6e
		if (new_context->remote.sa_family == AF_INET) {
    cf10:	8c83      	ldrh	r3, [r0, #36]	; 0x24
    cf12:	2b01      	cmp	r3, #1
    cf14:	d004      	beq.n	cf20 <tcp_syn_rcvd+0x350>
		} else if (new_context->remote.sa_family == AF_INET6) {
    cf16:	2b02      	cmp	r3, #2
    cf18:	d018      	beq.n	cf4c <tcp_syn_rcvd+0x37c>
			net_context_unref(new_context);
    cf1a:	f006 fae2 	bl	134e2 <net_context_unref>
			return NET_DROP;
    cf1e:	e66d      	b.n	cbfc <tcp_syn_rcvd+0x2c>
			addrlen = sizeof(struct sockaddr_in);
    cf20:	2208      	movs	r2, #8
		context->tcp->accept_cb(new_context,
    cf22:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cf24:	6821      	ldr	r1, [r4, #0]
    cf26:	9100      	str	r1, [sp, #0]
    cf28:	f8d3 609c 	ldr.w	r6, [r3, #156]	; 0x9c
    cf2c:	f100 0124 	add.w	r1, r0, #36	; 0x24
    cf30:	2300      	movs	r3, #0
    cf32:	47b0      	blx	r6
		net_pkt_unref(pkt);
    cf34:	4628      	mov	r0, r5
    cf36:	f006 ff0e 	bl	13d56 <net_pkt_unref>
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
    cf3a:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
    cf3e:	f023 0306 	bic.w	r3, r3, #6
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
    cf42:	f043 0304 	orr.w	r3, r3, #4
    cf46:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
		return NET_OK;
    cf4a:	e70e      	b.n	cd6a <tcp_syn_rcvd+0x19a>
			addrlen = sizeof(struct sockaddr_in6);
    cf4c:	2218      	movs	r2, #24
    cf4e:	e7e8      	b.n	cf22 <tcp_syn_rcvd+0x352>
    cf50:	20003f40 	.word	0x20003f40
    cf54:	00014a57 	.word	0x00014a57
    cf58:	0000c795 	.word	0x0000c795

0000cf5c <net_tcp_update_recv_wnd>:
	if (!context->tcp) {
    cf5c:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
{
    cf5e:	b508      	push	{r3, lr}
	if (!context->tcp) {
    cf60:	b982      	cbnz	r2, cf84 <net_tcp_update_recv_wnd+0x28>
		NET_ERR("context->tcp == NULL");
    cf62:	2301      	movs	r3, #1
    cf64:	f04f 0100 	mov.w	r1, #0
    cf68:	f363 0107 	bfi	r1, r3, #0, #8
    cf6c:	4a0b      	ldr	r2, [pc, #44]	; (cf9c <net_tcp_update_recv_wnd+0x40>)
    cf6e:	4b0c      	ldr	r3, [pc, #48]	; (cfa0 <net_tcp_update_recv_wnd+0x44>)
    cf70:	480c      	ldr	r0, [pc, #48]	; (cfa4 <net_tcp_update_recv_wnd+0x48>)
    cf72:	1a9b      	subs	r3, r3, r2
    cf74:	08db      	lsrs	r3, r3, #3
    cf76:	f363 118f 	bfi	r1, r3, #6, #10
    cf7a:	f004 fffb 	bl	11f74 <log_0>
		return -EPROTOTYPE;
    cf7e:	f06f 006a 	mvn.w	r0, #106	; 0x6a
}
    cf82:	bd08      	pop	{r3, pc}
	new_win = context->tcp->recv_wnd + delta;
    cf84:	f8b2 30b8 	ldrh.w	r3, [r2, #184]	; 0xb8
    cf88:	4419      	add	r1, r3
	if (new_win < 0 || new_win > UINT16_MAX) {
    cf8a:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
	context->tcp->recv_wnd = new_win;
    cf8e:	bf3a      	itte	cc
    cf90:	f8a2 10b8 	strhcc.w	r1, [r2, #184]	; 0xb8
	return 0;
    cf94:	2000      	movcc	r0, #0
		return -EINVAL;
    cf96:	f06f 0015 	mvncs.w	r0, #21
    cf9a:	e7f2      	b.n	cf82 <net_tcp_update_recv_wnd+0x26>
    cf9c:	00016344 	.word	0x00016344
    cfa0:	00016404 	.word	0x00016404
    cfa4:	00018b2d 	.word	0x00018b2d

0000cfa8 <net_tcp_get>:
{
    cfa8:	b510      	push	{r4, lr}
    cfaa:	4604      	mov	r4, r0
	context->tcp = net_tcp_alloc(context);
    cfac:	f7ff f9ba 	bl	c324 <net_tcp_alloc>
    cfb0:	63e0      	str	r0, [r4, #60]	; 0x3c
	if (!context->tcp) {
    cfb2:	b178      	cbz	r0, cfd4 <net_tcp_get+0x2c>
	k_delayed_work_init(&context->tcp->ack_timer, handle_ack_timeout);
    cfb4:	4909      	ldr	r1, [pc, #36]	; (cfdc <net_tcp_get+0x34>)
    cfb6:	3008      	adds	r0, #8
    cfb8:	f008 ff8d 	bl	15ed6 <k_delayed_work_init>
	k_delayed_work_init(&context->tcp->fin_timer, handle_fin_timeout);
    cfbc:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    cfbe:	4908      	ldr	r1, [pc, #32]	; (cfe0 <net_tcp_get+0x38>)
    cfc0:	3028      	adds	r0, #40	; 0x28
    cfc2:	f008 ff88 	bl	15ed6 <k_delayed_work_init>
	k_delayed_work_init(&context->tcp->timewait_timer,
    cfc6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    cfc8:	4906      	ldr	r1, [pc, #24]	; (cfe4 <net_tcp_get+0x3c>)
    cfca:	3068      	adds	r0, #104	; 0x68
    cfcc:	f008 ff83 	bl	15ed6 <k_delayed_work_init>
	return 0;
    cfd0:	2000      	movs	r0, #0
}
    cfd2:	bd10      	pop	{r4, pc}
		return -ENOBUFS;
    cfd4:	f06f 0068 	mvn.w	r0, #104	; 0x68
    cfd8:	e7fb      	b.n	cfd2 <net_tcp_get+0x2a>
    cfda:	bf00      	nop
    cfdc:	00014e33 	.word	0x00014e33
    cfe0:	00014727 	.word	0x00014727
    cfe4:	00014df3 	.word	0x00014df3

0000cfe8 <net_tcp_unref>:
{
    cfe8:	b538      	push	{r3, r4, r5, lr}
	if (!context->tcp)
    cfea:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
{
    cfec:	4604      	mov	r4, r0
	if (!context->tcp)
    cfee:	b18b      	cbz	r3, d014 <net_tcp_unref+0x2c>
		if (tcp_backlog[i].tcp != context->tcp) {
    cff0:	4d09      	ldr	r5, [pc, #36]	; (d018 <net_tcp_unref+0x30>)
    cff2:	682a      	ldr	r2, [r5, #0]
    cff4:	4293      	cmp	r3, r2
    cff6:	d108      	bne.n	d00a <net_tcp_unref+0x22>
		k_delayed_work_cancel(&tcp_backlog[i].ack_timer);
    cff8:	f105 000c 	add.w	r0, r5, #12
    cffc:	f008 ff73 	bl	15ee6 <k_delayed_work_cancel>
		(void)memset(&tcp_backlog[i], 0, sizeof(tcp_backlog[i]));
    d000:	2238      	movs	r2, #56	; 0x38
    d002:	2100      	movs	r1, #0
    d004:	4628      	mov	r0, r5
    d006:	f7f5 f8f0 	bl	21ea <memset>
	net_tcp_release(context->tcp);
    d00a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    d00c:	f7ff fa88 	bl	c520 <net_tcp_release>
	context->tcp = NULL;
    d010:	2300      	movs	r3, #0
    d012:	63e3      	str	r3, [r4, #60]	; 0x3c
}
    d014:	2000      	movs	r0, #0
    d016:	bd38      	pop	{r3, r4, r5, pc}
    d018:	20003f40 	.word	0x20003f40

0000d01c <net_tcp_accept>:
}

int net_tcp_accept(struct net_context *context,
		   net_tcp_accept_cb_t cb,
		   void *user_data)
{
    d01c:	b5f0      	push	{r4, r5, r6, r7, lr}
    d01e:	4616      	mov	r6, r2
	u16_t lport = 0U;
	int ret;

	NET_ASSERT(context->tcp);

	if (net_tcp_get_state(context->tcp) != NET_TCP_LISTEN) {
    d020:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
	return (enum net_tcp_state)tcp->state;
    d022:	f8d2 30bc 	ldr.w	r3, [r2, #188]	; 0xbc
    d026:	f3c3 3343 	ubfx	r3, r3, #13, #4
    d02a:	2b01      	cmp	r3, #1
{
    d02c:	b089      	sub	sp, #36	; 0x24
    d02e:	4604      	mov	r4, r0
    d030:	460d      	mov	r5, r1
	if (net_tcp_get_state(context->tcp) != NET_TCP_LISTEN) {
    d032:	d143      	bne.n	d0bc <net_tcp_accept+0xa0>
		NET_DBG("Context %p in wrong state %d, should be %d",
			context, context->tcp->state, NET_TCP_LISTEN);
		return -EINVAL;
	}

	if (cb == NULL) {
    d034:	b939      	cbnz	r1, d046 <net_tcp_accept+0x2a>
		/* The context is being shut down */
		if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
    d036:	f8b0 306c 	ldrh.w	r3, [r0, #108]	; 0x6c
    d03a:	2b06      	cmp	r3, #6
    d03c:	d103      	bne.n	d046 <net_tcp_accept+0x2a>
			context->tcp->accept_cb = NULL;
    d03e:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
	/* accept callback is only valid for TCP contexts */
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
		context->tcp->accept_cb = cb;
	}

	return 0;
    d042:	2000      	movs	r0, #0
    d044:	e03c      	b.n	d0c0 <net_tcp_accept+0xa4>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
    d046:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
    d04a:	f3c3 03c2 	ubfx	r3, r3, #3, #3
	if (net_context_get_family(context) == AF_INET) {
    d04e:	2b01      	cmp	r3, #1
	local_addr.sa_family = net_context_get_family(context);
    d050:	f8ad 3018 	strh.w	r3, [sp, #24]
	if (net_context_get_family(context) == AF_INET) {
    d054:	d12f      	bne.n	d0b6 <net_tcp_accept+0x9a>
		if (net_sin_ptr(&context->local)->sin_addr) {
    d056:	6a23      	ldr	r3, [r4, #32]
    d058:	b113      	cbz	r3, d060 <net_tcp_accept+0x44>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
    d05a:	681b      	ldr	r3, [r3, #0]
    d05c:	9307      	str	r3, [sp, #28]
			laddr = &local_addr;
    d05e:	ab06      	add	r3, sp, #24
		net_sin(&local_addr)->sin_port = lport =
    d060:	8be0      	ldrh	r0, [r4, #30]
    d062:	f8ad 001a 	strh.w	r0, [sp, #26]
			       ntohs(net_sin(&context->remote)->sin_port),
    d066:	8ce7      	ldrh	r7, [r4, #38]	; 0x26
	ret = net_tcp_register(net_context_get_family(context),
    d068:	f8b4 206e 	ldrh.w	r2, [r4, #110]	; 0x6e
	return net_conn_register(IPPROTO_TCP, family, remote_addr, local_addr,
    d06c:	ba40      	rev16	r0, r0
    d06e:	b280      	uxth	r0, r0
    d070:	9001      	str	r0, [sp, #4]
			       ntohs(net_sin(&context->remote)->sin_port),
    d072:	0238      	lsls	r0, r7, #8
	ret = net_tcp_register(net_context_get_family(context),
    d074:	f104 0c2c 	add.w	ip, r4, #44	; 0x2c
			       ntohs(net_sin(&context->remote)->sin_port),
    d078:	ea40 2017 	orr.w	r0, r0, r7, lsr #8
	ret = net_tcp_register(net_context_get_family(context),
    d07c:	f3c2 01c2 	ubfx	r1, r2, #3, #3
    d080:	e9cd 4c03 	strd	r4, ip, [sp, #12]
    d084:	f412 7280 	ands.w	r2, r2, #256	; 0x100
    d088:	f8df c038 	ldr.w	ip, [pc, #56]	; d0c4 <net_tcp_accept+0xa8>
    d08c:	f8cd c008 	str.w	ip, [sp, #8]
    d090:	b280      	uxth	r0, r0
    d092:	bf18      	it	ne
    d094:	f104 0224 	addne.w	r2, r4, #36	; 0x24
    d098:	9000      	str	r0, [sp, #0]
    d09a:	2006      	movs	r0, #6
    d09c:	f7fe ff46 	bl	bf2c <net_conn_register>
	if (ret < 0) {
    d0a0:	2800      	cmp	r0, #0
    d0a2:	db0d      	blt.n	d0c0 <net_tcp_accept+0xa4>
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
    d0a4:	f8b4 306c 	ldrh.w	r3, [r4, #108]	; 0x6c
	context->user_data = user_data;
    d0a8:	6026      	str	r6, [r4, #0]
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
    d0aa:	2b06      	cmp	r3, #6
    d0ac:	d1c9      	bne.n	d042 <net_tcp_accept+0x26>
		context->tcp->accept_cb = cb;
    d0ae:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    d0b0:	f8c3 509c 	str.w	r5, [r3, #156]	; 0x9c
    d0b4:	e7c5      	b.n	d042 <net_tcp_accept+0x26>
	u16_t lport = 0U;
    d0b6:	2000      	movs	r0, #0
	struct sockaddr *laddr = NULL;
    d0b8:	4603      	mov	r3, r0
    d0ba:	e7d4      	b.n	d066 <net_tcp_accept+0x4a>
		return -EINVAL;
    d0bc:	f06f 0015 	mvn.w	r0, #21
}
    d0c0:	b009      	add	sp, #36	; 0x24
    d0c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d0c4:	0000cbd1 	.word	0x0000cbd1

0000d0c8 <net_tcp_connect>:
		    u16_t rport,
		    u16_t lport,
		    s32_t timeout,
		    net_context_connect_cb_t cb,
		    void *user_data)
{
    d0c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    d0ca:	460e      	mov	r6, r1
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
    d0cc:	f8b0 106e 	ldrh.w	r1, [r0, #110]	; 0x6e
    d0d0:	b087      	sub	sp, #28
    d0d2:	4604      	mov	r4, r0
    d0d4:	f3c1 1081 	ubfx	r0, r1, #6, #2
	int ret;

	NET_ASSERT(context->tcp);

	if (net_context_get_type(context) != SOCK_STREAM) {
    d0d8:	2801      	cmp	r0, #1
{
    d0da:	9d0d      	ldr	r5, [sp, #52]	; 0x34
	if (net_context_get_type(context) != SOCK_STREAM) {
    d0dc:	d138      	bne.n	d150 <net_tcp_connect+0x88>
	}

	/* We need to register a handler, otherwise the SYN-ACK
	 * packet would not be received.
	 */
	ret = net_tcp_register(net_context_get_family(context),
    d0de:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    d0e2:	e9cd 4003 	strd	r4, r0, [sp, #12]
    d0e6:	481d      	ldr	r0, [pc, #116]	; (d15c <net_tcp_connect+0x94>)
    d0e8:	9002      	str	r0, [sp, #8]
    d0ea:	f8bd 0030 	ldrh.w	r0, [sp, #48]	; 0x30
    d0ee:	ba5b      	rev16	r3, r3
    d0f0:	ba40      	rev16	r0, r0
    d0f2:	b280      	uxth	r0, r0
    d0f4:	b29b      	uxth	r3, r3
    d0f6:	9001      	str	r0, [sp, #4]
    d0f8:	9300      	str	r3, [sp, #0]
    d0fa:	f3c1 01c2 	ubfx	r1, r1, #3, #3
    d0fe:	4613      	mov	r3, r2
    d100:	2006      	movs	r0, #6
    d102:	4632      	mov	r2, r6
    d104:	f7fe ff12 	bl	bf2c <net_conn_register>
			       ntohs(rport),
			       ntohs(lport),
			       tcp_synack_received,
			       context,
			       &context->conn_handler);
	if (ret < 0) {
    d108:	2800      	cmp	r0, #0
    d10a:	db1f      	blt.n	d14c <net_tcp_connect+0x84>
		return ret;
	}

	context->connect_cb = cb;
    d10c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    d10e:	63a3      	str	r3, [r4, #56]	; 0x38
	context->user_data = user_data;
    d110:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    d112:	6023      	str	r3, [r4, #0]
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
    d114:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
	net_tcp_change_state(context->tcp, NET_TCP_SYN_SENT);
    d118:	4627      	mov	r7, r4
    d11a:	f023 0306 	bic.w	r3, r3, #6
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
    d11e:	f043 0302 	orr.w	r3, r3, #2
    d122:	f857 0f3c 	ldr.w	r0, [r7, #60]!
    d126:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
    d12a:	2102      	movs	r1, #2
    d12c:	f007 fd27 	bl	14b7e <net_tcp_change_state>
	return send_syn_segment(context, NULL, remote, NET_TCP_SYN, "SYN");
    d130:	2302      	movs	r3, #2
    d132:	4632      	mov	r2, r6
    d134:	2100      	movs	r1, #0
    d136:	4638      	mov	r0, r7
    d138:	f007 fe2a 	bl	14d90 <send_syn_segment.isra.38>
	net_context_set_state(context, NET_CONTEXT_CONNECTING);

	send_syn(context, addr);

	/* in tcp_synack_received() we give back this semaphore */
	if (timeout != 0 && k_sem_take(&context->tcp->connect_wait, timeout)) {
    d13c:	b12d      	cbz	r5, d14a <net_tcp_connect+0x82>
    d13e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    d140:	4629      	mov	r1, r5
    d142:	30a0      	adds	r0, #160	; 0xa0
    d144:	f002 fa8c 	bl	f660 <z_impl_k_sem_take>
    d148:	b928      	cbnz	r0, d156 <net_tcp_connect+0x8e>
		return -ETIMEDOUT;
	}

	return 0;
    d14a:	2000      	movs	r0, #0
}
    d14c:	b007      	add	sp, #28
    d14e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -ENOTSUP;
    d150:	f06f 0085 	mvn.w	r0, #133	; 0x85
    d154:	e7fa      	b.n	d14c <net_tcp_connect+0x84>
		return -ETIMEDOUT;
    d156:	f06f 0073 	mvn.w	r0, #115	; 0x73
    d15a:	e7f7      	b.n	d14c <net_tcp_connect+0x84>
    d15c:	0000c9cd 	.word	0x0000c9cd

0000d160 <connect_request_encode>:
	return mqtt_encode_fixed_header(message_type, start, buf);
}

int connect_request_encode(const struct mqtt_client *client,
			   struct buf_ctx *buf)
{
    d160:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	} else {
		mqtt_proto_desc = &mqtt_3_1_0_proto_desc;
	}

	/* Reserve space for fixed header. */
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
    d164:	680f      	ldr	r7, [r1, #0]
	u8_t connect_flags = client->clean_session << 1;
    d166:	f890 505d 	ldrb.w	r5, [r0, #93]	; 0x5d
	start = buf->cur;

	MQTT_TRC("Encoding Protocol Description. Str:%s Size:%08x.",
		 mqtt_proto_desc->utf8, mqtt_proto_desc->size);

	err_code = pack_utf8_str(mqtt_proto_desc, buf);
    d16a:	4b3b      	ldr	r3, [pc, #236]	; (d258 <connect_request_encode+0xf8>)
    d16c:	4a3b      	ldr	r2, [pc, #236]	; (d25c <connect_request_encode+0xfc>)
{
    d16e:	4606      	mov	r6, r0
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
    d170:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
    d174:	3705      	adds	r7, #5
	err_code = pack_utf8_str(mqtt_proto_desc, buf);
    d176:	2804      	cmp	r0, #4
    d178:	bf0c      	ite	eq
    d17a:	4610      	moveq	r0, r2
    d17c:	4618      	movne	r0, r3
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
    d17e:	600f      	str	r7, [r1, #0]
{
    d180:	460c      	mov	r4, r1
	err_code = pack_utf8_str(mqtt_proto_desc, buf);
    d182:	f008 f868 	bl	15256 <pack_utf8_str>
	u8_t connect_flags = client->clean_session << 1;
    d186:	f3c5 0540 	ubfx	r5, r5, #1, #1
	if (err_code != 0) {
    d18a:	4603      	mov	r3, r0
    d18c:	b938      	cbnz	r0, d19e <connect_request_encode+0x3e>
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
    d18e:	e9d4 2000 	ldrd	r2, r0, [r4]
    d192:	4290      	cmp	r0, r2
		return err_code;
	}

	MQTT_TRC("Encoding Protocol Version %02x.", client->protocol_version);
	err_code = pack_uint8(client->protocol_version, buf);
    d194:	f896 105c 	ldrb.w	r1, [r6, #92]	; 0x5c
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
    d198:	d104      	bne.n	d1a4 <connect_request_encode+0x44>
		return -ENOMEM;
    d19a:	f06f 030b 	mvn.w	r3, #11

	/* Write the flags the connect flags. */
	*connect_flags_pos = connect_flags;

	return mqtt_encode_fixed_header(message_type, start, buf);
}
    d19e:	4618      	mov	r0, r3
    d1a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	*(buf->cur++) = val;
    d1a4:	1c50      	adds	r0, r2, #1
    d1a6:	6020      	str	r0, [r4, #0]
    d1a8:	7011      	strb	r1, [r2, #0]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
    d1aa:	e9d4 8200 	ldrd	r8, r2, [r4]
    d1ae:	4590      	cmp	r8, r2
    d1b0:	d0f3      	beq.n	d19a <connect_request_encode+0x3a>
	*(buf->cur++) = val;
    d1b2:	f108 0201 	add.w	r2, r8, #1
    d1b6:	6022      	str	r2, [r4, #0]
	err_code = pack_uint16(MQTT_KEEPALIVE, buf);
    d1b8:	4621      	mov	r1, r4
	*(buf->cur++) = val;
    d1ba:	f888 3000 	strb.w	r3, [r8]
	err_code = pack_uint16(MQTT_KEEPALIVE, buf);
    d1be:	203c      	movs	r0, #60	; 0x3c
    d1c0:	f008 f837 	bl	15232 <pack_uint16>
	if (err_code != 0) {
    d1c4:	4603      	mov	r3, r0
    d1c6:	2800      	cmp	r0, #0
    d1c8:	d1e9      	bne.n	d19e <connect_request_encode+0x3e>
	err_code = pack_utf8_str(&client->client_id, buf);
    d1ca:	f106 002c 	add.w	r0, r6, #44	; 0x2c
    d1ce:	f008 f842 	bl	15256 <pack_utf8_str>
	if (err_code != 0) {
    d1d2:	4603      	mov	r3, r0
    d1d4:	2800      	cmp	r0, #0
    d1d6:	d1e2      	bne.n	d19e <connect_request_encode+0x3e>
	if (client->will_topic != NULL) {
    d1d8:	6c30      	ldr	r0, [r6, #64]	; 0x40
	u8_t connect_flags = client->clean_session << 1;
    d1da:	006d      	lsls	r5, r5, #1
	if (client->will_topic != NULL) {
    d1dc:	b1d8      	cbz	r0, d216 <connect_request_encode+0xb6>
		connect_flags |= client->will_retain << 5;
    d1de:	f896 305d 	ldrb.w	r3, [r6, #93]	; 0x5d
		connect_flags |= MQTT_CONNECT_FLAG_WILL_TOPIC;
    d1e2:	f045 0504 	orr.w	r5, r5, #4
		connect_flags |= client->will_retain << 5;
    d1e6:	f003 0301 	and.w	r3, r3, #1
    d1ea:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
		connect_flags |= ((client->will_topic->qos & 0x03) << 3);
    d1ee:	7a03      	ldrb	r3, [r0, #8]
    d1f0:	00db      	lsls	r3, r3, #3
    d1f2:	f003 0318 	and.w	r3, r3, #24
		err_code = pack_utf8_str(&client->will_topic->topic, buf);
    d1f6:	4621      	mov	r1, r4
		connect_flags |= client->will_retain << 5;
    d1f8:	431d      	orrs	r5, r3
		err_code = pack_utf8_str(&client->will_topic->topic, buf);
    d1fa:	f008 f82c 	bl	15256 <pack_utf8_str>
		if (err_code != 0) {
    d1fe:	4603      	mov	r3, r0
    d200:	2800      	cmp	r0, #0
    d202:	d1cc      	bne.n	d19e <connect_request_encode+0x3e>
		if (client->will_message != NULL) {
    d204:	6c73      	ldr	r3, [r6, #68]	; 0x44
			err_code = pack_utf8_str(client->will_message, buf);
    d206:	4621      	mov	r1, r4
		if (client->will_message != NULL) {
    d208:	b313      	cbz	r3, d250 <connect_request_encode+0xf0>
			err_code = pack_utf8_str(client->will_message, buf);
    d20a:	4618      	mov	r0, r3
    d20c:	f008 f823 	bl	15256 <pack_utf8_str>
			if (err_code != 0) {
    d210:	4603      	mov	r3, r0
    d212:	2800      	cmp	r0, #0
    d214:	d1c3      	bne.n	d19e <connect_request_encode+0x3e>
	if (client->user_name != NULL) {
    d216:	6bb0      	ldr	r0, [r6, #56]	; 0x38
    d218:	b138      	cbz	r0, d22a <connect_request_encode+0xca>
		err_code = pack_utf8_str(client->user_name, buf);
    d21a:	4621      	mov	r1, r4
    d21c:	f008 f81b 	bl	15256 <pack_utf8_str>
		if (err_code != 0) {
    d220:	4603      	mov	r3, r0
    d222:	2800      	cmp	r0, #0
    d224:	d1bb      	bne.n	d19e <connect_request_encode+0x3e>
		connect_flags |= MQTT_CONNECT_FLAG_USERNAME;
    d226:	f045 0580 	orr.w	r5, r5, #128	; 0x80
	if (client->password != NULL) {
    d22a:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
    d22c:	b138      	cbz	r0, d23e <connect_request_encode+0xde>
		err_code = pack_utf8_str(client->password, buf);
    d22e:	4621      	mov	r1, r4
    d230:	f008 f811 	bl	15256 <pack_utf8_str>
		if (err_code != 0) {
    d234:	4603      	mov	r3, r0
    d236:	2800      	cmp	r0, #0
    d238:	d1b1      	bne.n	d19e <connect_request_encode+0x3e>
		connect_flags |= MQTT_CONNECT_FLAG_PASSWORD;
    d23a:	f045 0540 	orr.w	r5, r5, #64	; 0x40
	*connect_flags_pos = connect_flags;
    d23e:	f888 5000 	strb.w	r5, [r8]
	return mqtt_encode_fixed_header(message_type, start, buf);
    d242:	4622      	mov	r2, r4
    d244:	4639      	mov	r1, r7
    d246:	2010      	movs	r0, #16
}
    d248:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
    d24c:	f008 b81e 	b.w	1528c <mqtt_encode_fixed_header>
	return pack_uint16(0x0000, buf);
    d250:	f007 ffef 	bl	15232 <pack_uint16>
    d254:	e7dc      	b.n	d210 <connect_request_encode+0xb0>
    d256:	bf00      	nop
    d258:	00016764 	.word	0x00016764
    d25c:	0001676c 	.word	0x0001676c

0000d260 <mqtt_read_message_chunk>:
	return err_code;
}

static int mqtt_read_message_chunk(struct mqtt_client *client,
				   struct buf_ctx *buf, u32_t length)
{
    d260:	b5f0      	push	{r4, r5, r6, r7, lr}
    d262:	460f      	mov	r7, r1
	int len;

	/* Calculate how much data we need to read from the transport,
	 * given the already buffered data.
	 */
	remaining = length - (buf->end - buf->cur);
    d264:	e9d1 6100 	ldrd	r6, r1, [r1]
    d268:	1b8e      	subs	r6, r1, r6
    d26a:	1b96      	subs	r6, r2, r6
	if (remaining <= 0) {
    d26c:	2e00      	cmp	r6, #0
{
    d26e:	b087      	sub	sp, #28
    d270:	4605      	mov	r5, r0
	if (remaining <= 0) {
    d272:	dc03      	bgt.n	d27c <mqtt_read_message_chunk+0x1c>
		return 0;
    d274:	2400      	movs	r4, #0
		MQTT_TRC("[CID %p]: Message partially received.", client);
		return -EAGAIN;
	}

	return 0;
}
    d276:	4620      	mov	r0, r4
    d278:	b007      	add	sp, #28
    d27a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (buf->end + remaining > client->rx_buf + client->rx_buf_size) {
    d27c:	e9d0 3413 	ldrd	r3, r4, [r0, #76]	; 0x4c
    d280:	198a      	adds	r2, r1, r6
    d282:	4423      	add	r3, r4
    d284:	429a      	cmp	r2, r3
    d286:	d911      	bls.n	d2ac <mqtt_read_message_chunk+0x4c>
		MQTT_ERR("[CID %p]: Buffer too small to receive the message",
    d288:	2301      	movs	r3, #1
    d28a:	f04f 0200 	mov.w	r2, #0
    d28e:	f363 0207 	bfi	r2, r3, #0, #8
    d292:	4932      	ldr	r1, [pc, #200]	; (d35c <mqtt_read_message_chunk+0xfc>)
    d294:	4b32      	ldr	r3, [pc, #200]	; (d360 <mqtt_read_message_chunk+0x100>)
    d296:	1a5b      	subs	r3, r3, r1
    d298:	08db      	lsrs	r3, r3, #3
    d29a:	4601      	mov	r1, r0
    d29c:	f363 128f 	bfi	r2, r3, #6, #10
    d2a0:	4830      	ldr	r0, [pc, #192]	; (d364 <mqtt_read_message_chunk+0x104>)
    d2a2:	f004 fe74 	bl	11f8e <log_1>
		return -ENOMEM;
    d2a6:	f06f 040b 	mvn.w	r4, #11
    d2aa:	e7e4      	b.n	d276 <mqtt_read_message_chunk+0x16>
	len = mqtt_transport_read(client, buf->end, remaining);
    d2ac:	4632      	mov	r2, r6
    d2ae:	f000 fa4d 	bl	d74c <mqtt_transport_read>
	if (len < 0) {
    d2b2:	1e04      	subs	r4, r0, #0
    d2b4:	da18      	bge.n	d2e8 <mqtt_read_message_chunk+0x88>
		MQTT_TRC("[CID %p]: Transport read error: %d", client, len);
    d2b6:	2304      	movs	r3, #4
    d2b8:	f04f 0600 	mov.w	r6, #0
    d2bc:	f363 0607 	bfi	r6, r3, #0, #8
    d2c0:	4a27      	ldr	r2, [pc, #156]	; (d360 <mqtt_read_message_chunk+0x100>)
    d2c2:	4b26      	ldr	r3, [pc, #152]	; (d35c <mqtt_read_message_chunk+0xfc>)
    d2c4:	1ad2      	subs	r2, r2, r3
    d2c6:	08d2      	lsrs	r2, r2, #3
    d2c8:	4b27      	ldr	r3, [pc, #156]	; (d368 <mqtt_read_message_chunk+0x108>)
    d2ca:	9302      	str	r3, [sp, #8]
    d2cc:	f362 168f 	bfi	r6, r2, #6, #10
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
    d2d0:	f002 f994 	bl	f5fc <z_impl_k_current_get>
    d2d4:	4633      	mov	r3, r6
    d2d6:	e9cd 0503 	strd	r0, r5, [sp, #12]
    d2da:	2204      	movs	r2, #4
    d2dc:	a902      	add	r1, sp, #8
    d2de:	4823      	ldr	r0, [pc, #140]	; (d36c <mqtt_read_message_chunk+0x10c>)
    d2e0:	9405      	str	r4, [sp, #20]
    d2e2:	f004 fe9b 	bl	1201c <log_n>
		return len;
    d2e6:	e7c6      	b.n	d276 <mqtt_read_message_chunk+0x16>
	if (len == 0) {
    d2e8:	d117      	bne.n	d31a <mqtt_read_message_chunk+0xba>
		MQTT_TRC("[CID %p]: Connection closed.", client);
    d2ea:	2304      	movs	r3, #4
    d2ec:	f04f 0400 	mov.w	r4, #0
    d2f0:	4a1a      	ldr	r2, [pc, #104]	; (d35c <mqtt_read_message_chunk+0xfc>)
    d2f2:	f363 0407 	bfi	r4, r3, #0, #8
    d2f6:	4b1a      	ldr	r3, [pc, #104]	; (d360 <mqtt_read_message_chunk+0x100>)
    d2f8:	1a9b      	subs	r3, r3, r2
    d2fa:	08db      	lsrs	r3, r3, #3
    d2fc:	f363 148f 	bfi	r4, r3, #6, #10
    d300:	f002 f97c 	bl	f5fc <z_impl_k_current_get>
    d304:	f8ad 4000 	strh.w	r4, [sp]
    d308:	4602      	mov	r2, r0
    d30a:	462b      	mov	r3, r5
    d30c:	4916      	ldr	r1, [pc, #88]	; (d368 <mqtt_read_message_chunk+0x108>)
    d30e:	4818      	ldr	r0, [pc, #96]	; (d370 <mqtt_read_message_chunk+0x110>)
    d310:	f004 fe69 	bl	11fe6 <log_3>
		return -ENOTCONN;
    d314:	f06f 047f 	mvn.w	r4, #127	; 0x7f
    d318:	e7ad      	b.n	d276 <mqtt_read_message_chunk+0x16>
	client->internal.rx_buf_datalen += len;
    d31a:	69eb      	ldr	r3, [r5, #28]
    d31c:	4423      	add	r3, r4
    d31e:	61eb      	str	r3, [r5, #28]
	buf->end += len;
    d320:	687b      	ldr	r3, [r7, #4]
	if (len < remaining) {
    d322:	42b4      	cmp	r4, r6
	buf->end += len;
    d324:	4423      	add	r3, r4
    d326:	607b      	str	r3, [r7, #4]
	if (len < remaining) {
    d328:	daa4      	bge.n	d274 <mqtt_read_message_chunk+0x14>
		MQTT_TRC("[CID %p]: Message partially received.", client);
    d32a:	2304      	movs	r3, #4
    d32c:	f04f 0400 	mov.w	r4, #0
    d330:	4a0a      	ldr	r2, [pc, #40]	; (d35c <mqtt_read_message_chunk+0xfc>)
    d332:	f363 0407 	bfi	r4, r3, #0, #8
    d336:	4b0a      	ldr	r3, [pc, #40]	; (d360 <mqtt_read_message_chunk+0x100>)
    d338:	1a9b      	subs	r3, r3, r2
    d33a:	08db      	lsrs	r3, r3, #3
    d33c:	f363 148f 	bfi	r4, r3, #6, #10
    d340:	f002 f95c 	bl	f5fc <z_impl_k_current_get>
    d344:	f8ad 4000 	strh.w	r4, [sp]
    d348:	4602      	mov	r2, r0
    d34a:	462b      	mov	r3, r5
    d34c:	4906      	ldr	r1, [pc, #24]	; (d368 <mqtt_read_message_chunk+0x108>)
    d34e:	4809      	ldr	r0, [pc, #36]	; (d374 <mqtt_read_message_chunk+0x114>)
    d350:	f004 fe49 	bl	11fe6 <log_3>
		return -EAGAIN;
    d354:	f06f 040a 	mvn.w	r4, #10
    d358:	e78d      	b.n	d276 <mqtt_read_message_chunk+0x16>
    d35a:	bf00      	nop
    d35c:	00016344 	.word	0x00016344
    d360:	000163d4 	.word	0x000163d4
    d364:	00018e27 	.word	0x00018e27
    d368:	00018be2 	.word	0x00018be2
    d36c:	00018e59 	.word	0x00018e59
    d370:	00018e86 	.word	0x00018e86
    d374:	00018ead 	.word	0x00018ead

0000d378 <mqtt_handle_rx>:

	return err_code;
}

int mqtt_handle_rx(struct mqtt_client *client)
{
    d378:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int err_code;
	u8_t type_and_flags;
	u32_t var_length;
	struct buf_ctx buf;

	buf.cur = client->rx_buf;
    d37c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
    d37e:	69c2      	ldr	r2, [r0, #28]
{
    d380:	b095      	sub	sp, #84	; 0x54
    d382:	4605      	mov	r5, r0
	buf.cur = client->rx_buf;
    d384:	9305      	str	r3, [sp, #20]
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
    d386:	4413      	add	r3, r2
    d388:	9306      	str	r3, [sp, #24]
	u8_t chunk_size = MQTT_FIXED_HEADER_MIN_SIZE;
    d38a:	2202      	movs	r2, #2
		err_code = mqtt_read_message_chunk(client, buf, chunk_size);
    d38c:	a905      	add	r1, sp, #20
    d38e:	4628      	mov	r0, r5
    d390:	f7ff ff66 	bl	d260 <mqtt_read_message_chunk>
		if (err_code < 0) {
    d394:	1e04      	subs	r4, r0, #0
    d396:	db2b      	blt.n	d3f0 <mqtt_handle_rx+0x78>
		buf->cur = client->rx_buf;
    d398:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
    d39a:	9305      	str	r3, [sp, #20]
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
    d39c:	aa04      	add	r2, sp, #16
    d39e:	f10d 010f 	add.w	r1, sp, #15
    d3a2:	a805      	add	r0, sp, #20
    d3a4:	f007 fec3 	bl	1512e <fixed_header_decode>
	} while (err_code == -EAGAIN);
    d3a8:	f110 0f0b 	cmn.w	r0, #11
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
    d3ac:	4604      	mov	r4, r0
		chunk_size = 1U;
    d3ae:	f04f 0201 	mov.w	r2, #1
	} while (err_code == -EAGAIN);
    d3b2:	d0eb      	beq.n	d38c <mqtt_handle_rx+0x14>

	err_code = mqtt_read_and_parse_fixed_header(client, &type_and_flags,
						    &var_length, &buf);
	if (err_code < 0) {
    d3b4:	2800      	cmp	r0, #0
    d3b6:	db1f      	blt.n	d3f8 <mqtt_handle_rx+0x80>
		return (err_code == -EAGAIN) ? 0 : err_code;
	}

	if ((type_and_flags & 0xF0) == MQTT_PKT_TYPE_PUBLISH) {
    d3b8:	f89d 600f 	ldrb.w	r6, [sp, #15]
    d3bc:	f006 03f0 	and.w	r3, r6, #240	; 0xf0
    d3c0:	2b30      	cmp	r3, #48	; 0x30
    d3c2:	d11d      	bne.n	d400 <mqtt_handle_rx+0x88>
	err_code = mqtt_read_message_chunk(client, buf, sizeof(u16_t));
    d3c4:	2202      	movs	r2, #2
    d3c6:	a905      	add	r1, sp, #20
    d3c8:	4628      	mov	r0, r5
    d3ca:	f7ff ff49 	bl	d260 <mqtt_read_message_chunk>
	if (err_code < 0) {
    d3ce:	1e04      	subs	r4, r0, #0
    d3d0:	db0e      	blt.n	d3f0 <mqtt_handle_rx+0x78>
	variable_header_length = *buf->cur << 8; /* MSB */
    d3d2:	9b05      	ldr	r3, [sp, #20]
    d3d4:	881a      	ldrh	r2, [r3, #0]
    d3d6:	ba52      	rev16	r2, r2
    d3d8:	b292      	uxth	r2, r2
	if (qos > MQTT_QOS_0_AT_MOST_ONCE) {
    d3da:	f016 0f06 	tst.w	r6, #6
	variable_header_length += sizeof(u16_t);
    d3de:	bf0c      	ite	eq
    d3e0:	3202      	addeq	r2, #2
		variable_header_length += sizeof(u16_t);
    d3e2:	3204      	addne	r2, #4
		err_code = mqtt_read_publish_var_header(client, type_and_flags,
							&buf);
	} else {
		err_code = mqtt_read_message_chunk(client, &buf, var_length);
    d3e4:	a905      	add	r1, sp, #20
    d3e6:	4628      	mov	r0, r5
    d3e8:	f7ff ff3a 	bl	d260 <mqtt_read_message_chunk>
	}

	if (err_code < 0) {
    d3ec:	1e04      	subs	r4, r0, #0
    d3ee:	da09      	bge.n	d404 <mqtt_handle_rx+0x8c>
		return (err_code == -EAGAIN) ? 0 : err_code;
    d3f0:	f114 0f0b 	cmn.w	r4, #11
    d3f4:	d100      	bne.n	d3f8 <mqtt_handle_rx+0x80>
    d3f6:	2400      	movs	r4, #0
	// LOG_DBG("halo\n");

	client->internal.rx_buf_datalen = 0U;

	return 0;
}
    d3f8:	4620      	mov	r0, r4
    d3fa:	b015      	add	sp, #84	; 0x54
    d3fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		err_code = mqtt_read_message_chunk(client, &buf, var_length);
    d400:	9a04      	ldr	r2, [sp, #16]
    d402:	e7ef      	b.n	d3e4 <mqtt_handle_rx+0x6c>
	err_code = mqtt_handle_packet(client, type_and_flags, var_length, &buf);
    d404:	f89d 700f 	ldrb.w	r7, [sp, #15]
    d408:	f8dd 8010 	ldr.w	r8, [sp, #16]
	evt.result = 0;
    d40c:	f007 03f0 	and.w	r3, r7, #240	; 0xf0
    d410:	2400      	movs	r4, #0
	switch (type_and_flags & 0xF0) {
    d412:	2b60      	cmp	r3, #96	; 0x60
	evt.result = 0;
    d414:	9413      	str	r4, [sp, #76]	; 0x4c
	switch (type_and_flags & 0xF0) {
    d416:	f000 8111 	beq.w	d63c <mqtt_handle_rx+0x2c4>
    d41a:	d82a      	bhi.n	d472 <mqtt_handle_rx+0xfa>
    d41c:	2b30      	cmp	r3, #48	; 0x30
    d41e:	f000 80af 	beq.w	d580 <mqtt_handle_rx+0x208>
    d422:	d804      	bhi.n	d42e <mqtt_handle_rx+0xb6>
    d424:	2b20      	cmp	r3, #32
    d426:	d062      	beq.n	d4ee <mqtt_handle_rx+0x176>
	client->internal.rx_buf_datalen = 0U;
    d428:	2400      	movs	r4, #0
    d42a:	61ec      	str	r4, [r5, #28]
	return 0;
    d42c:	e7e4      	b.n	d3f8 <mqtt_handle_rx+0x80>
	switch (type_and_flags & 0xF0) {
    d42e:	2b40      	cmp	r3, #64	; 0x40
    d430:	f000 80e5 	beq.w	d5fe <mqtt_handle_rx+0x286>
    d434:	2b50      	cmp	r3, #80	; 0x50
    d436:	d1f7      	bne.n	d428 <mqtt_handle_rx+0xb0>
		MQTT_TRC("[CID %p]: Received MQTT_PKT_TYPE_PUBREC!", client);
    d438:	2304      	movs	r3, #4
    d43a:	f04f 0400 	mov.w	r4, #0
    d43e:	4aab      	ldr	r2, [pc, #684]	; (d6ec <mqtt_handle_rx+0x374>)
    d440:	f363 0407 	bfi	r4, r3, #0, #8
    d444:	4baa      	ldr	r3, [pc, #680]	; (d6f0 <mqtt_handle_rx+0x378>)
    d446:	1a9b      	subs	r3, r3, r2
    d448:	08db      	lsrs	r3, r3, #3
    d44a:	f363 148f 	bfi	r4, r3, #6, #10
    d44e:	f002 f8d5 	bl	f5fc <z_impl_k_current_get>
    d452:	462b      	mov	r3, r5
    d454:	4602      	mov	r2, r0
    d456:	f8ad 4000 	strh.w	r4, [sp]
    d45a:	49a6      	ldr	r1, [pc, #664]	; (d6f4 <mqtt_handle_rx+0x37c>)
    d45c:	48a6      	ldr	r0, [pc, #664]	; (d6f8 <mqtt_handle_rx+0x380>)
    d45e:	f004 fdc2 	bl	11fe6 <log_3>
		evt.type = MQTT_EVT_PUBREC;
    d462:	2304      	movs	r3, #4
		err_code = publish_receive_decode(buf, &evt.param.pubrec);
    d464:	a90d      	add	r1, sp, #52	; 0x34
    d466:	a805      	add	r0, sp, #20
		evt.type = MQTT_EVT_PUBREC;
    d468:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		err_code = publish_receive_decode(buf, &evt.param.pubrec);
    d46c:	f007 fec9 	bl	15202 <publish_receive_decode>
    d470:	e0e1      	b.n	d636 <mqtt_handle_rx+0x2be>
	switch (type_and_flags & 0xF0) {
    d472:	2b90      	cmp	r3, #144	; 0x90
    d474:	f000 80ff 	beq.w	d676 <mqtt_handle_rx+0x2fe>
    d478:	d81e      	bhi.n	d4b8 <mqtt_handle_rx+0x140>
    d47a:	2b70      	cmp	r3, #112	; 0x70
    d47c:	d1d4      	bne.n	d428 <mqtt_handle_rx+0xb0>
		MQTT_TRC("[CID %p]: Received MQTT_PKT_TYPE_PUBCOMP!", client);
    d47e:	2304      	movs	r3, #4
    d480:	f04f 0400 	mov.w	r4, #0
    d484:	4a99      	ldr	r2, [pc, #612]	; (d6ec <mqtt_handle_rx+0x374>)
    d486:	f363 0407 	bfi	r4, r3, #0, #8
    d48a:	4b99      	ldr	r3, [pc, #612]	; (d6f0 <mqtt_handle_rx+0x378>)
    d48c:	1a9b      	subs	r3, r3, r2
    d48e:	08db      	lsrs	r3, r3, #3
    d490:	f363 148f 	bfi	r4, r3, #6, #10
    d494:	f002 f8b2 	bl	f5fc <z_impl_k_current_get>
    d498:	462b      	mov	r3, r5
    d49a:	4602      	mov	r2, r0
    d49c:	f8ad 4000 	strh.w	r4, [sp]
    d4a0:	4994      	ldr	r1, [pc, #592]	; (d6f4 <mqtt_handle_rx+0x37c>)
    d4a2:	4896      	ldr	r0, [pc, #600]	; (d6fc <mqtt_handle_rx+0x384>)
    d4a4:	f004 fd9f 	bl	11fe6 <log_3>
		evt.type = MQTT_EVT_PUBCOMP;
    d4a8:	2306      	movs	r3, #6
		err_code = publish_complete_decode(buf, &evt.param.pubcomp);
    d4aa:	a90d      	add	r1, sp, #52	; 0x34
    d4ac:	a805      	add	r0, sp, #20
		evt.type = MQTT_EVT_PUBCOMP;
    d4ae:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		err_code = publish_complete_decode(buf, &evt.param.pubcomp);
    d4b2:	f007 feaa 	bl	1520a <publish_complete_decode>
    d4b6:	e0be      	b.n	d636 <mqtt_handle_rx+0x2be>
	switch (type_and_flags & 0xF0) {
    d4b8:	2bb0      	cmp	r3, #176	; 0xb0
    d4ba:	f000 80f9 	beq.w	d6b0 <mqtt_handle_rx+0x338>
    d4be:	2bd0      	cmp	r3, #208	; 0xd0
    d4c0:	d1b2      	bne.n	d428 <mqtt_handle_rx+0xb0>
		MQTT_TRC("[CID %p]: Received MQTT_PKT_TYPE_PINGRSP!", client);
    d4c2:	2304      	movs	r3, #4
    d4c4:	f04f 0400 	mov.w	r4, #0
    d4c8:	4a88      	ldr	r2, [pc, #544]	; (d6ec <mqtt_handle_rx+0x374>)
    d4ca:	f363 0407 	bfi	r4, r3, #0, #8
    d4ce:	4b88      	ldr	r3, [pc, #544]	; (d6f0 <mqtt_handle_rx+0x378>)
    d4d0:	1a9b      	subs	r3, r3, r2
    d4d2:	08db      	lsrs	r3, r3, #3
    d4d4:	f363 148f 	bfi	r4, r3, #6, #10
    d4d8:	f002 f890 	bl	f5fc <z_impl_k_current_get>
    d4dc:	f8ad 4000 	strh.w	r4, [sp]
    d4e0:	4602      	mov	r2, r0
    d4e2:	462b      	mov	r3, r5
    d4e4:	4983      	ldr	r1, [pc, #524]	; (d6f4 <mqtt_handle_rx+0x37c>)
    d4e6:	4886      	ldr	r0, [pc, #536]	; (d700 <mqtt_handle_rx+0x388>)
    d4e8:	f004 fd7d 	bl	11fe6 <log_3>
	if (err_code < 0) {
    d4ec:	e79c      	b.n	d428 <mqtt_handle_rx+0xb0>
		MQTT_TRC("[CID %p]: Received MQTT_PKT_TYPE_CONNACK!", client);
    d4ee:	2304      	movs	r3, #4
    d4f0:	f04f 0700 	mov.w	r7, #0
    d4f4:	f363 0707 	bfi	r7, r3, #0, #8
    d4f8:	4e7d      	ldr	r6, [pc, #500]	; (d6f0 <mqtt_handle_rx+0x378>)
    d4fa:	4b7c      	ldr	r3, [pc, #496]	; (d6ec <mqtt_handle_rx+0x374>)
    d4fc:	f8df 81f4 	ldr.w	r8, [pc, #500]	; d6f4 <mqtt_handle_rx+0x37c>
    d500:	1af6      	subs	r6, r6, r3
    d502:	f002 f87b 	bl	f5fc <z_impl_k_current_get>
    d506:	f3c6 06c9 	ubfx	r6, r6, #3, #10
    d50a:	f366 178f 	bfi	r7, r6, #6, #10
    d50e:	4602      	mov	r2, r0
    d510:	462b      	mov	r3, r5
    d512:	4641      	mov	r1, r8
    d514:	487b      	ldr	r0, [pc, #492]	; (d704 <mqtt_handle_rx+0x38c>)
    d516:	f8ad 7000 	strh.w	r7, [sp]
    d51a:	f004 fd64 	bl	11fe6 <log_3>
		err_code = connect_ack_decode(client, buf, &evt.param.connack);
    d51e:	aa0d      	add	r2, sp, #52	; 0x34
    d520:	a905      	add	r1, sp, #20
    d522:	4628      	mov	r0, r5
		evt.type = MQTT_EVT_CONNACK;
    d524:	f88d 4030 	strb.w	r4, [sp, #48]	; 0x30
		err_code = connect_ack_decode(client, buf, &evt.param.connack);
    d528:	f007 fe12 	bl	15150 <connect_ack_decode>
		if (err_code == 0) {
    d52c:	4604      	mov	r4, r0
    d52e:	2800      	cmp	r0, #0
    d530:	f040 8082 	bne.w	d638 <mqtt_handle_rx+0x2c0>
			MQTT_TRC("[CID %p]: return_code: %d", client,
    d534:	2304      	movs	r3, #4
    d536:	f04f 0700 	mov.w	r7, #0
    d53a:	f363 0707 	bfi	r7, r3, #0, #8
    d53e:	f8cd 801c 	str.w	r8, [sp, #28]
    d542:	f002 f85b 	bl	f5fc <z_impl_k_current_get>
    d546:	f366 178f 	bfi	r7, r6, #6, #10
    d54a:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
    d54e:	930a      	str	r3, [sp, #40]	; 0x28
    d550:	e9cd 0508 	strd	r0, r5, [sp, #32]
    d554:	2204      	movs	r2, #4
    d556:	463b      	mov	r3, r7
    d558:	a907      	add	r1, sp, #28
    d55a:	486b      	ldr	r0, [pc, #428]	; (d708 <mqtt_handle_rx+0x390>)
    d55c:	f004 fd5e 	bl	1201c <log_n>
			if (evt.param.connack.return_code ==
    d560:	f89d 2035 	ldrb.w	r2, [sp, #53]	; 0x35
    d564:	b91a      	cbnz	r2, d56e <mqtt_handle_rx+0x1f6>
				MQTT_SET_STATE(client, MQTT_STATE_CONNECTED);
    d566:	69ab      	ldr	r3, [r5, #24]
    d568:	f043 0304 	orr.w	r3, r3, #4
    d56c:	61ab      	str	r3, [r5, #24]
			evt.result = evt.param.connack.return_code;
    d56e:	9213      	str	r2, [sp, #76]	; 0x4c
		event_notify(client, &evt);
    d570:	a90c      	add	r1, sp, #48	; 0x30
    d572:	4628      	mov	r0, r5
    d574:	f007 ff83 	bl	1547e <event_notify>
	if (err_code < 0) {
    d578:	2c00      	cmp	r4, #0
    d57a:	f6bf af55 	bge.w	d428 <mqtt_handle_rx+0xb0>
    d57e:	e73b      	b.n	d3f8 <mqtt_handle_rx+0x80>
		MQTT_TRC("[CID %p]: Received MQTT_PKT_TYPE_PUBLISH", client);
    d580:	2304      	movs	r3, #4
    d582:	f04f 0400 	mov.w	r4, #0
    d586:	f363 0407 	bfi	r4, r3, #0, #8
    d58a:	4e59      	ldr	r6, [pc, #356]	; (d6f0 <mqtt_handle_rx+0x378>)
    d58c:	4b57      	ldr	r3, [pc, #348]	; (d6ec <mqtt_handle_rx+0x374>)
    d58e:	f8df 9164 	ldr.w	r9, [pc, #356]	; d6f4 <mqtt_handle_rx+0x37c>
    d592:	1af6      	subs	r6, r6, r3
    d594:	f002 f832 	bl	f5fc <z_impl_k_current_get>
    d598:	f3c6 06c9 	ubfx	r6, r6, #3, #10
    d59c:	f366 148f 	bfi	r4, r6, #6, #10
    d5a0:	f8ad 4000 	strh.w	r4, [sp]
    d5a4:	462b      	mov	r3, r5
    d5a6:	4602      	mov	r2, r0
    d5a8:	4649      	mov	r1, r9
    d5aa:	4858      	ldr	r0, [pc, #352]	; (d70c <mqtt_handle_rx+0x394>)
    d5ac:	f004 fd1b 	bl	11fe6 <log_3>
		evt.type = MQTT_EVT_PUBLISH;
    d5b0:	2302      	movs	r3, #2
		err_code = publish_decode(type_and_flags, var_length, buf,
    d5b2:	aa05      	add	r2, sp, #20
    d5b4:	4641      	mov	r1, r8
		evt.type = MQTT_EVT_PUBLISH;
    d5b6:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		err_code = publish_decode(type_and_flags, var_length, buf,
    d5ba:	4638      	mov	r0, r7
    d5bc:	ab0d      	add	r3, sp, #52	; 0x34
    d5be:	f007 fde2 	bl	15186 <publish_decode>
		client->internal.remaining_payload =
    d5c2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    d5c4:	622b      	str	r3, [r5, #32]
		MQTT_TRC("PUB QoS:%02x, message len %08x, topic len %08x",
    d5c6:	f04f 0700 	mov.w	r7, #0
    d5ca:	2304      	movs	r3, #4
    d5cc:	f363 0707 	bfi	r7, r3, #0, #8
		err_code = publish_decode(type_and_flags, var_length, buf,
    d5d0:	4604      	mov	r4, r0
		evt.result = err_code;
    d5d2:	9013      	str	r0, [sp, #76]	; 0x4c
		MQTT_TRC("PUB QoS:%02x, message len %08x, topic len %08x",
    d5d4:	f8cd 901c 	str.w	r9, [sp, #28]
    d5d8:	f002 f810 	bl	f5fc <z_impl_k_current_get>
    d5dc:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
    d5e0:	9309      	str	r3, [sp, #36]	; 0x24
    d5e2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    d5e4:	930a      	str	r3, [sp, #40]	; 0x28
    d5e6:	f366 178f 	bfi	r7, r6, #6, #10
    d5ea:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    d5ec:	9008      	str	r0, [sp, #32]
    d5ee:	930b      	str	r3, [sp, #44]	; 0x2c
    d5f0:	2205      	movs	r2, #5
    d5f2:	463b      	mov	r3, r7
    d5f4:	a907      	add	r1, sp, #28
    d5f6:	4846      	ldr	r0, [pc, #280]	; (d710 <mqtt_handle_rx+0x398>)
    d5f8:	f004 fd10 	bl	1201c <log_n>
	if (notify_event == true) {
    d5fc:	e7b8      	b.n	d570 <mqtt_handle_rx+0x1f8>
		MQTT_TRC("[CID %p]: Received MQTT_PKT_TYPE_PUBACK!", client);
    d5fe:	2304      	movs	r3, #4
    d600:	f04f 0400 	mov.w	r4, #0
    d604:	4a39      	ldr	r2, [pc, #228]	; (d6ec <mqtt_handle_rx+0x374>)
    d606:	f363 0407 	bfi	r4, r3, #0, #8
    d60a:	4b39      	ldr	r3, [pc, #228]	; (d6f0 <mqtt_handle_rx+0x378>)
    d60c:	1a9b      	subs	r3, r3, r2
    d60e:	08db      	lsrs	r3, r3, #3
    d610:	f363 148f 	bfi	r4, r3, #6, #10
    d614:	f001 fff2 	bl	f5fc <z_impl_k_current_get>
    d618:	462b      	mov	r3, r5
    d61a:	4602      	mov	r2, r0
    d61c:	4935      	ldr	r1, [pc, #212]	; (d6f4 <mqtt_handle_rx+0x37c>)
    d61e:	483d      	ldr	r0, [pc, #244]	; (d714 <mqtt_handle_rx+0x39c>)
    d620:	f8ad 4000 	strh.w	r4, [sp]
    d624:	f004 fcdf 	bl	11fe6 <log_3>
		evt.type = MQTT_EVT_PUBACK;
    d628:	2303      	movs	r3, #3
		err_code = publish_ack_decode(buf, &evt.param.puback);
    d62a:	a90d      	add	r1, sp, #52	; 0x34
    d62c:	a805      	add	r0, sp, #20
		evt.type = MQTT_EVT_PUBACK;
    d62e:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		err_code = publish_ack_decode(buf, &evt.param.puback);
    d632:	f007 fde4 	bl	151fe <publish_ack_decode>
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
    d636:	4604      	mov	r4, r0
		evt.result = err_code;
    d638:	9413      	str	r4, [sp, #76]	; 0x4c
	if (notify_event == true) {
    d63a:	e799      	b.n	d570 <mqtt_handle_rx+0x1f8>
		MQTT_TRC("[CID %p]: Received MQTT_PKT_TYPE_PUBREL!", client);
    d63c:	2304      	movs	r3, #4
    d63e:	f04f 0400 	mov.w	r4, #0
    d642:	4a2a      	ldr	r2, [pc, #168]	; (d6ec <mqtt_handle_rx+0x374>)
    d644:	f363 0407 	bfi	r4, r3, #0, #8
    d648:	4b29      	ldr	r3, [pc, #164]	; (d6f0 <mqtt_handle_rx+0x378>)
    d64a:	1a9b      	subs	r3, r3, r2
    d64c:	08db      	lsrs	r3, r3, #3
    d64e:	f363 148f 	bfi	r4, r3, #6, #10
    d652:	f001 ffd3 	bl	f5fc <z_impl_k_current_get>
    d656:	462b      	mov	r3, r5
    d658:	4602      	mov	r2, r0
    d65a:	f8ad 4000 	strh.w	r4, [sp]
    d65e:	4925      	ldr	r1, [pc, #148]	; (d6f4 <mqtt_handle_rx+0x37c>)
    d660:	482d      	ldr	r0, [pc, #180]	; (d718 <mqtt_handle_rx+0x3a0>)
    d662:	f004 fcc0 	bl	11fe6 <log_3>
		evt.type = MQTT_EVT_PUBREL;
    d666:	2305      	movs	r3, #5
		err_code = publish_release_decode(buf, &evt.param.pubrel);
    d668:	a90d      	add	r1, sp, #52	; 0x34
    d66a:	a805      	add	r0, sp, #20
		evt.type = MQTT_EVT_PUBREL;
    d66c:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		err_code = publish_release_decode(buf, &evt.param.pubrel);
    d670:	f007 fdc9 	bl	15206 <publish_release_decode>
    d674:	e7df      	b.n	d636 <mqtt_handle_rx+0x2be>
		MQTT_TRC("[CID %p]: Received MQTT_PKT_TYPE_SUBACK!", client);
    d676:	2304      	movs	r3, #4
    d678:	f04f 0400 	mov.w	r4, #0
    d67c:	4a1b      	ldr	r2, [pc, #108]	; (d6ec <mqtt_handle_rx+0x374>)
    d67e:	f363 0407 	bfi	r4, r3, #0, #8
    d682:	4b1b      	ldr	r3, [pc, #108]	; (d6f0 <mqtt_handle_rx+0x378>)
    d684:	1a9b      	subs	r3, r3, r2
    d686:	08db      	lsrs	r3, r3, #3
    d688:	f363 148f 	bfi	r4, r3, #6, #10
    d68c:	f001 ffb6 	bl	f5fc <z_impl_k_current_get>
    d690:	462b      	mov	r3, r5
    d692:	4602      	mov	r2, r0
    d694:	f8ad 4000 	strh.w	r4, [sp]
    d698:	4916      	ldr	r1, [pc, #88]	; (d6f4 <mqtt_handle_rx+0x37c>)
    d69a:	4820      	ldr	r0, [pc, #128]	; (d71c <mqtt_handle_rx+0x3a4>)
    d69c:	f004 fca3 	bl	11fe6 <log_3>
		evt.type = MQTT_EVT_SUBACK;
    d6a0:	2307      	movs	r3, #7
		err_code = subscribe_ack_decode(buf, &evt.param.suback);
    d6a2:	a90d      	add	r1, sp, #52	; 0x34
    d6a4:	a805      	add	r0, sp, #20
		evt.type = MQTT_EVT_SUBACK;
    d6a6:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		err_code = subscribe_ack_decode(buf, &evt.param.suback);
    d6aa:	f007 fdb0 	bl	1520e <subscribe_ack_decode>
    d6ae:	e7c2      	b.n	d636 <mqtt_handle_rx+0x2be>
		MQTT_TRC("[CID %p]: Received MQTT_PKT_TYPE_UNSUBACK!", client);
    d6b0:	2304      	movs	r3, #4
    d6b2:	f04f 0400 	mov.w	r4, #0
    d6b6:	4a0d      	ldr	r2, [pc, #52]	; (d6ec <mqtt_handle_rx+0x374>)
    d6b8:	f363 0407 	bfi	r4, r3, #0, #8
    d6bc:	4b0c      	ldr	r3, [pc, #48]	; (d6f0 <mqtt_handle_rx+0x378>)
    d6be:	1a9b      	subs	r3, r3, r2
    d6c0:	08db      	lsrs	r3, r3, #3
    d6c2:	f363 148f 	bfi	r4, r3, #6, #10
    d6c6:	f001 ff99 	bl	f5fc <z_impl_k_current_get>
    d6ca:	462b      	mov	r3, r5
    d6cc:	4602      	mov	r2, r0
    d6ce:	f8ad 4000 	strh.w	r4, [sp]
    d6d2:	4908      	ldr	r1, [pc, #32]	; (d6f4 <mqtt_handle_rx+0x37c>)
    d6d4:	4812      	ldr	r0, [pc, #72]	; (d720 <mqtt_handle_rx+0x3a8>)
    d6d6:	f004 fc86 	bl	11fe6 <log_3>
		evt.type = MQTT_EVT_UNSUBACK;
    d6da:	2308      	movs	r3, #8
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
    d6dc:	a90d      	add	r1, sp, #52	; 0x34
    d6de:	a805      	add	r0, sp, #20
		evt.type = MQTT_EVT_UNSUBACK;
    d6e0:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
    d6e4:	f007 fda3 	bl	1522e <unsubscribe_ack_decode>
    d6e8:	e7a5      	b.n	d636 <mqtt_handle_rx+0x2be>
    d6ea:	bf00      	nop
    d6ec:	00016344 	.word	0x00016344
    d6f0:	000163d4 	.word	0x000163d4
    d6f4:	00018bcf 	.word	0x00018bcf
    d6f8:	00018cf1 	.word	0x00018cf1
    d6fc:	00018d57 	.word	0x00018d57
    d700:	00018df3 	.word	0x00018df3
    d704:	00018bfa 	.word	0x00018bfa
    d708:	00018c2e 	.word	0x00018c2e
    d70c:	00018c52 	.word	0x00018c52
    d710:	00018c85 	.word	0x00018c85
    d714:	00018cbe 	.word	0x00018cbe
    d718:	00018d24 	.word	0x00018d24
    d71c:	00018d8b 	.word	0x00018d8b
    d720:	00018dbe 	.word	0x00018dbe

0000d724 <mqtt_transport_connect>:
#endif /* CONFIG_MQTT_LIB_SOCKS */
};

int mqtt_transport_connect(struct mqtt_client *client)
{
	return transport_fn[client->transport.type].connect(client);
    d724:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
    d728:	4a01      	ldr	r2, [pc, #4]	; (d730 <mqtt_transport_connect+0xc>)
    d72a:	011b      	lsls	r3, r3, #4
    d72c:	58d3      	ldr	r3, [r2, r3]
    d72e:	4718      	bx	r3
    d730:	00016774 	.word	0x00016774

0000d734 <mqtt_transport_write>:
}

int mqtt_transport_write(struct mqtt_client *client, const u8_t *data,
			 u32_t datalen)
{
    d734:	b410      	push	{r4}
	return transport_fn[client->transport.type].write(client, data,
    d736:	4b04      	ldr	r3, [pc, #16]	; (d748 <mqtt_transport_write+0x14>)
    d738:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
    d73c:	eb03 1304 	add.w	r3, r3, r4, lsl #4
							  datalen);
}
    d740:	bc10      	pop	{r4}
	return transport_fn[client->transport.type].write(client, data,
    d742:	685b      	ldr	r3, [r3, #4]
    d744:	4718      	bx	r3
    d746:	bf00      	nop
    d748:	00016774 	.word	0x00016774

0000d74c <mqtt_transport_read>:

int mqtt_transport_read(struct mqtt_client *client, u8_t *data, u32_t buflen)
{
    d74c:	b410      	push	{r4}
	return transport_fn[client->transport.type].read(client, data, buflen);
    d74e:	4b04      	ldr	r3, [pc, #16]	; (d760 <mqtt_transport_read+0x14>)
    d750:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
    d754:	eb03 1304 	add.w	r3, r3, r4, lsl #4
}
    d758:	bc10      	pop	{r4}
	return transport_fn[client->transport.type].read(client, data, buflen);
    d75a:	689b      	ldr	r3, [r3, #8]
    d75c:	4718      	bx	r3
    d75e:	bf00      	nop
    d760:	00016774 	.word	0x00016774

0000d764 <sys_mutex_unlock>:
	return k_mutex_lock(&mutex->kernel_mutex, timeout);
}

static inline int sys_mutex_unlock(struct sys_mutex *mutex)
{
	if (mutex->kernel_mutex.lock_count == 0) {
    d764:	68c2      	ldr	r2, [r0, #12]
{
    d766:	b508      	push	{r3, lr}
	if (mutex->kernel_mutex.lock_count == 0) {
    d768:	b142      	cbz	r2, d77c <sys_mutex_unlock+0x18>
		return -EINVAL;
	}

	if (mutex->kernel_mutex.owner != _current) {
    d76a:	4b07      	ldr	r3, [pc, #28]	; (d788 <sys_mutex_unlock+0x24>)
    d76c:	6882      	ldr	r2, [r0, #8]
    d76e:	689b      	ldr	r3, [r3, #8]
    d770:	429a      	cmp	r2, r3
    d772:	d106      	bne.n	d782 <sys_mutex_unlock+0x1e>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
    d774:	f001 fbea 	bl	ef4c <z_impl_k_mutex_unlock>
		return -EPERM;
	}

	k_mutex_unlock(&mutex->kernel_mutex);
	return 0;
    d778:	2000      	movs	r0, #0
}
    d77a:	bd08      	pop	{r3, pc}
		return -EINVAL;
    d77c:	f06f 0015 	mvn.w	r0, #21
    d780:	e7fb      	b.n	d77a <sys_mutex_unlock+0x16>
		return -EPERM;
    d782:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d786:	e7f8      	b.n	d77a <sys_mutex_unlock+0x16>
    d788:	200055e4 	.word	0x200055e4

0000d78c <client_disconnect>:
		mqtt_mutex_lock(client);
	}
}

static void client_disconnect(struct mqtt_client *client, int result)
{
    d78c:	b530      	push	{r4, r5, lr}
    d78e:	b089      	sub	sp, #36	; 0x24
    d790:	4604      	mov	r4, r0
    d792:	460d      	mov	r5, r1
	int err_code;

	err_code = mqtt_transport_disconnect(client);
    d794:	f007 fe5f 	bl	15456 <mqtt_transport_disconnect>
	if (err_code < 0) {
    d798:	2800      	cmp	r0, #0
    d79a:	da0d      	bge.n	d7b8 <client_disconnect+0x2c>
		MQTT_ERR("Failed to disconnect transport!");
    d79c:	2301      	movs	r3, #1
    d79e:	f04f 0100 	mov.w	r1, #0
    d7a2:	f363 0107 	bfi	r1, r3, #0, #8
    d7a6:	4a11      	ldr	r2, [pc, #68]	; (d7ec <client_disconnect+0x60>)
    d7a8:	4b11      	ldr	r3, [pc, #68]	; (d7f0 <client_disconnect+0x64>)
    d7aa:	4812      	ldr	r0, [pc, #72]	; (d7f4 <client_disconnect+0x68>)
    d7ac:	1a9b      	subs	r3, r3, r2
    d7ae:	08db      	lsrs	r3, r3, #3
    d7b0:	f363 118f 	bfi	r1, r3, #6, #10
    d7b4:	f004 fbde 	bl	11f74 <log_0>
	if (MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED) ||
    d7b8:	69a3      	ldr	r3, [r4, #24]
    d7ba:	f013 030c 	ands.w	r3, r3, #12
		evt.type = MQTT_EVT_DISCONNECT;
    d7be:	bf14      	ite	ne
    d7c0:	2301      	movne	r3, #1
		evt.type = MQTT_EVT_CONNACK;
    d7c2:	f88d 3000 	strbeq.w	r3, [sp]
	event_notify(client, &evt);
    d7c6:	4669      	mov	r1, sp
		evt.result = -ECONNREFUSED;
    d7c8:	bf08      	it	eq
    d7ca:	f06f 036e 	mvneq.w	r3, #110	; 0x6e
	event_notify(client, &evt);
    d7ce:	4620      	mov	r0, r4
		evt.type = MQTT_EVT_DISCONNECT;
    d7d0:	bf16      	itet	ne
    d7d2:	f88d 3000 	strbne.w	r3, [sp]
		evt.result = -ECONNREFUSED;
    d7d6:	9307      	streq	r3, [sp, #28]
		evt.result = result;
    d7d8:	9507      	strne	r5, [sp, #28]
	event_notify(client, &evt);
    d7da:	f007 fe50 	bl	1547e <event_notify>
	MQTT_STATE_INIT(client);
    d7de:	2300      	movs	r3, #0
	client->internal.last_activity = 0U;
    d7e0:	e9c4 3305 	strd	r3, r3, [r4, #20]
	client->internal.remaining_payload = 0U;
    d7e4:	e9c4 3307 	strd	r3, r3, [r4, #28]
	}

	disconnect_event_notify(client, result);
}
    d7e8:	b009      	add	sp, #36	; 0x24
    d7ea:	bd30      	pop	{r4, r5, pc}
    d7ec:	00016344 	.word	0x00016344
    d7f0:	000163b4 	.word	0x000163b4
    d7f4:	00018efb 	.word	0x00018efb

0000d7f8 <net_config_init>:
#else
#define setup_ipv6(...)
#endif /* CONFIG_NET_IPV6 */

int net_config_init(const char *app_info, u32_t flags, s32_t timeout)
{
    d7f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d7fc:	b086      	sub	sp, #24
    d7fe:	4616      	mov	r6, r2
    d800:	4682      	mov	sl, r0
    d802:	4689      	mov	r9, r1
    d804:	4d5c      	ldr	r5, [pc, #368]	; (d978 <net_config_init+0x180>)
#define LOOP_DIVIDER 10
	struct net_if *iface = net_if_get_default();
    d806:	f7fd fc27 	bl	b058 <net_if_get_default>
    d80a:	4b5c      	ldr	r3, [pc, #368]	; (d97c <net_config_init+0x184>)
    d80c:	1aed      	subs	r5, r5, r3
	int loop = timeout / LOOP_DIVIDER;
    d80e:	270a      	movs	r7, #10
	struct net_if *iface = net_if_get_default();
    d810:	4604      	mov	r4, r0
	int loop = timeout / LOOP_DIVIDER;
    d812:	fb96 f7f7 	sdiv	r7, r6, r7
	int count = 0;

	if (app_info) {
    d816:	f3c5 05c9 	ubfx	r5, r5, #3, #10
    d81a:	f1ba 0f00 	cmp.w	sl, #0
    d81e:	d00e      	beq.n	d83e <net_config_init+0x46>
		NET_INFO("%s", log_strdup(app_info));
    d820:	2303      	movs	r3, #3
    d822:	f04f 0800 	mov.w	r8, #0
    d826:	4650      	mov	r0, sl
    d828:	f363 0807 	bfi	r8, r3, #0, #8
    d82c:	f7f9 fba8 	bl	6f80 <log_strdup>
    d830:	f365 188f 	bfi	r8, r5, #6, #10
    d834:	4601      	mov	r1, r0
    d836:	4642      	mov	r2, r8
    d838:	4851      	ldr	r0, [pc, #324]	; (d980 <net_config_init+0x188>)
    d83a:	f004 fba8 	bl	11f8e <log_1>
	}

	if (!iface) {
    d83e:	b974      	cbnz	r4, d85e <net_config_init+0x66>
		NET_ERR("No network interfaces");
    d840:	2301      	movs	r3, #1
    d842:	f04f 0100 	mov.w	r1, #0
    d846:	f363 0107 	bfi	r1, r3, #0, #8
    d84a:	484e      	ldr	r0, [pc, #312]	; (d984 <net_config_init+0x18c>)
    d84c:	f365 118f 	bfi	r1, r5, #6, #10
    d850:	f004 fb90 	bl	11f74 <log_0>
		return -ENODEV;
    d854:	f06f 0012 	mvn.w	r0, #18
		NET_ERR("Timeout while waiting setup");
		return -ETIMEDOUT;
	}

	return 0;
}
    d858:	b006      	add	sp, #24
    d85a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (flags & NET_CONFIG_NEED_IPV6) {
    d85e:	f3c9 0140 	ubfx	r1, r9, #1, #1
	if (flags & NET_CONFIG_NEED_IPV4) {
    d862:	f019 0f04 	tst.w	r9, #4
		count++;
    d866:	bf18      	it	ne
    d868:	3101      	addne	r1, #1
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    d86a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    d86e:	4846      	ldr	r0, [pc, #280]	; (d988 <net_config_init+0x190>)
    d870:	f008 fa96 	bl	15da0 <z_impl_k_sem_init>
	if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_ADDR, &addr)) {
    d874:	aa01      	add	r2, sp, #4
    d876:	4945      	ldr	r1, [pc, #276]	; (d98c <net_config_init+0x194>)
    d878:	2001      	movs	r0, #1
    d87a:	f006 fc7c 	bl	14176 <net_addr_pton>
    d87e:	4603      	mov	r3, r0
    d880:	b1d8      	cbz	r0, d8ba <net_config_init+0xc2>
		NET_ERR("Invalid address: %s", CONFIG_NET_CONFIG_MY_IPV4_ADDR);
    d882:	f04f 0200 	mov.w	r2, #0
    d886:	2301      	movs	r3, #1
    d888:	f363 0207 	bfi	r2, r3, #0, #8
    d88c:	f365 128f 	bfi	r2, r5, #6, #10
    d890:	493e      	ldr	r1, [pc, #248]	; (d98c <net_config_init+0x194>)
    d892:	483f      	ldr	r0, [pc, #252]	; (d990 <net_config_init+0x198>)
    d894:	f004 fb7b 	bl	11f8e <log_1>
	if (timeout < 0) {
    d898:	2e00      	cmp	r6, #0
    d89a:	db65      	blt.n	d968 <net_config_init+0x170>
	} else if (timeout == 0) {
    d89c:	d067      	beq.n	d96e <net_config_init+0x176>
		count = timeout / 1000 + 1;
    d89e:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    d8a2:	fb96 f4f4 	sdiv	r4, r6, r4
    d8a6:	3401      	adds	r4, #1
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    d8a8:	f8df 80f4 	ldr.w	r8, [pc, #244]	; d9a0 <net_config_init+0x1a8>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SEM_COUNT_GET, k_sem_count_get, unsigned int, struct k_sem *, sem)
    d8ac:	f8df 90d8 	ldr.w	r9, [pc, #216]	; d988 <net_config_init+0x190>
    d8b0:	3c01      	subs	r4, #1
	while (count--) {
    d8b2:	1c63      	adds	r3, r4, #1
    d8b4:	d13f      	bne.n	d936 <net_config_init+0x13e>
	return 0;
    d8b6:	2000      	movs	r0, #0
    d8b8:	e7ce      	b.n	d858 <net_config_init+0x60>
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
    d8ba:	2203      	movs	r2, #3
    d8bc:	a901      	add	r1, sp, #4
    d8be:	4620      	mov	r0, r4
    d8c0:	f7fd fc88 	bl	b1d4 <net_if_ipv4_addr_add>
	NET_INFO("IPv4 address: %s",
    d8c4:	f04f 0800 	mov.w	r8, #0
    d8c8:	2303      	movs	r3, #3
    d8ca:	aa02      	add	r2, sp, #8
    d8cc:	a901      	add	r1, sp, #4
    d8ce:	f363 0807 	bfi	r8, r3, #0, #8
    d8d2:	2001      	movs	r0, #1
    d8d4:	2310      	movs	r3, #16
    d8d6:	f7fd ffed 	bl	b8b4 <net_addr_ntop>
    d8da:	f7f9 fb51 	bl	6f80 <log_strdup>
    d8de:	f365 188f 	bfi	r8, r5, #6, #10
    d8e2:	4601      	mov	r1, r0
    d8e4:	4642      	mov	r2, r8
    d8e6:	482b      	ldr	r0, [pc, #172]	; (d994 <net_config_init+0x19c>)
    d8e8:	f004 fb51 	bl	11f8e <log_1>
		if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_NETMASK,
    d8ec:	492a      	ldr	r1, [pc, #168]	; (d998 <net_config_init+0x1a0>)
    d8ee:	aa01      	add	r2, sp, #4
    d8f0:	2001      	movs	r0, #1
    d8f2:	f006 fc40 	bl	14176 <net_addr_pton>
    d8f6:	4601      	mov	r1, r0
    d8f8:	b190      	cbz	r0, d920 <net_config_init+0x128>
			NET_ERR("Invalid netmask: %s",
    d8fa:	f04f 0200 	mov.w	r2, #0
    d8fe:	2301      	movs	r3, #1
    d900:	f363 0207 	bfi	r2, r3, #0, #8
    d904:	f365 128f 	bfi	r2, r5, #6, #10
    d908:	4923      	ldr	r1, [pc, #140]	; (d998 <net_config_init+0x1a0>)
    d90a:	4824      	ldr	r0, [pc, #144]	; (d99c <net_config_init+0x1a4>)
    d90c:	f004 fb3f 	bl	11f8e <log_1>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    d910:	2100      	movs	r1, #0
    d912:	481d      	ldr	r0, [pc, #116]	; (d988 <net_config_init+0x190>)
    d914:	f001 fea4 	bl	f660 <z_impl_k_sem_take>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    d918:	4821      	ldr	r0, [pc, #132]	; (d9a0 <net_config_init+0x1a8>)
    d91a:	f001 fe75 	bl	f608 <z_impl_k_sem_give>
    d91e:	e7bb      	b.n	d898 <net_config_init+0xa0>
 */
static inline void net_if_ipv4_set_netmask(struct net_if *iface,
					   const struct in_addr *netmask)
{
#if defined(CONFIG_NET_IPV4)
	if (net_if_config_ipv4_get(iface, NULL) < 0) {
    d920:	4620      	mov	r0, r4
    d922:	f7fd fba3 	bl	b06c <net_if_config_ipv4_get>
    d926:	2800      	cmp	r0, #0
    d928:	dbf2      	blt.n	d910 <net_config_init+0x118>
		return;
	}

	if (!iface->config.ip.ipv4) {
    d92a:	6863      	ldr	r3, [r4, #4]
    d92c:	2b00      	cmp	r3, #0
    d92e:	d0ef      	beq.n	d910 <net_config_init+0x118>
		return;
	}

	net_ipaddr_copy(&iface->config.ip.ipv4->netmask, netmask);
    d930:	9a01      	ldr	r2, [sp, #4]
    d932:	61da      	str	r2, [r3, #28]
    d934:	e7ec      	b.n	d910 <net_config_init+0x118>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    d936:	4639      	mov	r1, r7
    d938:	4640      	mov	r0, r8
    d93a:	f001 fe91 	bl	f660 <z_impl_k_sem_take>
		if (k_sem_take(&waiter, loop)) {
    d93e:	b1c0      	cbz	r0, d972 <net_config_init+0x17a>
			if (!k_sem_count_get(&counter)) {
    d940:	f8d9 3008 	ldr.w	r3, [r9, #8]
    d944:	b9ab      	cbnz	r3, d972 <net_config_init+0x17a>
	if (!count && timeout) {
    d946:	2c00      	cmp	r4, #0
    d948:	d1b5      	bne.n	d8b6 <net_config_init+0xbe>
    d94a:	2e00      	cmp	r6, #0
    d94c:	d0b3      	beq.n	d8b6 <net_config_init+0xbe>
		NET_ERR("Timeout while waiting setup");
    d94e:	2301      	movs	r3, #1
    d950:	f04f 0100 	mov.w	r1, #0
    d954:	f363 0107 	bfi	r1, r3, #0, #8
    d958:	4812      	ldr	r0, [pc, #72]	; (d9a4 <net_config_init+0x1ac>)
    d95a:	f365 118f 	bfi	r1, r5, #6, #10
    d95e:	f004 fb09 	bl	11f74 <log_0>
		return -ETIMEDOUT;
    d962:	f06f 0073 	mvn.w	r0, #115	; 0x73
    d966:	e777      	b.n	d858 <net_config_init+0x60>
		count = -1;
    d968:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    d96c:	e79c      	b.n	d8a8 <net_config_init+0xb0>
		count = 0;
    d96e:	4634      	mov	r4, r6
    d970:	e79a      	b.n	d8a8 <net_config_init+0xb0>
    d972:	3c01      	subs	r4, #1
    d974:	e79d      	b.n	d8b2 <net_config_init+0xba>
    d976:	bf00      	nop
    d978:	0001636c 	.word	0x0001636c
    d97c:	00016344 	.word	0x00016344
    d980:	000173c1 	.word	0x000173c1
    d984:	00018f5c 	.word	0x00018f5c
    d988:	200043f8 	.word	0x200043f8
    d98c:	00018f72 	.word	0x00018f72
    d990:	00018f7c 	.word	0x00018f7c
    d994:	00018f90 	.word	0x00018f90
    d998:	00018fa1 	.word	0x00018fa1
    d99c:	00018faf 	.word	0x00018faf
    d9a0:	20011dc0 	.word	0x20011dc0
    d9a4:	00018fc3 	.word	0x00018fc3

0000d9a8 <init_app>:

#if defined(CONFIG_NET_CONFIG_AUTO_INIT)
static int init_app(struct device *device)
{
    d9a8:	b510      	push	{r4, lr}
	if (IS_ENABLED(CONFIG_NET_CONFIG_NEED_IPV4)) {
		flags |= NET_CONFIG_NEED_IPV4;
	}

	/* Initialize the application automatically if needed */
	ret = net_config_init("Initializing network", flags,
    d9aa:	f247 5230 	movw	r2, #30000	; 0x7530
    d9ae:	2100      	movs	r1, #0
    d9b0:	480a      	ldr	r0, [pc, #40]	; (d9dc <init_app+0x34>)
    d9b2:	f7ff ff21 	bl	d7f8 <net_config_init>
			      K_SECONDS(CONFIG_NET_CONFIG_INIT_TIMEOUT));
	if (ret < 0) {
    d9b6:	1e04      	subs	r4, r0, #0
    d9b8:	da0e      	bge.n	d9d8 <init_app+0x30>
		NET_ERR("Network initialization failed (%d)", ret);
    d9ba:	2301      	movs	r3, #1
    d9bc:	f04f 0200 	mov.w	r2, #0
    d9c0:	f363 0207 	bfi	r2, r3, #0, #8
    d9c4:	4906      	ldr	r1, [pc, #24]	; (d9e0 <init_app+0x38>)
    d9c6:	4b07      	ldr	r3, [pc, #28]	; (d9e4 <init_app+0x3c>)
    d9c8:	4807      	ldr	r0, [pc, #28]	; (d9e8 <init_app+0x40>)
    d9ca:	1a5b      	subs	r3, r3, r1
    d9cc:	08db      	lsrs	r3, r3, #3
    d9ce:	f363 128f 	bfi	r2, r3, #6, #10
    d9d2:	4621      	mov	r1, r4
    d9d4:	f004 fadb 	bl	11f8e <log_1>
			log_backend_activate(backend, NULL);
		}
	}

	return ret;
}
    d9d8:	4620      	mov	r0, r4
    d9da:	bd10      	pop	{r4, pc}
    d9dc:	00018f24 	.word	0x00018f24
    d9e0:	00016344 	.word	0x00016344
    d9e4:	0001636c 	.word	0x0001636c
    d9e8:	00018f39 	.word	0x00018f39

0000d9ec <netusb_send>:
	net_if_down(netusb.iface);
}

bool netusb_enabled(void)
{
	return !!netusb.func;
    d9ec:	4b0c      	ldr	r3, [pc, #48]	; (da20 <netusb_send+0x34>)
    d9ee:	685b      	ldr	r3, [r3, #4]
{
    d9f0:	b510      	push	{r4, lr}
	if (!netusb_enabled()) {
    d9f2:	b123      	cbz	r3, d9fe <netusb_send+0x12>
	ret = netusb.func->send_pkt(pkt);
    d9f4:	685b      	ldr	r3, [r3, #4]
    d9f6:	4608      	mov	r0, r1
}
    d9f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ret = netusb.func->send_pkt(pkt);
    d9fc:	4718      	bx	r3
		LOG_ERR("interface disabled");
    d9fe:	2301      	movs	r3, #1
    da00:	f04f 0100 	mov.w	r1, #0
    da04:	4a07      	ldr	r2, [pc, #28]	; (da24 <netusb_send+0x38>)
    da06:	4808      	ldr	r0, [pc, #32]	; (da28 <netusb_send+0x3c>)
    da08:	f363 0107 	bfi	r1, r3, #0, #8
    da0c:	4b07      	ldr	r3, [pc, #28]	; (da2c <netusb_send+0x40>)
    da0e:	1a9b      	subs	r3, r3, r2
    da10:	08db      	lsrs	r3, r3, #3
    da12:	f363 118f 	bfi	r1, r3, #6, #10
    da16:	f004 faad 	bl	11f74 <log_0>
}
    da1a:	f06f 0012 	mvn.w	r0, #18
    da1e:	bd10      	pop	{r4, pc}
    da20:	20004410 	.word	0x20004410
    da24:	00016344 	.word	0x00016344
    da28:	00019050 	.word	0x00019050
    da2c:	00016444 	.word	0x00016444

0000da30 <netusb_init>:
}

static void netusb_init(struct net_if *iface)
{
    da30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	static u8_t mac[6] = { 0x00, 0x00, 0x5E, 0x00, 0x53, 0x00 };

	LOG_DBG("netusb device initialization");

	netusb.iface = iface;
    da32:	4b2e      	ldr	r3, [pc, #184]	; (daec <netusb_init+0xbc>)
{
    da34:	4604      	mov	r4, r0
	netusb.iface = iface;
    da36:	6018      	str	r0, [r3, #0]

	ethernet_init(iface);
    da38:	f005 fd26 	bl	13488 <ethernet_init>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    da3c:	6823      	ldr	r3, [r4, #0]
    da3e:	f3bf 8f5b 	dmb	ish
    da42:	68db      	ldr	r3, [r3, #12]
    da44:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(iface->if_dev->flags, NET_IF_UP)) {
    da48:	07db      	lsls	r3, r3, #31
    da4a:	d405      	bmi.n	da58 <netusb_init+0x28>
	net_if_get_link_addr(iface)->addr = addr;
    da4c:	6823      	ldr	r3, [r4, #0]
    da4e:	4a28      	ldr	r2, [pc, #160]	; (daf0 <netusb_init+0xc0>)
    da50:	611a      	str	r2, [r3, #16]
	net_if_get_link_addr(iface)->len = len;
    da52:	f240 3206 	movw	r2, #774	; 0x306
    da56:	829a      	strh	r2, [r3, #20]

	net_if_set_link_addr(iface, mac, sizeof(mac), NET_LINK_ETHERNET);

	net_if_down(iface);
    da58:	4620      	mov	r0, r4
    da5a:	f7fd fd31 	bl	b4c0 <net_if_down>

#ifndef CONFIG_USB_COMPOSITE_DEVICE
	/* Linker-defined symbols bound the USB descriptor structs */
	extern struct usb_cfg_data __usb_data_start[];
	extern struct usb_cfg_data __usb_data_end[];
	size_t size = (__usb_data_end - __usb_data_start);
    da5e:	4c25      	ldr	r4, [pc, #148]	; (daf4 <netusb_init+0xc4>)
    da60:	4b25      	ldr	r3, [pc, #148]	; (daf8 <netusb_init+0xc8>)
    da62:	4d26      	ldr	r5, [pc, #152]	; (dafc <netusb_init+0xcc>)
		struct usb_cfg_data *cfg = &(__usb_data_start[i]);
		int ret;

		LOG_DBG("Registering function %u", i);

		cfg->interface.payload_data = interface_data;
    da64:	4f26      	ldr	r7, [pc, #152]	; (db00 <netusb_init+0xd0>)
	size_t size = (__usb_data_end - __usb_data_start);
    da66:	1b1b      	subs	r3, r3, r4
    da68:	109b      	asrs	r3, r3, #2
    da6a:	435d      	muls	r5, r3
	for (size_t i = 0; i < size; i++) {
    da6c:	2600      	movs	r6, #0
    da6e:	42ae      	cmp	r6, r5
    da70:	d10c      	bne.n	da8c <netusb_init+0x5c>
			return;
		}
	}
#endif /* CONFIG_USB_COMPOSITE_DEVICE */

	LOG_INF("netusb initialized");
    da72:	2303      	movs	r3, #3
    da74:	f04f 0100 	mov.w	r1, #0
    da78:	f363 0107 	bfi	r1, r3, #0, #8
    da7c:	4a21      	ldr	r2, [pc, #132]	; (db04 <netusb_init+0xd4>)
    da7e:	4b22      	ldr	r3, [pc, #136]	; (db08 <netusb_init+0xd8>)
    da80:	4822      	ldr	r0, [pc, #136]	; (db0c <netusb_init+0xdc>)
    da82:	1a9b      	subs	r3, r3, r2
    da84:	08db      	lsrs	r3, r3, #3
    da86:	f363 118f 	bfi	r1, r3, #6, #10
    da8a:	e014      	b.n	dab6 <netusb_init+0x86>
		cfg->interface.payload_data = interface_data;
    da8c:	61e7      	str	r7, [r4, #28]
		cfg->usb_device_description = usb_get_device_descriptor();
    da8e:	f7fa fd4f 	bl	8530 <usb_get_device_descriptor>
    da92:	6020      	str	r0, [r4, #0]
		ret = usb_set_config(cfg);
    da94:	4620      	mov	r0, r4
    da96:	f7fa fa67 	bl	7f68 <usb_set_config>
		if (ret < 0) {
    da9a:	2800      	cmp	r0, #0
    da9c:	da0f      	bge.n	dabe <netusb_init+0x8e>
			LOG_ERR("Failed to configure USB device");
    da9e:	2301      	movs	r3, #1
    daa0:	f04f 0100 	mov.w	r1, #0
    daa4:	f363 0107 	bfi	r1, r3, #0, #8
    daa8:	4a16      	ldr	r2, [pc, #88]	; (db04 <netusb_init+0xd4>)
    daaa:	4b17      	ldr	r3, [pc, #92]	; (db08 <netusb_init+0xd8>)
    daac:	4818      	ldr	r0, [pc, #96]	; (db10 <netusb_init+0xe0>)
    daae:	1a9b      	subs	r3, r3, r2
    dab0:	08db      	lsrs	r3, r3, #3
    dab2:	f363 118f 	bfi	r1, r3, #6, #10
}
    dab6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	LOG_INF("netusb initialized");
    daba:	f004 ba5b 	b.w	11f74 <log_0>
		ret = usb_enable(cfg);
    dabe:	4620      	mov	r0, r4
    dac0:	f7fa fa80 	bl	7fc4 <usb_enable>
		if (ret < 0) {
    dac4:	2800      	cmp	r0, #0
    dac6:	f104 042c 	add.w	r4, r4, #44	; 0x2c
    daca:	da0c      	bge.n	dae6 <netusb_init+0xb6>
			LOG_ERR("Failed to enable USB");
    dacc:	2301      	movs	r3, #1
    dace:	f04f 0100 	mov.w	r1, #0
    dad2:	f363 0107 	bfi	r1, r3, #0, #8
    dad6:	4a0b      	ldr	r2, [pc, #44]	; (db04 <netusb_init+0xd4>)
    dad8:	4b0b      	ldr	r3, [pc, #44]	; (db08 <netusb_init+0xd8>)
    dada:	480e      	ldr	r0, [pc, #56]	; (db14 <netusb_init+0xe4>)
    dadc:	1a9b      	subs	r3, r3, r2
    dade:	08db      	lsrs	r3, r3, #3
    dae0:	f363 118f 	bfi	r1, r3, #6, #10
    dae4:	e7e7      	b.n	dab6 <netusb_init+0x86>
	for (size_t i = 0; i < size; i++) {
    dae6:	3601      	adds	r6, #1
    dae8:	e7c1      	b.n	da6e <netusb_init+0x3e>
    daea:	bf00      	nop
    daec:	20004410 	.word	0x20004410
    daf0:	20011c00 	.word	0x20011c00
    daf4:	20011f3c 	.word	0x20011f3c
    daf8:	20011f68 	.word	0x20011f68
    dafc:	ba2e8ba3 	.word	0xba2e8ba3
    db00:	20005b7a 	.word	0x20005b7a
    db04:	00016344 	.word	0x00016344
    db08:	00016444 	.word	0x00016444
    db0c:	0001901e 	.word	0x0001901e
    db10:	00018fea 	.word	0x00018fea
    db14:	00019009 	.word	0x00019009

0000db18 <netusb_net_iface>:
}
    db18:	4b01      	ldr	r3, [pc, #4]	; (db20 <netusb_net_iface+0x8>)
    db1a:	6818      	ldr	r0, [r3, #0]
    db1c:	4770      	bx	lr
    db1e:	bf00      	nop
    db20:	20004410 	.word	0x20004410

0000db24 <netusb_recv>:
	if (net_recv_data(netusb.iface, pkt) < 0) {
    db24:	4b0e      	ldr	r3, [pc, #56]	; (db60 <netusb_recv+0x3c>)
{
    db26:	b510      	push	{r4, lr}
	if (net_recv_data(netusb.iface, pkt) < 0) {
    db28:	4601      	mov	r1, r0
{
    db2a:	4604      	mov	r4, r0
	if (net_recv_data(netusb.iface, pkt) < 0) {
    db2c:	6818      	ldr	r0, [r3, #0]
    db2e:	f7fd fa03 	bl	af38 <net_recv_data>
    db32:	2800      	cmp	r0, #0
    db34:	da13      	bge.n	db5e <netusb_recv+0x3a>
		LOG_ERR("Packet %p dropped by NET stack", pkt);
    db36:	2301      	movs	r3, #1
    db38:	f04f 0200 	mov.w	r2, #0
    db3c:	f363 0207 	bfi	r2, r3, #0, #8
    db40:	4908      	ldr	r1, [pc, #32]	; (db64 <netusb_recv+0x40>)
    db42:	4b09      	ldr	r3, [pc, #36]	; (db68 <netusb_recv+0x44>)
    db44:	4809      	ldr	r0, [pc, #36]	; (db6c <netusb_recv+0x48>)
    db46:	1a5b      	subs	r3, r3, r1
    db48:	08db      	lsrs	r3, r3, #3
    db4a:	4621      	mov	r1, r4
    db4c:	f363 128f 	bfi	r2, r3, #6, #10
    db50:	f004 fa1d 	bl	11f8e <log_1>
		net_pkt_unref(pkt);
    db54:	4620      	mov	r0, r4
}
    db56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		net_pkt_unref(pkt);
    db5a:	f006 b8fc 	b.w	13d56 <net_pkt_unref>
}
    db5e:	bd10      	pop	{r4, pc}
    db60:	20004410 	.word	0x20004410
    db64:	00016344 	.word	0x00016344
    db68:	00016444 	.word	0x00016444
    db6c:	00019031 	.word	0x00019031

0000db70 <netusb_enable>:
{
    db70:	b510      	push	{r4, lr}
	netusb.func = func;
    db72:	4c0f      	ldr	r4, [pc, #60]	; (dbb0 <netusb_enable+0x40>)
    db74:	6060      	str	r0, [r4, #4]
	net_if_up(netusb.iface);
    db76:	6820      	ldr	r0, [r4, #0]
    db78:	f7fd fc78 	bl	b46c <net_if_up>
	return !!netusb.func;
    db7c:	6863      	ldr	r3, [r4, #4]
	if (!netusb_enabled()) {
    db7e:	b97b      	cbnz	r3, dba0 <netusb_enable+0x30>
		LOG_ERR("interface disabled");
    db80:	2301      	movs	r3, #1
    db82:	f04f 0100 	mov.w	r1, #0
    db86:	f363 0107 	bfi	r1, r3, #0, #8
    db8a:	4a0a      	ldr	r2, [pc, #40]	; (dbb4 <netusb_enable+0x44>)
    db8c:	4b0a      	ldr	r3, [pc, #40]	; (dbb8 <netusb_enable+0x48>)
    db8e:	480b      	ldr	r0, [pc, #44]	; (dbbc <netusb_enable+0x4c>)
    db90:	1a9b      	subs	r3, r3, r2
    db92:	08db      	lsrs	r3, r3, #3
    db94:	f363 118f 	bfi	r1, r3, #6, #10
}
    db98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		LOG_ERR("interface disabled");
    db9c:	f004 b9ea 	b.w	11f74 <log_0>
	if (!netusb.func->connect_media) {
    dba0:	681b      	ldr	r3, [r3, #0]
    dba2:	b11b      	cbz	r3, dbac <netusb_enable+0x3c>
	return netusb.func->connect_media(true);
    dba4:	2001      	movs	r0, #1
}
    dba6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return netusb.func->connect_media(true);
    dbaa:	4718      	bx	r3
}
    dbac:	bd10      	pop	{r4, pc}
    dbae:	bf00      	nop
    dbb0:	20004410 	.word	0x20004410
    dbb4:	00016344 	.word	0x00016344
    dbb8:	00016444 	.word	0x00016444
    dbbc:	00019050 	.word	0x00019050

0000dbc0 <netusb_disable>:
{
    dbc0:	b510      	push	{r4, lr}
	return !!netusb.func;
    dbc2:	4c0c      	ldr	r4, [pc, #48]	; (dbf4 <netusb_disable+0x34>)
	if (!netusb_enabled()) {
    dbc4:	6863      	ldr	r3, [r4, #4]
    dbc6:	b1a3      	cbz	r3, dbf2 <netusb_disable+0x32>
	netusb.func = NULL;
    dbc8:	2300      	movs	r3, #0
    dbca:	6063      	str	r3, [r4, #4]
		LOG_ERR("interface disabled");
    dbcc:	f04f 0100 	mov.w	r1, #0
    dbd0:	2301      	movs	r3, #1
    dbd2:	f363 0107 	bfi	r1, r3, #0, #8
    dbd6:	4a08      	ldr	r2, [pc, #32]	; (dbf8 <netusb_disable+0x38>)
    dbd8:	4b08      	ldr	r3, [pc, #32]	; (dbfc <netusb_disable+0x3c>)
    dbda:	4809      	ldr	r0, [pc, #36]	; (dc00 <netusb_disable+0x40>)
    dbdc:	1a9b      	subs	r3, r3, r2
    dbde:	08db      	lsrs	r3, r3, #3
    dbe0:	f363 118f 	bfi	r1, r3, #6, #10
    dbe4:	f004 f9c6 	bl	11f74 <log_0>
	net_if_down(netusb.iface);
    dbe8:	6820      	ldr	r0, [r4, #0]
}
    dbea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	net_if_down(netusb.iface);
    dbee:	f7fd bc67 	b.w	b4c0 <net_if_down>
}
    dbf2:	bd10      	pop	{r4, pc}
    dbf4:	20004410 	.word	0x20004410
    dbf8:	00016344 	.word	0x00016344
    dbfc:	00016444 	.word	0x00016444
    dc00:	00019050 	.word	0x00019050

0000dc04 <netusb_enabled>:
	return !!netusb.func;
    dc04:	4b02      	ldr	r3, [pc, #8]	; (dc10 <netusb_enabled+0xc>)
    dc06:	6858      	ldr	r0, [r3, #4]
}
    dc08:	3000      	adds	r0, #0
    dc0a:	bf18      	it	ne
    dc0c:	2001      	movne	r0, #1
    dc0e:	4770      	bx	lr
    dc10:	20004410 	.word	0x20004410

0000dc14 <ecm_status_cb>:
			  const u8_t *param)
{
	ARG_UNUSED(cfg);

	/* Check the USB status and do needed action if required */
	switch (status) {
    dc14:	2904      	cmp	r1, #4
    dc16:	d002      	beq.n	dc1e <ecm_status_cb+0xa>
    dc18:	2907      	cmp	r1, #7
    dc1a:	d002      	beq.n	dc22 <ecm_status_cb+0xe>
    dc1c:	4770      	bx	lr
	case USB_DC_DISCONNECTED:
		LOG_DBG("USB device disconnected");
		netusb_disable();
    dc1e:	f7ff bfcf 	b.w	dbc0 <netusb_disable>
	return cdc_ecm_cfg.if0.bInterfaceNumber;
    dc22:	4b06      	ldr	r3, [pc, #24]	; (dc3c <ecm_status_cb+0x28>)
	if (iface_num != ecm_get_first_iface_number() + 1 || !alt_set) {
    dc24:	7891      	ldrb	r1, [r2, #2]
    dc26:	789b      	ldrb	r3, [r3, #2]
    dc28:	3301      	adds	r3, #1
    dc2a:	4299      	cmp	r1, r3
    dc2c:	d104      	bne.n	dc38 <ecm_status_cb+0x24>
    dc2e:	78d3      	ldrb	r3, [r2, #3]
    dc30:	b113      	cbz	r3, dc38 <ecm_status_cb+0x24>
	netusb_enable(&ecm_function);
    dc32:	4803      	ldr	r0, [pc, #12]	; (dc40 <ecm_status_cb+0x2c>)
    dc34:	f7ff bf9c 	b.w	db70 <netusb_enable>
	case USB_DC_UNKNOWN:
	default:
		LOG_DBG("USB unknown state: %d", status);
		break;
	}
}
    dc38:	4770      	bx	lr
    dc3a:	bf00      	nop
    dc3c:	20011eab 	.word	0x20011eab
    dc40:	20010d18 	.word	0x20010d18

0000dc44 <ecm_interface_config>:
	.bString = CONFIG_USB_DEVICE_NETWORK_ECM_MAC
};

static void ecm_interface_config(struct usb_desc_header *head,
				 u8_t bInterfaceNumber)
{
    dc44:	b510      	push	{r4, lr}
	int idx = usb_get_str_descriptor_idx(&utf16le_mac);
    dc46:	4808      	ldr	r0, [pc, #32]	; (dc68 <ecm_interface_config+0x24>)
{
    dc48:	460c      	mov	r4, r1
	int idx = usb_get_str_descriptor_idx(&utf16le_mac);
    dc4a:	f7fa fb3d 	bl	82c8 <usb_get_str_descriptor_idx>

	ARG_UNUSED(head);

	if (idx) {
    dc4e:	4b07      	ldr	r3, [pc, #28]	; (dc6c <ecm_interface_config+0x28>)
    dc50:	b100      	cbz	r0, dc54 <ecm_interface_config+0x10>
		LOG_DBG("fixup string %d", idx);
		cdc_ecm_cfg.if0_netfun_ecm.iMACAddress = idx;
    dc52:	7598      	strb	r0, [r3, #22]
	}

	cdc_ecm_cfg.if0.bInterfaceNumber = bInterfaceNumber;
    dc54:	709c      	strb	r4, [r3, #2]
	cdc_ecm_cfg.if0_union.bControlInterface = bInterfaceNumber;
    dc56:	745c      	strb	r4, [r3, #17]
	cdc_ecm_cfg.if0_union.bSubordinateInterface0 = bInterfaceNumber + 1;
    dc58:	3401      	adds	r4, #1
    dc5a:	b2e4      	uxtb	r4, r4
    dc5c:	749c      	strb	r4, [r3, #18]
	cdc_ecm_cfg.if1_0.bInterfaceNumber = bInterfaceNumber + 1;
    dc5e:	f883 4029 	strb.w	r4, [r3, #41]	; 0x29
	cdc_ecm_cfg.if1_1.bInterfaceNumber = bInterfaceNumber + 1;
    dc62:	f883 4032 	strb.w	r4, [r3, #50]	; 0x32
#ifdef CONFIG_USB_COMPOSITE_DEVICE
	cdc_ecm_cfg.iad.bFirstInterface = bInterfaceNumber;
#endif
}
    dc66:	bd10      	pop	{r4, pc}
    dc68:	20011f1e 	.word	0x20011f1e
    dc6c:	20011eab 	.word	0x20011eab

0000dc70 <ecm_class_handler>:
{
    dc70:	b510      	push	{r4, lr}
    dc72:	4604      	mov	r4, r0
	if (!netusb_enabled()) {
    dc74:	f7ff ffc6 	bl	dc04 <netusb_enabled>
    dc78:	b980      	cbnz	r0, dc9c <ecm_class_handler+0x2c>
		LOG_ERR("interface disabled");
    dc7a:	2301      	movs	r3, #1
    dc7c:	f04f 0100 	mov.w	r1, #0
    dc80:	f363 0107 	bfi	r1, r3, #0, #8
    dc84:	4a0f      	ldr	r2, [pc, #60]	; (dcc4 <ecm_class_handler+0x54>)
    dc86:	4b10      	ldr	r3, [pc, #64]	; (dcc8 <ecm_class_handler+0x58>)
    dc88:	4810      	ldr	r0, [pc, #64]	; (dccc <ecm_class_handler+0x5c>)
    dc8a:	1a9b      	subs	r3, r3, r2
    dc8c:	08db      	lsrs	r3, r3, #3
    dc8e:	f363 118f 	bfi	r1, r3, #6, #10
    dc92:	f004 f96f 	bl	11f74 <log_0>
		return -ENODEV;
    dc96:	f06f 0012 	mvn.w	r0, #18
}
    dc9a:	bd10      	pop	{r4, pc}
	if (setup->bmRequestType != USB_CDC_ECM_REQ_TYPE) {
    dc9c:	7821      	ldrb	r1, [r4, #0]
    dc9e:	2921      	cmp	r1, #33	; 0x21
    dca0:	d00d      	beq.n	dcbe <ecm_class_handler+0x4e>
		LOG_WRN("Unhandled req_type 0x%x", setup->bmRequestType);
    dca2:	2302      	movs	r3, #2
    dca4:	f04f 0200 	mov.w	r2, #0
    dca8:	f363 0207 	bfi	r2, r3, #0, #8
    dcac:	4805      	ldr	r0, [pc, #20]	; (dcc4 <ecm_class_handler+0x54>)
    dcae:	4b06      	ldr	r3, [pc, #24]	; (dcc8 <ecm_class_handler+0x58>)
    dcb0:	1a1b      	subs	r3, r3, r0
    dcb2:	08db      	lsrs	r3, r3, #3
    dcb4:	f363 128f 	bfi	r2, r3, #6, #10
    dcb8:	4805      	ldr	r0, [pc, #20]	; (dcd0 <ecm_class_handler+0x60>)
    dcba:	f004 f968 	bl	11f8e <log_1>
	return 0;
    dcbe:	2000      	movs	r0, #0
    dcc0:	e7eb      	b.n	dc9a <ecm_class_handler+0x2a>
    dcc2:	bf00      	nop
    dcc4:	00016344 	.word	0x00016344
    dcc8:	0001643c 	.word	0x0001643c
    dccc:	00019050 	.word	0x00019050
    dcd0:	00019076 	.word	0x00019076

0000dcd4 <ecm_send>:
{
    dcd4:	b538      	push	{r3, r4, r5, lr}
	size_t len = net_pkt_get_len(pkt);
    dcd6:	6943      	ldr	r3, [r0, #20]
	size_t bytes = 0;
    dcd8:	2400      	movs	r4, #0
	while (buf) {
    dcda:	b9ab      	cbnz	r3, dd08 <ecm_send+0x34>
	if (len > sizeof(tx_buf)) {
    dcdc:	f240 53ea 	movw	r3, #1514	; 0x5ea
    dce0:	429c      	cmp	r4, r3
    dce2:	d915      	bls.n	dd10 <ecm_send+0x3c>
		LOG_WRN("Trying to send too large packet, drop");
    dce4:	2302      	movs	r3, #2
    dce6:	f04f 0100 	mov.w	r1, #0
    dcea:	f363 0107 	bfi	r1, r3, #0, #8
    dcee:	4a1a      	ldr	r2, [pc, #104]	; (dd58 <ecm_send+0x84>)
    dcf0:	4b1a      	ldr	r3, [pc, #104]	; (dd5c <ecm_send+0x88>)
    dcf2:	481b      	ldr	r0, [pc, #108]	; (dd60 <ecm_send+0x8c>)
    dcf4:	1a9b      	subs	r3, r3, r2
    dcf6:	08db      	lsrs	r3, r3, #3
    dcf8:	f363 118f 	bfi	r1, r3, #6, #10
    dcfc:	f004 f93a 	bl	11f74 <log_0>
		return -ENOMEM;
    dd00:	f06f 050b 	mvn.w	r5, #11
}
    dd04:	4628      	mov	r0, r5
    dd06:	bd38      	pop	{r3, r4, r5, pc}
		bytes += buf->len;
    dd08:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
    dd0a:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
    dd0c:	4414      	add	r4, r2
		buf = buf->frags;
    dd0e:	e7e4      	b.n	dcda <ecm_send+0x6>
	if (net_pkt_read(pkt, tx_buf, len)) {
    dd10:	4622      	mov	r2, r4
    dd12:	4914      	ldr	r1, [pc, #80]	; (dd64 <ecm_send+0x90>)
    dd14:	f006 f920 	bl	13f58 <net_pkt_read>
    dd18:	4605      	mov	r5, r0
    dd1a:	b9c8      	cbnz	r0, dd50 <ecm_send+0x7c>
	ret = usb_transfer_sync(ecm_ep_data[ECM_IN_EP_IDX].ep_addr,
    dd1c:	4812      	ldr	r0, [pc, #72]	; (dd68 <ecm_send+0x94>)
    dd1e:	4911      	ldr	r1, [pc, #68]	; (dd64 <ecm_send+0x90>)
    dd20:	7d00      	ldrb	r0, [r0, #20]
    dd22:	2302      	movs	r3, #2
    dd24:	4622      	mov	r2, r4
    dd26:	f7fa faaf 	bl	8288 <usb_transfer_sync>
	if (ret != len) {
    dd2a:	42a0      	cmp	r0, r4
    dd2c:	d0ea      	beq.n	dd04 <ecm_send+0x30>
		LOG_ERR("Transfer failure");
    dd2e:	2301      	movs	r3, #1
    dd30:	f04f 0100 	mov.w	r1, #0
    dd34:	f363 0107 	bfi	r1, r3, #0, #8
    dd38:	4a07      	ldr	r2, [pc, #28]	; (dd58 <ecm_send+0x84>)
    dd3a:	4b08      	ldr	r3, [pc, #32]	; (dd5c <ecm_send+0x88>)
    dd3c:	480b      	ldr	r0, [pc, #44]	; (dd6c <ecm_send+0x98>)
    dd3e:	1a9b      	subs	r3, r3, r2
    dd40:	08db      	lsrs	r3, r3, #3
    dd42:	f363 118f 	bfi	r1, r3, #6, #10
    dd46:	f004 f915 	bl	11f74 <log_0>
		return -EINVAL;
    dd4a:	f06f 0515 	mvn.w	r5, #21
    dd4e:	e7d9      	b.n	dd04 <ecm_send+0x30>
		return -ENOBUFS;
    dd50:	f06f 0568 	mvn.w	r5, #104	; 0x68
    dd54:	e7d6      	b.n	dd04 <ecm_send+0x30>
    dd56:	bf00      	nop
    dd58:	00016344 	.word	0x00016344
    dd5c:	0001643c 	.word	0x0001643c
    dd60:	000190c6 	.word	0x000190c6
    dd64:	20006290 	.word	0x20006290
    dd68:	20010d00 	.word	0x20010d00
    dd6c:	000190ec 	.word	0x000190ec

0000dd70 <ecm_read_cb>:
{
    dd70:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (size <= 0) {
    dd72:	1e0c      	subs	r4, r1, #0
    dd74:	dd39      	ble.n	ddea <ecm_read_cb+0x7a>
	if (rx_buf[size - 1] == 0U) { /* last byte is null */
    dd76:	4932      	ldr	r1, [pc, #200]	; (de40 <ecm_read_cb+0xd0>)
    dd78:	1e60      	subs	r0, r4, #1
    dd7a:	460e      	mov	r6, r1
    dd7c:	5c0b      	ldrb	r3, [r1, r0]
    dd7e:	b9d3      	cbnz	r3, ddb6 <ecm_read_cb+0x46>
	if (len < NET_IPV6H_LEN + sizeof(struct net_eth_hdr)) {
    dd80:	2c35      	cmp	r4, #53	; 0x35
    dd82:	dd15      	ble.n	ddb0 <ecm_read_cb+0x40>
	switch (ntohs(hdr->type)) {
    dd84:	898d      	ldrh	r5, [r1, #12]
    dd86:	022a      	lsls	r2, r5, #8
    dd88:	ea42 2215 	orr.w	r2, r2, r5, lsr #8
    dd8c:	b292      	uxth	r2, r2
    dd8e:	f640 0506 	movw	r5, #2054	; 0x806
    dd92:	42aa      	cmp	r2, r5
    dd94:	d006      	beq.n	dda4 <ecm_read_cb+0x34>
    dd96:	f248 65dd 	movw	r5, #34525	; 0x86dd
    dd9a:	42aa      	cmp	r2, r5
    dd9c:	d033      	beq.n	de06 <ecm_read_cb+0x96>
    dd9e:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
    dda2:	d105      	bne.n	ddb0 <ecm_read_cb+0x40>
		ip_len = ntohs(((struct net_ipv4_hdr *)ip_data)->len);
    dda4:	8a32      	ldrh	r2, [r6, #16]
		ip_len = ntohs(((struct net_ipv6_hdr *)ip_data)->len);
    dda6:	0213      	lsls	r3, r2, #8
    dda8:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
    ddac:	b29b      	uxth	r3, r3
	return sizeof(struct net_eth_hdr) + ip_len;
    ddae:	330e      	adds	r3, #14
			size--;
    ddb0:	4298      	cmp	r0, r3
    ddb2:	bf08      	it	eq
    ddb4:	461c      	moveq	r4, r3
	pkt = net_pkt_alloc_with_buffer(netusb_net_iface(), size,
    ddb6:	f7ff feaf 	bl	db18 <netusb_net_iface>
    ddba:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    ddbe:	9300      	str	r3, [sp, #0]
    ddc0:	2300      	movs	r3, #0
    ddc2:	461a      	mov	r2, r3
    ddc4:	4621      	mov	r1, r4
    ddc6:	f7fd fcdd 	bl	b784 <net_pkt_alloc_with_buffer>
	if (!pkt) {
    ddca:	4605      	mov	r5, r0
    ddcc:	b9e8      	cbnz	r0, de0a <ecm_read_cb+0x9a>
		LOG_ERR("no memory for network packet\n");
    ddce:	2301      	movs	r3, #1
    ddd0:	f04f 0100 	mov.w	r1, #0
    ddd4:	f363 0107 	bfi	r1, r3, #0, #8
    ddd8:	4a1a      	ldr	r2, [pc, #104]	; (de44 <ecm_read_cb+0xd4>)
    ddda:	4b1b      	ldr	r3, [pc, #108]	; (de48 <ecm_read_cb+0xd8>)
    dddc:	481b      	ldr	r0, [pc, #108]	; (de4c <ecm_read_cb+0xdc>)
    ddde:	1a9b      	subs	r3, r3, r2
    dde0:	08db      	lsrs	r3, r3, #3
    dde2:	f363 118f 	bfi	r1, r3, #6, #10
    dde6:	f004 f8c5 	bl	11f74 <log_0>
	usb_transfer(ecm_ep_data[ECM_OUT_EP_IDX].ep_addr, rx_buf,
    ddea:	2300      	movs	r3, #0
    ddec:	9301      	str	r3, [sp, #4]
    ddee:	4818      	ldr	r0, [pc, #96]	; (de50 <ecm_read_cb+0xe0>)
    ddf0:	4b18      	ldr	r3, [pc, #96]	; (de54 <ecm_read_cb+0xe4>)
    ddf2:	9300      	str	r3, [sp, #0]
    ddf4:	f240 52ea 	movw	r2, #1514	; 0x5ea
    ddf8:	2301      	movs	r3, #1
    ddfa:	4911      	ldr	r1, [pc, #68]	; (de40 <ecm_read_cb+0xd0>)
    ddfc:	7b00      	ldrb	r0, [r0, #12]
    ddfe:	f7fa f99d 	bl	813c <usb_transfer>
}
    de02:	b002      	add	sp, #8
    de04:	bd70      	pop	{r4, r5, r6, pc}
		ip_len = ntohs(((struct net_ipv6_hdr *)ip_data)->len);
    de06:	8a4a      	ldrh	r2, [r1, #18]
    de08:	e7cd      	b.n	dda6 <ecm_read_cb+0x36>
	if (net_pkt_write(pkt, rx_buf, size)) {
    de0a:	4622      	mov	r2, r4
    de0c:	490c      	ldr	r1, [pc, #48]	; (de40 <ecm_read_cb+0xd0>)
    de0e:	f006 f93f 	bl	14090 <net_pkt_write>
    de12:	b188      	cbz	r0, de38 <ecm_read_cb+0xc8>
		LOG_ERR("Unable to write into pkt\n");
    de14:	2301      	movs	r3, #1
    de16:	f04f 0100 	mov.w	r1, #0
    de1a:	4a0a      	ldr	r2, [pc, #40]	; (de44 <ecm_read_cb+0xd4>)
    de1c:	480e      	ldr	r0, [pc, #56]	; (de58 <ecm_read_cb+0xe8>)
    de1e:	f363 0107 	bfi	r1, r3, #0, #8
    de22:	4b09      	ldr	r3, [pc, #36]	; (de48 <ecm_read_cb+0xd8>)
    de24:	1a9b      	subs	r3, r3, r2
    de26:	08db      	lsrs	r3, r3, #3
    de28:	f363 118f 	bfi	r1, r3, #6, #10
    de2c:	f004 f8a2 	bl	11f74 <log_0>
		net_pkt_unref(pkt);
    de30:	4628      	mov	r0, r5
    de32:	f005 ff90 	bl	13d56 <net_pkt_unref>
		goto done;
    de36:	e7d8      	b.n	ddea <ecm_read_cb+0x7a>
	netusb_recv(pkt);
    de38:	4628      	mov	r0, r5
    de3a:	f7ff fe73 	bl	db24 <netusb_recv>
    de3e:	e7d4      	b.n	ddea <ecm_read_cb+0x7a>
    de40:	20005ca6 	.word	0x20005ca6
    de44:	00016344 	.word	0x00016344
    de48:	0001643c 	.word	0x0001643c
    de4c:	0001908e 	.word	0x0001908e
    de50:	20010d00 	.word	0x20010d00
    de54:	0000dd71 	.word	0x0000dd71
    de58:	000190ac 	.word	0x000190ac

0000de5c <ecm_connect>:
{
    de5c:	b510      	push	{r4, lr}
    de5e:	4c08      	ldr	r4, [pc, #32]	; (de80 <ecm_connect+0x24>)
    de60:	7b23      	ldrb	r3, [r4, #12]
	if (connected) {
    de62:	b130      	cbz	r0, de72 <ecm_connect+0x16>
		ecm_read_cb(ecm_ep_data[ECM_OUT_EP_IDX].ep_addr, 0, NULL);
    de64:	2200      	movs	r2, #0
    de66:	4611      	mov	r1, r2
    de68:	4618      	mov	r0, r3
    de6a:	f7ff ff81 	bl	dd70 <ecm_read_cb>
}
    de6e:	2000      	movs	r0, #0
    de70:	bd10      	pop	{r4, pc}
		usb_cancel_transfer(ecm_ep_data[ECM_OUT_EP_IDX].ep_addr);
    de72:	4618      	mov	r0, r3
    de74:	f7fa f9de 	bl	8234 <usb_cancel_transfer>
		usb_cancel_transfer(ecm_ep_data[ECM_IN_EP_IDX].ep_addr);
    de78:	7d20      	ldrb	r0, [r4, #20]
    de7a:	f7fa f9db 	bl	8234 <usb_cancel_transfer>
    de7e:	e7f6      	b.n	de6e <ecm_connect+0x12>
    de80:	20010d00 	.word	0x20010d00

0000de84 <nrf_gpio_pin_port_decode.part.8>:
 * @param[inout] Pointer to absolute pin number which is overriden by relative to port pin number.
 *
 * @return Pointer to port register set.
 *
 */
__STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
    de84:	b508      	push	{r3, lr}
{
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    de86:	4a03      	ldr	r2, [pc, #12]	; (de94 <nrf_gpio_pin_port_decode.part.8+0x10>)
    de88:	4b03      	ldr	r3, [pc, #12]	; (de98 <nrf_gpio_pin_port_decode.part.8+0x14>)
    de8a:	4804      	ldr	r0, [pc, #16]	; (de9c <nrf_gpio_pin_port_decode.part.8+0x18>)
    de8c:	f240 11dd 	movw	r1, #477	; 0x1dd
    de90:	f7f2 fc74 	bl	77c <__assert_func>
    de94:	00019105 	.word	0x00019105
    de98:	0001911e 	.word	0x0001911e
    de9c:	00019131 	.word	0x00019131

0000dea0 <nrf_gpio_cfg_sense_set>:
    dea0:	282f      	cmp	r0, #47	; 0x2f
        sense_config);
}


__STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config)
{
    dea2:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    dea4:	d901      	bls.n	deaa <nrf_gpio_cfg_sense_set+0xa>
    dea6:	f7ff ffed 	bl	de84 <nrf_gpio_pin_port_decode.part.8>
    if (*p_pin < P0_PIN_NUM)
    deaa:	281f      	cmp	r0, #31
        return NRF_P1;
    deac:	bf8a      	itet	hi
    deae:	4b0a      	ldrhi	r3, [pc, #40]	; (ded8 <nrf_gpio_cfg_sense_set+0x38>)
        return NRF_P0;
    deb0:	f04f 43a0 	movls.w	r3, #1342177280	; 0x50000000
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    deb4:	f000 001f 	andhi.w	r0, r0, #31
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);

    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
    reg->PIN_CNF[pin_number] &= ~GPIO_PIN_CNF_SENSE_Msk;
    deb8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    debc:	f8d0 2700 	ldr.w	r2, [r0, #1792]	; 0x700
    dec0:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    dec4:	f8c0 2700 	str.w	r2, [r0, #1792]	; 0x700
    reg->PIN_CNF[pin_number] |= (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    dec8:	f8d0 3700 	ldr.w	r3, [r0, #1792]	; 0x700
    decc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    ded0:	f8c0 3700 	str.w	r3, [r0, #1792]	; 0x700
}
    ded4:	bd08      	pop	{r3, pc}
    ded6:	bf00      	nop
    ded8:	50000300 	.word	0x50000300

0000dedc <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
    dedc:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    dede:	4b09      	ldr	r3, [pc, #36]	; (df04 <gpio_nrfx_init+0x28>)
    dee0:	781a      	ldrb	r2, [r3, #0]
    dee2:	b96a      	cbnz	r2, df00 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
    dee4:	2101      	movs	r1, #1
    dee6:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ,
    dee8:	2006      	movs	r0, #6
    deea:	2105      	movs	r1, #5
    deec:	f7fb ff80 	bl	9df0 <z_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ);
    def0:	2006      	movs	r0, #6
    def2:	f7fb ff4b 	bl	9d8c <z_arch_irq_enable>
    return ((uint32_t)NRF_GPIOTE + event);
}

__STATIC_INLINE void nrf_gpiote_int_enable(uint32_t mask)
{
    NRF_GPIOTE->INTENSET = mask;
    def6:	4b04      	ldr	r3, [pc, #16]	; (df08 <gpio_nrfx_init+0x2c>)
    def8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    defc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    df00:	2000      	movs	r0, #0
    df02:	bd08      	pop	{r3, pc}
    df04:	2000687a 	.word	0x2000687a
    df08:	40006000 	.word	0x40006000

0000df0c <gpiote_pin_int_cfg>:
{
    df0c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return port->config->config_info;
    df0e:	6803      	ldr	r3, [r0, #0]
	struct gpio_nrfx_data *data = get_port_data(port);
    df10:	6887      	ldr	r7, [r0, #8]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    df12:	689b      	ldr	r3, [r3, #8]
    df14:	f001 051f 	and.w	r5, r1, #31
{
    df18:	460e      	mov	r6, r1
    NRF_GPIOTE->INTENCLR = mask;
}

__STATIC_INLINE uint32_t nrf_gpiote_int_is_enabled(uint32_t mask)
{
    return (NRF_GPIOTE->INTENSET & mask);
    df1a:	494e      	ldr	r1, [pc, #312]	; (e054 <gpiote_pin_int_cfg+0x148>)
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    df1c:	791b      	ldrb	r3, [r3, #4]
    df1e:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
    df22:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
    df26:	b2d2      	uxtb	r2, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    df28:	2300      	movs	r3, #0
                              ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

__STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(uint32_t idx)
{
    return ((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    df2a:	f503 70a2 	add.w	r0, r3, #324	; 0x144
    df2e:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
    df32:	f3c0 2005 	ubfx	r0, r0, #8, #6
		if ((nrf_gpiote_event_pin_get(i) == abs_pin)
    df36:	4285      	cmp	r5, r0
    df38:	d170      	bne.n	e01c <gpiote_pin_int_cfg+0x110>
		    && (intenset & BIT(i))) {
    df3a:	fa22 f003 	lsr.w	r0, r2, r3
    df3e:	07c0      	lsls	r0, r0, #31
    df40:	d56c      	bpl.n	e01c <gpiote_pin_int_cfg+0x110>
   NRF_GPIOTE->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    df42:	009a      	lsls	r2, r3, #2
    df44:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    df48:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    df4c:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
    df50:	f020 0001 	bic.w	r0, r0, #1
    df54:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(BIT(i));
    df58:	2201      	movs	r2, #1
    df5a:	fa02 f303 	lsl.w	r3, r2, r3
    NRF_GPIOTE->INTENCLR = mask;
    df5e:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
    df62:	4628      	mov	r0, r5
    df64:	2100      	movs	r1, #0
    df66:	f7ff ff9b 	bl	dea0 <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
    df6a:	68b8      	ldr	r0, [r7, #8]
    df6c:	40f0      	lsrs	r0, r6
    df6e:	f010 0001 	ands.w	r0, r0, #1
    df72:	d051      	beq.n	e018 <gpiote_pin_int_cfg+0x10c>
    df74:	68f8      	ldr	r0, [r7, #12]
    df76:	40f0      	lsrs	r0, r6
    df78:	f010 0001 	ands.w	r0, r0, #1
    df7c:	d04c      	beq.n	e018 <gpiote_pin_int_cfg+0x10c>
		if (data->trig_edge & BIT(pin)) {
    df7e:	6978      	ldr	r0, [r7, #20]
    df80:	40f0      	lsrs	r0, r6
    df82:	f010 0401 	ands.w	r4, r0, #1
    df86:	d055      	beq.n	e034 <gpiote_pin_int_cfg+0x128>
			if (data->double_edge & BIT(pin)) {
    df88:	69bb      	ldr	r3, [r7, #24]
    df8a:	40f3      	lsrs	r3, r6
    df8c:	07db      	lsls	r3, r3, #31
    df8e:	d449      	bmi.n	e024 <gpiote_pin_int_cfg+0x118>
			} else if (((data->active_level & BIT(pin)) != 0U)
    df90:	693b      	ldr	r3, [r7, #16]
				   ^ ((BIT(pin) & data->inverted) != 0)) {
    df92:	69fa      	ldr	r2, [r7, #28]
			} else if (((data->active_level & BIT(pin)) != 0U)
    df94:	40f3      	lsrs	r3, r6
				   ^ ((BIT(pin) & data->inverted) != 0)) {
    df96:	fa22 f606 	lsr.w	r6, r2, r6
			} else if (((data->active_level & BIT(pin)) != 0U)
    df9a:	f003 0301 	and.w	r3, r3, #1
    df9e:	f006 0601 	and.w	r6, r6, #1
				pol = NRF_GPIOTE_POLARITY_HITOLO;
    dfa2:	42b3      	cmp	r3, r6
    dfa4:	bf14      	ite	ne
    dfa6:	2601      	movne	r6, #1
    dfa8:	2602      	moveq	r6, #2
    NRF_GPIOTE->CONFIG[idx] = 0;
}

__STATIC_INLINE bool nrf_gpiote_te_is_enabled(uint32_t idx)
{
    return (NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
    dfaa:	4c2a      	ldr	r4, [pc, #168]	; (e054 <gpiote_pin_int_cfg+0x148>)
    dfac:	2100      	movs	r1, #0
    dfae:	f501 73a2 	add.w	r3, r1, #324	; 0x144
    dfb2:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(channel)) {
    dfb6:	f010 0003 	ands.w	r0, r0, #3
    dfba:	d135      	bne.n	e028 <gpiote_pin_int_cfg+0x11c>
  NRF_GPIOTE->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    dfbc:	008b      	lsls	r3, r1, #2
    dfbe:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    dfc2:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
  NRF_GPIOTE->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    dfc6:	022d      	lsls	r5, r5, #8
  NRF_GPIOTE->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    dfc8:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    dfcc:	f422 324f 	bic.w	r2, r2, #211968	; 0x33c00
    dfd0:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    dfd4:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
  NRF_GPIOTE->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    dfd8:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    dfdc:	f405 557c 	and.w	r5, r5, #16128	; 0x3f00
    dfe0:	ea45 4606 	orr.w	r6, r5, r6, lsl #16
    dfe4:	4316      	orrs	r6, r2
			nrf_gpiote_events_t evt =
    dfe6:	f101 0240 	add.w	r2, r1, #64	; 0x40
    dfea:	0092      	lsls	r2, r2, #2
    return ((uint32_t)NRF_GPIOTE + event);
    dfec:	b292      	uxth	r2, r2
    dfee:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    dff2:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
  NRF_GPIOTE->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    dff6:	f8c3 6510 	str.w	r6, [r3, #1296]	; 0x510
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
    dffa:	6010      	str	r0, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
    dffc:	6812      	ldr	r2, [r2, #0]
    dffe:	9201      	str	r2, [sp, #4]
    (void)dummy;
    e000:	9a01      	ldr	r2, [sp, #4]
   NRF_GPIOTE->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    e002:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    e006:	f042 0201 	orr.w	r2, r2, #1
    e00a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
			nrf_gpiote_int_enable(BIT(channel));
    e00e:	2301      	movs	r3, #1
    e010:	fa03 f101 	lsl.w	r1, r3, r1
    NRF_GPIOTE->INTENSET = mask;
    e014:	f8c4 1304 	str.w	r1, [r4, #772]	; 0x304
}
    e018:	b003      	add	sp, #12
    e01a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    e01c:	3301      	adds	r3, #1
    e01e:	2b08      	cmp	r3, #8
    e020:	d183      	bne.n	df2a <gpiote_pin_int_cfg+0x1e>
    e022:	e79e      	b.n	df62 <gpiote_pin_int_cfg+0x56>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    e024:	2603      	movs	r6, #3
    e026:	e7c0      	b.n	dfaa <gpiote_pin_int_cfg+0x9e>
    e028:	3101      	adds	r1, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
    e02a:	2908      	cmp	r1, #8
    e02c:	d1bf      	bne.n	dfae <gpiote_pin_int_cfg+0xa2>
	return -ENODEV;
    e02e:	f06f 0012 	mvn.w	r0, #18
    e032:	e7f1      	b.n	e018 <gpiote_pin_int_cfg+0x10c>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
    e034:	693b      	ldr	r3, [r7, #16]
    e036:	69fa      	ldr	r2, [r7, #28]
    e038:	4053      	eors	r3, r2
    e03a:	fa23 f606 	lsr.w	r6, r3, r6
		return NRF_GPIO_PIN_SENSE_HIGH;
    e03e:	f016 0f01 	tst.w	r6, #1
			nrf_gpio_cfg_sense_set(abs_pin, sense);
    e042:	4628      	mov	r0, r5
    e044:	bf0c      	ite	eq
    e046:	2103      	moveq	r1, #3
    e048:	2102      	movne	r1, #2
    e04a:	f7ff ff29 	bl	dea0 <nrf_gpio_cfg_sense_set>
	int res = 0;
    e04e:	4620      	mov	r0, r4
    e050:	e7e2      	b.n	e018 <gpiote_pin_int_cfg+0x10c>
    e052:	bf00      	nop
    e054:	40006000 	.word	0x40006000

0000e058 <gpio_nrfx_config>:
{
    e058:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e05c:	4607      	mov	r7, r0
	struct gpio_nrfx_data *data = get_port_data(port);
    e05e:	6885      	ldr	r5, [r0, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    e060:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
    e064:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
{
    e068:	461e      	mov	r6, r3
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    e06a:	d03e      	beq.n	e0ea <gpio_nrfx_config+0x92>
    e06c:	dc09      	bgt.n	e082 <gpio_nrfx_config+0x2a>
    e06e:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
    e072:	d03c      	beq.n	e0ee <gpio_nrfx_config+0x96>
    e074:	f5b0 5f40 	cmp.w	r0, #12288	; 0x3000
    e078:	d03b      	beq.n	e0f2 <gpio_nrfx_config+0x9a>
    e07a:	b190      	cbz	r0, e0a2 <gpio_nrfx_config+0x4a>
		return -EINVAL;
    e07c:	f06f 0015 	mvn.w	r0, #21
    e080:	e031      	b.n	e0e6 <gpio_nrfx_config+0x8e>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    e082:	f5b0 4fe0 	cmp.w	r0, #28672	; 0x7000
    e086:	d036      	beq.n	e0f6 <gpio_nrfx_config+0x9e>
    e088:	dc04      	bgt.n	e094 <gpio_nrfx_config+0x3c>
    e08a:	f5b0 4fa0 	cmp.w	r0, #20480	; 0x5000
    e08e:	d1f5      	bne.n	e07c <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0H1;
    e090:	2003      	movs	r0, #3
    e092:	e006      	b.n	e0a2 <gpio_nrfx_config+0x4a>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
    e094:	f5b0 4f40 	cmp.w	r0, #49152	; 0xc000
    e098:	d02f      	beq.n	e0fa <gpio_nrfx_config+0xa2>
    e09a:	f5b0 4f50 	cmp.w	r0, #53248	; 0xd000
    e09e:	d1ed      	bne.n	e07c <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0D1;
    e0a0:	2007      	movs	r0, #7
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
    e0a2:	f406 7840 	and.w	r8, r6, #768	; 0x300
    e0a6:	f5b8 7f80 	cmp.w	r8, #256	; 0x100
    e0aa:	d028      	beq.n	e0fe <gpio_nrfx_config+0xa6>
		pull = NRF_GPIO_PIN_NOPULL;
    e0ac:	f5a8 7400 	sub.w	r4, r8, #512	; 0x200
    e0b0:	4263      	negs	r3, r4
    e0b2:	4163      	adcs	r3, r4
	dir = ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT)
    e0b4:	f006 0c01 	and.w	ip, r6, #1
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
    e0b8:	ea4f 084c 	mov.w	r8, ip, lsl #1
	if (access_op == GPIO_ACCESS_BY_PORT) {
    e0bc:	2901      	cmp	r1, #1
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    e0be:	ea48 080c 	orr.w	r8, r8, ip
		from_pin = pin;
    e0c2:	bf18      	it	ne
    e0c4:	b2d4      	uxtbne	r4, r2
    e0c6:	ea48 2000 	orr.w	r0, r8, r0, lsl #8
        return NRF_P1;
    e0ca:	f8df a0b8 	ldr.w	sl, [pc, #184]	; e184 <gpio_nrfx_config+0x12c>
		to_pin   = pin;
    e0ce:	bf12      	itee	ne
    e0d0:	46a1      	movne	r9, r4
		to_pin   = 31U;
    e0d2:	f04f 091f 	moveq.w	r9, #31
		from_pin = 0U;
    e0d6:	2400      	moveq	r4, #0
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    e0d8:	ea40 0883 	orr.w	r8, r0, r3, lsl #2
    e0dc:	f04f 0b01 	mov.w	fp, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    e0e0:	45a1      	cmp	r9, r4
    e0e2:	d20e      	bcs.n	e102 <gpio_nrfx_config+0xaa>
	return 0;
    e0e4:	2000      	movs	r0, #0
}
    e0e6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		drive = NRF_GPIO_PIN_S0H1;
    e0ea:	2002      	movs	r0, #2
    e0ec:	e7d9      	b.n	e0a2 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_H0S1;
    e0ee:	2001      	movs	r0, #1
    e0f0:	e7d7      	b.n	e0a2 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0S1;
    e0f2:	2004      	movs	r0, #4
    e0f4:	e7d5      	b.n	e0a2 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0H1;
    e0f6:	2005      	movs	r0, #5
    e0f8:	e7d3      	b.n	e0a2 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_S0D1;
    e0fa:	2006      	movs	r0, #6
    e0fc:	e7d1      	b.n	e0a2 <gpio_nrfx_config+0x4a>
		pull = NRF_GPIO_PIN_PULLUP;
    e0fe:	2303      	movs	r3, #3
    e100:	e7d8      	b.n	e0b4 <gpio_nrfx_config+0x5c>
	return port->config->config_info;
    e102:	683b      	ldr	r3, [r7, #0]
		nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num,
    e104:	689b      	ldr	r3, [r3, #8]
    e106:	791b      	ldrb	r3, [r3, #4]
    e108:	f004 021f 	and.w	r2, r4, #31
    e10c:	ea42 1243 	orr.w	r2, r2, r3, lsl #5
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    e110:	2a2f      	cmp	r2, #47	; 0x2f
    e112:	dd01      	ble.n	e118 <gpio_nrfx_config+0xc0>
    e114:	f7ff feb6 	bl	de84 <nrf_gpio_pin_port_decode.part.8>
    if (*p_pin < P0_PIN_NUM)
    e118:	2a1f      	cmp	r2, #31
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    e11a:	bfc6      	itte	gt
    e11c:	f002 021f 	andgt.w	r2, r2, #31
        return NRF_P1;
    e120:	4653      	movgt	r3, sl
        return NRF_P0;
    e122:	f04f 43a0 	movle.w	r3, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    e126:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
    e12a:	07b1      	lsls	r1, r6, #30
    e12c:	f843 8022 	str.w	r8, [r3, r2, lsl #2]
    e130:	68ab      	ldr	r3, [r5, #8]
    e132:	fa0b f204 	lsl.w	r2, fp, r4
    e136:	bf4c      	ite	mi
    e138:	4313      	orrmi	r3, r2
    e13a:	4393      	bicpl	r3, r2
    e13c:	60ab      	str	r3, [r5, #8]
		WRITE_BIT(data->trig_edge, curr_pin, flags & GPIO_INT_EDGE);
    e13e:	696b      	ldr	r3, [r5, #20]
    e140:	06b0      	lsls	r0, r6, #26
    e142:	bf4c      	ite	mi
    e144:	4313      	orrmi	r3, r2
    e146:	4393      	bicpl	r3, r2
    e148:	616b      	str	r3, [r5, #20]
		WRITE_BIT(data->double_edge, curr_pin,
    e14a:	69ab      	ldr	r3, [r5, #24]
    e14c:	0671      	lsls	r1, r6, #25
    e14e:	bf4c      	ite	mi
    e150:	4313      	orrmi	r3, r2
    e152:	4393      	bicpl	r3, r2
    e154:	61ab      	str	r3, [r5, #24]
		WRITE_BIT(data->active_level, curr_pin,
    e156:	692b      	ldr	r3, [r5, #16]
    e158:	0770      	lsls	r0, r6, #29
    e15a:	bf4c      	ite	mi
    e15c:	4313      	orrmi	r3, r2
    e15e:	4393      	bicpl	r3, r2
    e160:	612b      	str	r3, [r5, #16]
		WRITE_BIT(data->inverted, curr_pin, flags & GPIO_POL_INV);
    e162:	69eb      	ldr	r3, [r5, #28]
    e164:	0631      	lsls	r1, r6, #24
    e166:	bf4c      	ite	mi
    e168:	431a      	orrmi	r2, r3
    e16a:	ea23 0202 	bicpl.w	r2, r3, r2
    e16e:	61ea      	str	r2, [r5, #28]
		res = gpiote_pin_int_cfg(port, curr_pin);
    e170:	4621      	mov	r1, r4
    e172:	4638      	mov	r0, r7
    e174:	f7ff feca 	bl	df0c <gpiote_pin_int_cfg>
		if (res != 0) {
    e178:	2800      	cmp	r0, #0
    e17a:	d1b4      	bne.n	e0e6 <gpio_nrfx_config+0x8e>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
    e17c:	3401      	adds	r4, #1
    e17e:	b2e4      	uxtb	r4, r4
    e180:	e7ae      	b.n	e0e0 <gpio_nrfx_config+0x88>
    e182:	bf00      	nop
    e184:	50000300 	.word	0x50000300

0000e188 <gpiote_event_handler>:
{
    e188:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (*(uint32_t *)nrf_gpiote_event_addr_get(event) == 0x1UL) ? true : false;
    e18a:	4d2d      	ldr	r5, [pc, #180]	; (e240 <gpiote_event_handler+0xb8>)
    e18c:	682c      	ldr	r4, [r5, #0]
    e18e:	b085      	sub	sp, #20
	u32_t fired_triggers[GPIO_COUNT] = {0};
    e190:	2600      	movs	r6, #0
	if (port_event) {
    e192:	2c01      	cmp	r4, #1
	u32_t fired_triggers[GPIO_COUNT] = {0};
    e194:	e9cd 6602 	strd	r6, r6, [sp, #8]
	if (port_event) {
    e198:	d10b      	bne.n	e1b2 <gpiote_event_handler+0x2a>
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p0));
    e19a:	482a      	ldr	r0, [pc, #168]	; (e244 <gpiote_event_handler+0xbc>)
    e19c:	f007 fb3a 	bl	15814 <check_level_trigger_pins>
		fired_triggers[0] =
    e1a0:	9002      	str	r0, [sp, #8]
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p1));
    e1a2:	4829      	ldr	r0, [pc, #164]	; (e248 <gpiote_event_handler+0xc0>)
    e1a4:	f007 fb36 	bl	15814 <check_level_trigger_pins>
		fired_triggers[1] =
    e1a8:	9003      	str	r0, [sp, #12]
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
    e1aa:	602e      	str	r6, [r5, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
    e1ac:	682b      	ldr	r3, [r5, #0]
    e1ae:	9300      	str	r3, [sp, #0]
    (void)dummy;
    e1b0:	9b00      	ldr	r3, [sp, #0]
    return (NRF_GPIOTE->INTENSET & mask);
    e1b2:	4e26      	ldr	r6, [pc, #152]	; (e24c <gpiote_event_handler+0xc4>)
{
    e1b4:	2300      	movs	r3, #0
		if (nrf_gpiote_int_is_enabled(BIT(i)) &&
    e1b6:	2701      	movs	r7, #1
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
    e1b8:	469c      	mov	ip, r3
    return (NRF_GPIOTE->INTENSET & mask);
    e1ba:	f8d6 2304 	ldr.w	r2, [r6, #772]	; 0x304
    e1be:	fa07 f103 	lsl.w	r1, r7, r3
    e1c2:	4211      	tst	r1, r2
    e1c4:	d01e      	beq.n	e204 <gpiote_event_handler+0x7c>
    return ((uint32_t)NRF_GPIOTE + event);
    e1c6:	009a      	lsls	r2, r3, #2
    e1c8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    e1cc:	f502 42c2 	add.w	r2, r2, #24832	; 0x6100
    e1d0:	6811      	ldr	r1, [r2, #0]
    e1d2:	2901      	cmp	r1, #1
    e1d4:	d116      	bne.n	e204 <gpiote_event_handler+0x7c>
    return ((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    e1d6:	f503 70a2 	add.w	r0, r3, #324	; 0x144
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    e1da:	f10d 0e10 	add.w	lr, sp, #16
    e1de:	f856 5020 	ldr.w	r5, [r6, r0, lsl #2]
    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
    e1e2:	f8c2 c000 	str.w	ip, [r2]
    e1e6:	f3c5 3040 	ubfx	r0, r5, #13, #1
    e1ea:	eb0e 0080 	add.w	r0, lr, r0, lsl #2
    e1ee:	f3c5 2504 	ubfx	r5, r5, #8, #5
    e1f2:	40a9      	lsls	r1, r5
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
    e1f4:	6812      	ldr	r2, [r2, #0]
    e1f6:	f850 5c08 	ldr.w	r5, [r0, #-8]
    e1fa:	9201      	str	r2, [sp, #4]
    e1fc:	4329      	orrs	r1, r5
    (void)dummy;
    e1fe:	9a01      	ldr	r2, [sp, #4]
    e200:	f840 1c08 	str.w	r1, [r0, #-8]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    e204:	3301      	adds	r3, #1
    e206:	2b08      	cmp	r3, #8
    e208:	d1d7      	bne.n	e1ba <gpiote_event_handler+0x32>
	if (fired_triggers[0]) {
    e20a:	9a02      	ldr	r2, [sp, #8]
    e20c:	b11a      	cbz	r2, e216 <gpiote_event_handler+0x8e>
	gpio_fire_callbacks(&get_port_data(port)->callbacks, port, pins);
    e20e:	490d      	ldr	r1, [pc, #52]	; (e244 <gpiote_event_handler+0xbc>)
    e210:	6888      	ldr	r0, [r1, #8]
    e212:	f007 fa8c 	bl	1572e <gpio_fire_callbacks>
	if (fired_triggers[1]) {
    e216:	9a03      	ldr	r2, [sp, #12]
    e218:	b12a      	cbz	r2, e226 <gpiote_event_handler+0x9e>
	gpio_fire_callbacks(&get_port_data(port)->callbacks, port, pins);
    e21a:	4b0a      	ldr	r3, [pc, #40]	; (e244 <gpiote_event_handler+0xbc>)
    e21c:	f103 010c 	add.w	r1, r3, #12
    e220:	6958      	ldr	r0, [r3, #20]
    e222:	f007 fa84 	bl	1572e <gpio_fire_callbacks>
	if (port_event) {
    e226:	2c01      	cmp	r4, #1
    e228:	d108      	bne.n	e23c <gpiote_event_handler+0xb4>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p0));
    e22a:	4806      	ldr	r0, [pc, #24]	; (e244 <gpiote_event_handler+0xbc>)
    e22c:	f007 fb20 	bl	15870 <cfg_level_pins>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
    e230:	4805      	ldr	r0, [pc, #20]	; (e248 <gpiote_event_handler+0xc0>)
}
    e232:	b005      	add	sp, #20
    e234:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
    e238:	f007 bb1a 	b.w	15870 <cfg_level_pins>
}
    e23c:	b005      	add	sp, #20
    e23e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e240:	4000617c 	.word	0x4000617c
    e244:	20011c8c 	.word	0x20011c8c
    e248:	20011c98 	.word	0x20011c98
    e24c:	40006000 	.word	0x40006000

0000e250 <event_txdrdy_check>:

}

__STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type * p_reg, nrf_uart_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e250:	4b05      	ldr	r3, [pc, #20]	; (e268 <event_txdrdy_check+0x18>)
    e252:	681b      	ldr	r3, [r3, #0]

static bool event_txdrdy_check(void)
{
	return (nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_TXDRDY)
#ifdef CONFIG_UART_0_INTERRUPT_DRIVEN
		|| uart_sw_event_txdrdy
    e254:	b92b      	cbnz	r3, e262 <event_txdrdy_check+0x12>
    e256:	4b05      	ldr	r3, [pc, #20]	; (e26c <event_txdrdy_check+0x1c>)
    e258:	7818      	ldrb	r0, [r3, #0]
    e25a:	3000      	adds	r0, #0
    e25c:	bf18      	it	ne
    e25e:	2001      	movne	r0, #1
    e260:	4770      	bx	lr
    e262:	2001      	movs	r0, #1
#endif
	       );
}
    e264:	4770      	bx	lr
    e266:	bf00      	nop
    e268:	4000211c 	.word	0x4000211c
    e26c:	2000687b 	.word	0x2000687b

0000e270 <uart_nrfx_err_check>:
    e270:	4b03      	ldr	r3, [pc, #12]	; (e280 <uart_nrfx_err_check+0x10>)
    e272:	6818      	ldr	r0, [r3, #0]
/** Console I/O function */
static int uart_nrfx_err_check(struct device *dev)
{
	u32_t error = 0U;

	if (nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_ERROR)) {
    e274:	b118      	cbz	r0, e27e <uart_nrfx_err_check+0xe>
    p_reg->INTENCLR = int_mask;
}

__STATIC_INLINE uint32_t nrf_uart_errorsrc_get_and_clear(NRF_UART_Type * p_reg)
{
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    e276:	f8d3 035c 	ldr.w	r0, [r3, #860]	; 0x35c
    p_reg->ERRORSRC = errsrc_mask;
    e27a:	f8c3 035c 	str.w	r0, [r3, #860]	; 0x35c
		/* register bitfields maps to the defines in uart.h */
		error = nrf_uart_errorsrc_get_and_clear(uart0_addr);
	}

	return error;
}
    e27e:	4770      	bx	lr
    e280:	40002124 	.word	0x40002124

0000e284 <uart_nrfx_irq_rx_enable>:
    p_reg->INTENSET = int_mask;
    e284:	4b02      	ldr	r3, [pc, #8]	; (e290 <uart_nrfx_irq_rx_enable+0xc>)
    e286:	2204      	movs	r2, #4
    e288:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

/** Interrupt driven receiver enabling function */
static void uart_nrfx_irq_rx_enable(struct device *dev)
{
	nrf_uart_int_enable(uart0_addr, NRF_UART_INT_MASK_RXDRDY);
}
    e28c:	4770      	bx	lr
    e28e:	bf00      	nop
    e290:	40002000 	.word	0x40002000

0000e294 <uart_nrfx_irq_rx_disable>:
    p_reg->INTENCLR = int_mask;
    e294:	4b02      	ldr	r3, [pc, #8]	; (e2a0 <uart_nrfx_irq_rx_disable+0xc>)
    e296:	2204      	movs	r2, #4
    e298:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

/** Interrupt driven receiver disabling function */
static void uart_nrfx_irq_rx_disable(struct device *dev)
{
	nrf_uart_int_disable(uart0_addr, NRF_UART_INT_MASK_RXDRDY);
}
    e29c:	4770      	bx	lr
    e29e:	bf00      	nop
    e2a0:	40002000 	.word	0x40002000

0000e2a4 <uart_nrfx_irq_rx_ready>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e2a4:	4b02      	ldr	r3, [pc, #8]	; (e2b0 <uart_nrfx_irq_rx_ready+0xc>)
    e2a6:	6818      	ldr	r0, [r3, #0]

/** Interrupt driven receiver ready function */
static int uart_nrfx_irq_rx_ready(struct device *dev)
{
	return nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY);
}
    e2a8:	3000      	adds	r0, #0
    e2aa:	bf18      	it	ne
    e2ac:	2001      	movne	r0, #1
    e2ae:	4770      	bx	lr
    e2b0:	40002108 	.word	0x40002108

0000e2b4 <uart_nrfx_irq_err_enable>:
    p_reg->INTENSET = int_mask;
    e2b4:	4b02      	ldr	r3, [pc, #8]	; (e2c0 <uart_nrfx_irq_err_enable+0xc>)
    e2b6:	f44f 7200 	mov.w	r2, #512	; 0x200
    e2ba:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

/** Interrupt driven error enabling function */
static void uart_nrfx_irq_err_enable(struct device *dev)
{
	nrf_uart_int_enable(uart0_addr, NRF_UART_INT_MASK_ERROR);
}
    e2be:	4770      	bx	lr
    e2c0:	40002000 	.word	0x40002000

0000e2c4 <uart_nrfx_irq_err_disable>:
    p_reg->INTENCLR = int_mask;
    e2c4:	4b02      	ldr	r3, [pc, #8]	; (e2d0 <uart_nrfx_irq_err_disable+0xc>)
    e2c6:	f44f 7200 	mov.w	r2, #512	; 0x200
    e2ca:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

/** Interrupt driven error disabling function */
static void uart_nrfx_irq_err_disable(struct device *dev)
{
	nrf_uart_int_disable(uart0_addr, NRF_UART_INT_MASK_ERROR);
}
    e2ce:	4770      	bx	lr
    e2d0:	40002000 	.word	0x40002000

0000e2d4 <uart_nrfx_irq_callback_set>:
static void uart_nrfx_irq_callback_set(struct device *dev,
				       uart_irq_callback_user_data_t cb,
				       void *cb_data)
{
	(void)dev;
	irq_callback = cb;
    e2d4:	4b02      	ldr	r3, [pc, #8]	; (e2e0 <uart_nrfx_irq_callback_set+0xc>)
    e2d6:	6019      	str	r1, [r3, #0]
	irq_cb_data = cb_data;
    e2d8:	4b02      	ldr	r3, [pc, #8]	; (e2e4 <uart_nrfx_irq_callback_set+0x10>)
    e2da:	601a      	str	r2, [r3, #0]
}
    e2dc:	4770      	bx	lr
    e2de:	bf00      	nop
    e2e0:	20004458 	.word	0x20004458
    e2e4:	2000445c 	.word	0x2000445c

0000e2e8 <uart_nrfx_isr>:
 */
static void uart_nrfx_isr(void *arg)
{
	ARG_UNUSED(arg);

	if (irq_callback) {
    e2e8:	4b03      	ldr	r3, [pc, #12]	; (e2f8 <uart_nrfx_isr+0x10>)
    e2ea:	681b      	ldr	r3, [r3, #0]
    e2ec:	b113      	cbz	r3, e2f4 <uart_nrfx_isr+0xc>
		irq_callback(irq_cb_data);
    e2ee:	4a03      	ldr	r2, [pc, #12]	; (e2fc <uart_nrfx_isr+0x14>)
    e2f0:	6810      	ldr	r0, [r2, #0]
    e2f2:	4718      	bx	r3
	}
}
    e2f4:	4770      	bx	lr
    e2f6:	bf00      	nop
    e2f8:	20004458 	.word	0x20004458
    e2fc:	2000445c 	.word	0x2000445c

0000e300 <uart_nrfx_irq_tx_disable>:
    e300:	4b03      	ldr	r3, [pc, #12]	; (e310 <uart_nrfx_irq_tx_disable+0x10>)
    e302:	2280      	movs	r2, #128	; 0x80
    e304:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->TXD = txd;
}

__STATIC_INLINE void nrf_uart_task_trigger(NRF_UART_Type * p_reg, nrf_uart_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e308:	2201      	movs	r2, #1
    e30a:	60da      	str	r2, [r3, #12]
	device_busy_clear(dev);
    e30c:	f007 bb2d 	b.w	1596a <device_busy_clear>
    e310:	40002000 	.word	0x40002000

0000e314 <uart_nrfx_irq_tx_enable>:
{
    e314:	b508      	push	{r3, lr}
	device_busy_set(dev);
    e316:	f007 fb27 	bl	15968 <device_busy_set>
    e31a:	4b0d      	ldr	r3, [pc, #52]	; (e350 <uart_nrfx_irq_tx_enable+0x3c>)
    e31c:	2201      	movs	r2, #1
    e31e:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = int_mask;
    e320:	2280      	movs	r2, #128	; 0x80
    e322:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	__asm__ volatile(
    e326:	f04f 0220 	mov.w	r2, #32
    e32a:	f3ef 8311 	mrs	r3, BASEPRI
    e32e:	f382 8811 	msr	BASEPRI, r2
    e332:	f3bf 8f6f 	isb	sy
	if (uart_sw_event_txdrdy) {
    e336:	4a07      	ldr	r2, [pc, #28]	; (e354 <uart_nrfx_irq_tx_enable+0x40>)
    e338:	7812      	ldrb	r2, [r2, #0]
    e33a:	b11a      	cbz	r2, e344 <uart_nrfx_irq_tx_enable+0x30>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e33c:	4a06      	ldr	r2, [pc, #24]	; (e358 <uart_nrfx_irq_tx_enable+0x44>)
    e33e:	2104      	movs	r1, #4
    e340:	f8c2 1100 	str.w	r1, [r2, #256]	; 0x100
	__asm__ volatile(
    e344:	f383 8811 	msr	BASEPRI, r3
    e348:	f3bf 8f6f 	isb	sy
}
    e34c:	bd08      	pop	{r3, pc}
    e34e:	bf00      	nop
    e350:	40002008 	.word	0x40002008
    e354:	2000687b 	.word	0x2000687b
    e358:	e000e100 	.word	0xe000e100

0000e35c <uart_nrfx_configure>:
{
    e35c:	b530      	push	{r4, r5, lr}
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
    e35e:	794b      	ldrb	r3, [r1, #5]
    e360:	2b01      	cmp	r3, #1
    e362:	d120      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    e364:	798b      	ldrb	r3, [r1, #6]
    e366:	2b03      	cmp	r3, #3
    e368:	d11d      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
	switch (cfg->flow_ctrl) {
    e36a:	79cc      	ldrb	r4, [r1, #7]
    e36c:	b12c      	cbz	r4, e37a <uart_nrfx_configure+0x1e>
    e36e:	2c01      	cmp	r4, #1
    e370:	d119      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
	return dev->config->config_info;
    e372:	6803      	ldr	r3, [r0, #0]
		if (get_dev_config(dev)->rts_cts_pins_set) {
    e374:	689b      	ldr	r3, [r3, #8]
    e376:	781b      	ldrb	r3, [r3, #0]
    e378:	b1ab      	cbz	r3, e3a6 <uart_nrfx_configure+0x4a>
	switch (cfg->parity) {
    e37a:	790a      	ldrb	r2, [r1, #4]
    e37c:	b112      	cbz	r2, e384 <uart_nrfx_configure+0x28>
    e37e:	2a02      	cmp	r2, #2
    e380:	d111      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
		parity = NRF_UART_PARITY_INCLUDED;
    e382:	220e      	movs	r2, #14
	if (baudrate_set(dev, cfg->baudrate) != 0) {
    e384:	680b      	ldr	r3, [r1, #0]
	switch (baudrate) {
    e386:	f647 2512 	movw	r5, #31250	; 0x7a12
    e38a:	42ab      	cmp	r3, r5
    e38c:	d05f      	beq.n	e44e <uart_nrfx_configure+0xf2>
    e38e:	d827      	bhi.n	e3e0 <uart_nrfx_configure+0x84>
    e390:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    e394:	d05e      	beq.n	e454 <uart_nrfx_configure+0xf8>
    e396:	d812      	bhi.n	e3be <uart_nrfx_configure+0x62>
    e398:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    e39c:	d05c      	beq.n	e458 <uart_nrfx_configure+0xfc>
    e39e:	d805      	bhi.n	e3ac <uart_nrfx_configure+0x50>
    e3a0:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    e3a4:	d05b      	beq.n	e45e <uart_nrfx_configure+0x102>
		return -ENOTSUP;
    e3a6:	f06f 0085 	mvn.w	r0, #133	; 0x85
    e3aa:	e04f      	b.n	e44c <uart_nrfx_configure+0xf0>
	switch (baudrate) {
    e3ac:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    e3b0:	d058      	beq.n	e464 <uart_nrfx_configure+0x108>
    e3b2:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    e3b6:	d1f6      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UART_BAUDRATE_2400;
    e3b8:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    e3bc:	e03b      	b.n	e436 <uart_nrfx_configure+0xda>
	switch (baudrate) {
    e3be:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    e3c2:	d052      	beq.n	e46a <uart_nrfx_configure+0x10e>
    e3c4:	d804      	bhi.n	e3d0 <uart_nrfx_configure+0x74>
    e3c6:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    e3ca:	d1ec      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UART_BAUDRATE_9600;
    e3cc:	4b30      	ldr	r3, [pc, #192]	; (e490 <uart_nrfx_configure+0x134>)
    e3ce:	e032      	b.n	e436 <uart_nrfx_configure+0xda>
	switch (baudrate) {
    e3d0:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    e3d4:	d04c      	beq.n	e470 <uart_nrfx_configure+0x114>
    e3d6:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    e3da:	d1e4      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UART_BAUDRATE_28800;
    e3dc:	4b2d      	ldr	r3, [pc, #180]	; (e494 <uart_nrfx_configure+0x138>)
    e3de:	e02a      	b.n	e436 <uart_nrfx_configure+0xda>
	switch (baudrate) {
    e3e0:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    e3e4:	d046      	beq.n	e474 <uart_nrfx_configure+0x118>
    e3e6:	d811      	bhi.n	e40c <uart_nrfx_configure+0xb0>
    e3e8:	f64d 25c0 	movw	r5, #56000	; 0xdac0
    e3ec:	42ab      	cmp	r3, r5
    e3ee:	d043      	beq.n	e478 <uart_nrfx_configure+0x11c>
    e3f0:	d804      	bhi.n	e3fc <uart_nrfx_configure+0xa0>
    e3f2:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
    e3f6:	d1d6      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UART_BAUDRATE_38400;
    e3f8:	4b27      	ldr	r3, [pc, #156]	; (e498 <uart_nrfx_configure+0x13c>)
    e3fa:	e01c      	b.n	e436 <uart_nrfx_configure+0xda>
	switch (baudrate) {
    e3fc:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    e400:	d03d      	beq.n	e47e <uart_nrfx_configure+0x122>
    e402:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    e406:	d1ce      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UART_BAUDRATE_76800;
    e408:	4b24      	ldr	r3, [pc, #144]	; (e49c <uart_nrfx_configure+0x140>)
    e40a:	e014      	b.n	e436 <uart_nrfx_configure+0xda>
	switch (baudrate) {
    e40c:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    e410:	d037      	beq.n	e482 <uart_nrfx_configure+0x126>
    e412:	d808      	bhi.n	e426 <uart_nrfx_configure+0xca>
    e414:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    e418:	d035      	beq.n	e486 <uart_nrfx_configure+0x12a>
    e41a:	4d21      	ldr	r5, [pc, #132]	; (e4a0 <uart_nrfx_configure+0x144>)
    e41c:	42ab      	cmp	r3, r5
    e41e:	d1c2      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UART_BAUDRATE_250000;
    e420:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    e424:	e007      	b.n	e436 <uart_nrfx_configure+0xda>
	switch (baudrate) {
    e426:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    e42a:	d02e      	beq.n	e48a <uart_nrfx_configure+0x12e>
    e42c:	4d1d      	ldr	r5, [pc, #116]	; (e4a4 <uart_nrfx_configure+0x148>)
    e42e:	42ab      	cmp	r3, r5
    e430:	d1b9      	bne.n	e3a6 <uart_nrfx_configure+0x4a>
		nrf_baudrate = NRF_UART_BAUDRATE_1000000;
    e432:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    p_reg->CONFIG = (uint32_t)parity | (uint32_t)hwfc;
}

__STATIC_INLINE void nrf_uart_baudrate_set(NRF_UART_Type   * p_reg, nrf_uart_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    e436:	4d1c      	ldr	r5, [pc, #112]	; (e4a8 <uart_nrfx_configure+0x14c>)
    e438:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
	get_dev_data(dev)->uart_config = *cfg;
    e43c:	6883      	ldr	r3, [r0, #8]
    e43e:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)parity | (uint32_t)hwfc;
    e440:	4322      	orrs	r2, r4
    e442:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
    e446:	e883 0003 	stmia.w	r3, {r0, r1}
	return 0;
    e44a:	2000      	movs	r0, #0
}
    e44c:	bd30      	pop	{r4, r5, pc}
		nrf_baudrate = NRF_UART_BAUDRATE_31250;
    e44e:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    e452:	e7f0      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = NRF_UART_BAUDRATE_4800;
    e454:	4b15      	ldr	r3, [pc, #84]	; (e4ac <uart_nrfx_configure+0x150>)
    e456:	e7ee      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = 0x00027000;
    e458:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    e45c:	e7eb      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = 0x00014000;
    e45e:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    e462:	e7e8      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = NRF_UART_BAUDRATE_1200;
    e464:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    e468:	e7e5      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = NRF_UART_BAUDRATE_14400;
    e46a:	f44f 136c 	mov.w	r3, #3866624	; 0x3b0000
    e46e:	e7e2      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = NRF_UART_BAUDRATE_19200;
    e470:	4b0f      	ldr	r3, [pc, #60]	; (e4b0 <uart_nrfx_configure+0x154>)
    e472:	e7e0      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = NRF_UART_BAUDRATE_115200;
    e474:	4b0f      	ldr	r3, [pc, #60]	; (e4b4 <uart_nrfx_configure+0x158>)
    e476:	e7de      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = NRF_UART_BAUDRATE_56000;
    e478:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    e47c:	e7db      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = NRF_UART_BAUDRATE_57600;
    e47e:	4b0e      	ldr	r3, [pc, #56]	; (e4b8 <uart_nrfx_configure+0x15c>)
    e480:	e7d9      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = NRF_UART_BAUDRATE_460800;
    e482:	4b0e      	ldr	r3, [pc, #56]	; (e4bc <uart_nrfx_configure+0x160>)
    e484:	e7d7      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = NRF_UART_BAUDRATE_230400;
    e486:	4b0e      	ldr	r3, [pc, #56]	; (e4c0 <uart_nrfx_configure+0x164>)
    e488:	e7d5      	b.n	e436 <uart_nrfx_configure+0xda>
		nrf_baudrate = NRF_UART_BAUDRATE_921600;
    e48a:	4b0e      	ldr	r3, [pc, #56]	; (e4c4 <uart_nrfx_configure+0x168>)
    e48c:	e7d3      	b.n	e436 <uart_nrfx_configure+0xda>
    e48e:	bf00      	nop
    e490:	00275000 	.word	0x00275000
    e494:	0075f000 	.word	0x0075f000
    e498:	009d5000 	.word	0x009d5000
    e49c:	013a9000 	.word	0x013a9000
    e4a0:	0003d090 	.word	0x0003d090
    e4a4:	000f4240 	.word	0x000f4240
    e4a8:	40002000 	.word	0x40002000
    e4ac:	0013b000 	.word	0x0013b000
    e4b0:	004ea000 	.word	0x004ea000
    e4b4:	01d7e000 	.word	0x01d7e000
    e4b8:	00ebf000 	.word	0x00ebf000
    e4bc:	075f7000 	.word	0x075f7000
    e4c0:	03afb000 	.word	0x03afb000
    e4c4:	0ebed000 	.word	0x0ebed000

0000e4c8 <uart_nrfx_irq_is_pending>:
{
    e4c8:	b508      	push	{r3, lr}
    return (bool)(p_reg->INTENSET & int_mask);
    e4ca:	4b0c      	ldr	r3, [pc, #48]	; (e4fc <uart_nrfx_irq_is_pending+0x34>)
    e4cc:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
		||
    e4d0:	f012 0f80 	tst.w	r2, #128	; 0x80
    e4d4:	461a      	mov	r2, r3
    e4d6:	d105      	bne.n	e4e4 <uart_nrfx_irq_is_pending+0x1c>
    e4d8:	f8d2 0304 	ldr.w	r0, [r2, #772]	; 0x304
    e4dc:	f010 0004 	ands.w	r0, r0, #4
    e4e0:	d106      	bne.n	e4f0 <uart_nrfx_irq_is_pending+0x28>
}
    e4e2:	bd08      	pop	{r3, pc}
		 event_txdrdy_check())
    e4e4:	f7ff feb4 	bl	e250 <event_txdrdy_check>
					   NRF_UART_INT_MASK_TXDRDY) &&
    e4e8:	2800      	cmp	r0, #0
    e4ea:	d0f5      	beq.n	e4d8 <uart_nrfx_irq_is_pending+0x10>
		||
    e4ec:	2001      	movs	r0, #1
    e4ee:	e7f8      	b.n	e4e2 <uart_nrfx_irq_is_pending+0x1a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e4f0:	4b03      	ldr	r3, [pc, #12]	; (e500 <uart_nrfx_irq_is_pending+0x38>)
    e4f2:	6818      	ldr	r0, [r3, #0]
					   NRF_UART_INT_MASK_RXDRDY) &&
    e4f4:	3000      	adds	r0, #0
    e4f6:	bf18      	it	ne
    e4f8:	2001      	movne	r0, #1
    e4fa:	e7f2      	b.n	e4e2 <uart_nrfx_irq_is_pending+0x1a>
    e4fc:	40002000 	.word	0x40002000
    e500:	40002108 	.word	0x40002108

0000e504 <nrf_gpio_pin_port_decode>:
{
    e504:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
    e506:	6803      	ldr	r3, [r0, #0]
    e508:	2b2f      	cmp	r3, #47	; 0x2f
    e50a:	d906      	bls.n	e51a <nrf_gpio_pin_port_decode+0x16>
    e50c:	4b07      	ldr	r3, [pc, #28]	; (e52c <nrf_gpio_pin_port_decode+0x28>)
    e50e:	4a08      	ldr	r2, [pc, #32]	; (e530 <nrf_gpio_pin_port_decode+0x2c>)
    e510:	4808      	ldr	r0, [pc, #32]	; (e534 <nrf_gpio_pin_port_decode+0x30>)
    e512:	f240 11dd 	movw	r1, #477	; 0x1dd
    e516:	f7f2 f931 	bl	77c <__assert_func>
    if (*p_pin < P0_PIN_NUM)
    e51a:	2b1f      	cmp	r3, #31
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
    e51c:	bf85      	ittet	hi
    e51e:	f003 031f 	andhi.w	r3, r3, #31
    e522:	6003      	strhi	r3, [r0, #0]
        return NRF_P0;
    e524:	f04f 40a0 	movls.w	r0, #1342177280	; 0x50000000
        return NRF_P1;
    e528:	4803      	ldrhi	r0, [pc, #12]	; (e538 <nrf_gpio_pin_port_decode+0x34>)
}
    e52a:	bd08      	pop	{r3, pc}
    e52c:	0001911e 	.word	0x0001911e
    e530:	00019165 	.word	0x00019165
    e534:	00019131 	.word	0x00019131
    e538:	50000300 	.word	0x50000300

0000e53c <uart_nrfx_fifo_read>:
{
    e53c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	while ((size - num_rx > 0) &&
    e53e:	2300      	movs	r3, #0
    e540:	4c09      	ldr	r4, [pc, #36]	; (e568 <uart_nrfx_fifo_read+0x2c>)
    return p_reg->RXD;
    e542:	4f0a      	ldr	r7, [pc, #40]	; (e56c <uart_nrfx_fifo_read+0x30>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e544:	461e      	mov	r6, r3
    e546:	b2d8      	uxtb	r0, r3
    e548:	1a15      	subs	r5, r2, r0
    e54a:	2d00      	cmp	r5, #0
    e54c:	dd02      	ble.n	e554 <uart_nrfx_fifo_read+0x18>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e54e:	6825      	ldr	r5, [r4, #0]
    e550:	3301      	adds	r3, #1
    e552:	b90d      	cbnz	r5, e558 <uart_nrfx_fifo_read+0x1c>
}
    e554:	b003      	add	sp, #12
    e556:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e558:	6026      	str	r6, [r4, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    e55a:	6825      	ldr	r5, [r4, #0]
    e55c:	9501      	str	r5, [sp, #4]
    (void)dummy;
    e55e:	9d01      	ldr	r5, [sp, #4]
    return p_reg->RXD;
    e560:	f8d7 5518 	ldr.w	r5, [r7, #1304]	; 0x518
    e564:	540d      	strb	r5, [r1, r0]
    e566:	e7ee      	b.n	e546 <uart_nrfx_fifo_read+0xa>
    e568:	40002108 	.word	0x40002108
    e56c:	40002000 	.word	0x40002000

0000e570 <uart_nrfx_poll_out>:
{
    e570:	b507      	push	{r0, r1, r2, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e572:	4a0b      	ldr	r2, [pc, #44]	; (e5a0 <uart_nrfx_poll_out+0x30>)
    e574:	2300      	movs	r3, #0
    e576:	6013      	str	r3, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    e578:	6812      	ldr	r2, [r2, #0]
    e57a:	9201      	str	r2, [sp, #4]
    (void)dummy;
    e57c:	9a01      	ldr	r2, [sp, #4]
	uart_sw_event_txdrdy = 0U;
    e57e:	4a09      	ldr	r2, [pc, #36]	; (e5a4 <uart_nrfx_poll_out+0x34>)
    e580:	7013      	strb	r3, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e582:	4b09      	ldr	r3, [pc, #36]	; (e5a8 <uart_nrfx_poll_out+0x38>)
    e584:	2201      	movs	r2, #1
    e586:	601a      	str	r2, [r3, #0]
    p_reg->TXD = txd;
    e588:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	while (!event_txdrdy_check()) {
    e58c:	f7ff fe60 	bl	e250 <event_txdrdy_check>
    e590:	2800      	cmp	r0, #0
    e592:	d0fb      	beq.n	e58c <uart_nrfx_poll_out+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e594:	4b05      	ldr	r3, [pc, #20]	; (e5ac <uart_nrfx_poll_out+0x3c>)
    e596:	2201      	movs	r2, #1
    e598:	601a      	str	r2, [r3, #0]
}
    e59a:	b003      	add	sp, #12
    e59c:	f85d fb04 	ldr.w	pc, [sp], #4
    e5a0:	4000211c 	.word	0x4000211c
    e5a4:	2000687b 	.word	0x2000687b
    e5a8:	40002008 	.word	0x40002008
    e5ac:	4000200c 	.word	0x4000200c

0000e5b0 <uart_nrfx_poll_in>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e5b0:	4b08      	ldr	r3, [pc, #32]	; (e5d4 <uart_nrfx_poll_in+0x24>)
    e5b2:	681a      	ldr	r2, [r3, #0]
{
    e5b4:	b082      	sub	sp, #8
	if (!nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY)) {
    e5b6:	b152      	cbz	r2, e5ce <uart_nrfx_poll_in+0x1e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e5b8:	2000      	movs	r0, #0
    e5ba:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    e5bc:	681b      	ldr	r3, [r3, #0]
    e5be:	9301      	str	r3, [sp, #4]
    (void)dummy;
    e5c0:	9b01      	ldr	r3, [sp, #4]
    return p_reg->RXD;
    e5c2:	4b05      	ldr	r3, [pc, #20]	; (e5d8 <uart_nrfx_poll_in+0x28>)
    e5c4:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
    e5c8:	700b      	strb	r3, [r1, #0]
}
    e5ca:	b002      	add	sp, #8
    e5cc:	4770      	bx	lr
		return -1;
    e5ce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e5d2:	e7fa      	b.n	e5ca <uart_nrfx_poll_in+0x1a>
    e5d4:	40002108 	.word	0x40002108
    e5d8:	40002000 	.word	0x40002000

0000e5dc <uart_nrfx_fifo_fill>:
{
    e5dc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e5e0:	4e0d      	ldr	r6, [pc, #52]	; (e618 <uart_nrfx_fifo_fill+0x3c>)
	uart_sw_event_txdrdy = 0U;
    e5e2:	4f0e      	ldr	r7, [pc, #56]	; (e61c <uart_nrfx_fifo_fill+0x40>)
    p_reg->TXD = txd;
    e5e4:	f8df 8038 	ldr.w	r8, [pc, #56]	; e620 <uart_nrfx_fifo_fill+0x44>
	while ((len - num_tx > 0) &&
    e5e8:	2400      	movs	r4, #0
    e5ea:	b2e5      	uxtb	r5, r4
    e5ec:	1b53      	subs	r3, r2, r5
    e5ee:	2b00      	cmp	r3, #0
    e5f0:	dd03      	ble.n	e5fa <uart_nrfx_fifo_fill+0x1e>
	       event_txdrdy_check()) {
    e5f2:	f7ff fe2d 	bl	e250 <event_txdrdy_check>
    e5f6:	3401      	adds	r4, #1
	while ((len - num_tx > 0) &&
    e5f8:	b918      	cbnz	r0, e602 <uart_nrfx_fifo_fill+0x26>
}
    e5fa:	4628      	mov	r0, r5
    e5fc:	b002      	add	sp, #8
    e5fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e602:	2300      	movs	r3, #0
    e604:	6033      	str	r3, [r6, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    e606:	6830      	ldr	r0, [r6, #0]
    e608:	9001      	str	r0, [sp, #4]
    (void)dummy;
    e60a:	9801      	ldr	r0, [sp, #4]
	uart_sw_event_txdrdy = 0U;
    e60c:	703b      	strb	r3, [r7, #0]
    p_reg->TXD = txd;
    e60e:	5d4b      	ldrb	r3, [r1, r5]
    e610:	f8c8 351c 	str.w	r3, [r8, #1308]	; 0x51c
    e614:	e7e9      	b.n	e5ea <uart_nrfx_fifo_fill+0xe>
    e616:	bf00      	nop
    e618:	4000211c 	.word	0x4000211c
    e61c:	2000687b 	.word	0x2000687b
    e620:	40002000 	.word	0x40002000

0000e624 <uart_nrfx_init>:
 * @param dev UART device struct
 *
 * @return 0 on success
 */
static int uart_nrfx_init(struct device *dev)
{
    e624:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    e628:	2606      	movs	r6, #6
    e62a:	4607      	mov	r7, r0
}


__STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    e62c:	a801      	add	r0, sp, #4
    e62e:	9601      	str	r6, [sp, #4]
    e630:	f7ff ff68 	bl	e504 <nrf_gpio_pin_port_decode>

    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    e634:	9b01      	ldr	r3, [sp, #4]
    p_reg->PSEL.RXD = pselrxd;
    e636:	4c31      	ldr	r4, [pc, #196]	; (e6fc <uart_nrfx_init+0xd8>)
    e638:	2501      	movs	r5, #1
    e63a:	fa05 f303 	lsl.w	r3, r5, r3
}


__STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
    e63e:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    e642:	a801      	add	r0, sp, #4
    e644:	9601      	str	r6, [sp, #4]
    e646:	f7ff ff5d 	bl	e504 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    e64a:	9b01      	ldr	r3, [sp, #4]
    e64c:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    e650:	f04f 0903 	mov.w	r9, #3
    e654:	f840 9023 	str.w	r9, [r0, r3, lsl #2]
    nrf_gpio_cfg(
    e658:	f04f 0a08 	mov.w	sl, #8
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    e65c:	a801      	add	r0, sp, #4
    e65e:	f8cd a004 	str.w	sl, [sp, #4]
    e662:	f7ff ff4f 	bl	e504 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    e666:	9b01      	ldr	r3, [sp, #4]
    e668:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    e66c:	f04f 0800 	mov.w	r8, #0
    e670:	f840 8023 	str.w	r8, [r0, r3, lsl #2]
    e674:	f8c4 a514 	str.w	sl, [r4, #1300]	; 0x514
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    e678:	a801      	add	r0, sp, #4
    p_reg->PSEL.TXD = pseltxd;
    e67a:	f8c4 650c 	str.w	r6, [r4, #1292]	; 0x50c
        nrf_gpio_pin_set(pin_number);
    e67e:	2605      	movs	r6, #5
    e680:	9601      	str	r6, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    e682:	f7ff ff3f 	bl	e504 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    e686:	9b01      	ldr	r3, [sp, #4]
    e688:	fa05 f303 	lsl.w	r3, r5, r3
    p_reg->OUTSET = set_mask;
    e68c:	f8c0 3508 	str.w	r3, [r0, #1288]	; 0x508
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    e690:	a801      	add	r0, sp, #4
    e692:	9601      	str	r6, [sp, #4]
    e694:	f7ff ff36 	bl	e504 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    e698:	9b01      	ldr	r3, [sp, #4]
    e69a:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    e69e:	f840 9023 	str.w	r9, [r0, r3, lsl #2]
    nrf_gpio_cfg(
    e6a2:	f04f 0907 	mov.w	r9, #7
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    e6a6:	a801      	add	r0, sp, #4
    e6a8:	f8cd 9004 	str.w	r9, [sp, #4]
    e6ac:	f7ff ff2a 	bl	e504 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    e6b0:	9b01      	ldr	r3, [sp, #4]
			       DT_NORDIC_NRF_UART_UART_0_RTS_PIN,
			       DT_NORDIC_NRF_UART_UART_0_CTS_PIN);
#endif

	/* Set initial configuration */
	err = uart_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    e6b2:	68b9      	ldr	r1, [r7, #8]
    e6b4:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    e6b8:	f840 8023 	str.w	r8, [r0, r3, lsl #2]
    p_reg->PSEL.RTS = pselrts;
    e6bc:	f8c4 6508 	str.w	r6, [r4, #1288]	; 0x508
    e6c0:	4638      	mov	r0, r7
    p_reg->PSEL.CTS = pselcts;
    e6c2:	f8c4 9510 	str.w	r9, [r4, #1296]	; 0x510
    e6c6:	f7ff fe49 	bl	e35c <uart_nrfx_configure>
	if (err) {
    e6ca:	4606      	mov	r6, r0
    e6cc:	b990      	cbnz	r0, e6f4 <uart_nrfx_init+0xd0>
    p_reg->ENABLE = UART_ENABLE_ENABLE_Enabled;
    e6ce:	2304      	movs	r3, #4
    e6d0:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e6d4:	4b0a      	ldr	r3, [pc, #40]	; (e700 <uart_nrfx_init+0xdc>)
    e6d6:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
    e6d8:	681b      	ldr	r3, [r3, #0]
    e6da:	9301      	str	r3, [sp, #4]
    (void)dummy;
    e6dc:	9b01      	ldr	r3, [sp, #4]

#ifdef CONFIG_UART_0_INTERRUPT_DRIVEN
	/* Simulate that the TXDRDY event is set, so that the transmitter status
	 * is indicated correctly.
	 */
	uart_sw_event_txdrdy = 1U;
    e6de:	4b09      	ldr	r3, [pc, #36]	; (e704 <uart_nrfx_init+0xe0>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e6e0:	6025      	str	r5, [r4, #0]
#endif

#if defined(CONFIG_UART_ASYNC_API) || defined(CONFIG_UART_0_INTERRUPT_DRIVEN)

	IRQ_CONNECT(DT_NORDIC_NRF_UART_UART_0_IRQ,
    e6e2:	4602      	mov	r2, r0
    e6e4:	4629      	mov	r1, r5
    e6e6:	2002      	movs	r0, #2
	uart_sw_event_txdrdy = 1U;
    e6e8:	701d      	strb	r5, [r3, #0]
	IRQ_CONNECT(DT_NORDIC_NRF_UART_UART_0_IRQ,
    e6ea:	f7fb fb81 	bl	9df0 <z_irq_priority_set>
		    DT_NORDIC_NRF_UART_UART_0_IRQ_PRIORITY,
		    uart_nrfx_isr,
		    DEVICE_GET(uart_nrfx_uart0),
		    0);
	irq_enable(DT_NORDIC_NRF_UART_UART_0_IRQ);
    e6ee:	2002      	movs	r0, #2
    e6f0:	f7fb fb4c 	bl	9d8c <z_arch_irq_enable>
	defined(DT_NORDIC_NRF_UART_UART_0_CTS_PIN)
	k_delayed_work_init(&uart0_cb.tx_timeout_work, tx_timeout);
#endif
#endif
	return 0;
}
    e6f4:	4630      	mov	r0, r6
    e6f6:	b002      	add	sp, #8
    e6f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e6fc:	40002000 	.word	0x40002000
    e700:	40002108 	.word	0x40002108
    e704:	2000687b 	.word	0x2000687b

0000e708 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static u16_t rng_pool_get(struct rng_pool *rngp, u8_t *buf, u16_t len)
{
    e708:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t last  = rngp->last;
    e70a:	7883      	ldrb	r3, [r0, #2]
	u32_t mask  = rngp->mask;
    e70c:	78c7      	ldrb	r7, [r0, #3]
	__asm__ volatile(
    e70e:	f04f 0420 	mov.w	r4, #32
    e712:	f3ef 8e11 	mrs	lr, BASEPRI
    e716:	f384 8811 	msr	BASEPRI, r4
    e71a:	f3bf 8f6f 	isb	sy
	u32_t first, available;
	u32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
    e71e:	7806      	ldrb	r6, [r0, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
    e720:	f890 c001 	ldrb.w	ip, [r0, #1]

	available = (last - first) & mask;
    e724:	1b9b      	subs	r3, r3, r6
    e726:	403b      	ands	r3, r7
	if (available < len) {
    e728:	429a      	cmp	r2, r3
		len = available;
    e72a:	bf88      	it	hi
    e72c:	b29a      	uxthhi	r2, r3

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
    e72e:	18b4      	adds	r4, r6, r2
    e730:	403c      	ands	r4, r7
	first = rngp->first_alloc;
    e732:	4635      	mov	r5, r6
	rngp->first_alloc = (first + len) & mask;
    e734:	7004      	strb	r4, [r0, #0]
	__asm__ volatile(
    e736:	f38e 8811 	msr	BASEPRI, lr
    e73a:	f3bf 8f6f 	isb	sy
    e73e:	440a      	add	r2, r1
	u8_t *dst   = buf;
    e740:	460c      	mov	r4, r1
	irq_unlock(key);

	while (likely(len--)) {
    e742:	42a2      	cmp	r2, r4
    e744:	d11a      	bne.n	e77c <rng_pool_get+0x74>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
    e746:	4566      	cmp	r6, ip
    e748:	d10d      	bne.n	e766 <rng_pool_get+0x5e>
	__asm__ volatile(
    e74a:	f04f 0520 	mov.w	r5, #32
    e74e:	f3ef 8211 	mrs	r2, BASEPRI
    e752:	f385 8811 	msr	BASEPRI, r5
    e756:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
    e75a:	7805      	ldrb	r5, [r0, #0]
    e75c:	7045      	strb	r5, [r0, #1]
	__asm__ volatile(
    e75e:	f382 8811 	msr	BASEPRI, r2
    e762:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
    e766:	1a64      	subs	r4, r4, r1
    e768:	b2a2      	uxth	r2, r4
	available = available - len;
	if (available <= rngp->threshold) {
    e76a:	7901      	ldrb	r1, [r0, #4]
	available = available - len;
    e76c:	1a9c      	subs	r4, r3, r2
	if (available <= rngp->threshold) {
    e76e:	42a1      	cmp	r1, r4
    return (uint32_t *)((uint8_t *)NRF_RNG + rng_task);
}

__STATIC_INLINE void nrf_rng_task_trigger(nrf_rng_task_t rng_task)
{
    *((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_task)) = NRF_RNG_TASK_SET;
    e770:	bf22      	ittt	cs
    e772:	4b07      	ldrcs	r3, [pc, #28]	; (e790 <rng_pool_get+0x88>)
    e774:	2101      	movcs	r1, #1
    e776:	6019      	strcs	r1, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG_TASK_START);
	}

	return len;
}
    e778:	4610      	mov	r0, r2
    e77a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
    e77c:	eb00 0e05 	add.w	lr, r0, r5
		first = (first + 1) & mask;
    e780:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
    e782:	f89e e005 	ldrb.w	lr, [lr, #5]
    e786:	f804 eb01 	strb.w	lr, [r4], #1
		first = (first + 1) & mask;
    e78a:	403d      	ands	r5, r7
    e78c:	e7d9      	b.n	e742 <rng_pool_get+0x3a>
    e78e:	bf00      	nop
    e790:	4000d000 	.word	0x4000d000

0000e794 <entropy_nrf5_get_entropy>:
		k_sem_give(&entropy_nrf5_data.sem_sync);
	}
}

static int entropy_nrf5_get_entropy(struct device *device, u8_t *buf, u16_t len)
{
    e794:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    e798:	4d11      	ldr	r5, [pc, #68]	; (e7e0 <entropy_nrf5_get_entropy+0x4c>)
    e79a:	460e      	mov	r6, r1
    e79c:	4614      	mov	r4, r2

	while (len) {
		u16_t bytes;

		k_sem_take(&entropy_nrf5_data.sem_lock, K_FOREVER);
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
    e79e:	f105 0845 	add.w	r8, r5, #69	; 0x45
    e7a2:	f105 0918 	add.w	r9, r5, #24
	while (len) {
    e7a6:	b914      	cbnz	r4, e7ae <entropy_nrf5_get_entropy+0x1a>
		len -= bytes;
		buf += bytes;
	}

	return 0;
}
    e7a8:	4620      	mov	r0, r4
    e7aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    e7ae:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e7b2:	4628      	mov	r0, r5
    e7b4:	f000 ff54 	bl	f660 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
    e7b8:	4622      	mov	r2, r4
    e7ba:	4631      	mov	r1, r6
    e7bc:	4640      	mov	r0, r8
    e7be:	f7ff ffa3 	bl	e708 <rng_pool_get>
    e7c2:	4607      	mov	r7, r0
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    e7c4:	4628      	mov	r0, r5
    e7c6:	f000 ff1f 	bl	f608 <z_impl_k_sem_give>
		if (bytes == 0U) {
    e7ca:	b92f      	cbnz	r7, e7d8 <entropy_nrf5_get_entropy+0x44>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
    e7cc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    e7d0:	4648      	mov	r0, r9
    e7d2:	f000 ff45 	bl	f660 <z_impl_k_sem_take>
    e7d6:	e7e6      	b.n	e7a6 <entropy_nrf5_get_entropy+0x12>
		len -= bytes;
    e7d8:	1be4      	subs	r4, r4, r7
    e7da:	b2a4      	uxth	r4, r4
		buf += bytes;
    e7dc:	443e      	add	r6, r7
    e7de:	e7e2      	b.n	e7a6 <entropy_nrf5_get_entropy+0x12>
    e7e0:	20004460 	.word	0x20004460

0000e7e4 <random_byte_get>:
{
    e7e4:	b082      	sub	sp, #8
	__asm__ volatile(
    e7e6:	f04f 0320 	mov.w	r3, #32
    e7ea:	f3ef 8211 	mrs	r2, BASEPRI
    e7ee:	f383 8811 	msr	BASEPRI, r3
    e7f2:	f3bf 8f6f 	isb	sy
#endif
}

__STATIC_INLINE bool nrf_rng_event_get(nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_event));
    e7f6:	4b0a      	ldr	r3, [pc, #40]	; (e820 <random_byte_get+0x3c>)
    e7f8:	6819      	ldr	r1, [r3, #0]
	if (nrf_rng_event_get(NRF_RNG_EVENT_VALRDY)) {
    e7fa:	b171      	cbz	r1, e81a <random_byte_get+0x36>
     NRF_RNG->SHORTS &= ~rng_short_mask;
}

__STATIC_INLINE uint8_t nrf_rng_random_value_get(void)
{
    return (uint8_t)(NRF_RNG->VALUE & RNG_VALUE_VALUE_Msk);
    e7fc:	4909      	ldr	r1, [pc, #36]	; (e824 <random_byte_get+0x40>)
    e7fe:	f8d1 0508 	ldr.w	r0, [r1, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_event)) = NRF_RNG_EVENT_CLEAR;
    e802:	2100      	movs	r1, #0
    e804:	6019      	str	r1, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_event));
    e806:	681b      	ldr	r3, [r3, #0]
    e808:	9301      	str	r3, [sp, #4]
    (void)dummy;
    e80a:	9b01      	ldr	r3, [sp, #4]
		retval = nrf_rng_random_value_get();
    e80c:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
    e80e:	f382 8811 	msr	BASEPRI, r2
    e812:	f3bf 8f6f 	isb	sy
}
    e816:	b002      	add	sp, #8
    e818:	4770      	bx	lr
	int retval = -EAGAIN;
    e81a:	f06f 000a 	mvn.w	r0, #10
    e81e:	e7f6      	b.n	e80e <random_byte_get+0x2a>
    e820:	4000d100 	.word	0x4000d100
    e824:	4000d000 	.word	0x4000d000

0000e828 <entropy_nrf5_get_entropy_isr>:
	u16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    e828:	07db      	lsls	r3, r3, #31
{
    e82a:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    e82e:	4688      	mov	r8, r1
    e830:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
    e832:	d405      	bmi.n	e840 <entropy_nrf5_get_entropy_isr+0x18>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
    e834:	4820      	ldr	r0, [pc, #128]	; (e8b8 <entropy_nrf5_get_entropy_isr+0x90>)
    e836:	f7ff ff67 	bl	e708 <rng_pool_get>
			irq_enable(RNG_IRQn);
		}
	}

	return cnt;
}
    e83a:	b002      	add	sp, #8
    e83c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
    e840:	2a00      	cmp	r2, #0
    e842:	d032      	beq.n	e8aa <entropy_nrf5_get_entropy_isr+0x82>
	__asm__ volatile(
    e844:	f04f 0320 	mov.w	r3, #32
    e848:	f3ef 8511 	mrs	r5, BASEPRI
    e84c:	f383 8811 	msr	BASEPRI, r3
    e850:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(RNG_IRQn);
    e854:	200d      	movs	r0, #13
    e856:	f7fb fabd 	bl	9dd4 <z_arch_irq_is_enabled>
    e85a:	4607      	mov	r7, r0
		irq_disable(RNG_IRQn);
    e85c:	200d      	movs	r0, #13
    e85e:	f7fb faa5 	bl	9dac <z_arch_irq_disable>
	__asm__ volatile(
    e862:	f385 8811 	msr	BASEPRI, r5
    e866:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_event)) = NRF_RNG_EVENT_CLEAR;
    e86a:	4e14      	ldr	r6, [pc, #80]	; (e8bc <entropy_nrf5_get_entropy_isr+0x94>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e86c:	f8df 9054 	ldr.w	r9, [pc, #84]	; e8c4 <entropy_nrf5_get_entropy_isr+0x9c>
    e870:	2200      	movs	r2, #0
    e872:	6032      	str	r2, [r6, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_event));
    e874:	6832      	ldr	r2, [r6, #0]
    e876:	9201      	str	r2, [sp, #4]
    (void)dummy;
    e878:	9a01      	ldr	r2, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_task)) = NRF_RNG_TASK_SET;
    e87a:	4a11      	ldr	r2, [pc, #68]	; (e8c0 <entropy_nrf5_get_entropy_isr+0x98>)
    e87c:	2101      	movs	r1, #1
    e87e:	6011      	str	r1, [r2, #0]
    e880:	4625      	mov	r5, r4
    e882:	f44f 5a00 	mov.w	sl, #8192	; 0x2000
    return (bool) * ((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_event));
    e886:	6833      	ldr	r3, [r6, #0]
			while (!nrf_rng_event_get(NRF_RNG_EVENT_VALRDY)) {
    e888:	b18b      	cbz	r3, e8ae <entropy_nrf5_get_entropy_isr+0x86>
			byte = random_byte_get();
    e88a:	f7ff ffab 	bl	e7e4 <random_byte_get>
			if (byte < 0) {
    e88e:	2800      	cmp	r0, #0
    e890:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
    e894:	dbf7      	blt.n	e886 <entropy_nrf5_get_entropy_isr+0x5e>
    e896:	3d01      	subs	r5, #1
    e898:	b2ad      	uxth	r5, r5
			buf[--len] = byte;
    e89a:	f808 0005 	strb.w	r0, [r8, r5]
		} while (len);
    e89e:	2d00      	cmp	r5, #0
    e8a0:	d1f1      	bne.n	e886 <entropy_nrf5_get_entropy_isr+0x5e>
		if (irq_enabled) {
    e8a2:	b117      	cbz	r7, e8aa <entropy_nrf5_get_entropy_isr+0x82>
			irq_enable(RNG_IRQn);
    e8a4:	200d      	movs	r0, #13
    e8a6:	f7fb fa71 	bl	9d8c <z_arch_irq_enable>
	return cnt;
    e8aa:	4620      	mov	r0, r4
    e8ac:	e7c5      	b.n	e83a <entropy_nrf5_get_entropy_isr+0x12>
				__WFE();
    e8ae:	bf20      	wfe
				__SEV();
    e8b0:	bf40      	sev
				__WFE();
    e8b2:	bf20      	wfe
    e8b4:	e7e7      	b.n	e886 <entropy_nrf5_get_entropy_isr+0x5e>
    e8b6:	bf00      	nop
    e8b8:	20004490 	.word	0x20004490
    e8bc:	4000d100 	.word	0x4000d100
    e8c0:	4000d000 	.word	0x4000d000
    e8c4:	e000e100 	.word	0xe000e100

0000e8c8 <entropy_nrf5_init>:
		    entropy_nrf5_init, &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(struct device *device)
{
    e8c8:	b537      	push	{r0, r1, r2, r4, r5, lr}
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
    e8ca:	4c1b      	ldr	r4, [pc, #108]	; (e938 <entropy_nrf5_init+0x70>)
    e8cc:	2201      	movs	r2, #1
    e8ce:	4611      	mov	r1, r2
    e8d0:	4620      	mov	r0, r4
    e8d2:	f007 fa65 	bl	15da0 <z_impl_k_sem_init>
    e8d6:	f104 0018 	add.w	r0, r4, #24
    e8da:	2201      	movs	r2, #1
    e8dc:	2100      	movs	r1, #0
    e8de:	f007 fa5f 	bl	15da0 <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
    e8e2:	f240 4307 	movw	r3, #1031	; 0x407
    e8e6:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
    e8ea:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    e8ee:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
    e8f0:	230c      	movs	r3, #12
    e8f2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	rngp->first_alloc = 0U;
    e8f6:	2500      	movs	r5, #0
    NRF_RNG->CONFIG |= RNG_CONFIG_DERCEN_Msk;
}

__STATIC_INLINE void nrf_rng_error_correction_disable(void)
{
    NRF_RNG->CONFIG &= ~RNG_CONFIG_DERCEN_Msk;
    e8f8:	4b10      	ldr	r3, [pc, #64]	; (e93c <entropy_nrf5_init+0x74>)
    e8fa:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
    e8fe:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
    e902:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
    e906:	f022 0201 	bic.w	r2, r2, #1
    e90a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_event)) = NRF_RNG_EVENT_CLEAR;
    e90e:	4a0c      	ldr	r2, [pc, #48]	; (e940 <entropy_nrf5_init+0x78>)
    e910:	6015      	str	r5, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_event));
    e912:	6812      	ldr	r2, [r2, #0]
    e914:	9201      	str	r2, [sp, #4]
    (void)dummy;
    e916:	9a01      	ldr	r2, [sp, #4]
    NRF_RNG->INTENSET = rng_int_mask;
    e918:	2201      	movs	r2, #1
    e91a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	nrf_rng_event_clear(NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG_TASK_START);

	IRQ_CONNECT(RNG_IRQn, CONFIG_ENTROPY_NRF5_PRI, isr,
    e91e:	2105      	movs	r1, #5
    *((volatile uint32_t *)((uint8_t *)NRF_RNG + rng_task)) = NRF_RNG_TASK_SET;
    e920:	601a      	str	r2, [r3, #0]
    e922:	200d      	movs	r0, #13
    e924:	462a      	mov	r2, r5
    e926:	f7fb fa63 	bl	9df0 <z_irq_priority_set>
		    &entropy_nrf5_data, 0);
	irq_enable(RNG_IRQn);
    e92a:	200d      	movs	r0, #13
    e92c:	f7fb fa2e 	bl	9d8c <z_arch_irq_enable>

	return 0;
}
    e930:	4628      	mov	r0, r5
    e932:	b003      	add	sp, #12
    e934:	bd30      	pop	{r4, r5, pc}
    e936:	bf00      	nop
    e938:	20004460 	.word	0x20004460
    e93c:	4000d000 	.word	0x4000d000
    e940:	4000d100 	.word	0x4000d100

0000e944 <isr>:
{
    e944:	b510      	push	{r4, lr}
	byte = random_byte_get();
    e946:	f7ff ff4d 	bl	e7e4 <random_byte_get>
	if (byte < 0) {
    e94a:	2800      	cmp	r0, #0
    e94c:	db20      	blt.n	e990 <isr+0x4c>
	u8_t last  = rngp->last;
    e94e:	4b17      	ldr	r3, [pc, #92]	; (e9ac <isr+0x68>)
    e950:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
    e954:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	u8_t mask  = rngp->mask;
    e958:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
    e95c:	1a51      	subs	r1, r2, r1
    e95e:	ea34 0101 	bics.w	r1, r4, r1
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
    e962:	b2c0      	uxtb	r0, r0
	if (((last - first) & mask) == mask) {
    e964:	d10d      	bne.n	e982 <isr+0x3e>
	u8_t last  = rngp->last;
    e966:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
    e96a:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	u8_t mask  = rngp->mask;
    e96e:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
    e972:	1a51      	subs	r1, r2, r1
    e974:	ea34 0101 	bics.w	r1, r4, r1
    e978:	d10b      	bne.n	e992 <isr+0x4e>
    e97a:	4b0d      	ldr	r3, [pc, #52]	; (e9b0 <isr+0x6c>)
    e97c:	2201      	movs	r2, #1
    e97e:	601a      	str	r2, [r3, #0]
    e980:	e00e      	b.n	e9a0 <isr+0x5c>
	rngp->buffer[last] = byte;
    e982:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
    e984:	3201      	adds	r2, #1
    e986:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
    e988:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
    e98c:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
    e990:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
    e992:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
    e994:	3201      	adds	r2, #1
    e996:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
    e998:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
    e99c:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
    e9a0:	4804      	ldr	r0, [pc, #16]	; (e9b4 <isr+0x70>)
}
    e9a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    e9a6:	f000 be2f 	b.w	f608 <z_impl_k_sem_give>
    e9aa:	bf00      	nop
    e9ac:	20004460 	.word	0x20004460
    e9b0:	4000d004 	.word	0x4000d004
    e9b4:	20004478 	.word	0x20004478

0000e9b8 <z_sys_device_do_config_level>:
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
    e9b8:	4b09      	ldr	r3, [pc, #36]	; (e9e0 <z_sys_device_do_config_level+0x28>)
{
    e9ba:	b570      	push	{r4, r5, r6, lr}
	for (info = config_levels[level]; info < config_levels[level+1];
    e9bc:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    e9c0:	3001      	adds	r0, #1
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
    e9c2:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
    e9c4:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
    e9c8:	42a5      	cmp	r5, r4
    e9ca:	d800      	bhi.n	e9ce <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
    e9cc:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
    e9ce:	6823      	ldr	r3, [r4, #0]
    e9d0:	4620      	mov	r0, r4
    e9d2:	685b      	ldr	r3, [r3, #4]
    e9d4:	4798      	blx	r3
		if (retval != 0) {
    e9d6:	b100      	cbz	r0, e9da <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
    e9d8:	6066      	str	r6, [r4, #4]
								info++) {
    e9da:	340c      	adds	r4, #12
    e9dc:	e7f4      	b.n	e9c8 <z_sys_device_do_config_level+0x10>
    e9de:	bf00      	nop
    e9e0:	00016820 	.word	0x00016820

0000e9e4 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
    e9e4:	4b10      	ldr	r3, [pc, #64]	; (ea28 <z_impl_device_get_binding+0x44>)
{
    e9e6:	b570      	push	{r4, r5, r6, lr}
	for (info = __device_init_start; info != __device_init_end; info++) {
    e9e8:	4c10      	ldr	r4, [pc, #64]	; (ea2c <z_impl_device_get_binding+0x48>)
{
    e9ea:	4605      	mov	r5, r0
    e9ec:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
    e9ee:	429c      	cmp	r4, r3
    e9f0:	d104      	bne.n	e9fc <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
    e9f2:	4c0e      	ldr	r4, [pc, #56]	; (ea2c <z_impl_device_get_binding+0x48>)
    e9f4:	42b4      	cmp	r4, r6
    e9f6:	d109      	bne.n	ea0c <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
    e9f8:	2400      	movs	r4, #0
    e9fa:	e012      	b.n	ea22 <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
    e9fc:	6862      	ldr	r2, [r4, #4]
    e9fe:	b11a      	cbz	r2, ea08 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
    ea00:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
    ea02:	6812      	ldr	r2, [r2, #0]
    ea04:	42aa      	cmp	r2, r5
    ea06:	d00c      	beq.n	ea22 <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
    ea08:	340c      	adds	r4, #12
    ea0a:	e7f0      	b.n	e9ee <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
    ea0c:	6863      	ldr	r3, [r4, #4]
    ea0e:	b90b      	cbnz	r3, ea14 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
    ea10:	340c      	adds	r4, #12
    ea12:	e7ef      	b.n	e9f4 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
    ea14:	6823      	ldr	r3, [r4, #0]
    ea16:	4628      	mov	r0, r5
    ea18:	6819      	ldr	r1, [r3, #0]
    ea1a:	f7f3 fbfb 	bl	2214 <strcmp>
    ea1e:	2800      	cmp	r0, #0
    ea20:	d1f6      	bne.n	ea10 <z_impl_device_get_binding+0x2c>
}
    ea22:	4620      	mov	r0, r4
    ea24:	bd70      	pop	{r4, r5, r6, pc}
    ea26:	bf00      	nop
    ea28:	20011cd4 	.word	0x20011cd4
    ea2c:	20011c08 	.word	0x20011c08

0000ea30 <z_impl_z_errno>:

Z_SYSCALL_HANDLER0_SIMPLE(z_errno);
#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
    ea30:	4b01      	ldr	r3, [pc, #4]	; (ea38 <z_impl_z_errno+0x8>)
    ea32:	6898      	ldr	r0, [r3, #8]
}
    ea34:	3054      	adds	r0, #84	; 0x54
    ea36:	4770      	bx	lr
    ea38:	200055e4 	.word	0x200055e4

0000ea3c <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
    ea3c:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
    ea3e:	4d0b      	ldr	r5, [pc, #44]	; (ea6c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xc>)
	__asm__ volatile(
    ea40:	f04f 0220 	mov.w	r2, #32
    ea44:	f3ef 8311 	mrs	r3, BASEPRI
    ea48:	f382 8811 	msr	BASEPRI, r2
    ea4c:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
    ea50:	f007 fa74 	bl	15f3c <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    ea54:	2101      	movs	r1, #1
    ea56:	2802      	cmp	r0, #2
	s32_t ticks = z_get_next_timeout_expiry();
    ea58:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    ea5a:	bfd8      	it	le
    ea5c:	4608      	movle	r0, r1
    ea5e:	f007 fa7d 	bl	15f5c <z_set_timeout_expiry>
	_kernel.idle = ticks;
    ea62:	622c      	str	r4, [r5, #32]
	k_cpu_idle();
    ea64:	f7fb fa0c 	bl	9e80 <k_cpu_idle>
    ea68:	e7ea      	b.n	ea40 <idle+0x4>
    ea6a:	bf00      	nop
    ea6c:	200055e4 	.word	0x200055e4

0000ea70 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(&__bss_start, 0,
    ea70:	4802      	ldr	r0, [pc, #8]	; (ea7c <z_bss_zero+0xc>)
__ssp_bos_icheck3(memset, void *, int)
    ea72:	4a03      	ldr	r2, [pc, #12]	; (ea80 <z_bss_zero+0x10>)
    ea74:	2100      	movs	r1, #0
    ea76:	1a12      	subs	r2, r2, r0
    ea78:	f7f3 bbb7 	b.w	21ea <memset>
    ea7c:	20002000 	.word	0x20002000
    ea80:	20006884 	.word	0x20006884

0000ea84 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    ea84:	b508      	push	{r3, lr}
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
    ea86:	4806      	ldr	r0, [pc, #24]	; (eaa0 <z_data_copy+0x1c>)
    ea88:	4a06      	ldr	r2, [pc, #24]	; (eaa4 <z_data_copy+0x20>)
    ea8a:	4907      	ldr	r1, [pc, #28]	; (eaa8 <z_data_copy+0x24>)
    ea8c:	1a12      	subs	r2, r2, r0
    ea8e:	f7f3 fb71 	bl	2174 <memcpy>
    ea92:	4a06      	ldr	r2, [pc, #24]	; (eaac <z_data_copy+0x28>)
    ea94:	4906      	ldr	r1, [pc, #24]	; (eab0 <z_data_copy+0x2c>)
    ea96:	4807      	ldr	r0, [pc, #28]	; (eab4 <z_data_copy+0x30>)
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 ((u32_t) &_app_smem_end - (u32_t) &_app_smem_start));
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    ea98:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    ea9c:	f7f3 bb6a 	b.w	2174 <memcpy>
    eaa0:	200109c8 	.word	0x200109c8
    eaa4:	20011f68 	.word	0x20011f68
    eaa8:	0001b268 	.word	0x0001b268
    eaac:	00002000 	.word	0x00002000
    eab0:	00019268 	.word	0x00019268
    eab4:	20000000 	.word	0x20000000

0000eab8 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    eab8:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    eaba:	2002      	movs	r0, #2
    eabc:	f7ff ff7c 	bl	e9b8 <z_sys_device_do_config_level>
	if (boot_delay > 0 && IS_ENABLED(CONFIG_MULTITHREADING)) {
		printk("***** delaying boot " STRINGIFY(CONFIG_BOOT_DELAY)
		       "ms (per build configuration) *****\n");
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}
	PRINT_BOOT_BANNER();
    eac0:	4807      	ldr	r0, [pc, #28]	; (eae0 <bg_thread_main+0x28>)
    eac2:	f003 f99d 	bl	11e00 <printk>

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
    eac6:	2003      	movs	r0, #3
    eac8:	f7ff ff76 	bl	e9b8 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
    eacc:	f000 fe94 	bl	f7f8 <z_init_static_threads>
	__main_time_stamp = (u64_t)k_cycle_get_32();
#endif

	extern void main(void);

	main();
    ead0:	f7f6 f974 	bl	4dbc <main>

	/* Mark nonessenrial since main() has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
    ead4:	4a03      	ldr	r2, [pc, #12]	; (eae4 <bg_thread_main+0x2c>)
    ead6:	7b13      	ldrb	r3, [r2, #12]
    ead8:	f023 0301 	bic.w	r3, r3, #1
    eadc:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    eade:	bd08      	pop	{r3, pc}
    eae0:	0001917f 	.word	0x0001917f
    eae4:	20004520 	.word	0x20004520

0000eae8 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    eae8:	b580      	push	{r7, lr}
    eaea:	b0a2      	sub	sp, #136	; 0x88
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	if (IS_ENABLED(CONFIG_LOG)) {
		log_core_init();
    eaec:	f7f8 f8b8 	bl	6c60 <log_core_init>
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    eaf0:	4b3c      	ldr	r3, [pc, #240]	; (ebe4 <z_cstart+0xfc>)
    eaf2:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    eaf6:	4b3c      	ldr	r3, [pc, #240]	; (ebe8 <z_cstart+0x100>)
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
    eaf8:	4e3c      	ldr	r6, [pc, #240]	; (ebec <z_cstart+0x104>)
    eafa:	695a      	ldr	r2, [r3, #20]
	_kernel.ready_q.cache = _main_thread;
    eafc:	4d3c      	ldr	r5, [pc, #240]	; (ebf0 <z_cstart+0x108>)
    eafe:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    eb02:	615a      	str	r2, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    eb04:	2400      	movs	r4, #0
    eb06:	22e0      	movs	r2, #224	; 0xe0
    eb08:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    eb0c:	77dc      	strb	r4, [r3, #31]
    eb0e:	761c      	strb	r4, [r3, #24]
    eb10:	765c      	strb	r4, [r3, #25]
    eb12:	769c      	strb	r4, [r3, #26]
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    eb14:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    eb16:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
    eb1a:	625a      	str	r2, [r3, #36]	; 0x24

static ALWAYS_INLINE void kernel_arch_init(void)
{
	z_InterruptStackSetup();
	z_ExcSetup();
	z_FaultInit();
    eb1c:	f7fb f92e 	bl	9d7c <z_FaultInit>
	z_CpuIdleInit();
    eb20:	f7fb f9a8 	bl	9e74 <z_CpuIdleInit>
	struct k_thread dummy_thread = {
    eb24:	ab07      	add	r3, sp, #28
    eb26:	4621      	mov	r1, r4
    eb28:	226c      	movs	r2, #108	; 0x6c
    eb2a:	4618      	mov	r0, r3
    eb2c:	f7f3 fb5d 	bl	21ea <memset>
    eb30:	2701      	movs	r7, #1
	_current = &dummy_thread;
    eb32:	60b0      	str	r0, [r6, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    eb34:	4620      	mov	r0, r4
	struct k_thread dummy_thread = {
    eb36:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    eb3a:	f7ff ff3d 	bl	e9b8 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    eb3e:	4638      	mov	r0, r7
    eb40:	f7ff ff3a 	bl	e9b8 <z_sys_device_do_config_level>
	z_sched_init();
    eb44:	f000 fc92 	bl	f46c <z_sched_init>
	z_setup_new_thread(_main_thread, _main_stack,
    eb48:	4b2a      	ldr	r3, [pc, #168]	; (ebf4 <z_cstart+0x10c>)
	_kernel.ready_q.cache = _main_thread;
    eb4a:	6275      	str	r5, [r6, #36]	; 0x24
	z_setup_new_thread(_main_thread, _main_stack,
    eb4c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    eb50:	e9cd 7304 	strd	r7, r3, [sp, #16]
    eb54:	e9cd 4402 	strd	r4, r4, [sp, #8]
    eb58:	e9cd 4400 	strd	r4, r4, [sp]
    eb5c:	4b26      	ldr	r3, [pc, #152]	; (ebf8 <z_cstart+0x110>)
    eb5e:	4927      	ldr	r1, [pc, #156]	; (ebfc <z_cstart+0x114>)
    eb60:	4628      	mov	r0, r5
    eb62:	f000 fdff 	bl	f764 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    eb66:	7b6b      	ldrb	r3, [r5, #13]
    eb68:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    eb6c:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
    eb70:	736a      	strb	r2, [r5, #13]
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
    eb72:	4634      	mov	r4, r6
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    eb74:	d104      	bne.n	eb80 <z_cstart+0x98>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
    eb76:	69ab      	ldr	r3, [r5, #24]
    eb78:	b913      	cbnz	r3, eb80 <z_cstart+0x98>
		z_add_thread_to_ready_q(thread);
    eb7a:	4628      	mov	r0, r5
    eb7c:	f000 fadc 	bl	f138 <z_add_thread_to_ready_q>
	z_setup_new_thread(thr, stack,
    eb80:	4b1f      	ldr	r3, [pc, #124]	; (ec00 <z_cstart+0x118>)
    eb82:	4e20      	ldr	r6, [pc, #128]	; (ec04 <z_cstart+0x11c>)
    eb84:	9305      	str	r3, [sp, #20]
    eb86:	2201      	movs	r2, #1
    eb88:	230f      	movs	r3, #15
    eb8a:	e9cd 3203 	strd	r3, r2, [sp, #12]
    eb8e:	2300      	movs	r3, #0
    eb90:	f44f 72a0 	mov.w	r2, #320	; 0x140
    eb94:	491c      	ldr	r1, [pc, #112]	; (ec08 <z_cstart+0x120>)
    eb96:	9300      	str	r3, [sp, #0]
    eb98:	4630      	mov	r0, r6
    eb9a:	e9cd 3301 	strd	r3, r3, [sp, #4]
    eb9e:	4b1b      	ldr	r3, [pc, #108]	; (ec0c <z_cstart+0x124>)
    eba0:	f000 fde0 	bl	f764 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    eba4:	7b73      	ldrb	r3, [r6, #13]
	_kernel.cpus[0].idle_thread = _idle_thread;
    eba6:	60e6      	str	r6, [r4, #12]
    eba8:	f023 0304 	bic.w	r3, r3, #4
    ebac:	7373      	strb	r3, [r6, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    ebae:	4b18      	ldr	r3, [pc, #96]	; (ec10 <z_cstart+0x128>)
	list->tail = (sys_dnode_t *)list;
    ebb0:	e9c4 3306 	strd	r3, r3, [r4, #24]
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arch_configure_static_mpu_regions();
    ebb4:	f7fb fa54 	bl	a060 <z_arch_configure_static_mpu_regions>
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arch_configure_dynamic_mpu_regions(main_thread);
    ebb8:	480d      	ldr	r0, [pc, #52]	; (ebf0 <z_cstart+0x108>)
	_current = main_thread;
    ebba:	60a5      	str	r5, [r4, #8]
	z_arch_configure_dynamic_mpu_regions(main_thread);
    ebbc:	f004 fa36 	bl	1302c <z_arch_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    ebc0:	4b0d      	ldr	r3, [pc, #52]	; (ebf8 <z_cstart+0x110>)
    ebc2:	4a14      	ldr	r2, [pc, #80]	; (ec14 <z_cstart+0x12c>)
    ebc4:	4618      	mov	r0, r3
    ebc6:	f382 8809 	msr	PSP, r2
    ebca:	b663      	cpsie	if
    ebcc:	f04f 0100 	mov.w	r1, #0
    ebd0:	f381 8811 	msr	BASEPRI, r1
    ebd4:	f3bf 8f6f 	isb	sy
    ebd8:	2100      	movs	r1, #0
    ebda:	2200      	movs	r2, #0
    ebdc:	2300      	movs	r3, #0
    ebde:	f002 ff85 	bl	11aec <z_thread_entry>
	"bl z_thread_entry \n\t"   /* z_thread_entry(_main, 0, 0, 0); */
	:
	: "r" (_main), "r" (start_of_main_stack)
	);

	CODE_UNREACHABLE;
    ebe2:	bf00      	nop
    ebe4:	20009e58 	.word	0x20009e58
    ebe8:	e000ed00 	.word	0xe000ed00
    ebec:	200055e4 	.word	0x200055e4
    ebf0:	20004520 	.word	0x20004520
    ebf4:	000191ad 	.word	0x000191ad
    ebf8:	0000eab9 	.word	0x0000eab9
    ebfc:	20007d18 	.word	0x20007d18
    ec00:	000191b2 	.word	0x000191b2
    ec04:	200044b4 	.word	0x200044b4
    ec08:	20008d18 	.word	0x20008d18
    ec0c:	0000ea3d 	.word	0x0000ea3d
    ec10:	200055fc 	.word	0x200055fc
    ec14:	20008d18 	.word	0x20008d18

0000ec18 <init_mem_slab_module>:
{
	ARG_UNUSED(dev);

	struct k_mem_slab *slab;

	for (slab = _k_mem_slab_list_start;
    ec18:	4b0b      	ldr	r3, [pc, #44]	; (ec48 <init_mem_slab_module+0x30>)
    ec1a:	480c      	ldr	r0, [pc, #48]	; (ec4c <init_mem_slab_module+0x34>)
{
    ec1c:	b570      	push	{r4, r5, r6, lr}
	slab->free_list = NULL;
    ec1e:	2400      	movs	r4, #0
	for (slab = _k_mem_slab_list_start;
    ec20:	4283      	cmp	r3, r0
    ec22:	d301      	bcc.n	ec28 <init_mem_slab_module+0x10>
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}
	return 0;
}
    ec24:	2000      	movs	r0, #0
    ec26:	bd70      	pop	{r4, r5, r6, pc}
	p = slab->buffer;
    ec28:	691a      	ldr	r2, [r3, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
    ec2a:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
    ec2c:	615c      	str	r4, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    ec2e:	2100      	movs	r1, #0
    ec30:	42a9      	cmp	r1, r5
    ec32:	d101      	bne.n	ec38 <init_mem_slab_module+0x20>
	     slab++) {
    ec34:	331c      	adds	r3, #28
    ec36:	e7f3      	b.n	ec20 <init_mem_slab_module+0x8>
		*(char **)p = slab->free_list;
    ec38:	695e      	ldr	r6, [r3, #20]
    ec3a:	6016      	str	r6, [r2, #0]
		p += slab->block_size;
    ec3c:	68de      	ldr	r6, [r3, #12]
		slab->free_list = p;
    ec3e:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    ec40:	3101      	adds	r1, #1
		p += slab->block_size;
    ec42:	4432      	add	r2, r6
    ec44:	e7f4      	b.n	ec30 <init_mem_slab_module+0x18>
    ec46:	bf00      	nop
    ec48:	20011d04 	.word	0x20011d04
    ec4c:	20011d3c 	.word	0x20011d3c

0000ec50 <k_mem_slab_alloc>:

	z_object_init(slab);
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
    ec50:	b510      	push	{r4, lr}
    ec52:	4613      	mov	r3, r2
    ec54:	460c      	mov	r4, r1
    ec56:	f04f 0220 	mov.w	r2, #32
    ec5a:	f3ef 8111 	mrs	r1, BASEPRI
    ec5e:	f382 8811 	msr	BASEPRI, r2
    ec62:	f3bf 8f6f 	isb	sy

	/* block size must be word aligned */
	__ASSERT((slab->block_size & (sizeof(void *) - 1)) == 0,
		 "block size not word aligned");

	if (slab->free_list != NULL) {
    ec66:	6942      	ldr	r2, [r0, #20]
    ec68:	b15a      	cbz	r2, ec82 <k_mem_slab_alloc+0x32>
		/* take a free block */
		*mem = slab->free_list;
    ec6a:	6022      	str	r2, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
    ec6c:	6813      	ldr	r3, [r2, #0]
    ec6e:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    ec70:	6983      	ldr	r3, [r0, #24]
    ec72:	3301      	adds	r3, #1
    ec74:	6183      	str	r3, [r0, #24]
		result = 0;
    ec76:	2000      	movs	r0, #0
	__asm__ volatile(
    ec78:	f381 8811 	msr	BASEPRI, r1
    ec7c:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
    ec80:	e00d      	b.n	ec9e <k_mem_slab_alloc+0x4e>
	} else if (timeout == K_NO_WAIT) {
    ec82:	b91b      	cbnz	r3, ec8c <k_mem_slab_alloc+0x3c>
		*mem = NULL;
    ec84:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
    ec86:	f06f 000b 	mvn.w	r0, #11
    ec8a:	e7f5      	b.n	ec78 <k_mem_slab_alloc+0x28>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
    ec8c:	4602      	mov	r2, r0
    ec8e:	4804      	ldr	r0, [pc, #16]	; (eca0 <k_mem_slab_alloc+0x50>)
    ec90:	f000 fb8c 	bl	f3ac <z_pend_curr>
		if (result == 0) {
    ec94:	b918      	cbnz	r0, ec9e <k_mem_slab_alloc+0x4e>
			*mem = _current->base.swap_data;
    ec96:	4b03      	ldr	r3, [pc, #12]	; (eca4 <k_mem_slab_alloc+0x54>)
    ec98:	689b      	ldr	r3, [r3, #8]
    ec9a:	695b      	ldr	r3, [r3, #20]
    ec9c:	6023      	str	r3, [r4, #0]
}
    ec9e:	bd10      	pop	{r4, pc}
    eca0:	2000687c 	.word	0x2000687c
    eca4:	200055e4 	.word	0x200055e4

0000eca8 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    eca8:	b570      	push	{r4, r5, r6, lr}
    ecaa:	4604      	mov	r4, r0
    ecac:	460d      	mov	r5, r1
	__asm__ volatile(
    ecae:	f04f 0320 	mov.w	r3, #32
    ecb2:	f3ef 8611 	mrs	r6, BASEPRI
    ecb6:	f383 8811 	msr	BASEPRI, r3
    ecba:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    ecbe:	f007 f82c 	bl	15d1a <z_unpend_first_thread>

	if (pending_thread != NULL) {
    ecc2:	b180      	cbz	r0, ece6 <k_mem_slab_free+0x3e>
		z_set_thread_return_value_with_data(pending_thread, 0, *mem);
    ecc4:	682a      	ldr	r2, [r5, #0]
	thread->base.swap_data = data;
    ecc6:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    ecc8:	7b42      	ldrb	r2, [r0, #13]
}

static ALWAYS_INLINE void
z_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    ecca:	2100      	movs	r1, #0
    eccc:	06d2      	lsls	r2, r2, #27
    ecce:	6681      	str	r1, [r0, #104]	; 0x68
    ecd0:	d103      	bne.n	ecda <k_mem_slab_free+0x32>
	if (z_is_thread_ready(thread)) {
    ecd2:	6983      	ldr	r3, [r0, #24]
    ecd4:	b90b      	cbnz	r3, ecda <k_mem_slab_free+0x32>
		z_add_thread_to_ready_q(thread);
    ecd6:	f000 fa2f 	bl	f138 <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
    ecda:	4631      	mov	r1, r6
    ecdc:	4808      	ldr	r0, [pc, #32]	; (ed00 <k_mem_slab_free+0x58>)
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
    ecde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
    ece2:	f006 bf9e 	b.w	15c22 <z_reschedule>
		**(char ***)mem = slab->free_list;
    ece6:	682b      	ldr	r3, [r5, #0]
    ece8:	6962      	ldr	r2, [r4, #20]
    ecea:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
    ecec:	682b      	ldr	r3, [r5, #0]
    ecee:	6163      	str	r3, [r4, #20]
		slab->num_used--;
    ecf0:	69a3      	ldr	r3, [r4, #24]
    ecf2:	3b01      	subs	r3, #1
    ecf4:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    ecf6:	f386 8811 	msr	BASEPRI, r6
    ecfa:	f3bf 8f6f 	isb	sy
}
    ecfe:	bd70      	pop	{r4, r5, r6, pc}
    ed00:	2000687c 	.word	0x2000687c

0000ed04 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
    ed04:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	struct k_mem_pool *p;

	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
    ed06:	4c07      	ldr	r4, [pc, #28]	; (ed24 <init_static_pools+0x20>)
    ed08:	4d07      	ldr	r5, [pc, #28]	; (ed28 <init_static_pools+0x24>)
    ed0a:	42ac      	cmp	r4, r5
    ed0c:	d301      	bcc.n	ed12 <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
    ed0e:	2000      	movs	r0, #0
    ed10:	bd38      	pop	{r3, r4, r5, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    ed12:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
    ed16:	4620      	mov	r0, r4
    ed18:	e9c4 3305 	strd	r3, r3, [r4, #20]
    ed1c:	f002 fd40 	bl	117a0 <z_sys_mem_pool_base_init>
	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
    ed20:	341c      	adds	r4, #28
    ed22:	e7f2      	b.n	ed0a <init_static_pools+0x6>
    ed24:	20011d3c 	.word	0x20011d3c
    ed28:	20011d90 	.word	0x20011d90

0000ed2c <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
    ed2c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	int ret;
	s64_t end = 0;

	__ASSERT(!(z_is_in_isr() && timeout != K_NO_WAIT), "");

	if (timeout > 0) {
    ed30:	1e1e      	subs	r6, r3, #0
{
    ed32:	4680      	mov	r8, r0
    ed34:	460c      	mov	r4, r1
    ed36:	4691      	mov	r9, r2
	if (timeout > 0) {
    ed38:	dd54      	ble.n	ede4 <k_mem_pool_alloc+0xb8>
		end = z_tick_get() + z_ms_to_ticks(timeout);
    ed3a:	f000 ff3b 	bl	fbb4 <z_tick_get>
    ed3e:	4605      	mov	r5, r0
	return (s32_t)ceiling_fraction(
    ed40:	4829      	ldr	r0, [pc, #164]	; (ede8 <k_mem_pool_alloc+0xbc>)
    ed42:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    ed46:	2100      	movs	r1, #0
    ed48:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    ed4c:	2300      	movs	r3, #0
    ed4e:	fbc7 0106 	smlal	r0, r1, r7, r6
    ed52:	f7f1 fca9 	bl	6a8 <__aeabi_ldivmod>
    ed56:	1945      	adds	r5, r0, r5
	return pool - &_k_mem_pool_list_start[0];
    ed58:	4b24      	ldr	r3, [pc, #144]	; (edec <k_mem_pool_alloc+0xc0>)
    ed5a:	4f25      	ldr	r7, [pc, #148]	; (edf0 <k_mem_pool_alloc+0xc4>)
    ed5c:	eba8 0303 	sub.w	r3, r8, r3
    ed60:	109b      	asrs	r3, r3, #2
    ed62:	435f      	muls	r7, r3

		if (ret == -EAGAIN) {
			ret = -ENOMEM;
		}

		block->id.pool = pool_id(p);
    ed64:	b2ff      	uxtb	r7, r7
		if (ret == 0 || timeout == K_NO_WAIT ||
		    ret != -ENOMEM) {
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
    ed66:	f108 0a14 	add.w	sl, r8, #20
			ret = z_sys_mem_pool_block_alloc(&p->base, size,
    ed6a:	9400      	str	r4, [sp, #0]
    ed6c:	ab03      	add	r3, sp, #12
    ed6e:	aa02      	add	r2, sp, #8
    ed70:	4649      	mov	r1, r9
    ed72:	4640      	mov	r0, r8
    ed74:	f002 fd5e 	bl	11834 <z_sys_mem_pool_block_alloc>
			if (ret != -EAGAIN) {
    ed78:	f110 0f0b 	cmn.w	r0, #11
    ed7c:	d10b      	bne.n	ed96 <k_mem_pool_alloc+0x6a>
			ret = z_sys_mem_pool_block_alloc(&p->base, size,
    ed7e:	9400      	str	r4, [sp, #0]
    ed80:	ab03      	add	r3, sp, #12
    ed82:	aa02      	add	r2, sp, #8
    ed84:	4649      	mov	r1, r9
    ed86:	4640      	mov	r0, r8
    ed88:	f002 fd54 	bl	11834 <z_sys_mem_pool_block_alloc>
			ret = -ENOMEM;
    ed8c:	f110 0f0b 	cmn.w	r0, #11
    ed90:	bf08      	it	eq
    ed92:	f06f 000b 	mvneq.w	r0, #11
		block->id.level = level_num;
    ed96:	7963      	ldrb	r3, [r4, #5]
    ed98:	9a02      	ldr	r2, [sp, #8]
		block->id.pool = pool_id(p);
    ed9a:	7127      	strb	r7, [r4, #4]
		block->id.level = level_num;
    ed9c:	f362 0303 	bfi	r3, r2, #0, #4
    eda0:	7163      	strb	r3, [r4, #5]
		block->id.block = block_num;
    eda2:	6863      	ldr	r3, [r4, #4]
    eda4:	9a03      	ldr	r2, [sp, #12]
    eda6:	f362 331f 	bfi	r3, r2, #12, #20
    edaa:	6063      	str	r3, [r4, #4]
		if (ret == 0 || timeout == K_NO_WAIT ||
    edac:	b1b8      	cbz	r0, edde <k_mem_pool_alloc+0xb2>
    edae:	b1b6      	cbz	r6, edde <k_mem_pool_alloc+0xb2>
    edb0:	f110 0f0c 	cmn.w	r0, #12
    edb4:	d113      	bne.n	edde <k_mem_pool_alloc+0xb2>
	__asm__ volatile(
    edb6:	f04f 0320 	mov.w	r3, #32
    edba:	f3ef 8011 	mrs	r0, BASEPRI
    edbe:	f383 8811 	msr	BASEPRI, r3
    edc2:	f3bf 8f6f 	isb	sy
	(void) z_pend_curr_irqlock(z_arch_irq_lock(), wait_q, timeout);
    edc6:	4632      	mov	r2, r6
    edc8:	4651      	mov	r1, sl
    edca:	f000 facb 	bl	f364 <z_pend_curr_irqlock>

		if (timeout != K_FOREVER) {
    edce:	1c73      	adds	r3, r6, #1
    edd0:	d0cb      	beq.n	ed6a <k_mem_pool_alloc+0x3e>
			timeout = end - z_tick_get();
    edd2:	f000 feef 	bl	fbb4 <z_tick_get>

			if (timeout < 0) {
    edd6:	1a2e      	subs	r6, r5, r0
    edd8:	d5c7      	bpl.n	ed6a <k_mem_pool_alloc+0x3e>
				break;
			}
		}
	}

	return -EAGAIN;
    edda:	f06f 000a 	mvn.w	r0, #10
}
    edde:	b004      	add	sp, #16
    ede0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	s64_t end = 0;
    ede4:	2500      	movs	r5, #0
    ede6:	e7b7      	b.n	ed58 <k_mem_pool_alloc+0x2c>
    ede8:	0004ffff 	.word	0x0004ffff
    edec:	20011d3c 	.word	0x20011d3c
    edf0:	b6db6db7 	.word	0xb6db6db7

0000edf4 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
    edf4:	b570      	push	{r4, r5, r6, lr}
    edf6:	7804      	ldrb	r4, [r0, #0]
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
    edf8:	6802      	ldr	r2, [r0, #0]
    edfa:	7841      	ldrb	r1, [r0, #1]
    edfc:	4e11      	ldr	r6, [pc, #68]	; (ee44 <k_mem_pool_free_id+0x50>)
    edfe:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    ee02:	00a4      	lsls	r4, r4, #2
    ee04:	0b12      	lsrs	r2, r2, #12
    ee06:	f001 010f 	and.w	r1, r1, #15
    ee0a:	1930      	adds	r0, r6, r4
    ee0c:	f002 fdce 	bl	119ac <z_sys_mem_pool_block_free>
    ee10:	f04f 0320 	mov.w	r3, #32
    ee14:	f3ef 8511 	mrs	r5, BASEPRI
    ee18:	f383 8811 	msr	BASEPRI, r3
    ee1c:	f3bf 8f6f 	isb	sy
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
    ee20:	f104 0014 	add.w	r0, r4, #20
    ee24:	4430      	add	r0, r6
    ee26:	f006 ffa5 	bl	15d74 <z_unpend_all>

	if (need_sched != 0) {
    ee2a:	b128      	cbz	r0, ee38 <k_mem_pool_free_id+0x44>
		z_reschedule(&lock, key);
    ee2c:	4629      	mov	r1, r5
    ee2e:	4806      	ldr	r0, [pc, #24]	; (ee48 <k_mem_pool_free_id+0x54>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
    ee30:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
    ee34:	f006 bef5 	b.w	15c22 <z_reschedule>
	__asm__ volatile(
    ee38:	f385 8811 	msr	BASEPRI, r5
    ee3c:	f3bf 8f6f 	isb	sy
}
    ee40:	bd70      	pop	{r4, r5, r6, pc}
    ee42:	bf00      	nop
    ee44:	20011d3c 	.word	0x20011d3c
    ee48:	2000687c 	.word	0x2000687c

0000ee4c <k_malloc>:
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
    ee4c:	4601      	mov	r1, r0
    ee4e:	4801      	ldr	r0, [pc, #4]	; (ee54 <k_malloc+0x8>)
    ee50:	f006 bda3 	b.w	1599a <k_mem_pool_malloc>
    ee54:	20011d74 	.word	0x20011d74

0000ee58 <z_thread_malloc>:

void *z_thread_malloc(size_t size)
{
	void *ret;

	if (_current->resource_pool != NULL) {
    ee58:	4b03      	ldr	r3, [pc, #12]	; (ee68 <z_thread_malloc+0x10>)
    ee5a:	689b      	ldr	r3, [r3, #8]
{
    ee5c:	4601      	mov	r1, r0
	if (_current->resource_pool != NULL) {
    ee5e:	6e18      	ldr	r0, [r3, #96]	; 0x60
    ee60:	b108      	cbz	r0, ee66 <z_thread_malloc+0xe>
		ret = k_mem_pool_malloc(_current->resource_pool, size);
    ee62:	f006 bd9a 	b.w	1599a <k_mem_pool_malloc>
	} else {
		ret = NULL;
	}

	return ret;
}
    ee66:	4770      	bx	lr
    ee68:	200055e4 	.word	0x200055e4

0000ee6c <z_impl_k_mutex_lock>:
		z_thread_priority_set(mutex->owner, new_prio);
	}
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
    ee6c:	b570      	push	{r4, r5, r6, lr}
    ee6e:	460d      	mov	r5, r1
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!z_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
    ee70:	4934      	ldr	r1, [pc, #208]	; (ef44 <z_impl_k_mutex_lock+0xd8>)
    ee72:	688b      	ldr	r3, [r1, #8]
    ee74:	7bda      	ldrb	r2, [r3, #15]
    ee76:	3a01      	subs	r2, #1
    ee78:	4604      	mov	r4, r0
    ee7a:	73da      	strb	r2, [r3, #15]
	k_spinlock_key_t key;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	z_sched_lock();

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    ee7c:	68c2      	ldr	r2, [r0, #12]
    ee7e:	4608      	mov	r0, r1
    ee80:	b14a      	cbz	r2, ee96 <z_impl_k_mutex_lock+0x2a>
    ee82:	68a3      	ldr	r3, [r4, #8]
    ee84:	6889      	ldr	r1, [r1, #8]
    ee86:	428b      	cmp	r3, r1
    ee88:	d012      	beq.n	eeb0 <z_impl_k_mutex_lock+0x44>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
    ee8a:	b99d      	cbnz	r5, eeb4 <z_impl_k_mutex_lock+0x48>
		k_sched_unlock();
    ee8c:	f000 f938 	bl	f100 <k_sched_unlock>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
    ee90:	f06f 050f 	mvn.w	r5, #15
    ee94:	e00a      	b.n	eeac <z_impl_k_mutex_lock+0x40>
					_current->base.prio :
    ee96:	688b      	ldr	r3, [r1, #8]
    ee98:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    ee9c:	6123      	str	r3, [r4, #16]
		mutex->lock_count++;
    ee9e:	3201      	adds	r2, #1
		mutex->owner = _current;
    eea0:	6883      	ldr	r3, [r0, #8]
		mutex->lock_count++;
    eea2:	60e2      	str	r2, [r4, #12]
		mutex->owner = _current;
    eea4:	60a3      	str	r3, [r4, #8]
		k_sched_unlock();
    eea6:	f000 f92b 	bl	f100 <k_sched_unlock>
		return 0;
    eeaa:	2500      	movs	r5, #0

	k_sched_unlock();

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
    eeac:	4628      	mov	r0, r5
    eeae:	bd70      	pop	{r4, r5, r6, pc}
					_current->base.prio :
    eeb0:	6923      	ldr	r3, [r4, #16]
    eeb2:	e7f3      	b.n	ee9c <z_impl_k_mutex_lock+0x30>
	new_prio = new_prio_for_inheritance(_current->base.prio,
    eeb4:	f991 100e 	ldrsb.w	r1, [r1, #14]
    eeb8:	f993 300e 	ldrsb.w	r3, [r3, #14]
    eebc:	4299      	cmp	r1, r3
    eebe:	bfa8      	it	ge
    eec0:	4619      	movge	r1, r3
    eec2:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	__asm__ volatile(
    eec6:	f04f 0320 	mov.w	r3, #32
    eeca:	f3ef 8611 	mrs	r6, BASEPRI
    eece:	f383 8811 	msr	BASEPRI, r3
    eed2:	f3bf 8f6f 	isb	sy
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    eed6:	68a0      	ldr	r0, [r4, #8]
    eed8:	f990 300e 	ldrsb.w	r3, [r0, #14]
    eedc:	4299      	cmp	r1, r3
    eede:	da01      	bge.n	eee4 <z_impl_k_mutex_lock+0x78>
		z_thread_priority_set(mutex->owner, new_prio);
    eee0:	f000 fa78 	bl	f3d4 <z_thread_priority_set>
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    eee4:	462b      	mov	r3, r5
    eee6:	4622      	mov	r2, r4
    eee8:	4631      	mov	r1, r6
    eeea:	4817      	ldr	r0, [pc, #92]	; (ef48 <z_impl_k_mutex_lock+0xdc>)
    eeec:	f000 fa5e 	bl	f3ac <z_pend_curr>
	if (got_mutex == 0) {
    eef0:	4605      	mov	r5, r0
    eef2:	b910      	cbnz	r0, eefa <z_impl_k_mutex_lock+0x8e>
		k_sched_unlock();
    eef4:	f000 f904 	bl	f100 <k_sched_unlock>
		return 0;
    eef8:	e7d8      	b.n	eeac <z_impl_k_mutex_lock+0x40>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    eefa:	6823      	ldr	r3, [r4, #0]
    eefc:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    eefe:	429c      	cmp	r4, r3
    ef00:	d007      	beq.n	ef12 <z_impl_k_mutex_lock+0xa6>
		new_prio_for_inheritance(waiter->base.prio, new_prio) :
    ef02:	b133      	cbz	r3, ef12 <z_impl_k_mutex_lock+0xa6>
    ef04:	f993 300e 	ldrsb.w	r3, [r3, #14]
    ef08:	4299      	cmp	r1, r3
    ef0a:	bfa8      	it	ge
    ef0c:	4619      	movge	r1, r3
    ef0e:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
    ef12:	f04f 0320 	mov.w	r3, #32
    ef16:	f3ef 8511 	mrs	r5, BASEPRI
    ef1a:	f383 8811 	msr	BASEPRI, r3
    ef1e:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, new_prio);
    ef22:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
    ef24:	f990 300e 	ldrsb.w	r3, [r0, #14]
    ef28:	4299      	cmp	r1, r3
    ef2a:	d001      	beq.n	ef30 <z_impl_k_mutex_lock+0xc4>
		z_thread_priority_set(mutex->owner, new_prio);
    ef2c:	f000 fa52 	bl	f3d4 <z_thread_priority_set>
	__asm__ volatile(
    ef30:	f385 8811 	msr	BASEPRI, r5
    ef34:	f3bf 8f6f 	isb	sy
	k_sched_unlock();
    ef38:	f000 f8e2 	bl	f100 <k_sched_unlock>
	return -EAGAIN;
    ef3c:	f06f 050a 	mvn.w	r5, #10
    ef40:	e7b4      	b.n	eeac <z_impl_k_mutex_lock+0x40>
    ef42:	bf00      	nop
    ef44:	200055e4 	.word	0x200055e4
    ef48:	2000687c 	.word	0x2000687c

0000ef4c <z_impl_k_mutex_unlock>:
    ef4c:	4b1e      	ldr	r3, [pc, #120]	; (efc8 <z_impl_k_mutex_unlock+0x7c>)
    ef4e:	689a      	ldr	r2, [r3, #8]
    ef50:	7bd3      	ldrb	r3, [r2, #15]
    ef52:	3b01      	subs	r3, #1
	return z_impl_k_mutex_lock((struct k_mutex *)mutex, (s32_t)timeout);
}
#endif

void z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    ef54:	b570      	push	{r4, r5, r6, lr}
    ef56:	4604      	mov	r4, r0
    ef58:	73d3      	strb	r3, [r2, #15]
	sys_trace_void(SYS_TRACE_ID_MUTEX_UNLOCK);
	z_sched_lock();

	K_DEBUG("mutex %p lock_count: %d\n", mutex, mutex->lock_count);

	if (mutex->lock_count - 1U != 0U) {
    ef5a:	68c3      	ldr	r3, [r0, #12]
    ef5c:	2b01      	cmp	r3, #1
    ef5e:	d005      	beq.n	ef6c <z_impl_k_mutex_unlock+0x20>
		mutex->lock_count--;
    ef60:	3b01      	subs	r3, #1
    ef62:	60c3      	str	r3, [r0, #12]
	}


k_mutex_unlock_return:
	k_sched_unlock();
}
    ef64:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_sched_unlock();
    ef68:	f000 b8ca 	b.w	f100 <k_sched_unlock>
	__asm__ volatile(
    ef6c:	f04f 0320 	mov.w	r3, #32
    ef70:	f3ef 8611 	mrs	r6, BASEPRI
    ef74:	f383 8811 	msr	BASEPRI, r3
    ef78:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    ef7c:	6901      	ldr	r1, [r0, #16]
    ef7e:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
    ef80:	f990 300e 	ldrsb.w	r3, [r0, #14]
    ef84:	4299      	cmp	r1, r3
    ef86:	d001      	beq.n	ef8c <z_impl_k_mutex_unlock+0x40>
		z_thread_priority_set(mutex->owner, new_prio);
    ef88:	f000 fa24 	bl	f3d4 <z_thread_priority_set>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    ef8c:	4620      	mov	r0, r4
    ef8e:	f006 fec4 	bl	15d1a <z_unpend_first_thread>
    ef92:	4605      	mov	r5, r0
	mutex->owner = new_owner;
    ef94:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
    ef96:	b180      	cbz	r0, efba <z_impl_k_mutex_unlock+0x6e>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    ef98:	7b43      	ldrb	r3, [r0, #13]
    ef9a:	06db      	lsls	r3, r3, #27
    ef9c:	d103      	bne.n	efa6 <z_impl_k_mutex_unlock+0x5a>
	if (z_is_thread_ready(thread)) {
    ef9e:	6983      	ldr	r3, [r0, #24]
    efa0:	b90b      	cbnz	r3, efa6 <z_impl_k_mutex_unlock+0x5a>
		z_add_thread_to_ready_q(thread);
    efa2:	f000 f8c9 	bl	f138 <z_add_thread_to_ready_q>
	__asm__ volatile(
    efa6:	f386 8811 	msr	BASEPRI, r6
    efaa:	f3bf 8f6f 	isb	sy
    efae:	2300      	movs	r3, #0
    efb0:	66ab      	str	r3, [r5, #104]	; 0x68
		mutex->owner_orig_prio = new_owner->base.prio;
    efb2:	f995 300e 	ldrsb.w	r3, [r5, #14]
    efb6:	6123      	str	r3, [r4, #16]
    efb8:	e7d4      	b.n	ef64 <z_impl_k_mutex_unlock+0x18>
		mutex->lock_count = 0U;
    efba:	60e0      	str	r0, [r4, #12]
    efbc:	f386 8811 	msr	BASEPRI, r6
    efc0:	f3bf 8f6f 	isb	sy
    efc4:	e7ce      	b.n	ef64 <z_impl_k_mutex_unlock+0x18>
    efc6:	bf00      	nop
    efc8:	200055e4 	.word	0x200055e4

0000efcc <resched>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    efcc:	f3ef 8005 	mrs	r0, IPSR
		|| (vector && !(SCB->ICSR & SCB_ICSR_RETTOBASE_Msk))
    efd0:	280d      	cmp	r0, #13
    efd2:	d809      	bhi.n	efe8 <resched+0x1c>
    efd4:	b128      	cbz	r0, efe2 <resched+0x16>
    efd6:	4b05      	ldr	r3, [pc, #20]	; (efec <resched+0x20>)
    efd8:	6858      	ldr	r0, [r3, #4]
    efda:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
    efde:	f3c0 20c0 	ubfx	r0, r0, #11, #1
	}
	_current_cpu->swap_ok = 0;
#endif

	return !z_is_in_isr();
}
    efe2:	f080 0001 	eor.w	r0, r0, #1
    efe6:	4770      	bx	lr
    efe8:	2001      	movs	r0, #1
    efea:	e7fa      	b.n	efe2 <resched+0x16>
    efec:	e000ed00 	.word	0xe000ed00

0000eff0 <reset_time_slice>:
{
    eff0:	b508      	push	{r3, lr}
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    eff2:	f7fa fcd1 	bl	9998 <z_clock_elapsed>
    eff6:	4b05      	ldr	r3, [pc, #20]	; (f00c <reset_time_slice+0x1c>)
    eff8:	4a05      	ldr	r2, [pc, #20]	; (f010 <reset_time_slice+0x20>)
    effa:	681b      	ldr	r3, [r3, #0]
    effc:	4418      	add	r0, r3
    effe:	6110      	str	r0, [r2, #16]
	z_set_timeout_expiry(slice_time, false);
    f000:	2100      	movs	r1, #0
    f002:	4618      	mov	r0, r3
}
    f004:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_set_timeout_expiry(slice_time, false);
    f008:	f006 bfa8 	b.w	15f5c <z_set_timeout_expiry>
    f00c:	2000561c 	.word	0x2000561c
    f010:	200055e4 	.word	0x200055e4

0000f014 <k_sched_time_slice_set>:
{
    f014:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f016:	460d      	mov	r5, r1
	__asm__ volatile(
    f018:	f04f 0320 	mov.w	r3, #32
    f01c:	f3ef 8411 	mrs	r4, BASEPRI
    f020:	f383 8811 	msr	BASEPRI, r3
    f024:	f3bf 8f6f 	isb	sy
    f028:	4e0d      	ldr	r6, [pc, #52]	; (f060 <k_sched_time_slice_set+0x4c>)
		_current_cpu->slice_ticks = 0;
    f02a:	4b0e      	ldr	r3, [pc, #56]	; (f064 <k_sched_time_slice_set+0x50>)
    f02c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    f030:	2700      	movs	r7, #0
    f032:	fbc1 6700 	smlal	r6, r7, r1, r0
    f036:	2200      	movs	r2, #0
    f038:	611a      	str	r2, [r3, #16]
    f03a:	4630      	mov	r0, r6
    f03c:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    f040:	2300      	movs	r3, #0
    f042:	4639      	mov	r1, r7
    f044:	f7f1 fb30 	bl	6a8 <__aeabi_ldivmod>
    f048:	4b07      	ldr	r3, [pc, #28]	; (f068 <k_sched_time_slice_set+0x54>)
    f04a:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
    f04c:	4b07      	ldr	r3, [pc, #28]	; (f06c <k_sched_time_slice_set+0x58>)
    f04e:	601d      	str	r5, [r3, #0]
		reset_time_slice();
    f050:	f7ff ffce 	bl	eff0 <reset_time_slice>
	__asm__ volatile(
    f054:	f384 8811 	msr	BASEPRI, r4
    f058:	f3bf 8f6f 	isb	sy
}
    f05c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f05e:	bf00      	nop
    f060:	0004ffff 	.word	0x0004ffff
    f064:	200055e4 	.word	0x200055e4
    f068:	2000561c 	.word	0x2000561c
    f06c:	20005618 	.word	0x20005618

0000f070 <k_sched_lock>:
	__asm__ volatile(
    f070:	f04f 0320 	mov.w	r3, #32
    f074:	f3ef 8111 	mrs	r1, BASEPRI
    f078:	f383 8811 	msr	BASEPRI, r3
    f07c:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
    f080:	4b04      	ldr	r3, [pc, #16]	; (f094 <k_sched_lock+0x24>)
    f082:	689a      	ldr	r2, [r3, #8]
    f084:	7bd3      	ldrb	r3, [r2, #15]
    f086:	3b01      	subs	r3, #1
    f088:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    f08a:	f381 8811 	msr	BASEPRI, r1
    f08e:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    f092:	4770      	bx	lr
    f094:	200055e4 	.word	0x200055e4

0000f098 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    f098:	4b09      	ldr	r3, [pc, #36]	; (f0c0 <z_priq_dumb_remove+0x28>)
    f09a:	f103 0228 	add.w	r2, r3, #40	; 0x28
    f09e:	4282      	cmp	r2, r0
    f0a0:	d105      	bne.n	f0ae <z_priq_dumb_remove+0x16>
    f0a2:	689b      	ldr	r3, [r3, #8]
    f0a4:	428b      	cmp	r3, r1
    f0a6:	d102      	bne.n	f0ae <z_priq_dumb_remove+0x16>
    f0a8:	7b4b      	ldrb	r3, [r1, #13]
    f0aa:	06db      	lsls	r3, r3, #27
    f0ac:	d106      	bne.n	f0bc <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    f0ae:	e9d1 3200 	ldrd	r3, r2, [r1]
    f0b2:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    f0b4:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    f0b6:	2300      	movs	r3, #0
	node->prev = NULL;
    f0b8:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!is_idle(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    f0bc:	4770      	bx	lr
    f0be:	bf00      	nop
    f0c0:	200055e4 	.word	0x200055e4

0000f0c4 <update_cache>:
{
    f0c4:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
    f0c6:	4c0d      	ldr	r4, [pc, #52]	; (f0fc <update_cache+0x38>)
{
    f0c8:	4602      	mov	r2, r0
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
    f0ca:	f104 0028 	add.w	r0, r4, #40	; 0x28
    f0ce:	f006 fded 	bl	15cac <z_priq_dumb_best>
	return th ? th : _current_cpu->idle_thread;
    f0d2:	4605      	mov	r5, r0
    f0d4:	b900      	cbnz	r0, f0d8 <update_cache+0x14>
    f0d6:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
    f0d8:	68a3      	ldr	r3, [r4, #8]
    f0da:	b94a      	cbnz	r2, f0f0 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
    f0dc:	7b5a      	ldrb	r2, [r3, #13]
    f0de:	06d2      	lsls	r2, r2, #27
    f0e0:	d106      	bne.n	f0f0 <update_cache+0x2c>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    f0e2:	69aa      	ldr	r2, [r5, #24]
    f0e4:	b922      	cbnz	r2, f0f0 <update_cache+0x2c>
	if (is_preempt(_current) || is_metairq(th)) {
    f0e6:	89da      	ldrh	r2, [r3, #14]
    f0e8:	2a7f      	cmp	r2, #127	; 0x7f
    f0ea:	d901      	bls.n	f0f0 <update_cache+0x2c>
		_kernel.ready_q.cache = _current;
    f0ec:	6263      	str	r3, [r4, #36]	; 0x24
}
    f0ee:	bd38      	pop	{r3, r4, r5, pc}
		if (th != _current) {
    f0f0:	429d      	cmp	r5, r3
    f0f2:	d001      	beq.n	f0f8 <update_cache+0x34>
			reset_time_slice();
    f0f4:	f7ff ff7c 	bl	eff0 <reset_time_slice>
		_kernel.ready_q.cache = th;
    f0f8:	6265      	str	r5, [r4, #36]	; 0x24
}
    f0fa:	e7f8      	b.n	f0ee <update_cache+0x2a>
    f0fc:	200055e4 	.word	0x200055e4

0000f100 <k_sched_unlock>:
{
    f100:	b510      	push	{r4, lr}
	__asm__ volatile(
    f102:	f04f 0320 	mov.w	r3, #32
    f106:	f3ef 8411 	mrs	r4, BASEPRI
    f10a:	f383 8811 	msr	BASEPRI, r3
    f10e:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
    f112:	4b08      	ldr	r3, [pc, #32]	; (f134 <k_sched_unlock+0x34>)
    f114:	689a      	ldr	r2, [r3, #8]
    f116:	7bd3      	ldrb	r3, [r2, #15]
    f118:	3301      	adds	r3, #1
    f11a:	73d3      	strb	r3, [r2, #15]
		update_cache(1);
    f11c:	2001      	movs	r0, #1
    f11e:	f7ff ffd1 	bl	f0c4 <update_cache>
	__asm__ volatile(
    f122:	f384 8811 	msr	BASEPRI, r4
    f126:	f3bf 8f6f 	isb	sy
}
    f12a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
    f12e:	f006 bd95 	b.w	15c5c <z_reschedule_unlocked>
    f132:	bf00      	nop
    f134:	200055e4 	.word	0x200055e4

0000f138 <z_add_thread_to_ready_q>:
{
    f138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    f13a:	f04f 0320 	mov.w	r3, #32
    f13e:	f3ef 8411 	mrs	r4, BASEPRI
    f142:	f383 8811 	msr	BASEPRI, r3
    f146:	f3bf 8f6f 	isb	sy
	return list->head == list;
    f14a:	4a15      	ldr	r2, [pc, #84]	; (f1a0 <z_add_thread_to_ready_q+0x68>)
    f14c:	4611      	mov	r1, r2
    f14e:	f851 3f28 	ldr.w	r3, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f152:	428b      	cmp	r3, r1
    f154:	d01d      	beq.n	f192 <z_add_thread_to_ready_q+0x5a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f156:	b1e3      	cbz	r3, f192 <z_add_thread_to_ready_q+0x5a>
    f158:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
    f15a:	f990 500e 	ldrsb.w	r5, [r0, #14]
    f15e:	f993 700e 	ldrsb.w	r7, [r3, #14]
    f162:	42af      	cmp	r7, r5
    f164:	dd10      	ble.n	f188 <z_add_thread_to_ready_q+0x50>
	node->prev = successor->prev;
    f166:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    f168:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
    f16c:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    f16e:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
    f170:	7b43      	ldrb	r3, [r0, #13]
    f172:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    f176:	7343      	strb	r3, [r0, #13]
		update_cache(0);
    f178:	2000      	movs	r0, #0
    f17a:	f7ff ffa3 	bl	f0c4 <update_cache>
	__asm__ volatile(
    f17e:	f384 8811 	msr	BASEPRI, r4
    f182:	f3bf 8f6f 	isb	sy
}
    f186:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    f188:	42b3      	cmp	r3, r6
    f18a:	d002      	beq.n	f192 <z_add_thread_to_ready_q+0x5a>
    f18c:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f18e:	2b00      	cmp	r3, #0
    f190:	d1e5      	bne.n	f15e <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
    f192:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    f194:	6043      	str	r3, [r0, #4]
	list->tail->next = node;
    f196:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
    f198:	6001      	str	r1, [r0, #0]
	list->tail->next = node;
    f19a:	6018      	str	r0, [r3, #0]
	list->tail = node;
    f19c:	62d0      	str	r0, [r2, #44]	; 0x2c
    f19e:	e7e7      	b.n	f170 <z_add_thread_to_ready_q+0x38>
    f1a0:	200055e4 	.word	0x200055e4

0000f1a4 <z_move_thread_to_end_of_prio_q>:
{
    f1a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f1a6:	4604      	mov	r4, r0
	__asm__ volatile(
    f1a8:	f04f 0320 	mov.w	r3, #32
    f1ac:	f3ef 8711 	mrs	r7, BASEPRI
    f1b0:	f383 8811 	msr	BASEPRI, r3
    f1b4:	f3bf 8f6f 	isb	sy
		_priq_run_remove(&_kernel.ready_q.runq, thread);
    f1b8:	4d19      	ldr	r5, [pc, #100]	; (f220 <z_move_thread_to_end_of_prio_q+0x7c>)
    f1ba:	f105 0628 	add.w	r6, r5, #40	; 0x28
    f1be:	4601      	mov	r1, r0
    f1c0:	4630      	mov	r0, r6
    f1c2:	f7ff ff69 	bl	f098 <z_priq_dumb_remove>
	return list->head == list;
    f1c6:	6aab      	ldr	r3, [r5, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f1c8:	42b3      	cmp	r3, r6
    f1ca:	462a      	mov	r2, r5
    f1cc:	d020      	beq.n	f210 <z_move_thread_to_end_of_prio_q+0x6c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f1ce:	b1fb      	cbz	r3, f210 <z_move_thread_to_end_of_prio_q+0x6c>
    f1d0:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
    f1d2:	f994 100e 	ldrsb.w	r1, [r4, #14]
    f1d6:	f993 500e 	ldrsb.w	r5, [r3, #14]
    f1da:	428d      	cmp	r5, r1
    f1dc:	dd13      	ble.n	f206 <z_move_thread_to_end_of_prio_q+0x62>
	node->prev = successor->prev;
    f1de:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
    f1e0:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
    f1e4:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    f1e6:	605c      	str	r4, [r3, #4]
    f1e8:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
    f1ea:	6890      	ldr	r0, [r2, #8]
    f1ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    f1f0:	7363      	strb	r3, [r4, #13]
    f1f2:	1b03      	subs	r3, r0, r4
    f1f4:	4258      	negs	r0, r3
    f1f6:	4158      	adcs	r0, r3
    f1f8:	f7ff ff64 	bl	f0c4 <update_cache>
	__asm__ volatile(
    f1fc:	f387 8811 	msr	BASEPRI, r7
    f200:	f3bf 8f6f 	isb	sy
}
    f204:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    f206:	4283      	cmp	r3, r0
    f208:	d002      	beq.n	f210 <z_move_thread_to_end_of_prio_q+0x6c>
    f20a:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f20c:	2b00      	cmp	r3, #0
    f20e:	d1e2      	bne.n	f1d6 <z_move_thread_to_end_of_prio_q+0x32>
	node->prev = list->tail;
    f210:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    f212:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    f214:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
    f216:	6026      	str	r6, [r4, #0]
	list->tail->next = node;
    f218:	601c      	str	r4, [r3, #0]
	list->tail = node;
    f21a:	62d4      	str	r4, [r2, #44]	; 0x2c
    f21c:	e7e4      	b.n	f1e8 <z_move_thread_to_end_of_prio_q+0x44>
    f21e:	bf00      	nop
    f220:	200055e4 	.word	0x200055e4

0000f224 <z_time_slice>:
	if (pending_current == _current) {
    f224:	4a16      	ldr	r2, [pc, #88]	; (f280 <z_time_slice+0x5c>)
    f226:	4917      	ldr	r1, [pc, #92]	; (f284 <z_time_slice+0x60>)
{
    f228:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
    f22a:	680c      	ldr	r4, [r1, #0]
    f22c:	6893      	ldr	r3, [r2, #8]
    f22e:	42a3      	cmp	r3, r4
    f230:	4614      	mov	r4, r2
    f232:	d103      	bne.n	f23c <z_time_slice+0x18>
}
    f234:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			reset_time_slice();
    f238:	f7ff beda 	b.w	eff0 <reset_time_slice>
	pending_current = NULL;
    f23c:	2500      	movs	r5, #0
    f23e:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
    f240:	4911      	ldr	r1, [pc, #68]	; (f288 <z_time_slice+0x64>)
    f242:	6809      	ldr	r1, [r1, #0]
    f244:	b1c1      	cbz	r1, f278 <z_time_slice+0x54>
		&& !z_is_thread_timeout_active(t);
    f246:	89d9      	ldrh	r1, [r3, #14]
    f248:	297f      	cmp	r1, #127	; 0x7f
    f24a:	d815      	bhi.n	f278 <z_time_slice+0x54>
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
    f24c:	490f      	ldr	r1, [pc, #60]	; (f28c <z_time_slice+0x68>)
    f24e:	f993 500e 	ldrsb.w	r5, [r3, #14]
    f252:	6809      	ldr	r1, [r1, #0]
    f254:	428d      	cmp	r5, r1
    f256:	db0f      	blt.n	f278 <z_time_slice+0x54>
	return thread == _idle_thread;
    f258:	490d      	ldr	r1, [pc, #52]	; (f290 <z_time_slice+0x6c>)
		&& !is_idle(t)
    f25a:	6809      	ldr	r1, [r1, #0]
    f25c:	428b      	cmp	r3, r1
    f25e:	d00b      	beq.n	f278 <z_time_slice+0x54>
		&& !z_is_thread_timeout_active(t);
    f260:	6999      	ldr	r1, [r3, #24]
    f262:	b949      	cbnz	r1, f278 <z_time_slice+0x54>
		if (ticks >= _current_cpu->slice_ticks) {
    f264:	6911      	ldr	r1, [r2, #16]
    f266:	4281      	cmp	r1, r0
    f268:	dc03      	bgt.n	f272 <z_time_slice+0x4e>
			z_move_thread_to_end_of_prio_q(_current);
    f26a:	4618      	mov	r0, r3
    f26c:	f7ff ff9a 	bl	f1a4 <z_move_thread_to_end_of_prio_q>
    f270:	e7e0      	b.n	f234 <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
    f272:	1a09      	subs	r1, r1, r0
    f274:	6111      	str	r1, [r2, #16]
}
    f276:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
    f278:	2300      	movs	r3, #0
    f27a:	6123      	str	r3, [r4, #16]
    f27c:	e7fb      	b.n	f276 <z_time_slice+0x52>
    f27e:	bf00      	nop
    f280:	200055e4 	.word	0x200055e4
    f284:	20005614 	.word	0x20005614
    f288:	2000561c 	.word	0x2000561c
    f28c:	20005618 	.word	0x20005618
    f290:	00016838 	.word	0x00016838

0000f294 <z_remove_thread_from_ready_q>:
{
    f294:	b538      	push	{r3, r4, r5, lr}
    f296:	4604      	mov	r4, r0
	__asm__ volatile(
    f298:	f04f 0320 	mov.w	r3, #32
    f29c:	f3ef 8511 	mrs	r5, BASEPRI
    f2a0:	f383 8811 	msr	BASEPRI, r3
    f2a4:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    f2a8:	7b43      	ldrb	r3, [r0, #13]
    f2aa:	065a      	lsls	r2, r3, #25
    f2ac:	d507      	bpl.n	f2be <z_remove_thread_from_ready_q+0x2a>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    f2ae:	4601      	mov	r1, r0
    f2b0:	4809      	ldr	r0, [pc, #36]	; (f2d8 <z_remove_thread_from_ready_q+0x44>)
    f2b2:	f7ff fef1 	bl	f098 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    f2b6:	7b63      	ldrb	r3, [r4, #13]
    f2b8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    f2bc:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    f2be:	4b07      	ldr	r3, [pc, #28]	; (f2dc <z_remove_thread_from_ready_q+0x48>)
    f2c0:	6898      	ldr	r0, [r3, #8]
    f2c2:	1b03      	subs	r3, r0, r4
    f2c4:	4258      	negs	r0, r3
    f2c6:	4158      	adcs	r0, r3
    f2c8:	f7ff fefc 	bl	f0c4 <update_cache>
	__asm__ volatile(
    f2cc:	f385 8811 	msr	BASEPRI, r5
    f2d0:	f3bf 8f6f 	isb	sy
}
    f2d4:	bd38      	pop	{r3, r4, r5, pc}
    f2d6:	bf00      	nop
    f2d8:	2000560c 	.word	0x2000560c
    f2dc:	200055e4 	.word	0x200055e4

0000f2e0 <pend>:
{
    f2e0:	b570      	push	{r4, r5, r6, lr}
    f2e2:	4604      	mov	r4, r0
    f2e4:	460d      	mov	r5, r1
    f2e6:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
    f2e8:	f7ff ffd4 	bl	f294 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
    f2ec:	7b63      	ldrb	r3, [r4, #13]
    f2ee:	f043 0302 	orr.w	r3, r3, #2
    f2f2:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
    f2f4:	b17d      	cbz	r5, f316 <pend+0x36>
	return list->head == list;
    f2f6:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
    f2f8:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f2fa:	429d      	cmp	r5, r3
    f2fc:	d026      	beq.n	f34c <pend+0x6c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f2fe:	b32b      	cbz	r3, f34c <pend+0x6c>
	if (t1->base.prio < t2->base.prio) {
    f300:	f994 200e 	ldrsb.w	r2, [r4, #14]
    f304:	f993 100e 	ldrsb.w	r1, [r3, #14]
    f308:	4291      	cmp	r1, r2
    f30a:	dd19      	ble.n	f340 <pend+0x60>
	node->prev = successor->prev;
    f30c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    f30e:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
    f312:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    f314:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
    f316:	1c73      	adds	r3, r6, #1
    f318:	d01f      	beq.n	f35a <pend+0x7a>
    f31a:	4810      	ldr	r0, [pc, #64]	; (f35c <pend+0x7c>)
    f31c:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    f320:	2100      	movs	r1, #0
    f322:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    f326:	fbc5 0106 	smlal	r0, r1, r5, r6
    f32a:	2300      	movs	r3, #0
    f32c:	f7f1 f9bc 	bl	6a8 <__aeabi_ldivmod>

extern void z_thread_timeout(struct _timeout *to);

static inline void z_add_thread_timeout(struct k_thread *th, s32_t ticks)
{
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    f330:	490b      	ldr	r1, [pc, #44]	; (f360 <pend+0x80>)
    f332:	1c42      	adds	r2, r0, #1
    f334:	f104 0018 	add.w	r0, r4, #24
}
    f338:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    f33c:	f000 bb78 	b.w	fa30 <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
    f340:	6869      	ldr	r1, [r5, #4]
    f342:	428b      	cmp	r3, r1
    f344:	d002      	beq.n	f34c <pend+0x6c>
    f346:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f348:	2b00      	cmp	r3, #0
    f34a:	d1db      	bne.n	f304 <pend+0x24>
	node->prev = list->tail;
    f34c:	686b      	ldr	r3, [r5, #4]
    f34e:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    f350:	686b      	ldr	r3, [r5, #4]
	node->next = list;
    f352:	6025      	str	r5, [r4, #0]
	list->tail->next = node;
    f354:	601c      	str	r4, [r3, #0]
	list->tail = node;
    f356:	606c      	str	r4, [r5, #4]
    f358:	e7dd      	b.n	f316 <pend+0x36>
}
    f35a:	bd70      	pop	{r4, r5, r6, pc}
    f35c:	0004ffff 	.word	0x0004ffff
    f360:	00015cb9 	.word	0x00015cb9

0000f364 <z_pend_curr_irqlock>:
{
    f364:	b570      	push	{r4, r5, r6, lr}
	pend(_current, wait_q, timeout);
    f366:	4d0f      	ldr	r5, [pc, #60]	; (f3a4 <z_pend_curr_irqlock+0x40>)
	pending_current = _current;
    f368:	4c0f      	ldr	r4, [pc, #60]	; (f3a8 <z_pend_curr_irqlock+0x44>)
{
    f36a:	4606      	mov	r6, r0
	pend(_current, wait_q, timeout);
    f36c:	68a8      	ldr	r0, [r5, #8]
    f36e:	f7ff ffb7 	bl	f2e0 <pend>
	pending_current = _current;
    f372:	68ab      	ldr	r3, [r5, #8]
    f374:	6023      	str	r3, [r4, #0]
    f376:	4630      	mov	r0, r6
    f378:	f7fa fb60 	bl	9a3c <__swap>
	__asm__ volatile(
    f37c:	f04f 0220 	mov.w	r2, #32
    f380:	f3ef 8311 	mrs	r3, BASEPRI
    f384:	f382 8811 	msr	BASEPRI, r2
    f388:	f3bf 8f6f 	isb	sy
		if (pending_current == _current) {
    f38c:	6822      	ldr	r2, [r4, #0]
    f38e:	68a9      	ldr	r1, [r5, #8]
    f390:	4291      	cmp	r1, r2
			pending_current = NULL;
    f392:	bf04      	itt	eq
    f394:	2200      	moveq	r2, #0
    f396:	6022      	streq	r2, [r4, #0]
	__asm__ volatile(
    f398:	f383 8811 	msr	BASEPRI, r3
    f39c:	f3bf 8f6f 	isb	sy
}
    f3a0:	bd70      	pop	{r4, r5, r6, pc}
    f3a2:	bf00      	nop
    f3a4:	200055e4 	.word	0x200055e4
    f3a8:	20005614 	.word	0x20005614

0000f3ac <z_pend_curr>:
{
    f3ac:	b510      	push	{r4, lr}
    f3ae:	460c      	mov	r4, r1
    f3b0:	4611      	mov	r1, r2
	pending_current = _current;
    f3b2:	4a06      	ldr	r2, [pc, #24]	; (f3cc <z_pend_curr+0x20>)
    f3b4:	6890      	ldr	r0, [r2, #8]
    f3b6:	4a06      	ldr	r2, [pc, #24]	; (f3d0 <z_pend_curr+0x24>)
    f3b8:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
    f3ba:	461a      	mov	r2, r3
    f3bc:	f7ff ff90 	bl	f2e0 <pend>
    f3c0:	4620      	mov	r0, r4
}
    f3c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f3c6:	f7fa bb39 	b.w	9a3c <__swap>
    f3ca:	bf00      	nop
    f3cc:	200055e4 	.word	0x200055e4
    f3d0:	20005614 	.word	0x20005614

0000f3d4 <z_thread_priority_set>:
{
    f3d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f3d8:	4604      	mov	r4, r0
	__asm__ volatile(
    f3da:	f04f 0320 	mov.w	r3, #32
    f3de:	f3ef 8911 	mrs	r9, BASEPRI
    f3e2:	f383 8811 	msr	BASEPRI, r3
    f3e6:	f3bf 8f6f 	isb	sy
		need_sched = z_is_thread_ready(thread);
    f3ea:	f006 fbef 	bl	15bcc <z_is_thread_ready>
		if (need_sched) {
    f3ee:	b24e      	sxtb	r6, r1
    f3f0:	4680      	mov	r8, r0
    f3f2:	2800      	cmp	r0, #0
    f3f4:	d034      	beq.n	f460 <z_thread_priority_set+0x8c>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    f3f6:	4d1c      	ldr	r5, [pc, #112]	; (f468 <z_thread_priority_set+0x94>)
    f3f8:	f105 0728 	add.w	r7, r5, #40	; 0x28
    f3fc:	4621      	mov	r1, r4
    f3fe:	4638      	mov	r0, r7
    f400:	f7ff fe4a 	bl	f098 <z_priq_dumb_remove>
	return list->head == list;
    f404:	6aab      	ldr	r3, [r5, #40]	; 0x28
			thread->base.prio = prio;
    f406:	73a6      	strb	r6, [r4, #14]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f408:	42bb      	cmp	r3, r7
    f40a:	462a      	mov	r2, r5
    f40c:	d021      	beq.n	f452 <z_thread_priority_set+0x7e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f40e:	b303      	cbz	r3, f452 <z_thread_priority_set+0x7e>
    f410:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
    f412:	f993 000e 	ldrsb.w	r0, [r3, #14]
    f416:	42b0      	cmp	r0, r6
    f418:	dd16      	ble.n	f448 <z_thread_priority_set+0x74>
	node->prev = successor->prev;
    f41a:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    f41c:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
    f420:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    f422:	605c      	str	r4, [r3, #4]
			update_cache(1);
    f424:	2001      	movs	r0, #1
    f426:	f7ff fe4d 	bl	f0c4 <update_cache>
	__asm__ volatile(
    f42a:	f389 8811 	msr	BASEPRI, r9
    f42e:	f3bf 8f6f 	isb	sy
	if (need_sched && _current->base.sched_locked == 0) {
    f432:	f1b8 0f00 	cmp.w	r8, #0
    f436:	d015      	beq.n	f464 <z_thread_priority_set+0x90>
    f438:	4b0b      	ldr	r3, [pc, #44]	; (f468 <z_thread_priority_set+0x94>)
    f43a:	689b      	ldr	r3, [r3, #8]
    f43c:	7bdb      	ldrb	r3, [r3, #15]
    f43e:	b98b      	cbnz	r3, f464 <z_thread_priority_set+0x90>
}
    f440:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		z_reschedule_unlocked();
    f444:	f006 bc0a 	b.w	15c5c <z_reschedule_unlocked>
	return (node == list->tail) ? NULL : node->next;
    f448:	4299      	cmp	r1, r3
    f44a:	d002      	beq.n	f452 <z_thread_priority_set+0x7e>
    f44c:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f44e:	2b00      	cmp	r3, #0
    f450:	d1df      	bne.n	f412 <z_thread_priority_set+0x3e>
	node->prev = list->tail;
    f452:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    f454:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    f456:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
    f458:	6027      	str	r7, [r4, #0]
	list->tail->next = node;
    f45a:	601c      	str	r4, [r3, #0]
	list->tail = node;
    f45c:	62d4      	str	r4, [r2, #44]	; 0x2c
    f45e:	e7e1      	b.n	f424 <z_thread_priority_set+0x50>
			thread->base.prio = prio;
    f460:	73a6      	strb	r6, [r4, #14]
    f462:	e7e2      	b.n	f42a <z_thread_priority_set+0x56>
}
    f464:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    f468:	200055e4 	.word	0x200055e4

0000f46c <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    f46c:	4b04      	ldr	r3, [pc, #16]	; (f480 <z_sched_init+0x14>)
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    f46e:	2100      	movs	r1, #0
    f470:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
    f474:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
    f478:	4608      	mov	r0, r1
    f47a:	f7ff bdcb 	b.w	f014 <k_sched_time_slice_set>
    f47e:	bf00      	nop
    f480:	200055e4 	.word	0x200055e4

0000f484 <z_impl_k_yield>:
}
#endif
#endif

void z_impl_k_yield(void)
{
    f484:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__ASSERT(!z_is_in_isr(), "");

	if (!is_idle(_current)) {
    f486:	4c22      	ldr	r4, [pc, #136]	; (f510 <z_impl_k_yield+0x8c>)
    f488:	4b22      	ldr	r3, [pc, #136]	; (f514 <z_impl_k_yield+0x90>)
    f48a:	68a2      	ldr	r2, [r4, #8]
    f48c:	681b      	ldr	r3, [r3, #0]
    f48e:	429a      	cmp	r2, r3
    f490:	d025      	beq.n	f4de <z_impl_k_yield+0x5a>
	__asm__ volatile(
    f492:	f04f 0320 	mov.w	r3, #32
    f496:	f3ef 8611 	mrs	r6, BASEPRI
    f49a:	f383 8811 	msr	BASEPRI, r3
    f49e:	f3bf 8f6f 	isb	sy
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
    f4a2:	f104 0528 	add.w	r5, r4, #40	; 0x28
    f4a6:	68a1      	ldr	r1, [r4, #8]
    f4a8:	4628      	mov	r0, r5
    f4aa:	f7ff fdf5 	bl	f098 <z_priq_dumb_remove>
	return list->head == list;
    f4ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
						 _current);
				_priq_run_add(&_kernel.ready_q.runq,
    f4b0:	68a2      	ldr	r2, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f4b2:	42ab      	cmp	r3, r5
    f4b4:	d024      	beq.n	f500 <z_impl_k_yield+0x7c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f4b6:	b31b      	cbz	r3, f500 <z_impl_k_yield+0x7c>
    f4b8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
    f4ba:	f992 000e 	ldrsb.w	r0, [r2, #14]
    f4be:	f993 700e 	ldrsb.w	r7, [r3, #14]
    f4c2:	4287      	cmp	r7, r0
    f4c4:	dd17      	ble.n	f4f6 <z_impl_k_yield+0x72>
	node->prev = successor->prev;
    f4c6:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
    f4c8:	e9c2 3100 	strd	r3, r1, [r2]
	successor->prev->next = node;
    f4cc:	600a      	str	r2, [r1, #0]
	successor->prev = node;
    f4ce:	605a      	str	r2, [r3, #4]
					      _current);
			}
			update_cache(1);
    f4d0:	2001      	movs	r0, #1
    f4d2:	f7ff fdf7 	bl	f0c4 <update_cache>
	__asm__ volatile(
    f4d6:	f386 8811 	msr	BASEPRI, r6
    f4da:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
    f4de:	f04f 0320 	mov.w	r3, #32
    f4e2:	f3ef 8011 	mrs	r0, BASEPRI
    f4e6:	f383 8811 	msr	BASEPRI, r3
    f4ea:	f3bf 8f6f 	isb	sy
		}
	}
	z_swap_unlocked();
}
    f4ee:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    f4f2:	f7fa baa3 	b.w	9a3c <__swap>
	return (node == list->tail) ? NULL : node->next;
    f4f6:	4299      	cmp	r1, r3
    f4f8:	d002      	beq.n	f500 <z_impl_k_yield+0x7c>
    f4fa:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f4fc:	2b00      	cmp	r3, #0
    f4fe:	d1de      	bne.n	f4be <z_impl_k_yield+0x3a>
	node->prev = list->tail;
    f500:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f502:	6053      	str	r3, [r2, #4]
	list->tail->next = node;
    f504:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	node->next = list;
    f506:	6015      	str	r5, [r2, #0]
	list->tail->next = node;
    f508:	601a      	str	r2, [r3, #0]
	list->tail = node;
    f50a:	62e2      	str	r2, [r4, #44]	; 0x2c
    f50c:	e7e0      	b.n	f4d0 <z_impl_k_yield+0x4c>
    f50e:	bf00      	nop
    f510:	200055e4 	.word	0x200055e4
    f514:	00016838 	.word	0x00016838

0000f518 <z_impl_k_sleep>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER0_SIMPLE_VOID(k_yield);
#endif

s32_t z_impl_k_sleep(s32_t duration)
{
    f518:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__ASSERT(!z_is_in_isr(), "");

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
    f51a:	4604      	mov	r4, r0
    f51c:	b918      	cbnz	r0, f526 <z_impl_k_sleep+0xe>
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)
    f51e:	f7ff ffb1 	bl	f484 <z_impl_k_yield>
		return __ticks_to_ms(ticks);
	}
#endif

	return 0;
}
    f522:	4620      	mov	r0, r4
    f524:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f526:	481e      	ldr	r0, [pc, #120]	; (f5a0 <z_impl_k_sleep+0x88>)
    f528:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    f52c:	2100      	movs	r1, #0
    f52e:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    f532:	2300      	movs	r3, #0
    f534:	fbc5 0104 	smlal	r0, r1, r5, r4
    f538:	f7f1 f8b6 	bl	6a8 <__aeabi_ldivmod>
	ticks = _TICK_ALIGN + z_ms_to_ticks(duration);
    f53c:	1c46      	adds	r6, r0, #1
	expected_wakeup_time = ticks + z_tick_get_32();
    f53e:	f006 fd27 	bl	15f90 <z_tick_get_32>
    f542:	1834      	adds	r4, r6, r0
    f544:	f04f 0320 	mov.w	r3, #32
    f548:	f3ef 8711 	mrs	r7, BASEPRI
    f54c:	f383 8811 	msr	BASEPRI, r3
    f550:	f3bf 8f6f 	isb	sy
	pending_current = _current;
    f554:	4d13      	ldr	r5, [pc, #76]	; (f5a4 <z_impl_k_sleep+0x8c>)
    f556:	4b14      	ldr	r3, [pc, #80]	; (f5a8 <z_impl_k_sleep+0x90>)
    f558:	68a8      	ldr	r0, [r5, #8]
    f55a:	6018      	str	r0, [r3, #0]
	z_remove_thread_from_ready_q(_current);
    f55c:	f7ff fe9a 	bl	f294 <z_remove_thread_from_ready_q>
    f560:	68a8      	ldr	r0, [r5, #8]
    f562:	4912      	ldr	r1, [pc, #72]	; (f5ac <z_impl_k_sleep+0x94>)
    f564:	4632      	mov	r2, r6
    f566:	3018      	adds	r0, #24
    f568:	f000 fa62 	bl	fa30 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    f56c:	68aa      	ldr	r2, [r5, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
    f56e:	7b53      	ldrb	r3, [r2, #13]
    f570:	f043 0310 	orr.w	r3, r3, #16
    f574:	7353      	strb	r3, [r2, #13]
    f576:	4638      	mov	r0, r7
    f578:	f7fa fa60 	bl	9a3c <__swap>
	ticks = expected_wakeup_time - z_tick_get_32();
    f57c:	f006 fd08 	bl	15f90 <z_tick_get_32>
    f580:	1a20      	subs	r0, r4, r0
	if (ticks > 0) {
    f582:	2800      	cmp	r0, #0
    f584:	dd09      	ble.n	f59a <z_impl_k_sleep+0x82>
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    f586:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    f58a:	2264      	movs	r2, #100	; 0x64
    f58c:	2300      	movs	r3, #0
    f58e:	fb80 0101 	smull	r0, r1, r0, r1
    f592:	f7f1 f8d9 	bl	748 <__aeabi_uldivmod>
    f596:	4604      	mov	r4, r0
		return __ticks_to_ms(ticks);
    f598:	e7c3      	b.n	f522 <z_impl_k_sleep+0xa>
	return 0;
    f59a:	2400      	movs	r4, #0
    f59c:	e7c1      	b.n	f522 <z_impl_k_sleep+0xa>
    f59e:	bf00      	nop
    f5a0:	0004ffff 	.word	0x0004ffff
    f5a4:	200055e4 	.word	0x200055e4
    f5a8:	20005614 	.word	0x20005614
    f5ac:	00015cb9 	.word	0x00015cb9

0000f5b0 <z_impl_k_wakeup>:
	return z_impl_k_sleep(duration);
}
#endif

void z_impl_k_wakeup(k_tid_t thread)
{
    f5b0:	b510      	push	{r4, lr}
	if (z_is_thread_pending(thread)) {
    f5b2:	7b43      	ldrb	r3, [r0, #13]
    f5b4:	079a      	lsls	r2, r3, #30
{
    f5b6:	4604      	mov	r4, r0
	if (z_is_thread_pending(thread)) {
    f5b8:	d41c      	bmi.n	f5f4 <z_impl_k_wakeup+0x44>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    f5ba:	3018      	adds	r0, #24
    f5bc:	f006 fca8 	bl	15f10 <z_abort_timeout>
		return;
	}

	if (z_abort_thread_timeout(thread) < 0) {
    f5c0:	2800      	cmp	r0, #0
    f5c2:	db17      	blt.n	f5f4 <z_impl_k_wakeup+0x44>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    f5c4:	7b63      	ldrb	r3, [r4, #13]
    f5c6:	f023 0310 	bic.w	r3, r3, #16
    f5ca:	7363      	strb	r3, [r4, #13]
	if (z_is_thread_ready(thread)) {
    f5cc:	4620      	mov	r0, r4
    f5ce:	f006 fafd 	bl	15bcc <z_is_thread_ready>
    f5d2:	b110      	cbz	r0, f5da <z_impl_k_wakeup+0x2a>
		z_add_thread_to_ready_q(thread);
    f5d4:	4620      	mov	r0, r4
    f5d6:	f7ff fdaf 	bl	f138 <z_add_thread_to_ready_q>
    f5da:	f3ef 8305 	mrs	r3, IPSR
    f5de:	2b0d      	cmp	r3, #13
    f5e0:	d808      	bhi.n	f5f4 <z_impl_k_wakeup+0x44>
    f5e2:	b11b      	cbz	r3, f5ec <z_impl_k_wakeup+0x3c>
    f5e4:	4b04      	ldr	r3, [pc, #16]	; (f5f8 <z_impl_k_wakeup+0x48>)
    f5e6:	685b      	ldr	r3, [r3, #4]
    f5e8:	051b      	lsls	r3, r3, #20
    f5ea:	d503      	bpl.n	f5f4 <z_impl_k_wakeup+0x44>

	if (IS_ENABLED(CONFIG_SMP) &&
	    !IS_ENABLED(CONFIG_SCHED_IPI_SUPPORTED)) {
		z_sched_ipi();
	}
}
    f5ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_reschedule_unlocked();
    f5f0:	f006 bb34 	b.w	15c5c <z_reschedule_unlocked>
}
    f5f4:	bd10      	pop	{r4, pc}
    f5f6:	bf00      	nop
    f5f8:	e000ed00 	.word	0xe000ed00

0000f5fc <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
    f5fc:	4b01      	ldr	r3, [pc, #4]	; (f604 <z_impl_k_current_get+0x8>)
    f5fe:	6898      	ldr	r0, [r3, #8]
    f600:	4770      	bx	lr
    f602:	bf00      	nop
    f604:	200055e4 	.word	0x200055e4

0000f608 <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    f608:	b570      	push	{r4, r5, r6, lr}
    f60a:	4604      	mov	r4, r0
    f60c:	f04f 0320 	mov.w	r3, #32
    f610:	f3ef 8611 	mrs	r6, BASEPRI
    f614:	f383 8811 	msr	BASEPRI, r3
    f618:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
    f61c:	f006 fb7d 	bl	15d1a <z_unpend_first_thread>
	if (thread != NULL) {
    f620:	4605      	mov	r5, r0
    f622:	b170      	cbz	r0, f642 <z_impl_k_sem_give+0x3a>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    f624:	7b43      	ldrb	r3, [r0, #13]
    f626:	06db      	lsls	r3, r3, #27
    f628:	d103      	bne.n	f632 <z_impl_k_sem_give+0x2a>
	if (z_is_thread_ready(thread)) {
    f62a:	6983      	ldr	r3, [r0, #24]
    f62c:	b90b      	cbnz	r3, f632 <z_impl_k_sem_give+0x2a>
		z_add_thread_to_ready_q(thread);
    f62e:	f7ff fd83 	bl	f138 <z_add_thread_to_ready_q>
    f632:	2300      	movs	r3, #0
    f634:	66ab      	str	r3, [r5, #104]	; 0x68
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
    f636:	4631      	mov	r1, r6
    f638:	4808      	ldr	r0, [pc, #32]	; (f65c <z_impl_k_sem_give+0x54>)
}
    f63a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
    f63e:	f006 baf0 	b.w	15c22 <z_reschedule>
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
    f642:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    f646:	429a      	cmp	r2, r3
    f648:	bf18      	it	ne
    f64a:	3301      	addne	r3, #1
    f64c:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    f64e:	2102      	movs	r1, #2
    f650:	f104 0010 	add.w	r0, r4, #16
    f654:	f006 fd34 	bl	160c0 <z_handle_obj_poll_events>
    f658:	e7ed      	b.n	f636 <z_impl_k_sem_give+0x2e>
    f65a:	bf00      	nop
    f65c:	2000687c 	.word	0x2000687c

0000f660 <z_impl_k_sem_take>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_sem_give, K_OBJ_SEM, struct k_sem *);
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
    f660:	b410      	push	{r4}
    f662:	4602      	mov	r2, r0
    f664:	460b      	mov	r3, r1
    f666:	f04f 0020 	mov.w	r0, #32
    f66a:	f3ef 8111 	mrs	r1, BASEPRI
    f66e:	f380 8811 	msr	BASEPRI, r0
    f672:	f3bf 8f6f 	isb	sy
	__ASSERT(((z_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
    f676:	6894      	ldr	r4, [r2, #8]
    f678:	b144      	cbz	r4, f68c <z_impl_k_sem_take+0x2c>
		sem->count--;
    f67a:	3c01      	subs	r4, #1
    f67c:	6094      	str	r4, [r2, #8]
	__asm__ volatile(
    f67e:	f381 8811 	msr	BASEPRI, r1
    f682:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
    f686:	2000      	movs	r0, #0

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
	return ret;
}
    f688:	bc10      	pop	{r4}
    f68a:	4770      	bx	lr
	if (timeout == K_NO_WAIT) {
    f68c:	b933      	cbnz	r3, f69c <z_impl_k_sem_take+0x3c>
    f68e:	f381 8811 	msr	BASEPRI, r1
    f692:	f3bf 8f6f 	isb	sy
		return -EBUSY;
    f696:	f06f 000f 	mvn.w	r0, #15
    f69a:	e7f5      	b.n	f688 <z_impl_k_sem_take+0x28>
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    f69c:	4801      	ldr	r0, [pc, #4]	; (f6a4 <z_impl_k_sem_take+0x44>)
}
    f69e:	bc10      	pop	{r4}
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    f6a0:	f7ff be84 	b.w	f3ac <z_pend_curr>
    f6a4:	2000687c 	.word	0x2000687c

0000f6a8 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
    f6a8:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
    f6aa:	4c08      	ldr	r4, [pc, #32]	; (f6cc <k_sys_work_q_init+0x24>)
    f6ac:	4908      	ldr	r1, [pc, #32]	; (f6d0 <k_sys_work_q_init+0x28>)
    f6ae:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    f6b2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    f6b6:	4620      	mov	r0, r4
    f6b8:	f000 f90c 	bl	f8d4 <k_work_q_start>
K_SYSCALL_DECLARE2(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, int, k_tid_t, thread_id, const char *, value)
    f6bc:	4905      	ldr	r1, [pc, #20]	; (f6d4 <k_sys_work_q_init+0x2c>)
    f6be:	f104 0010 	add.w	r0, r4, #16
    f6c2:	f006 fb7f 	bl	15dc4 <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
    f6c6:	2000      	movs	r0, #0
    f6c8:	bd10      	pop	{r4, pc}
    f6ca:	bf00      	nop
    f6cc:	20005620 	.word	0x20005620
    f6d0:	20009e58 	.word	0x20009e58
    f6d4:	000191b7 	.word	0x000191b7

0000f6d8 <k_is_in_isr>:
    f6d8:	f3ef 8005 	mrs	r0, IPSR
    f6dc:	280d      	cmp	r0, #13
    f6de:	d807      	bhi.n	f6f0 <k_is_in_isr+0x18>
    f6e0:	b138      	cbz	r0, f6f2 <k_is_in_isr+0x1a>
    f6e2:	4b04      	ldr	r3, [pc, #16]	; (f6f4 <k_is_in_isr+0x1c>)
    f6e4:	6858      	ldr	r0, [r3, #4]
    f6e6:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
    f6ea:	f3c0 20c0 	ubfx	r0, r0, #11, #1
    f6ee:	4770      	bx	lr
    f6f0:	2001      	movs	r0, #1
}

bool k_is_in_isr(void)
{
	return z_is_in_isr();
}
    f6f2:	4770      	bx	lr
    f6f4:	e000ed00 	.word	0xe000ed00

0000f6f8 <z_thread_essential_clear>:
 * Exceptions raised by this thread may be recoverable.
 * (This is the default tag for a thread.)
 */
void z_thread_essential_clear(void)
{
	_current->base.user_options &= ~K_ESSENTIAL;
    f6f8:	4b03      	ldr	r3, [pc, #12]	; (f708 <z_thread_essential_clear+0x10>)
    f6fa:	689a      	ldr	r2, [r3, #8]
    f6fc:	7b13      	ldrb	r3, [r2, #12]
    f6fe:	f023 0301 	bic.w	r3, r3, #1
    f702:	7313      	strb	r3, [r2, #12]
}
    f704:	4770      	bx	lr
    f706:	bf00      	nop
    f708:	200055e4 	.word	0x200055e4

0000f70c <z_is_thread_essential>:
 *
 * Returns true if current thread is essential, false if it is not.
 */
bool z_is_thread_essential(void)
{
	return (_current->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
    f70c:	4b02      	ldr	r3, [pc, #8]	; (f718 <z_is_thread_essential+0xc>)
    f70e:	689b      	ldr	r3, [r3, #8]
    f710:	7b18      	ldrb	r0, [r3, #12]
}
    f712:	f000 0001 	and.w	r0, r0, #1
    f716:	4770      	bx	lr
    f718:	200055e4 	.word	0x200055e4

0000f71c <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
    f71c:	b510      	push	{r4, lr}
    f71e:	4602      	mov	r2, r0
	__asm__ volatile(
    f720:	f04f 0320 	mov.w	r3, #32
    f724:	f3ef 8411 	mrs	r4, BASEPRI
    f728:	f383 8811 	msr	BASEPRI, r3
    f72c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
    f730:	7b43      	ldrb	r3, [r0, #13]
    f732:	0759      	lsls	r1, r3, #29
    f734:	d404      	bmi.n	f740 <z_impl_k_thread_start+0x24>
	__asm__ volatile(
    f736:	f384 8811 	msr	BASEPRI, r4
    f73a:	f3bf 8f6f 	isb	sy
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
    f73e:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    f740:	f023 0304 	bic.w	r3, r3, #4
    f744:	7343      	strb	r3, [r0, #13]
	if (z_is_thread_ready(thread)) {
    f746:	f006 fb34 	bl	15db2 <z_is_thread_ready>
    f74a:	b110      	cbz	r0, f752 <z_impl_k_thread_start+0x36>
		z_add_thread_to_ready_q(thread);
    f74c:	4610      	mov	r0, r2
    f74e:	f7ff fcf3 	bl	f138 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
    f752:	4621      	mov	r1, r4
    f754:	4802      	ldr	r0, [pc, #8]	; (f760 <z_impl_k_thread_start+0x44>)
}
    f756:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&lock, key);
    f75a:	f006 ba62 	b.w	15c22 <z_reschedule>
    f75e:	bf00      	nop
    f760:	2000687c 	.word	0x2000687c

0000f764 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
    f764:	b530      	push	{r4, r5, lr}
    f766:	b087      	sub	sp, #28
    f768:	4604      	mov	r4, r0
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    f76a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    f76c:	9504      	str	r5, [sp, #16]
    f76e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    f770:	9503      	str	r5, [sp, #12]
    f772:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    f774:	9502      	str	r5, [sp, #8]
    f776:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    f778:	9501      	str	r5, [sp, #4]
    f77a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    f77c:	9500      	str	r5, [sp, #0]
    f77e:	f7fa fb4f 	bl	9e20 <z_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    f782:	4b03      	ldr	r3, [pc, #12]	; (f790 <z_setup_new_thread+0x2c>)
    f784:	689b      	ldr	r3, [r3, #8]
    f786:	b103      	cbz	r3, f78a <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    f788:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    f78a:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
    f78c:	b007      	add	sp, #28
    f78e:	bd30      	pop	{r4, r5, pc}
    f790:	200055e4 	.word	0x200055e4

0000f794 <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, u32_t options, s32_t delay)
{
    f794:	b570      	push	{r4, r5, r6, lr}
    f796:	b086      	sub	sp, #24
#if defined(CONFIG_TEST) && defined(CONFIG_ARCH_HAS_USERSPACE) && !defined(CONFIG_USERSPACE)
	__ASSERT((options & K_USER) == 0,
		 "Platform is capable of user mode, and test thread created with K_USER option, but CONFIG_TEST_USERSPACE or CONFIG_USERSPACE is not set\n");
#endif

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    f798:	2600      	movs	r6, #0
    f79a:	9605      	str	r6, [sp, #20]
    f79c:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    f79e:	9604      	str	r6, [sp, #16]
    f7a0:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    f7a2:	9603      	str	r6, [sp, #12]
    f7a4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    f7a6:	9602      	str	r6, [sp, #8]
    f7a8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
{
    f7aa:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    f7ac:	9601      	str	r6, [sp, #4]
    f7ae:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    f7b0:	9600      	str	r6, [sp, #0]
{
    f7b2:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    f7b4:	f7ff ffd6 	bl	f764 <z_setup_new_thread>
			  prio, options, NULL);

	if (delay != K_FOREVER) {
    f7b8:	1c6b      	adds	r3, r5, #1
    f7ba:	d003      	beq.n	f7c4 <z_impl_k_thread_create+0x30>
	if (delay == 0) {
    f7bc:	b92d      	cbnz	r5, f7ca <z_impl_k_thread_create+0x36>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread)
    f7be:	4620      	mov	r0, r4
    f7c0:	f7ff ffac 	bl	f71c <z_impl_k_thread_start>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
    f7c4:	4620      	mov	r0, r4
    f7c6:	b006      	add	sp, #24
    f7c8:	bd70      	pop	{r4, r5, r6, pc}
	return (s32_t)ceiling_fraction(
    f7ca:	4809      	ldr	r0, [pc, #36]	; (f7f0 <z_impl_k_thread_create+0x5c>)
    f7cc:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    f7d0:	2100      	movs	r1, #0
    f7d2:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    f7d6:	2300      	movs	r3, #0
    f7d8:	fbc6 0105 	smlal	r0, r1, r6, r5
    f7dc:	f7f0 ff64 	bl	6a8 <__aeabi_ldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    f7e0:	4904      	ldr	r1, [pc, #16]	; (f7f4 <z_impl_k_thread_create+0x60>)
    f7e2:	1c42      	adds	r2, r0, #1
    f7e4:	f104 0018 	add.w	r0, r4, #24
    f7e8:	f000 f922 	bl	fa30 <z_add_timeout>
    f7ec:	e7ea      	b.n	f7c4 <z_impl_k_thread_create+0x30>
    f7ee:	bf00      	nop
    f7f0:	0004ffff 	.word	0x0004ffff
    f7f4:	00015cb9 	.word	0x00015cb9

0000f7f8 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    f7f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
    f7fc:	4e28      	ldr	r6, [pc, #160]	; (f8a0 <z_init_static_threads+0xa8>)
    f7fe:	4d29      	ldr	r5, [pc, #164]	; (f8a4 <z_init_static_threads+0xac>)
{
    f800:	b087      	sub	sp, #28
    f802:	46b0      	mov	r8, r6
	_FOREACH_STATIC_THREAD(thread_data) {
    f804:	42b5      	cmp	r5, r6
    f806:	f105 0430 	add.w	r4, r5, #48	; 0x30
    f80a:	d30f      	bcc.n	f82c <z_init_static_threads+0x34>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    f80c:	f7ff fc30 	bl	f070 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    f810:	4c24      	ldr	r4, [pc, #144]	; (f8a4 <z_init_static_threads+0xac>)
    f812:	4e25      	ldr	r6, [pc, #148]	; (f8a8 <z_init_static_threads+0xb0>)
    f814:	f8df a094 	ldr.w	sl, [pc, #148]	; f8ac <z_init_static_threads+0xb4>
    f818:	f44f 4900 	mov.w	r9, #32768	; 0x8000
    f81c:	2700      	movs	r7, #0
    f81e:	4544      	cmp	r4, r8
    f820:	d321      	bcc.n	f866 <z_init_static_threads+0x6e>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
    f822:	b007      	add	sp, #28
    f824:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
    f828:	f7ff bc6a 	b.w	f100 <k_sched_unlock>
		z_setup_new_thread(
    f82c:	f854 3c04 	ldr.w	r3, [r4, #-4]
    f830:	9305      	str	r3, [sp, #20]
    f832:	f854 3c10 	ldr.w	r3, [r4, #-16]
    f836:	9304      	str	r3, [sp, #16]
    f838:	f854 3c14 	ldr.w	r3, [r4, #-20]
    f83c:	9303      	str	r3, [sp, #12]
    f83e:	f854 3c18 	ldr.w	r3, [r4, #-24]
    f842:	9302      	str	r3, [sp, #8]
    f844:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    f848:	9301      	str	r3, [sp, #4]
    f84a:	f854 3c20 	ldr.w	r3, [r4, #-32]
    f84e:	9300      	str	r3, [sp, #0]
    f850:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
    f854:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
    f858:	f7ff ff84 	bl	f764 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    f85c:	f854 3c30 	ldr.w	r3, [r4, #-48]
    f860:	64dd      	str	r5, [r3, #76]	; 0x4c
    f862:	4625      	mov	r5, r4
    f864:	e7ce      	b.n	f804 <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_FOREVER) {
    f866:	6a61      	ldr	r1, [r4, #36]	; 0x24
    f868:	1c4b      	adds	r3, r1, #1
    f86a:	d004      	beq.n	f876 <z_init_static_threads+0x7e>
			schedule_new_thread(thread_data->init_thread,
    f86c:	6825      	ldr	r5, [r4, #0]
	if (delay == 0) {
    f86e:	b921      	cbnz	r1, f87a <z_init_static_threads+0x82>
    f870:	4628      	mov	r0, r5
    f872:	f7ff ff53 	bl	f71c <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    f876:	3430      	adds	r4, #48	; 0x30
    f878:	e7d1      	b.n	f81e <z_init_static_threads+0x26>
    f87a:	46b3      	mov	fp, r6
    f87c:	46bc      	mov	ip, r7
    f87e:	fbc9 bc01 	smlal	fp, ip, r9, r1
    f882:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    f886:	2300      	movs	r3, #0
    f888:	4658      	mov	r0, fp
    f88a:	4661      	mov	r1, ip
    f88c:	f7f0 ff0c 	bl	6a8 <__aeabi_ldivmod>
    f890:	4651      	mov	r1, sl
    f892:	1c42      	adds	r2, r0, #1
    f894:	f105 0018 	add.w	r0, r5, #24
    f898:	f000 f8ca 	bl	fa30 <z_add_timeout>
    f89c:	e7eb      	b.n	f876 <z_init_static_threads+0x7e>
    f89e:	bf00      	nop
    f8a0:	20011d04 	.word	0x20011d04
    f8a4:	20011cd4 	.word	0x20011cd4
    f8a8:	0004ffff 	.word	0x0004ffff
    f8ac:	00015cb9 	.word	0x00015cb9

0000f8b0 <k_thread_user_mode_enter>:
	z_init_thread_timeout(thread_base);
}

FUNC_NORETURN void k_thread_user_mode_enter(k_thread_entry_t entry,
					    void *p1, void *p2, void *p3)
{
    f8b0:	b580      	push	{r7, lr}
    f8b2:	461f      	mov	r7, r3
	_current->base.user_options |= K_USER;
    f8b4:	4b06      	ldr	r3, [pc, #24]	; (f8d0 <k_thread_user_mode_enter+0x20>)
    f8b6:	689d      	ldr	r5, [r3, #8]
    f8b8:	7b2c      	ldrb	r4, [r5, #12]
    f8ba:	f044 0404 	orr.w	r4, r4, #4
{
    f8be:	4616      	mov	r6, r2
	_current->base.user_options |= K_USER;
    f8c0:	732c      	strb	r4, [r5, #12]
	z_thread_essential_clear();
    f8c2:	f7ff ff19 	bl	f6f8 <z_thread_essential_clear>
#endif
#ifdef CONFIG_USERSPACE
	z_arch_user_mode_enter(entry, p1, p2, p3);
#else
	/* XXX In this case we do not reset the stack */
	z_thread_entry(entry, p1, p2, p3);
    f8c6:	463b      	mov	r3, r7
    f8c8:	4632      	mov	r2, r6
    f8ca:	f002 f90f 	bl	11aec <z_thread_entry>
    f8ce:	bf00      	nop
    f8d0:	200055e4 	.word	0x200055e4

0000f8d4 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
    f8d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f8d8:	4605      	mov	r5, r0
    f8da:	b086      	sub	sp, #24
    f8dc:	4698      	mov	r8, r3
    f8de:	460e      	mov	r6, r1
    f8e0:	4617      	mov	r7, r2
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
    f8e2:	f105 0410 	add.w	r4, r5, #16
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_QUEUE_INIT, k_queue_init, struct k_queue *, queue)
    f8e6:	f006 f8e5 	bl	15ab4 <z_impl_k_queue_init>
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
    f8ea:	2000      	movs	r0, #0
    f8ec:	e9cd 0004 	strd	r0, r0, [sp, #16]
    f8f0:	e9cd 0802 	strd	r0, r8, [sp, #8]
    f8f4:	e9cd 5000 	strd	r5, r0, [sp]
    f8f8:	4631      	mov	r1, r6
    f8fa:	4b06      	ldr	r3, [pc, #24]	; (f914 <k_work_q_start+0x40>)
    f8fc:	463a      	mov	r2, r7
    f8fe:	4620      	mov	r0, r4
    f900:	f7ff ff48 	bl	f794 <z_impl_k_thread_create>
K_SYSCALL_DECLARE2(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, int, k_tid_t, thread_id, const char *, value)
    f904:	4904      	ldr	r1, [pc, #16]	; (f918 <k_work_q_start+0x44>)
    f906:	4620      	mov	r0, r4
			work_q, NULL, NULL, prio, 0, 0);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
    f908:	b006      	add	sp, #24
    f90a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    f90e:	f006 ba59 	b.w	15dc4 <z_impl_k_thread_name_set>
    f912:	bf00      	nop
    f914:	00011b01 	.word	0x00011b01
    f918:	000191c0 	.word	0x000191c0

0000f91c <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   s32_t delay)
{
    f91c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f920:	4606      	mov	r6, r0
    f922:	460d      	mov	r5, r1
    f924:	4617      	mov	r7, r2
	__asm__ volatile(
    f926:	f04f 0320 	mov.w	r3, #32
    f92a:	f3ef 8811 	mrs	r8, BASEPRI
    f92e:	f383 8811 	msr	BASEPRI, r3
    f932:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
    f936:	69cc      	ldr	r4, [r1, #28]
    f938:	b15c      	cbz	r4, f952 <k_delayed_work_submit_to_queue+0x36>
    f93a:	4284      	cmp	r4, r0
    f93c:	d12b      	bne.n	f996 <k_delayed_work_submit_to_queue+0x7a>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
    f93e:	4628      	mov	r0, r5
    f940:	f006 fa87 	bl	15e52 <work_cancel>
		if (err < 0) {
    f944:	1e04      	subs	r4, r0, #0
    f946:	da06      	bge.n	f956 <k_delayed_work_submit_to_queue+0x3a>
	__asm__ volatile(
    f948:	f388 8811 	msr	BASEPRI, r8
    f94c:	f3bf 8f6f 	isb	sy
	z_add_timeout(&work->timeout, work_timeout,
		     _TICK_ALIGN + z_ms_to_ticks(delay));

done:
	k_spin_unlock(&lock, key);
	return err;
    f950:	e00c      	b.n	f96c <k_delayed_work_submit_to_queue+0x50>
	if (work->work_q == work_q) {
    f952:	2800      	cmp	r0, #0
    f954:	d0f3      	beq.n	f93e <k_delayed_work_submit_to_queue+0x22>
	work->work_q = work_q;
    f956:	61ee      	str	r6, [r5, #28]
	if (delay == 0) {
    f958:	b95f      	cbnz	r7, f972 <k_delayed_work_submit_to_queue+0x56>
    f95a:	f388 8811 	msr	BASEPRI, r8
    f95e:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
    f962:	4629      	mov	r1, r5
    f964:	4630      	mov	r0, r6
    f966:	f006 fa57 	bl	15e18 <k_work_submit_to_queue>
		return 0;
    f96a:	463c      	mov	r4, r7
}
    f96c:	4620      	mov	r0, r4
    f96e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f972:	480a      	ldr	r0, [pc, #40]	; (f99c <k_delayed_work_submit_to_queue+0x80>)
    f974:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    f978:	2100      	movs	r1, #0
    f97a:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    f97e:	2300      	movs	r3, #0
    f980:	fbc6 0107 	smlal	r0, r1, r6, r7
    f984:	f7f0 fe90 	bl	6a8 <__aeabi_ldivmod>
	z_add_timeout(&work->timeout, work_timeout,
    f988:	4905      	ldr	r1, [pc, #20]	; (f9a0 <k_delayed_work_submit_to_queue+0x84>)
    f98a:	1c42      	adds	r2, r0, #1
    f98c:	f105 000c 	add.w	r0, r5, #12
    f990:	f000 f84e 	bl	fa30 <z_add_timeout>
    f994:	e7d8      	b.n	f948 <k_delayed_work_submit_to_queue+0x2c>
		err = -EADDRINUSE;
    f996:	f06f 046f 	mvn.w	r4, #111	; 0x6f
    f99a:	e7d5      	b.n	f948 <k_delayed_work_submit_to_queue+0x2c>
    f99c:	0004ffff 	.word	0x0004ffff
    f9a0:	00015e49 	.word	0x00015e49

0000f9a4 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    f9a4:	4b03      	ldr	r3, [pc, #12]	; (f9b4 <elapsed+0x10>)
    f9a6:	681b      	ldr	r3, [r3, #0]
    f9a8:	b90b      	cbnz	r3, f9ae <elapsed+0xa>
    f9aa:	f7f9 bff5 	b.w	9998 <z_clock_elapsed>
}
    f9ae:	2000      	movs	r0, #0
    f9b0:	4770      	bx	lr
    f9b2:	bf00      	nop
    f9b4:	2000569c 	.word	0x2000569c

0000f9b8 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    f9b8:	6803      	ldr	r3, [r0, #0]
    f9ba:	b140      	cbz	r0, f9ce <remove_timeout+0x16>
    f9bc:	4a07      	ldr	r2, [pc, #28]	; (f9dc <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
    f9be:	6852      	ldr	r2, [r2, #4]
    f9c0:	4290      	cmp	r0, r2
    f9c2:	d004      	beq.n	f9ce <remove_timeout+0x16>
	if (next(t) != NULL) {
    f9c4:	b11b      	cbz	r3, f9ce <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
    f9c6:	689a      	ldr	r2, [r3, #8]
    f9c8:	6881      	ldr	r1, [r0, #8]
    f9ca:	440a      	add	r2, r1
    f9cc:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
    f9ce:	6842      	ldr	r2, [r0, #4]
    f9d0:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    f9d2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    f9d4:	2300      	movs	r3, #0
	node->prev = NULL;
    f9d6:	e9c0 3300 	strd	r3, r3, [r0]
}
    f9da:	4770      	bx	lr
    f9dc:	20010d28 	.word	0x20010d28

0000f9e0 <next_timeout>:

static s32_t next_timeout(void)
{
    f9e0:	b538      	push	{r3, r4, r5, lr}
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
    f9e2:	4b10      	ldr	r3, [pc, #64]	; (fa24 <next_timeout+0x44>)
    f9e4:	781b      	ldrb	r3, [r3, #0]
    f9e6:	2b00      	cmp	r3, #0
	return list->head == list;
    f9e8:	4b0f      	ldr	r3, [pc, #60]	; (fa28 <next_timeout+0x48>)
    f9ea:	681c      	ldr	r4, [r3, #0]
    f9ec:	bf14      	ite	ne
    f9ee:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    f9f2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f9f6:	429c      	cmp	r4, r3
    f9f8:	d00a      	beq.n	fa10 <next_timeout+0x30>
	struct _timeout *to = first();
	s32_t ret = to == NULL ? maxw : MAX(0, to->dticks - elapsed());
    f9fa:	b14c      	cbz	r4, fa10 <next_timeout+0x30>
    f9fc:	68a5      	ldr	r5, [r4, #8]
    f9fe:	f7ff ffd1 	bl	f9a4 <elapsed>
    fa02:	1a28      	subs	r0, r5, r0
    fa04:	2800      	cmp	r0, #0
    fa06:	db0a      	blt.n	fa1e <next_timeout+0x3e>
    fa08:	68a4      	ldr	r4, [r4, #8]
    fa0a:	f7ff ffcb 	bl	f9a4 <elapsed>
    fa0e:	1a20      	subs	r0, r4, r0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    fa10:	4b06      	ldr	r3, [pc, #24]	; (fa2c <next_timeout+0x4c>)
    fa12:	691b      	ldr	r3, [r3, #16]
    fa14:	b113      	cbz	r3, fa1c <next_timeout+0x3c>
    fa16:	4298      	cmp	r0, r3
    fa18:	bfa8      	it	ge
    fa1a:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    fa1c:	bd38      	pop	{r3, r4, r5, pc}
	s32_t ret = to == NULL ? maxw : MAX(0, to->dticks - elapsed());
    fa1e:	2000      	movs	r0, #0
    fa20:	e7f6      	b.n	fa10 <next_timeout+0x30>
    fa22:	bf00      	nop
    fa24:	2000687c 	.word	0x2000687c
    fa28:	20010d28 	.word	0x20010d28
    fa2c:	200055e4 	.word	0x200055e4

0000fa30 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
    fa30:	b570      	push	{r4, r5, r6, lr}
    fa32:	4604      	mov	r4, r0
    fa34:	4616      	mov	r6, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    fa36:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
    fa38:	f04f 0320 	mov.w	r3, #32
    fa3c:	f3ef 8511 	mrs	r5, BASEPRI
    fa40:	f383 8811 	msr	BASEPRI, r3
    fa44:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    fa48:	f7ff ffac 	bl	f9a4 <elapsed>
	return list->head == list;
    fa4c:	4b18      	ldr	r3, [pc, #96]	; (fab0 <z_add_timeout+0x80>)
    fa4e:	681a      	ldr	r2, [r3, #0]
    fa50:	2e01      	cmp	r6, #1
    fa52:	bfac      	ite	ge
    fa54:	1980      	addge	r0, r0, r6
    fa56:	3001      	addlt	r0, #1
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fa58:	429a      	cmp	r2, r3
    fa5a:	60a0      	str	r0, [r4, #8]
    fa5c:	d001      	beq.n	fa62 <z_add_timeout+0x32>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    fa5e:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
    fa60:	b932      	cbnz	r2, fa70 <z_add_timeout+0x40>
	node->prev = list->tail;
    fa62:	685a      	ldr	r2, [r3, #4]
    fa64:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
    fa66:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    fa68:	6023      	str	r3, [r4, #0]
	list->tail->next = node;
    fa6a:	6014      	str	r4, [r2, #0]
	list->tail = node;
    fa6c:	605c      	str	r4, [r3, #4]
    fa6e:	e00a      	b.n	fa86 <z_add_timeout+0x56>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
    fa70:	6890      	ldr	r0, [r2, #8]
    fa72:	68a1      	ldr	r1, [r4, #8]
    fa74:	4288      	cmp	r0, r1
    fa76:	dd15      	ble.n	faa4 <z_add_timeout+0x74>
				t->dticks -= to->dticks;
    fa78:	1a41      	subs	r1, r0, r1
    fa7a:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
    fa7c:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    fa7e:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
    fa82:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    fa84:	6054      	str	r4, [r2, #4]
	return list->head == list;
    fa86:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fa88:	429a      	cmp	r2, r3
    fa8a:	d006      	beq.n	fa9a <z_add_timeout+0x6a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    fa8c:	4294      	cmp	r4, r2
    fa8e:	d104      	bne.n	fa9a <z_add_timeout+0x6a>
			z_clock_set_timeout(next_timeout(), false);
    fa90:	f7ff ffa6 	bl	f9e0 <next_timeout>
    fa94:	2100      	movs	r1, #0
    fa96:	f7f9 ff43 	bl	9920 <z_clock_set_timeout>
	__asm__ volatile(
    fa9a:	f385 8811 	msr	BASEPRI, r5
    fa9e:	f3bf 8f6f 	isb	sy
		}
	}
}
    faa2:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
    faa4:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
    faa6:	42b2      	cmp	r2, r6
    faa8:	60a1      	str	r1, [r4, #8]
    faaa:	d0da      	beq.n	fa62 <z_add_timeout+0x32>
    faac:	6812      	ldr	r2, [r2, #0]
    faae:	e7d7      	b.n	fa60 <z_add_timeout+0x30>
    fab0:	20010d28 	.word	0x20010d28

0000fab4 <z_timeout_remaining>:

	return ret;
}

s32_t z_timeout_remaining(struct _timeout *timeout)
{
    fab4:	b538      	push	{r3, r4, r5, lr}
	s32_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
    fab6:	6804      	ldr	r4, [r0, #0]
    fab8:	b314      	cbz	r4, fb00 <z_timeout_remaining+0x4c>
	__asm__ volatile(
    faba:	f04f 0320 	mov.w	r3, #32
    fabe:	f3ef 8111 	mrs	r1, BASEPRI
    fac2:	f383 8811 	msr	BASEPRI, r3
    fac6:	f3bf 8f6f 	isb	sy
	return list->head == list;
    faca:	4a0e      	ldr	r2, [pc, #56]	; (fb04 <z_timeout_remaining+0x50>)
    facc:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    face:	4293      	cmp	r3, r2
    fad0:	d014      	beq.n	fafc <z_timeout_remaining+0x48>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    fad2:	6852      	ldr	r2, [r2, #4]
    fad4:	2400      	movs	r4, #0
		return 0;
	}

	LOCKED(&timeout_lock) {
		for (struct _timeout *t = first(); t != NULL; t = next(t)) {
    fad6:	b93b      	cbnz	r3, fae8 <z_timeout_remaining+0x34>
	__asm__ volatile(
    fad8:	f381 8811 	msr	BASEPRI, r1
    fadc:	f3bf 8f6f 	isb	sy
				break;
			}
		}
	}

	return ticks - elapsed();
    fae0:	f7ff ff60 	bl	f9a4 <elapsed>
    fae4:	1a20      	subs	r0, r4, r0
}
    fae6:	bd38      	pop	{r3, r4, r5, pc}
			ticks += t->dticks;
    fae8:	689d      	ldr	r5, [r3, #8]
			if (timeout == t) {
    faea:	4283      	cmp	r3, r0
			ticks += t->dticks;
    faec:	442c      	add	r4, r5
			if (timeout == t) {
    faee:	d0f3      	beq.n	fad8 <z_timeout_remaining+0x24>
    faf0:	2b00      	cmp	r3, #0
    faf2:	d0f1      	beq.n	fad8 <z_timeout_remaining+0x24>
	return (node == list->tail) ? NULL : node->next;
    faf4:	4293      	cmp	r3, r2
    faf6:	d0ef      	beq.n	fad8 <z_timeout_remaining+0x24>
    faf8:	681b      	ldr	r3, [r3, #0]
    fafa:	e7ec      	b.n	fad6 <z_timeout_remaining+0x22>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fafc:	2400      	movs	r4, #0
    fafe:	e7eb      	b.n	fad8 <z_timeout_remaining+0x24>
		return 0;
    fb00:	4620      	mov	r0, r4
    fb02:	e7f0      	b.n	fae6 <z_timeout_remaining+0x32>
    fb04:	20010d28 	.word	0x20010d28

0000fb08 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
    fb08:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
    fb0c:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    fb0e:	f7ff fb89 	bl	f224 <z_time_slice>
	__asm__ volatile(
    fb12:	f04f 0320 	mov.w	r3, #32
    fb16:	f3ef 8511 	mrs	r5, BASEPRI
    fb1a:	f383 8811 	msr	BASEPRI, r3
    fb1e:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    fb22:	4e21      	ldr	r6, [pc, #132]	; (fba8 <z_clock_announce+0xa0>)
    fb24:	4f21      	ldr	r7, [pc, #132]	; (fbac <z_clock_announce+0xa4>)
	return list->head == list;
    fb26:	f8df 9088 	ldr.w	r9, [pc, #136]	; fbb0 <z_clock_announce+0xa8>
    fb2a:	6034      	str	r4, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
    fb2c:	46b8      	mov	r8, r7
    fb2e:	f8d9 4000 	ldr.w	r4, [r9]
    fb32:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fb34:	454c      	cmp	r4, r9
    fb36:	e9d7 bc00 	ldrd	fp, ip, [r7]
    fb3a:	d005      	beq.n	fb48 <z_clock_announce+0x40>
    fb3c:	b124      	cbz	r4, fb48 <z_clock_announce+0x40>
    fb3e:	68a3      	ldr	r3, [r4, #8]
    fb40:	4293      	cmp	r3, r2
    fb42:	dd14      	ble.n	fb6e <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    fb44:	1a9b      	subs	r3, r3, r2
    fb46:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
    fb48:	eb1b 0002 	adds.w	r0, fp, r2
    fb4c:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
	announce_remaining = 0;
    fb50:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
    fb52:	e9c8 0100 	strd	r0, r1, [r8]
	announce_remaining = 0;
    fb56:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
    fb58:	f7ff ff42 	bl	f9e0 <next_timeout>
    fb5c:	4621      	mov	r1, r4
    fb5e:	f7f9 fedf 	bl	9920 <z_clock_set_timeout>
	__asm__ volatile(
    fb62:	f385 8811 	msr	BASEPRI, r5
    fb66:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    fb6a:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
    fb6e:	eb1b 0003 	adds.w	r0, fp, r3
    fb72:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
    fb76:	1ad3      	subs	r3, r2, r3
    fb78:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
    fb7a:	2300      	movs	r3, #0
		curr_tick += dt;
    fb7c:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
    fb80:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
    fb82:	4620      	mov	r0, r4
    fb84:	f7ff ff18 	bl	f9b8 <remove_timeout>
    fb88:	f385 8811 	msr	BASEPRI, r5
    fb8c:	f3bf 8f6f 	isb	sy
		t->fn(t);
    fb90:	68e3      	ldr	r3, [r4, #12]
    fb92:	4798      	blx	r3
	__asm__ volatile(
    fb94:	f04f 0320 	mov.w	r3, #32
    fb98:	f3ef 8511 	mrs	r5, BASEPRI
    fb9c:	f383 8811 	msr	BASEPRI, r3
    fba0:	f3bf 8f6f 	isb	sy
#endif

#ifdef SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    fba4:	e7c3      	b.n	fb2e <z_clock_announce+0x26>
    fba6:	bf00      	nop
    fba8:	2000569c 	.word	0x2000569c
    fbac:	20002050 	.word	0x20002050
    fbb0:	20010d28 	.word	0x20010d28

0000fbb4 <z_tick_get>:
{
	can_wait_forever = 1;
}

s64_t z_tick_get(void)
{
    fbb4:	e92d 4818 	stmdb	sp!, {r3, r4, fp, lr}
    fbb8:	f04f 0320 	mov.w	r3, #32
    fbbc:	f3ef 8411 	mrs	r4, BASEPRI
    fbc0:	f383 8811 	msr	BASEPRI, r3
    fbc4:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
    fbc8:	f7f9 fee6 	bl	9998 <z_clock_elapsed>
    fbcc:	4b07      	ldr	r3, [pc, #28]	; (fbec <z_tick_get+0x38>)
    fbce:	e9d3 2300 	ldrd	r2, r3, [r3]
    fbd2:	eb12 0b00 	adds.w	fp, r2, r0
    fbd6:	f143 0c00 	adc.w	ip, r3, #0
    fbda:	4658      	mov	r0, fp
    fbdc:	4661      	mov	r1, ip
	__asm__ volatile(
    fbde:	f384 8811 	msr	BASEPRI, r4
    fbe2:	f3bf 8f6f 	isb	sy
	}
	return t;
}
    fbe6:	e8bd 8818 	ldmia.w	sp!, {r3, r4, fp, pc}
    fbea:	bf00      	nop
    fbec:	20002050 	.word	0x20002050

0000fbf0 <k_poll_event_init>:
 */
static struct k_spinlock lock;

void k_poll_event_init(struct k_poll_event *event, u32_t type,
		       int mode, void *obj)
{
    fbf0:	b510      	push	{r4, lr}
	__ASSERT(type < (BIT(_POLL_NUM_TYPES)), "invalid type\n");
	__ASSERT(obj != NULL, "must provide an object\n");

	event->poller = NULL;
	/* event->tag is left uninitialized: the user will set it if needed */
	event->type = type;
    fbf2:	7b44      	ldrb	r4, [r0, #13]
    fbf4:	f361 0403 	bfi	r4, r1, #0, #4
	event->state = K_POLL_STATE_NOT_READY;
	event->mode = mode;
    fbf8:	7b81      	ldrb	r1, [r0, #14]
	event->type = type;
    fbfa:	7344      	strb	r4, [r0, #13]
	event->mode = mode;
    fbfc:	f362 0141 	bfi	r1, r2, #1, #1
    fc00:	7381      	strb	r1, [r0, #14]
	event->poller = NULL;
    fc02:	2200      	movs	r2, #0
	event->state = K_POLL_STATE_NOT_READY;
    fc04:	68c1      	ldr	r1, [r0, #12]
	event->poller = NULL;
    fc06:	6082      	str	r2, [r0, #8]
	event->state = K_POLL_STATE_NOT_READY;
    fc08:	4a02      	ldr	r2, [pc, #8]	; (fc14 <k_poll_event_init+0x24>)
    fc0a:	400a      	ands	r2, r1
	event->unused = 0U;
	event->obj = obj;
    fc0c:	e9c0 2303 	strd	r2, r3, [r0, #12]
}
    fc10:	bd10      	pop	{r4, pc}
    fc12:	bf00      	nop
    fc14:	00020fff 	.word	0x00020fff

0000fc18 <z_impl_k_poll>:
	event->poller = NULL;
	event->state |= state;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events, s32_t timeout)
{
    fc18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__ASSERT(num_events > 0, "zero events\n");

	int last_registered = -1, rc;
	k_spinlock_key_t key;

	struct _poller poller = { .thread = _current, .is_polling = true, };
    fc1c:	4b49      	ldr	r3, [pc, #292]	; (fd44 <z_impl_k_poll+0x12c>)
{
    fc1e:	b085      	sub	sp, #20
	struct _poller poller = { .thread = _current, .is_polling = true, };
    fc20:	689b      	ldr	r3, [r3, #8]
    fc22:	9300      	str	r3, [sp, #0]

	/* find events whose condition is already fulfilled */
	for (int ii = 0; ii < num_events; ii++) {
    fc24:	2600      	movs	r6, #0
	struct _poller poller = { .thread = _current, .is_polling = true, };
    fc26:	2301      	movs	r3, #1
{
    fc28:	4607      	mov	r7, r0
    fc2a:	468a      	mov	sl, r1
    fc2c:	4690      	mov	r8, r2
	struct _poller poller = { .thread = _current, .is_polling = true, };
    fc2e:	f88d 3004 	strb.w	r3, [sp, #4]
	for (int ii = 0; ii < num_events; ii++) {
    fc32:	4604      	mov	r4, r0
	int last_registered = -1, rc;
    fc34:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	event->poller = NULL;
    fc38:	46b1      	mov	r9, r6
	for (int ii = 0; ii < num_events; ii++) {
    fc3a:	4556      	cmp	r6, sl
    fc3c:	db17      	blt.n	fc6e <z_impl_k_poll+0x56>
	__asm__ volatile(
    fc3e:	f04f 0320 	mov.w	r3, #32
    fc42:	f3ef 8611 	mrs	r6, BASEPRI
    fc46:	f383 8811 	msr	BASEPRI, r3
    fc4a:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
    fc4e:	f89d 3004 	ldrb.w	r3, [sp, #4]
    fc52:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    fc56:	2b00      	cmp	r3, #0
    fc58:	d152      	bne.n	fd00 <z_impl_k_poll+0xe8>
	 * we've already know the return code (-EAGAIN), and even if they are
	 * added to the list of events that occurred, the user has to check the
	 * return code first, which invalidates the whole list of event states.
	 */
	key = k_spin_lock(&lock);
	clear_event_registrations(events, last_registered, key);
    fc5a:	4632      	mov	r2, r6
    fc5c:	4629      	mov	r1, r5
    fc5e:	4638      	mov	r0, r7
    fc60:	f006 f9aa 	bl	15fb8 <clear_event_registrations>
	__asm__ volatile(
    fc64:	f386 8811 	msr	BASEPRI, r6
    fc68:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	return swap_rc;
    fc6c:	e054      	b.n	fd18 <z_impl_k_poll+0x100>
	__asm__ volatile(
    fc6e:	f04f 0320 	mov.w	r3, #32
    fc72:	f3ef 8b11 	mrs	fp, BASEPRI
    fc76:	f383 8811 	msr	BASEPRI, r3
    fc7a:	f3bf 8f6f 	isb	sy
	switch (event->type) {
    fc7e:	7b63      	ldrb	r3, [r4, #13]
    fc80:	f003 030f 	and.w	r3, r3, #15
    fc84:	2b02      	cmp	r3, #2
    fc86:	d003      	beq.n	fc90 <z_impl_k_poll+0x78>
    fc88:	2b04      	cmp	r3, #4
    fc8a:	d004      	beq.n	fc96 <z_impl_k_poll+0x7e>
    fc8c:	2b01      	cmp	r3, #1
    fc8e:	d117      	bne.n	fcc0 <z_impl_k_poll+0xa8>
		if (event->signal->signaled != 0U) {
    fc90:	6922      	ldr	r2, [r4, #16]
    fc92:	6892      	ldr	r2, [r2, #8]
    fc94:	e001      	b.n	fc9a <z_impl_k_poll+0x82>
    fc96:	6922      	ldr	r2, [r4, #16]
		if (!k_queue_is_empty(event->queue)) {
    fc98:	6812      	ldr	r2, [r2, #0]
		if (event->signal->signaled != 0U) {
    fc9a:	b18a      	cbz	r2, fcc0 <z_impl_k_poll+0xa8>
	event->state |= state;
    fc9c:	68e2      	ldr	r2, [r4, #12]
	event->poller = NULL;
    fc9e:	f8c4 9008 	str.w	r9, [r4, #8]
	event->state |= state;
    fca2:	f3c2 3104 	ubfx	r1, r2, #12, #5
    fca6:	430b      	orrs	r3, r1
    fca8:	f363 3210 	bfi	r2, r3, #12, #5
    fcac:	60e2      	str	r2, [r4, #12]
			poller.is_polling = false;
    fcae:	f88d 9004 	strb.w	r9, [sp, #4]
	__asm__ volatile(
    fcb2:	f38b 8811 	msr	BASEPRI, fp
    fcb6:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
    fcba:	3601      	adds	r6, #1
    fcbc:	3414      	adds	r4, #20
    fcbe:	e7bc      	b.n	fc3a <z_impl_k_poll+0x22>
		} else if (timeout != K_NO_WAIT && poller.is_polling) {
    fcc0:	f1b8 0f00 	cmp.w	r8, #0
    fcc4:	d0f5      	beq.n	fcb2 <z_impl_k_poll+0x9a>
    fcc6:	f89d 2004 	ldrb.w	r2, [sp, #4]
    fcca:	2a00      	cmp	r2, #0
    fccc:	d0f1      	beq.n	fcb2 <z_impl_k_poll+0x9a>
	switch (event->type) {
    fcce:	2b02      	cmp	r3, #2
    fcd0:	d007      	beq.n	fce2 <z_impl_k_poll+0xca>
    fcd2:	2b04      	cmp	r3, #4
    fcd4:	d00f      	beq.n	fcf6 <z_impl_k_poll+0xde>
    fcd6:	2b01      	cmp	r3, #1
    fcd8:	d109      	bne.n	fcee <z_impl_k_poll+0xd6>
		add_event(&event->signal->poll_events, event, poller);
    fcda:	466a      	mov	r2, sp
    fcdc:	4621      	mov	r1, r4
    fcde:	6920      	ldr	r0, [r4, #16]
    fce0:	e003      	b.n	fcea <z_impl_k_poll+0xd2>
		add_event(&event->sem->poll_events, event, poller);
    fce2:	6920      	ldr	r0, [r4, #16]
    fce4:	466a      	mov	r2, sp
    fce6:	4621      	mov	r1, r4
    fce8:	3010      	adds	r0, #16
		add_event(&event->signal->poll_events, event, poller);
    fcea:	f006 f9bb 	bl	16064 <add_event>
	event->poller = poller;
    fcee:	f8c4 d008 	str.w	sp, [r4, #8]
				++last_registered;
    fcf2:	3501      	adds	r5, #1
    fcf4:	e7dd      	b.n	fcb2 <z_impl_k_poll+0x9a>
		add_event(&event->queue->poll_events, event, poller);
    fcf6:	6920      	ldr	r0, [r4, #16]
    fcf8:	466a      	mov	r2, sp
    fcfa:	4621      	mov	r1, r4
    fcfc:	3008      	adds	r0, #8
    fcfe:	e7f4      	b.n	fcea <z_impl_k_poll+0xd2>
	poller.is_polling = false;
    fd00:	2300      	movs	r3, #0
    fd02:	f88d 3004 	strb.w	r3, [sp, #4]
	if (timeout == K_NO_WAIT) {
    fd06:	f1b8 0f00 	cmp.w	r8, #0
    fd0a:	d109      	bne.n	fd20 <z_impl_k_poll+0x108>
    fd0c:	f386 8811 	msr	BASEPRI, r6
    fd10:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
    fd14:	f06f 040a 	mvn.w	r4, #10
}
    fd18:	4620      	mov	r0, r4
    fd1a:	b005      	add	sp, #20
    fd1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
    fd20:	aa02      	add	r2, sp, #8
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
    fd22:	4643      	mov	r3, r8
    fd24:	4631      	mov	r1, r6
    fd26:	4808      	ldr	r0, [pc, #32]	; (fd48 <z_impl_k_poll+0x130>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
    fd28:	e9cd 2202 	strd	r2, r2, [sp, #8]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
    fd2c:	f7ff fb3e 	bl	f3ac <z_pend_curr>
    fd30:	4604      	mov	r4, r0
	__asm__ volatile(
    fd32:	f04f 0320 	mov.w	r3, #32
    fd36:	f3ef 8611 	mrs	r6, BASEPRI
    fd3a:	f383 8811 	msr	BASEPRI, r3
    fd3e:	f3bf 8f6f 	isb	sy
    fd42:	e78a      	b.n	fc5a <z_impl_k_poll+0x42>
    fd44:	200055e4 	.word	0x200055e4
    fd48:	2000687d 	.word	0x2000687d

0000fd4c <run_fixed_patch_point_test>:
static void run_fixed_patch_point_test() {
    fd4c:	b508      	push	{r3, lr}
	load_local_fixed_patch(2);
    fd4e:	2002      	movs	r0, #2
    fd50:	f7f3 fac8 	bl	32e4 <load_local_fixed_patch>
}
    fd54:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	test_fixed_patch_point();
    fd58:	f7f3 bb84 	b.w	3464 <test_fixed_patch_point>

0000fd5c <run_eva_test>:
	run_ebpf_test();
    fd5c:	f7f3 ba9c 	b.w	3298 <run_ebpf_test>

0000fd60 <reset_patch>:
static void reset_patch() {
    fd60:	b508      	push	{r3, lr}
	show_hw_bkpt();
    fd62:	f7f2 fd89 	bl	2878 <show_hw_bkpt>
}
    fd66:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	clear_all_hw_bkpt();
    fd6a:	f7f2 be9f 	b.w	2aac <clear_all_hw_bkpt>

0000fd6e <test_patch_trigger>:
	trigger_debugmon();
    fd6e:	f000 b8cd 	b.w	ff0c <trigger_debugmon>

0000fd72 <shell_echo_str>:
static void shell_echo_str(char *str) {
    fd72:	b538      	push	{r3, r4, r5, lr}
    fd74:	1e45      	subs	r5, r0, #1
	for (const char *c = str; *c != '\0'; c++) {
    fd76:	f815 4f01 	ldrb.w	r4, [r5, #1]!
    fd7a:	b904      	cbnz	r4, fd7e <shell_echo_str+0xc>
}
    fd7c:	bd38      	pop	{r3, r4, r5, pc}
	if (c == '\n') {
    fd7e:	2c0a      	cmp	r4, #10
    fd80:	d102      	bne.n	fd88 <shell_echo_str+0x16>
		shell_put_char('\r');
    fd82:	200d      	movs	r0, #13
    fd84:	f000 f809 	bl	fd9a <shell_put_char>
		shell_put_char(c);
    fd88:	4620      	mov	r0, r4
    fd8a:	f000 f806 	bl	fd9a <shell_put_char>
    fd8e:	e7f2      	b.n	fd76 <shell_echo_str+0x4>

0000fd90 <shell_get_char>:
#include <misc/printk.h>
#include <console.h>

#pragma message("USE ZEPHYR_OS print-----------------------")

char shell_get_char() {
    fd90:	b508      	push	{r3, lr}
	return console_getchar();
    fd92:	f7f7 fbe3 	bl	755c <console_getchar>
}
    fd96:	b2c0      	uxtb	r0, r0
    fd98:	bd08      	pop	{r3, pc}

0000fd9a <shell_put_char>:

void shell_put_char(char c) {
	console_putchar(c);
    fd9a:	f7f7 bbd1 	b.w	7540 <console_putchar>

0000fd9e <log_print_porting>:
}

void log_print_porting(const char *fmt, va_list *args) {
	vprintk(fmt, *args);
    fd9e:	6809      	ldr	r1, [r1, #0]
    fda0:	f7f5 bb74 	b.w	548c <vprintk>

0000fda4 <FPB_Handler1>:
DECLARE_FPB_HANDLE(1);
    fda4:	e92d 500f 	stmdb	sp!, {r0, r1, r2, r3, ip, lr}
    fda8:	f01e 0f04 	tst.w	lr, #4
    fdac:	bf0c      	ite	eq
    fdae:	f3ef 8008 	mrseq	r0, MSP
    fdb2:	f3ef 8009 	mrsne	r0, PSP
    fdb6:	2101      	movs	r1, #1
    fdb8:	f000 f871 	bl	fe9e <leave_fpb_bpkt>
    fdbc:	e8bd 500f 	ldmia.w	sp!, {r0, r1, r2, r3, ip, lr}
    fdc0:	4770      	bx	lr

0000fdc2 <FPB_Handler2>:
DECLARE_FPB_HANDLE(2);
    fdc2:	e92d 500f 	stmdb	sp!, {r0, r1, r2, r3, ip, lr}
    fdc6:	f01e 0f04 	tst.w	lr, #4
    fdca:	bf0c      	ite	eq
    fdcc:	f3ef 8008 	mrseq	r0, MSP
    fdd0:	f3ef 8009 	mrsne	r0, PSP
    fdd4:	2102      	movs	r1, #2
    fdd6:	f000 f862 	bl	fe9e <leave_fpb_bpkt>
    fdda:	e8bd 500f 	ldmia.w	sp!, {r0, r1, r2, r3, ip, lr}
    fdde:	4770      	bx	lr

0000fde0 <FPB_Handler3>:
DECLARE_FPB_HANDLE(3);
    fde0:	e92d 500f 	stmdb	sp!, {r0, r1, r2, r3, ip, lr}
    fde4:	f01e 0f04 	tst.w	lr, #4
    fde8:	bf0c      	ite	eq
    fdea:	f3ef 8008 	mrseq	r0, MSP
    fdee:	f3ef 8009 	mrsne	r0, PSP
    fdf2:	2103      	movs	r1, #3
    fdf4:	f000 f853 	bl	fe9e <leave_fpb_bpkt>
    fdf8:	e8bd 500f 	ldmia.w	sp!, {r0, r1, r2, r3, ip, lr}
    fdfc:	4770      	bx	lr

0000fdfe <FPB_Handler4>:
DECLARE_FPB_HANDLE(4);
    fdfe:	e92d 500f 	stmdb	sp!, {r0, r1, r2, r3, ip, lr}
    fe02:	f01e 0f04 	tst.w	lr, #4
    fe06:	bf0c      	ite	eq
    fe08:	f3ef 8008 	mrseq	r0, MSP
    fe0c:	f3ef 8009 	mrsne	r0, PSP
    fe10:	2104      	movs	r1, #4
    fe12:	f000 f844 	bl	fe9e <leave_fpb_bpkt>
    fe16:	e8bd 500f 	ldmia.w	sp!, {r0, r1, r2, r3, ip, lr}
    fe1a:	4770      	bx	lr

0000fe1c <FPB_Handler5>:
	__asm__("PUSH {r0-r3, r12, lr}");
    fe1c:	e92d 500f 	stmdb	sp!, {r0, r1, r2, r3, ip, lr}
	__asm__("BL fpb_enable_callback");
    fe20:	f7f2 fe8c 	bl	2b3c <fpb_enable_callback>
	__asm__("MOV r5, r0");
    fe24:	4605      	mov	r5, r0
	__asm__("POP {r0-r3, r12, lr}");
    fe26:	e8bd 500f 	ldmia.w	sp!, {r0, r1, r2, r3, ip, lr}
	__asm__("MOV PC, r5");
    fe2a:	46af      	mov	pc, r5
}
    fe2c:	4770      	bx	lr

0000fe2e <calc_bpkt_addr>:
	uint32_t replace = (inst_addr & 0x2) == 0 ? 1 : 2;
    fe2e:	f010 0f02 	tst.w	r0, #2
	uint32_t fp_comp = (inst_addr & ~0x3) | 0x1 | (replace << 30);
    fe32:	bf14      	ite	ne
    fe34:	f04f 4300 	movne.w	r3, #2147483648	; 0x80000000
    fe38:	f04f 4380 	moveq.w	r3, #1073741824	; 0x40000000
    fe3c:	f020 0003 	bic.w	r0, r0, #3
    fe40:	4303      	orrs	r3, r0
	uint32_t final_addr = fp_comp & 0x1FFFFFFC;
    fe42:	f023 4060 	bic.w	r0, r3, #3758096384	; 0xe0000000
	if (replace == 0x2) {
    fe46:	0f9b      	lsrs	r3, r3, #30
    fe48:	f020 0003 	bic.w	r0, r0, #3
    fe4c:	2b02      	cmp	r3, #2
		final_addr |= 0x2;
    fe4e:	bf08      	it	eq
    fe50:	f040 0002 	orreq.w	r0, r0, #2
}
    fe54:	4770      	bx	lr

0000fe56 <calc_branch_instr>:
	uint32_t offset = (target_addr & (~0x1)) - (instr_addr & (~0x1)) - 4;
    fe56:	f020 0001 	bic.w	r0, r0, #1
    fe5a:	f021 0101 	bic.w	r1, r1, #1
    fe5e:	1a09      	subs	r1, r1, r0
    fe60:	3904      	subs	r1, #4
	uint8_t s  = (offset >> s_pos) & 0x01u;
    fe62:	0e0b      	lsrs	r3, r1, #24
	uint16_t lower_bl_instr =  ((0x02 << 14) | (j1 << 13) | (0x01 << 12) | (j2 << 11) | offset_11_lower);
    fe64:	ea83 50d1 	eor.w	r0, r3, r1, lsr #23
    fe68:	43c0      	mvns	r0, r0
    fe6a:	f000 0201 	and.w	r2, r0, #1
    fe6e:	ea83 5091 	eor.w	r0, r3, r1, lsr #22
    fe72:	43c0      	mvns	r0, r0
    fe74:	f000 0001 	and.w	r0, r0, #1
    fe78:	02c0      	lsls	r0, r0, #11
    fe7a:	ea40 3042 	orr.w	r0, r0, r2, lsl #13
	uint16_t upper_bl_instr =  ((0x1E << 11) | (s << 10) | offset_10_upper);
    fe7e:	f003 0301 	and.w	r3, r3, #1
	uint16_t offset_11_lower = ((offset) >> 1)  & 0x07FF; // UNCERTAIN about this!
    fe82:	f3c1 024a 	ubfx	r2, r1, #1, #11
	uint16_t offset_10_upper = (offset >> 12) & 0x03FF;
    fe86:	f3c1 3109 	ubfx	r1, r1, #12, #10
	uint16_t lower_bl_instr =  ((0x02 << 14) | (j1 << 13) | (0x01 << 12) | (j2 << 11) | offset_11_lower);
    fe8a:	4310      	orrs	r0, r2
	uint16_t upper_bl_instr =  ((0x1E << 11) | (s << 10) | offset_10_upper);
    fe8c:	ea41 2183 	orr.w	r1, r1, r3, lsl #10
	return ((upper_bl_instr << 16) | lower_bl_instr);
    fe90:	f441 4170 	orr.w	r1, r1, #61440	; 0xf000
    fe94:	f440 4010 	orr.w	r0, r0, #36864	; 0x9000
}
    fe98:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
    fe9c:	4770      	bx	lr

0000fe9e <leave_fpb_bpkt>:
uint32_t leave_fpb_bpkt(stack_context *ctx, int bpkt_idx) {
    fe9e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fea2:	008c      	lsls	r4, r1, #2
    fea4:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
    fea8:	f504 5400 	add.w	r4, r4, #8192	; 0x2000
    feac:	4605      	mov	r5, r0
	uint32_t inst_addr = FPB->COMP[bpkt_idx] & (~0x1);
    feae:	68a0      	ldr	r0, [r4, #8]
	ebpf_patch *patch = get_dynamic_patch_by_bpkt(inst_addr);
    feb0:	f020 0001 	bic.w	r0, r0, #1
uint32_t leave_fpb_bpkt(stack_context *ctx, int bpkt_idx) {
    feb4:	4688      	mov	r8, r1
	ebpf_patch *patch = get_dynamic_patch_by_bpkt(inst_addr);
    feb6:	f7f3 fbd3 	bl	3660 <get_dynamic_patch_by_bpkt>
	if (patch != NULL) {
    feba:	4606      	mov	r6, r0
    febc:	b1b8      	cbz	r0, feee <leave_fpb_bpkt+0x50>
		profile_start(EV1);
    febe:	2001      	movs	r0, #1
    fec0:	f7f3 fc66 	bl	3790 <profile_start>
		ret = run_ebpf_filter(patch, args, sizeof(ebpf_args_frame));
    fec4:	2210      	movs	r2, #16
    fec6:	4630      	mov	r0, r6
    fec8:	4629      	mov	r1, r5
    feca:	f000 f82e 	bl	ff2a <run_ebpf_filter>
    fece:	4607      	mov	r7, r0
    fed0:	460e      	mov	r6, r1
		profile_end(EV1);
    fed2:	2001      	movs	r0, #1
    fed4:	f7f3 fc66 	bl	37a4 <profile_end>
		uint32_t ret_code = ret & 0x00000000ffffffff;
    fed8:	4638      	mov	r0, r7
		if (op == FILTER_PASS) {
    feda:	b92e      	cbnz	r6, fee8 <leave_fpb_bpkt+0x4a>
			fpb_disable_cur_inst(bpkt_idx);
    fedc:	4640      	mov	r0, r8
    fede:	f7f2 fe05 	bl	2aec <fpb_disable_cur_inst>
			return FPB->COMP[bpkt_idx];
    fee2:	68a0      	ldr	r0, [r4, #8]
}
    fee4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else if (op == FILTER_DROP) {
    fee8:	2e01      	cmp	r6, #1
    feea:	d102      	bne.n	fef2 <leave_fpb_bpkt+0x54>
			*(volatile uint32_t *) &(ctx->r0) = ret_code;
    feec:	602f      	str	r7, [r5, #0]
	return ctx->lr;
    feee:	6968      	ldr	r0, [r5, #20]
    fef0:	e7f8      	b.n	fee4 <leave_fpb_bpkt+0x46>
		} else if (op == FILTER_REDIRECT) { // redirect lr to other address
    fef2:	2e02      	cmp	r6, #2
    fef4:	d1fb      	bne.n	feee <leave_fpb_bpkt+0x50>
    fef6:	e7f5      	b.n	fee4 <leave_fpb_bpkt+0x46>

0000fef8 <__debug_monitor>:
	__asm__ __volatile__("and r0, lr, #4");
    fef8:	f00e 0004 	and.w	r0, lr, #4
	__asm__ __volatile__("cmp r0, #0");
    fefc:	2800      	cmp	r0, #0
	__asm__ __volatile__("ite eq");
    fefe:	bf0c      	ite	eq
	__asm__ __volatile__("mrseq r0, msp");
    ff00:	f3ef 8008 	mrseq	r0, MSP
	__asm__ __volatile__("mrsne r0, psp");
    ff04:	f3ef 8009 	mrsne	r0, PSP
	__asm__ __volatile__("b leave_debug_monitor");
    ff08:	f7f2 be32 	b.w	2b70 <leave_debug_monitor>

0000ff0c <trigger_debugmon>:

void trigger_debugmon(void) {
	//test_func();
	//RawBuggyFunc();
	test_freertos_cve();
    ff0c:	f7f2 bc94 	b.w	2838 <test_freertos_cve>

0000ff10 <fixed_patch_point_hanlder>:
	__asm volatile("PUSH {r0, lr}");
    ff10:	b501      	push	{r0, lr}
	__asm volatile("MRS r0, CONTROL");
    ff12:	f3ef 8014 	mrs	r0, CONTROL
	__asm volatile("TST r0, #2");
    ff16:	f010 0f02 	tst.w	r0, #2
	__asm volatile("ITE EQ");
    ff1a:	bf0c      	ite	eq
	__asm volatile("MRSEQ r0, MSP");
    ff1c:	f3ef 8008 	mrseq	r0, MSP
	__asm volatile("MRSNE r0, PSP");
    ff20:	f3ef 8009 	mrsne	r0, PSP
	__asm volatile("BL dispatch_fixed_patch_point");
    ff24:	f7f3 faac 	bl	3480 <dispatch_fixed_patch_point>
	__asm volatile("POP {r0, pc}");
    ff28:	bd01      	pop	{r0, pc}

0000ff2a <run_ebpf_filter>:

uint64_t run_ebpf_filter(ebpf_patch *patch, void *args, int args_size) {
	if (patch->vm->use_jit) {
    ff2a:	6840      	ldr	r0, [r0, #4]
    ff2c:	7d03      	ldrb	r3, [r0, #20]
uint64_t run_ebpf_filter(ebpf_patch *patch, void *args, int args_size) {
    ff2e:	b430      	push	{r4, r5}
    ff30:	460c      	mov	r4, r1
	if (patch->vm->use_jit) {
    ff32:	b123      	cbz	r3, ff3e <run_ebpf_filter+0x14>
		// disable mpu
		// arm_core_mpu_disable();
		return patch->vm->jit_func(args, args_size);
    ff34:	68c3      	ldr	r3, [r0, #12]
    ff36:	b291      	uxth	r1, r2
    ff38:	4620      	mov	r0, r4
	} else {
		return ebpf_vm_exec(patch->vm, args, args_size);
	}
    ff3a:	bc30      	pop	{r4, r5}
		return patch->vm->jit_func(args, args_size);
    ff3c:	4718      	bx	r3
    ff3e:	bc30      	pop	{r4, r5}
		return ebpf_vm_exec(patch->vm, args, args_size);
    ff40:	f000 b88a 	b.w	10058 <ebpf_vm_exec>

0000ff44 <start_patch_service>:
// 	//pthread_join(task, NULL);
// 	return true;
// }
// #endif

bool start_patch_service() {
    ff44:	b508      	push	{r3, lr}
	init_patch_sys();
    ff46:	f7f3 fb39 	bl	35bc <init_patch_sys>
	// 	return false;
	// }

	// wait_for_patch();
	return false;
}
    ff4a:	2000      	movs	r0, #0
    ff4c:	bd08      	pop	{r3, pc}

0000ff4e <debug_log>:

#ifdef DEBUG

extern void log_print_porting(const char *fmt, va_list *args);

void debug_log(const char *fmt, ...) {
    ff4e:	b40f      	push	{r0, r1, r2, r3}
    ff50:	b507      	push	{r0, r1, r2, lr}
    ff52:	ab04      	add	r3, sp, #16
	va_list args;
	va_start(args, fmt);
	log_print_porting(fmt, &args);
    ff54:	a901      	add	r1, sp, #4
void debug_log(const char *fmt, ...) {
    ff56:	f853 0b04 	ldr.w	r0, [r3], #4
	va_start(args, fmt);
    ff5a:	9301      	str	r3, [sp, #4]
	log_print_porting(fmt, &args);
    ff5c:	f7ff ff1f 	bl	fd9e <log_print_porting>
	va_end(args);
}
    ff60:	b003      	add	sp, #12
    ff62:	f85d eb04 	ldr.w	lr, [sp], #4
    ff66:	b004      	add	sp, #16
    ff68:	4770      	bx	lr

0000ff6a <str2int>:
void debug_log(const char *fmt, ...) {}
#endif // end DEBUG

int str2int(char *str) {
	int val = 0;
	for (const char *c = str; *c != '\0'; c++) {
    ff6a:	1e42      	subs	r2, r0, #1
		val *= 10;
    ff6c:	210a      	movs	r1, #10
	int val = 0;
    ff6e:	2000      	movs	r0, #0
	for (const char *c = str; *c != '\0'; c++) {
    ff70:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    ff74:	b903      	cbnz	r3, ff78 <str2int+0xe>
		val += *c - '0';
	}
	return val;
}
    ff76:	4770      	bx	lr
		val += *c - '0';
    ff78:	3b30      	subs	r3, #48	; 0x30
    ff7a:	fb01 3000 	mla	r0, r1, r0, r3
    ff7e:	e7f7      	b.n	ff70 <str2int+0x6>

0000ff80 <calc_bpkt_pc>:
}


uint32_t calc_bpkt_pc(uint32_t inst_addr) {
#ifdef SYS_CORTEX_M4
	uint32_t inst_val = (uint32_t) (inst_addr & ~(0x1));
    ff80:	f020 0001 	bic.w	r0, r0, #1
	uint16_t thumb_inst = *(uint16_t *) inst_val;
	// DEBUG_LOG("calc_bpkt_pc 0x%08x -> 0x%08x\n", inst_addr, thumb_inst);
	if ((uint32_t) thumb_inst >= 0xe800) {
    ff84:	8803      	ldrh	r3, [r0, #0]
    ff86:	f5b3 4f68 	cmp.w	r3, #59392	; 0xe800
		return inst_val + 4;
    ff8a:	bf2c      	ite	cs
    ff8c:	3004      	addcs	r0, #4
	} else {
		return inst_val + 2;
    ff8e:	3002      	addcc	r0, #2
	}
#endif

	return inst_addr;
}
    ff90:	4770      	bx	lr

0000ff92 <little_endian_16_bit>:
}


uint32_t little_endian_16_bit(uint32_t val) {
	return ((val & 0xFFFF0000) >> 16) | ((val & 0x0000FFFF) << 16);
}
    ff92:	ea4f 4030 	mov.w	r0, r0, ror #16
    ff96:	4770      	bx	lr

0000ff98 <ebpf_free>:
	my_os_free(rmem);
    ff98:	f005 bd12 	b.w	159c0 <k_free>

0000ff9c <iot_print_log>:
	DEBUG_LOG(str);
    ff9c:	f7ff bfd7 	b.w	ff4e <debug_log>

0000ffa0 <bounds_check.isra.0>:
	}

	return ret;
}

bool bounds_check(const struct ebpf_vm *vm, void *addr, int size, const char *type, u16 cur_pc, void *mem, size_t mem_len, void *stack) {
    ffa0:	b570      	push	{r4, r5, r6, lr}
    ffa2:	9c05      	ldr	r4, [sp, #20]
	if (!vm->bounds_check_enabled) {
    ffa4:	b1a0      	cbz	r0, ffd0 <bounds_check.isra.0+0x30>
		return true;
	}
	if (mem && (addr >= mem && ((u32*)addr + size) <= ((u32*)mem + mem_len))) {
    ffa6:	b143      	cbz	r3, ffba <bounds_check.isra.0+0x1a>
    ffa8:	428b      	cmp	r3, r1
    ffaa:	d806      	bhi.n	ffba <bounds_check.isra.0+0x1a>
    ffac:	9e04      	ldr	r6, [sp, #16]
    ffae:	eb01 0582 	add.w	r5, r1, r2, lsl #2
    ffb2:	eb03 0386 	add.w	r3, r3, r6, lsl #2
    ffb6:	429d      	cmp	r5, r3
    ffb8:	d909      	bls.n	ffce <bounds_check.isra.0+0x2e>
		return true;
	}
	else if (addr >= stack && ((u32*)addr + size) <= ((u32*)stack + STACK_SIZE)) {
    ffba:	42a1      	cmp	r1, r4
    ffbc:	d30a      	bcc.n	ffd4 <bounds_check.isra.0+0x34>
    ffbe:	f504 7000 	add.w	r0, r4, #512	; 0x200
    ffc2:	eb01 0182 	add.w	r1, r1, r2, lsl #2
    ffc6:	4288      	cmp	r0, r1
    ffc8:	bf34      	ite	cc
    ffca:	2000      	movcc	r0, #0
    ffcc:	2001      	movcs	r0, #1
		//fprintf(stderr, "uBPF error: out of bounds memory %s at PC %u, addr %p, size %d\n", type, cur_pc, addr, size);
		//fprintf(stderr, "mem %p/%zd stack %p/%d\n", mem, mem_len, stack, STACK_SIZE);
		return false;
	}
	return true;
}
    ffce:	bd70      	pop	{r4, r5, r6, pc}
		return true;
    ffd0:	2001      	movs	r0, #1
    ffd2:	e7fc      	b.n	ffce <bounds_check.isra.0+0x2e>
		return false;
    ffd4:	2000      	movs	r0, #0
    ffd6:	e7fa      	b.n	ffce <bounds_check.isra.0+0x2e>

0000ffd8 <ebpf_register>:
{
    ffd8:	b570      	push	{r4, r5, r6, lr}
    ffda:	461e      	mov	r6, r3
	if (vm->helper_func == NULL) {
    ffdc:	6883      	ldr	r3, [r0, #8]
{
    ffde:	4604      	mov	r4, r0
    ffe0:	460d      	mov	r5, r1
	if (vm->helper_func == NULL) {
    ffe2:	b913      	cbnz	r3, ffea <ebpf_register+0x12>
		vm->helper_func = use_default_helper_func();
    ffe4:	f7f3 fc90 	bl	3908 <use_default_helper_func>
    ffe8:	60a0      	str	r0, [r4, #8]
	if (idx >= MAX_EXT_FUNCS) {
    ffea:	2d0b      	cmp	r5, #11
	vm->helper_func->ext_funcs[idx] = (ext_func)fn;
    ffec:	bf9f      	itttt	ls
    ffee:	68a3      	ldrls	r3, [r4, #8]
    fff0:	681a      	ldrls	r2, [r3, #0]
	return 0;
    fff2:	2000      	movls	r0, #0
	vm->helper_func->ext_funcs[idx] = (ext_func)fn;
    fff4:	f842 6025 	strls.w	r6, [r2, r5, lsl #2]
		return -1;
    fff8:	bf88      	it	hi
    fffa:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
}
    fffe:	bd70      	pop	{r4, r5, r6, pc}

00010000 <init_iot_ebpf_helpers>:
void init_iot_ebpf_helpers(struct ebpf_vm *vm) {
   10000:	b510      	push	{r4, lr}
   10002:	4604      	mov	r4, r0
	vm->helper_func = use_default_helper_func();
   10004:	f7f3 fc80 	bl	3908 <use_default_helper_func>
   10008:	60a0      	str	r0, [r4, #8]
	set_default_helpers(vm);
   1000a:	4620      	mov	r0, r4
}
   1000c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	set_default_helpers(vm);
   10010:	f7f3 bc90 	b.w	3934 <set_default_helpers>

00010014 <init_ebpf_vm>:
ebpf_vm *init_ebpf_vm(const uint8_t *code, uint32_t code_len) {
   10014:	b570      	push	{r4, r5, r6, lr}
   10016:	4606      	mov	r6, r0
	ebpf_vm *vm = (ebpf_vm *) ebpf_malloc(sizeof(ebpf_vm));
   10018:	2018      	movs	r0, #24
ebpf_vm *init_ebpf_vm(const uint8_t *code, uint32_t code_len) {
   1001a:	460d      	mov	r5, r1
	ebpf_vm *vm = (ebpf_vm *) ebpf_malloc(sizeof(ebpf_vm));
   1001c:	f7f3 fc08 	bl	3830 <ebpf_malloc>
	if (vm == NULL) {
   10020:	4604      	mov	r4, r0
   10022:	b128      	cbz	r0, 10030 <init_ebpf_vm+0x1c>
	vm->num_insts = (u16) code_len / sizeof(vm->insts[0]);
   10024:	f3c5 05cc 	ubfx	r5, r5, #3, #13
	vm->insts = (struct ebpf_inst *) code;
   10028:	6006      	str	r6, [r0, #0]
	vm->num_insts = (u16) code_len / sizeof(vm->insts[0]);
   1002a:	8085      	strh	r5, [r0, #4]
	init_iot_ebpf_helpers(vm);
   1002c:	f7ff ffe8 	bl	10000 <init_iot_ebpf_helpers>
}
   10030:	4620      	mov	r0, r4
   10032:	bd70      	pop	{r4, r5, r6, pc}

00010034 <ebpf_vm_set_inst>:
void ebpf_vm_set_inst(struct ebpf_vm *vm, const uint8_t *code, uint32_t code_len) {
   10034:	b570      	push	{r4, r5, r6, lr}
   10036:	4604      	mov	r4, r0
   10038:	4615      	mov	r5, r2
   1003a:	460e      	mov	r6, r1
	vm->num_insts = (u16) code_len / sizeof(vm->insts[0]);
   1003c:	f3c5 05cc 	ubfx	r5, r5, #3, #13
__ssp_bos_icheck3(memset, void *, int)
   10040:	2212      	movs	r2, #18
   10042:	2100      	movs	r1, #0
   10044:	3006      	adds	r0, #6
   10046:	f7f2 f8d0 	bl	21ea <memset>
	vm->insts = (struct ebpf_inst *) code;
   1004a:	6026      	str	r6, [r4, #0]
	vm->num_insts = (u16) code_len / sizeof(vm->insts[0]);
   1004c:	80a5      	strh	r5, [r4, #4]
	init_iot_ebpf_helpers(vm);
   1004e:	4620      	mov	r0, r4
}
   10050:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	init_iot_ebpf_helpers(vm);
   10054:	f7ff bfd4 	b.w	10000 <init_iot_ebpf_helpers>

00010058 <ebpf_vm_exec>:
u64 ebpf_vm_exec(const struct ebpf_vm *vm, void *mem, u32 mem_len) {
   10058:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1005c:	b0c5      	sub	sp, #276	; 0x114
	const struct ebpf_inst *insts = vm->insts;
   1005e:	6803      	ldr	r3, [r0, #0]
   10060:	930a      	str	r3, [sp, #40]	; 0x28
u64 ebpf_vm_exec(const struct ebpf_vm *vm, void *mem, u32 mem_len) {
   10062:	4690      	mov	r8, r2
	reg[1] = (uintptr) mem;
   10064:	2300      	movs	r3, #0
	reg[10] = (uintptr) stack + sizeof(stack);
   10066:	aa44      	add	r2, sp, #272	; 0x110
	reg[1] = (uintptr) mem;
   10068:	e9cd 130e 	strd	r1, r3, [sp, #56]	; 0x38
	reg[10] = (uintptr) stack + sizeof(stack);
   1006c:	e9cd 2320 	strd	r2, r3, [sp, #128]	; 0x80
u64 ebpf_vm_exec(const struct ebpf_vm *vm, void *mem, u32 mem_len) {
   10070:	4606      	mov	r6, r0
   10072:	460f      	mov	r7, r1
			BOUNDS_CHECK_STORE(1);
   10074:	f10d 0b90 	add.w	fp, sp, #144	; 0x90
		const struct ebpf_inst *inst = &insts[pc++];
   10078:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1007a:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
		switch (inst->opcode) {
   1007e:	f812 2033 	ldrb.w	r2, [r2, r3, lsl #3]
		const struct ebpf_inst *inst = &insts[pc++];
   10082:	1c5d      	adds	r5, r3, #1
		switch (inst->opcode) {
   10084:	3a04      	subs	r2, #4
		const struct ebpf_inst *inst = &insts[pc++];
   10086:	b2ad      	uxth	r5, r5
		switch (inst->opcode) {
   10088:	2ad9      	cmp	r2, #217	; 0xd9
   1008a:	f200 80ec 	bhi.w	10266 <ebpf_vm_exec+0x20e>
   1008e:	e8df f012 	tbh	[pc, r2, lsl #1]
   10092:	00da      	.short	0x00da
   10094:	00ea06a9 	.word	0x00ea06a9
   10098:	00ea02f7 	.word	0x00ea02f7
   1009c:	00ea00ea 	.word	0x00ea00ea
   100a0:	00ec00ea 	.word	0x00ec00ea
   100a4:	00ea00ea 	.word	0x00ea00ea
   100a8:	00ea0307 	.word	0x00ea0307
   100ac:	00ea00ea 	.word	0x00ea00ea
   100b0:	010100ea 	.word	0x010100ea
   100b4:	00ea06c5 	.word	0x00ea06c5
   100b8:	0698031a 	.word	0x0698031a
   100bc:	00ea00ea 	.word	0x00ea00ea
   100c0:	011200ea 	.word	0x011200ea
   100c4:	00ea06ae 	.word	0x00ea06ae
   100c8:	00ea032a 	.word	0x00ea032a
   100cc:	00ea00ea 	.word	0x00ea00ea
   100d0:	012600ea 	.word	0x012600ea
   100d4:	00ea06d9 	.word	0x00ea06d9
   100d8:	00ea033d 	.word	0x00ea033d
   100dc:	00ea00ea 	.word	0x00ea00ea
   100e0:	013700ea 	.word	0x013700ea
   100e4:	00ea06ed 	.word	0x00ea06ed
   100e8:	00ea0352 	.word	0x00ea0352
   100ec:	00ea00ea 	.word	0x00ea00ea
   100f0:	014c00ea 	.word	0x014c00ea
   100f4:	00ea0704 	.word	0x00ea0704
   100f8:	00ea036a 	.word	0x00ea036a
   100fc:	00ea00ea 	.word	0x00ea00ea
   10100:	015e00ea 	.word	0x015e00ea
   10104:	00ea0718 	.word	0x00ea0718
   10108:	00ea037a 	.word	0x00ea037a
   1010c:	00ea00ea 	.word	0x00ea00ea
   10110:	017800ea 	.word	0x017800ea
   10114:	00ea0785 	.word	0x00ea0785
   10118:	00ea0394 	.word	0x00ea0394
   1011c:	00ea00ea 	.word	0x00ea00ea
   10120:	018900ea 	.word	0x018900ea
   10124:	00ea079f 	.word	0x00ea079f
   10128:	00ea03a5 	.word	0x00ea03a5
   1012c:	00ea00ea 	.word	0x00ea00ea
   10130:	019e00ea 	.word	0x019e00ea
   10134:	00ea07ba 	.word	0x00ea07ba
   10138:	00ea03ba 	.word	0x00ea03ba
   1013c:	00ea00ea 	.word	0x00ea00ea
   10140:	01af00ea 	.word	0x01af00ea
   10144:	00ea07ce 	.word	0x00ea07ce
   10148:	00ea03cb 	.word	0x00ea03cb
   1014c:	05ac052d 	.word	0x05ac052d
   10150:	01c40635 	.word	0x01c40635
   10154:	00ea07e5 	.word	0x00ea07e5
   10158:	00ea03e0 	.word	0x00ea03e0
   1015c:	05cd0543 	.word	0x05cd0543
   10160:	01d50656 	.word	0x01d50656
   10164:	00ea07f9 	.word	0x00ea07f9
   10168:	00ea03f9 	.word	0x00ea03f9
   1016c:	05ee0566 	.word	0x05ee0566
   10170:	01e90677 	.word	0x01e90677
   10174:	00ea080f 	.word	0x00ea080f
   10178:	00ea0418 	.word	0x00ea0418
   1017c:	0589050b 	.word	0x0589050b
   10180:	01fa060f 	.word	0x01fa060f
   10184:	00ea0822 	.word	0x00ea0822
   10188:	00ea0431 	.word	0x00ea0431
   1018c:	00ea00ea 	.word	0x00ea00ea
   10190:	020e00ea 	.word	0x020e00ea
   10194:	00ea088d 	.word	0x00ea088d
   10198:	00ea0450 	.word	0x00ea0450
   1019c:	00ea00ea 	.word	0x00ea00ea
   101a0:	00ea00ea 	.word	0x00ea00ea
   101a4:	00ea00ea 	.word	0x00ea00ea
   101a8:	00ea00ea 	.word	0x00ea00ea
   101ac:	00ea00ea 	.word	0x00ea00ea
   101b0:	021e00ea 	.word	0x021e00ea
   101b4:	00ea08a7 	.word	0x00ea08a7
   101b8:	00ea045e 	.word	0x00ea045e
   101bc:	00ea00ea 	.word	0x00ea00ea
   101c0:	023300ea 	.word	0x023300ea
   101c4:	00ea00ea 	.word	0x00ea00ea
   101c8:	00ea046e 	.word	0x00ea046e
   101cc:	00ea00ea 	.word	0x00ea00ea
   101d0:	024f00ea 	.word	0x024f00ea
   101d4:	00ea072f 	.word	0x00ea072f
   101d8:	00ea0485 	.word	0x00ea0485
   101dc:	00ea00ea 	.word	0x00ea00ea
   101e0:	026000ea 	.word	0x026000ea
   101e4:	00ea0743 	.word	0x00ea0743
   101e8:	00ea0496 	.word	0x00ea0496
   101ec:	00ea00ea 	.word	0x00ea00ea
   101f0:	027500ea 	.word	0x027500ea
   101f4:	00ea075a 	.word	0x00ea075a
   101f8:	00ea04ab 	.word	0x00ea04ab
   101fc:	00ea00ea 	.word	0x00ea00ea
   10200:	028300ea 	.word	0x028300ea
   10204:	00ea076e 	.word	0x00ea076e
   10208:	00ea04b6 	.word	0x00ea04b6
   1020c:	00ea00ea 	.word	0x00ea00ea
   10210:	029500ea 	.word	0x029500ea
   10214:	00ea0839 	.word	0x00ea0839
   10218:	00ea04c5 	.word	0x00ea04c5
   1021c:	00ea00ea 	.word	0x00ea00ea
   10220:	02a600ea 	.word	0x02a600ea
   10224:	00ea084c 	.word	0x00ea084c
   10228:	00ea04e5 	.word	0x00ea04e5
   1022c:	00ea00ea 	.word	0x00ea00ea
   10230:	00ea00ea 	.word	0x00ea00ea
   10234:	00ea0863 	.word	0x00ea0863
   10238:	00ea00ea 	.word	0x00ea00ea
   1023c:	00ea00ea 	.word	0x00ea00ea
   10240:	02ba00ea 	.word	0x02ba00ea
   10244:	0877      	.short	0x0877
			DST = (u32)DST + (u32)IMM;
   10246:	7863      	ldrb	r3, [r4, #1]
   10248:	6860      	ldr	r0, [r4, #4]
   1024a:	aa44      	add	r2, sp, #272	; 0x110
   1024c:	f003 030f 	and.w	r3, r3, #15
   10250:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10254:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   10258:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   1025c:	4402      	add	r2, r0
   1025e:	f843 2ce0 	str.w	r2, [r3, #-224]
   10262:	2300      	movs	r3, #0
   10264:	604b      	str	r3, [r1, #4]
			DST = (u64) (u32)IMM | ((u64) (u32)insts[pc++].imm << 32);
   10266:	462b      	mov	r3, r5
   10268:	e706      	b.n	10078 <ebpf_vm_exec+0x20>
			DST = (u32)DST + (u32)SRC;
   1026a:	7863      	ldrb	r3, [r4, #1]
   1026c:	a844      	add	r0, sp, #272	; 0x110
   1026e:	f003 020f 	and.w	r2, r3, #15
   10272:	a944      	add	r1, sp, #272	; 0x110
   10274:	091b      	lsrs	r3, r3, #4
   10276:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   1027a:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   1027e:	f852 0ce0 	ldr.w	r0, [r2, #-224]
   10282:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10286:	4403      	add	r3, r0
   10288:	f842 3ce0 	str.w	r3, [r2, #-224]
   1028c:	2300      	movs	r3, #0
   1028e:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   10292:	e7e8      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST - (u32)IMM;
   10294:	7863      	ldrb	r3, [r4, #1]
   10296:	6860      	ldr	r0, [r4, #4]
   10298:	aa44      	add	r2, sp, #272	; 0x110
   1029a:	f003 030f 	and.w	r3, r3, #15
   1029e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   102a2:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   102a6:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   102aa:	1a12      	subs	r2, r2, r0
   102ac:	f843 2ce0 	str.w	r2, [r3, #-224]
   102b0:	2300      	movs	r3, #0
   102b2:	604b      	str	r3, [r1, #4]
			break;
   102b4:	e7d7      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST - (u32)SRC;
   102b6:	7863      	ldrb	r3, [r4, #1]
   102b8:	a944      	add	r1, sp, #272	; 0x110
   102ba:	f003 020f 	and.w	r2, r3, #15
   102be:	091b      	lsrs	r3, r3, #4
   102c0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   102c4:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   102c8:	f852 1ce0 	ldr.w	r1, [r2, #-224]
   102cc:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   102d0:	1ac9      	subs	r1, r1, r3
   102d2:	2300      	movs	r3, #0
   102d4:	f842 1ce0 	str.w	r1, [r2, #-224]
   102d8:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   102dc:	e7c3      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST * (u32)IMM;
   102de:	7863      	ldrb	r3, [r4, #1]
   102e0:	aa44      	add	r2, sp, #272	; 0x110
   102e2:	f003 030f 	and.w	r3, r3, #15
   102e6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   102ea:	6862      	ldr	r2, [r4, #4]
   102ec:	f853 0ce0 	ldr.w	r0, [r3, #-224]
   102f0:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   102f4:	4342      	muls	r2, r0
   102f6:	f843 2ce0 	str.w	r2, [r3, #-224]
   102fa:	2300      	movs	r3, #0
   102fc:	604b      	str	r3, [r1, #4]
			break;
   102fe:	e7b2      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST * (u32)SRC;
   10300:	7863      	ldrb	r3, [r4, #1]
   10302:	a844      	add	r0, sp, #272	; 0x110
   10304:	f003 020f 	and.w	r2, r3, #15
   10308:	a944      	add	r1, sp, #272	; 0x110
   1030a:	091b      	lsrs	r3, r3, #4
   1030c:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10310:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   10314:	f853 0ce0 	ldr.w	r0, [r3, #-224]
   10318:	f852 3ce0 	ldr.w	r3, [r2, #-224]
   1031c:	4343      	muls	r3, r0
   1031e:	f842 3ce0 	str.w	r3, [r2, #-224]
   10322:	2300      	movs	r3, #0
   10324:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   10328:	e79d      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST / (u32)IMM;
   1032a:	7863      	ldrb	r3, [r4, #1]
   1032c:	6860      	ldr	r0, [r4, #4]
   1032e:	aa44      	add	r2, sp, #272	; 0x110
   10330:	f003 030f 	and.w	r3, r3, #15
   10334:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10338:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   1033c:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   10340:	fbb2 f2f0 	udiv	r2, r2, r0
   10344:	f843 2ce0 	str.w	r2, [r3, #-224]
   10348:	2300      	movs	r3, #0
   1034a:	604b      	str	r3, [r1, #4]
			break;
   1034c:	e78b      	b.n	10266 <ebpf_vm_exec+0x20e>
			if (SRC == 0) {
   1034e:	7863      	ldrb	r3, [r4, #1]
   10350:	a944      	add	r1, sp, #272	; 0x110
   10352:	091a      	lsrs	r2, r3, #4
   10354:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10358:	e952 9a38 	ldrd	r9, sl, [r2, #-224]	; 0xe0
   1035c:	ea59 020a 	orrs.w	r2, r9, sl
   10360:	f000 8743 	beq.w	111ea <ebpf_vm_exec+0x1192>
			DST = (u32)DST / (u32)SRC;
   10364:	f003 030f 	and.w	r3, r3, #15
   10368:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   1036c:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   10370:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   10374:	fbb2 f0f9 	udiv	r0, r2, r9
   10378:	f843 0ce0 	str.w	r0, [r3, #-224]
   1037c:	2300      	movs	r3, #0
   1037e:	604b      	str	r3, [r1, #4]
			break;
   10380:	e771      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST | (u32)IMM;
   10382:	7863      	ldrb	r3, [r4, #1]
   10384:	6860      	ldr	r0, [r4, #4]
   10386:	aa44      	add	r2, sp, #272	; 0x110
   10388:	f003 030f 	and.w	r3, r3, #15
   1038c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10390:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   10394:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   10398:	4302      	orrs	r2, r0
   1039a:	f843 2ce0 	str.w	r2, [r3, #-224]
   1039e:	2300      	movs	r3, #0
   103a0:	604b      	str	r3, [r1, #4]
			break;
   103a2:	e760      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST | (u32)SRC;
   103a4:	7863      	ldrb	r3, [r4, #1]
   103a6:	a844      	add	r0, sp, #272	; 0x110
   103a8:	f003 020f 	and.w	r2, r3, #15
   103ac:	a944      	add	r1, sp, #272	; 0x110
   103ae:	091b      	lsrs	r3, r3, #4
   103b0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   103b4:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   103b8:	f852 0ce0 	ldr.w	r0, [r2, #-224]
   103bc:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   103c0:	4303      	orrs	r3, r0
   103c2:	f842 3ce0 	str.w	r3, [r2, #-224]
   103c6:	2300      	movs	r3, #0
   103c8:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   103cc:	e74b      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST & (u32)IMM;
   103ce:	7863      	ldrb	r3, [r4, #1]
   103d0:	6860      	ldr	r0, [r4, #4]
   103d2:	aa44      	add	r2, sp, #272	; 0x110
   103d4:	f003 030f 	and.w	r3, r3, #15
   103d8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   103dc:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   103e0:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   103e4:	4002      	ands	r2, r0
   103e6:	f843 2ce0 	str.w	r2, [r3, #-224]
   103ea:	2300      	movs	r3, #0
   103ec:	604b      	str	r3, [r1, #4]
			break;
   103ee:	e73a      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST & (u32)SRC;
   103f0:	7863      	ldrb	r3, [r4, #1]
   103f2:	a844      	add	r0, sp, #272	; 0x110
   103f4:	f003 020f 	and.w	r2, r3, #15
   103f8:	a944      	add	r1, sp, #272	; 0x110
   103fa:	091b      	lsrs	r3, r3, #4
   103fc:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10400:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   10404:	f852 0ce0 	ldr.w	r0, [r2, #-224]
   10408:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   1040c:	4003      	ands	r3, r0
   1040e:	f842 3ce0 	str.w	r3, [r2, #-224]
   10412:	2300      	movs	r3, #0
   10414:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   10418:	e725      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST << (u32)IMM;
   1041a:	7863      	ldrb	r3, [r4, #1]
   1041c:	6860      	ldr	r0, [r4, #4]
   1041e:	aa44      	add	r2, sp, #272	; 0x110
   10420:	f003 030f 	and.w	r3, r3, #15
   10424:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10428:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   1042c:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   10430:	4082      	lsls	r2, r0
   10432:	f843 2ce0 	str.w	r2, [r3, #-224]
   10436:	2300      	movs	r3, #0
   10438:	604b      	str	r3, [r1, #4]
			break;
   1043a:	e714      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST << (u32)SRC;
   1043c:	7863      	ldrb	r3, [r4, #1]
   1043e:	a944      	add	r1, sp, #272	; 0x110
   10440:	f003 020f 	and.w	r2, r3, #15
   10444:	091b      	lsrs	r3, r3, #4
   10446:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   1044a:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   1044e:	f852 1ce0 	ldr.w	r1, [r2, #-224]
   10452:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10456:	4099      	lsls	r1, r3
   10458:	2300      	movs	r3, #0
   1045a:	f842 1ce0 	str.w	r1, [r2, #-224]
   1045e:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   10462:	e700      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST >> (u32)IMM;
   10464:	7863      	ldrb	r3, [r4, #1]
   10466:	6860      	ldr	r0, [r4, #4]
   10468:	aa44      	add	r2, sp, #272	; 0x110
   1046a:	f003 030f 	and.w	r3, r3, #15
   1046e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10472:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   10476:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   1047a:	40c2      	lsrs	r2, r0
   1047c:	f843 2ce0 	str.w	r2, [r3, #-224]
   10480:	2300      	movs	r3, #0
   10482:	604b      	str	r3, [r1, #4]
			break;
   10484:	e6ef      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST >> (u32)SRC;
   10486:	7863      	ldrb	r3, [r4, #1]
   10488:	a944      	add	r1, sp, #272	; 0x110
   1048a:	f003 020f 	and.w	r2, r3, #15
   1048e:	091b      	lsrs	r3, r3, #4
   10490:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10494:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   10498:	f852 1ce0 	ldr.w	r1, [r2, #-224]
   1049c:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   104a0:	40d9      	lsrs	r1, r3
   104a2:	2300      	movs	r3, #0
   104a4:	f842 1ce0 	str.w	r1, [r2, #-224]
   104a8:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   104ac:	e6db      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)-DST;
   104ae:	7863      	ldrb	r3, [r4, #1]
   104b0:	aa44      	add	r2, sp, #272	; 0x110
   104b2:	f003 030f 	and.w	r3, r3, #15
   104b6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   104ba:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   104be:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   104c2:	4252      	negs	r2, r2
   104c4:	f843 2ce0 	str.w	r2, [r3, #-224]
   104c8:	2300      	movs	r3, #0
   104ca:	604b      	str	r3, [r1, #4]
			break;
   104cc:	e6cb      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST % (u32)IMM;
   104ce:	7863      	ldrb	r3, [r4, #1]
   104d0:	6861      	ldr	r1, [r4, #4]
   104d2:	aa44      	add	r2, sp, #272	; 0x110
   104d4:	f003 030f 	and.w	r3, r3, #15
   104d8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   104dc:	f1a3 0ce0 	sub.w	ip, r3, #224	; 0xe0
   104e0:	f853 0ce0 	ldr.w	r0, [r3, #-224]
   104e4:	fbb0 f2f1 	udiv	r2, r0, r1
   104e8:	fb01 0212 	mls	r2, r1, r2, r0
   104ec:	f843 2ce0 	str.w	r2, [r3, #-224]
   104f0:	2300      	movs	r3, #0
   104f2:	f8cc 3004 	str.w	r3, [ip, #4]
			break;
   104f6:	e6b6      	b.n	10266 <ebpf_vm_exec+0x20e>
			if (reg[inst->src] == 0) {
   104f8:	7863      	ldrb	r3, [r4, #1]
   104fa:	a944      	add	r1, sp, #272	; 0x110
   104fc:	091a      	lsrs	r2, r3, #4
   104fe:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10502:	e952 9a38 	ldrd	r9, sl, [r2, #-224]	; 0xe0
   10506:	ea59 020a 	orrs.w	r2, r9, sl
   1050a:	f000 866e 	beq.w	111ea <ebpf_vm_exec+0x1192>
			DST = (u32)DST % (u32)SRC;
   1050e:	f003 030f 	and.w	r3, r3, #15
   10512:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   10516:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   1051a:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   1051e:	fbb2 f4f9 	udiv	r4, r2, r9
   10522:	fb04 2019 	mls	r0, r4, r9, r2
   10526:	f843 0ce0 	str.w	r0, [r3, #-224]
   1052a:	2300      	movs	r3, #0
   1052c:	604b      	str	r3, [r1, #4]
			break;
   1052e:	e69a      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST ^ (u32)IMM;
   10530:	7863      	ldrb	r3, [r4, #1]
   10532:	6860      	ldr	r0, [r4, #4]
   10534:	aa44      	add	r2, sp, #272	; 0x110
   10536:	f003 030f 	and.w	r3, r3, #15
   1053a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1053e:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   10542:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   10546:	4042      	eors	r2, r0
   10548:	f843 2ce0 	str.w	r2, [r3, #-224]
   1054c:	2300      	movs	r3, #0
   1054e:	604b      	str	r3, [r1, #4]
			break;
   10550:	e689      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)DST ^ (u32)SRC;
   10552:	7863      	ldrb	r3, [r4, #1]
   10554:	a844      	add	r0, sp, #272	; 0x110
   10556:	f003 020f 	and.w	r2, r3, #15
   1055a:	a944      	add	r1, sp, #272	; 0x110
   1055c:	091b      	lsrs	r3, r3, #4
   1055e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10562:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   10566:	f852 0ce0 	ldr.w	r0, [r2, #-224]
   1056a:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   1056e:	4043      	eors	r3, r0
   10570:	f842 3ce0 	str.w	r3, [r2, #-224]
   10574:	2300      	movs	r3, #0
   10576:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   1057a:	e674      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)IMM;
   1057c:	7863      	ldrb	r3, [r4, #1]
   1057e:	6861      	ldr	r1, [r4, #4]
   10580:	aa44      	add	r2, sp, #272	; 0x110
   10582:	f003 030f 	and.w	r3, r3, #15
   10586:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1058a:	f1a3 02e0 	sub.w	r2, r3, #224	; 0xe0
   1058e:	f843 1ce0 	str.w	r1, [r3, #-224]
   10592:	2300      	movs	r3, #0
   10594:	6053      	str	r3, [r2, #4]
			break;
   10596:	e666      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u32)SRC;
   10598:	7863      	ldrb	r3, [r4, #1]
   1059a:	a844      	add	r0, sp, #272	; 0x110
   1059c:	f003 020f 	and.w	r2, r3, #15
   105a0:	091b      	lsrs	r3, r3, #4
   105a2:	a944      	add	r1, sp, #272	; 0x110
   105a4:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   105a8:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   105ac:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   105b0:	f842 3ce0 	str.w	r3, [r2, #-224]
   105b4:	2300      	movs	r3, #0
   105b6:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   105ba:	e654      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u64)(u32)(((s32)DST) >> IMM);
   105bc:	7863      	ldrb	r3, [r4, #1]
   105be:	6860      	ldr	r0, [r4, #4]
   105c0:	aa44      	add	r2, sp, #272	; 0x110
   105c2:	f003 030f 	and.w	r3, r3, #15
   105c6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   105ca:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   105ce:	f853 2ce0 	ldr.w	r2, [r3, #-224]
   105d2:	4102      	asrs	r2, r0
   105d4:	f843 2ce0 	str.w	r2, [r3, #-224]
   105d8:	2300      	movs	r3, #0
   105da:	604b      	str	r3, [r1, #4]
			break;
   105dc:	e643      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (u64)(u32)(((s32)DST) >> SRC);
   105de:	7863      	ldrb	r3, [r4, #1]
   105e0:	a944      	add	r1, sp, #272	; 0x110
   105e2:	f003 020f 	and.w	r2, r3, #15
   105e6:	091b      	lsrs	r3, r3, #4
   105e8:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   105ec:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   105f0:	f852 1ce0 	ldr.w	r1, [r2, #-224]
   105f4:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   105f8:	4119      	asrs	r1, r3
   105fa:	2300      	movs	r3, #0
   105fc:	f842 1ce0 	str.w	r1, [r2, #-224]
   10600:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   10604:	e62f      	b.n	10266 <ebpf_vm_exec+0x20e>
			switch (IMM) {
   10606:	6863      	ldr	r3, [r4, #4]
   10608:	2b20      	cmp	r3, #32
   1060a:	d014      	beq.n	10636 <ebpf_vm_exec+0x5de>
   1060c:	2b40      	cmp	r3, #64	; 0x40
   1060e:	d025      	beq.n	1065c <ebpf_vm_exec+0x604>
   10610:	2b10      	cmp	r3, #16
   10612:	f47f ae28 	bne.w	10266 <ebpf_vm_exec+0x20e>
				DST = my_htobe16(DST);
   10616:	7863      	ldrb	r3, [r4, #1]
   10618:	aa44      	add	r2, sp, #272	; 0x110
   1061a:	f003 030f 	and.w	r3, r3, #15
   1061e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10622:	2100      	movs	r1, #0
   10624:	f833 2ce0 	ldrh.w	r2, [r3, #-224]
//#define false 0
//#endif

static inline u16 __swap16(u16 x)
{
	return (u16) ((((u16)(x) & (u16)0x00ffU) << 8) | (((u16)(x) & (u16)0xff00U) >> 8));
   10628:	0210      	lsls	r0, r2, #8
   1062a:	ea40 2012 	orr.w	r0, r0, r2, lsr #8
   1062e:	b280      	uxth	r0, r0
   10630:	e943 0138 	strd	r0, r1, [r3, #-224]	; 0xe0
				break;
   10634:	e617      	b.n	10266 <ebpf_vm_exec+0x20e>
				DST = my_htobe32(DST);
   10636:	7863      	ldrb	r3, [r4, #1]
   10638:	aa44      	add	r2, sp, #272	; 0x110
   1063a:	f003 030f 	and.w	r3, r3, #15
   1063e:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   10642:	a944      	add	r1, sp, #272	; 0x110
   10644:	f852 2ce0 	ldr.w	r2, [r2, #-224]
   10648:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   1064c:	f1a3 01e0 	sub.w	r1, r3, #224	; 0xe0
   10650:	ba12      	rev	r2, r2
   10652:	f843 2ce0 	str.w	r2, [r3, #-224]
   10656:	2300      	movs	r3, #0
   10658:	604b      	str	r3, [r1, #4]
				break;
   1065a:	e604      	b.n	10266 <ebpf_vm_exec+0x20e>
				DST = my_htobe64(DST);
   1065c:	7863      	ldrb	r3, [r4, #1]
   1065e:	f003 030f 	and.w	r3, r3, #15
   10662:	b219      	sxth	r1, r3
   10664:	aa0c      	add	r2, sp, #48	; 0x30
   10666:	eb02 00c1 	add.w	r0, r2, r1, lsl #3
   1066a:	f852 2031 	ldr.w	r2, [r2, r1, lsl #3]
   1066e:	6841      	ldr	r1, [r0, #4]
   10670:	a844      	add	r0, sp, #272	; 0x110
   10672:	ba12      	rev	r2, r2
   10674:	ba09      	rev	r1, r1
   10676:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   1067a:	e943 1238 	strd	r1, r2, [r3, #-224]	; 0xe0
				break;
   1067e:	e5f2      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST + IMM;
   10680:	7861      	ldrb	r1, [r4, #1]
   10682:	6860      	ldr	r0, [r4, #4]
   10684:	ab44      	add	r3, sp, #272	; 0x110
   10686:	f001 010f 	and.w	r1, r1, #15
   1068a:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   1068e:	e951 2338 	ldrd	r2, r3, [r1, #-224]	; 0xe0
   10692:	eb12 0900 	adds.w	r9, r2, r0
   10696:	eb43 7ae0 	adc.w	sl, r3, r0, asr #31
   1069a:	e941 9a38 	strd	r9, sl, [r1, #-224]	; 0xe0
			break;
   1069e:	e5e2      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST + SRC;
   106a0:	7863      	ldrb	r3, [r4, #1]
   106a2:	aa44      	add	r2, sp, #272	; 0x110
   106a4:	f003 010f 	and.w	r1, r3, #15
   106a8:	091b      	lsrs	r3, r3, #4
   106aa:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
   106ae:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   106b2:	e953 2438 	ldrd	r2, r4, [r3, #-224]	; 0xe0
   106b6:	e951 0338 	ldrd	r0, r3, [r1, #-224]	; 0xe0
   106ba:	1812      	adds	r2, r2, r0
   106bc:	eb44 0303 	adc.w	r3, r4, r3
   106c0:	e941 2338 	strd	r2, r3, [r1, #-224]	; 0xe0
			break;
   106c4:	e5cf      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST - IMM;
   106c6:	7861      	ldrb	r1, [r4, #1]
   106c8:	6860      	ldr	r0, [r4, #4]
   106ca:	ab44      	add	r3, sp, #272	; 0x110
   106cc:	f001 010f 	and.w	r1, r1, #15
   106d0:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   106d4:	e951 2338 	ldrd	r2, r3, [r1, #-224]	; 0xe0
   106d8:	ebb2 0900 	subs.w	r9, r2, r0
   106dc:	eb63 7ae0 	sbc.w	sl, r3, r0, asr #31
   106e0:	e941 9a38 	strd	r9, sl, [r1, #-224]	; 0xe0
			break;
   106e4:	e5bf      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST - SRC;
   106e6:	7863      	ldrb	r3, [r4, #1]
   106e8:	a944      	add	r1, sp, #272	; 0x110
   106ea:	f003 020f 	and.w	r2, r3, #15
   106ee:	091b      	lsrs	r3, r3, #4
   106f0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   106f4:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   106f8:	e953 4338 	ldrd	r4, r3, [r3, #-224]	; 0xe0
   106fc:	e952 1038 	ldrd	r1, r0, [r2, #-224]	; 0xe0
   10700:	1b09      	subs	r1, r1, r4
   10702:	eb60 0003 	sbc.w	r0, r0, r3
   10706:	e942 1038 	strd	r1, r0, [r2, #-224]	; 0xe0
			break;
   1070a:	e5ac      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST * IMM;
   1070c:	7863      	ldrb	r3, [r4, #1]
   1070e:	6861      	ldr	r1, [r4, #4]
   10710:	aa44      	add	r2, sp, #272	; 0x110
   10712:	f003 030f 	and.w	r3, r3, #15
   10716:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1071a:	e953 0238 	ldrd	r0, r2, [r3, #-224]	; 0xe0
   1071e:	ea4f 7ae1 	mov.w	sl, r1, asr #31
   10722:	fb0a f400 	mul.w	r4, sl, r0
   10726:	fb01 4202 	mla	r2, r1, r2, r4
   1072a:	fba0 0101 	umull	r0, r1, r0, r1
   1072e:	4411      	add	r1, r2
   10730:	e943 0138 	strd	r0, r1, [r3, #-224]	; 0xe0
			break;
   10734:	e597      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST * SRC;
   10736:	7863      	ldrb	r3, [r4, #1]
   10738:	aa44      	add	r2, sp, #272	; 0x110
   1073a:	f003 010f 	and.w	r1, r3, #15
   1073e:	091b      	lsrs	r3, r3, #4
   10740:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10744:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
   10748:	e951 2438 	ldrd	r2, r4, [r1, #-224]	; 0xe0
   1074c:	f853 0cdc 	ldr.w	r0, [r3, #-220]
   10750:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10754:	435c      	muls	r4, r3
   10756:	fb02 4000 	mla	r0, r2, r0, r4
   1075a:	fba3 2302 	umull	r2, r3, r3, r2
   1075e:	4403      	add	r3, r0
   10760:	e941 2338 	strd	r2, r3, [r1, #-224]	; 0xe0
			break;
   10764:	e57f      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST / IMM;
   10766:	f894 9001 	ldrb.w	r9, [r4, #1]
   1076a:	6862      	ldr	r2, [r4, #4]
   1076c:	ab44      	add	r3, sp, #272	; 0x110
   1076e:	f009 090f 	and.w	r9, r9, #15
   10772:	eb03 09c9 	add.w	r9, r3, r9, lsl #3
   10776:	e959 0138 	ldrd	r0, r1, [r9, #-224]	; 0xe0
   1077a:	17d3      	asrs	r3, r2, #31
   1077c:	f7ef ffe4 	bl	748 <__aeabi_uldivmod>
   10780:	e949 0138 	strd	r0, r1, [r9, #-224]	; 0xe0
			break;
   10784:	e56f      	b.n	10266 <ebpf_vm_exec+0x20e>
			if (SRC == 0) {
   10786:	f894 9001 	ldrb.w	r9, [r4, #1]
   1078a:	aa44      	add	r2, sp, #272	; 0x110
   1078c:	ea4f 1319 	mov.w	r3, r9, lsr #4
   10790:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10794:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10798:	4313      	orrs	r3, r2
   1079a:	f000 8526 	beq.w	111ea <ebpf_vm_exec+0x1192>
			DST = DST / IMM;
   1079e:	ab44      	add	r3, sp, #272	; 0x110
   107a0:	6862      	ldr	r2, [r4, #4]
   107a2:	f009 090f 	and.w	r9, r9, #15
   107a6:	eb03 09c9 	add.w	r9, r3, r9, lsl #3
   107aa:	e959 0138 	ldrd	r0, r1, [r9, #-224]	; 0xe0
   107ae:	17d3      	asrs	r3, r2, #31
   107b0:	f7ef ffca 	bl	748 <__aeabi_uldivmod>
   107b4:	e949 0138 	strd	r0, r1, [r9, #-224]	; 0xe0
			break;
   107b8:	e555      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST | IMM;
   107ba:	7863      	ldrb	r3, [r4, #1]
   107bc:	6864      	ldr	r4, [r4, #4]
   107be:	aa44      	add	r2, sp, #272	; 0x110
   107c0:	f003 030f 	and.w	r3, r3, #15
   107c4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   107c8:	e953 0238 	ldrd	r0, r2, [r3, #-224]	; 0xe0
   107cc:	ea4f 7ae4 	mov.w	sl, r4, asr #31
   107d0:	4320      	orrs	r0, r4
   107d2:	ea42 020a 	orr.w	r2, r2, sl
   107d6:	e943 0238 	strd	r0, r2, [r3, #-224]	; 0xe0
			break;
   107da:	e544      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST | SRC;
   107dc:	7863      	ldrb	r3, [r4, #1]
   107de:	a844      	add	r0, sp, #272	; 0x110
   107e0:	f003 020f 	and.w	r2, r3, #15
   107e4:	a944      	add	r1, sp, #272	; 0x110
   107e6:	091b      	lsrs	r3, r3, #4
   107e8:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   107ec:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   107f0:	e953 4338 	ldrd	r4, r3, [r3, #-224]	; 0xe0
   107f4:	f852 0ce0 	ldr.w	r0, [r2, #-224]
   107f8:	4320      	orrs	r0, r4
   107fa:	f852 4cdc 	ldr.w	r4, [r2, #-220]
   107fe:	4323      	orrs	r3, r4
   10800:	e942 0338 	strd	r0, r3, [r2, #-224]	; 0xe0
			break;
   10804:	e52f      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST & IMM;
   10806:	7863      	ldrb	r3, [r4, #1]
   10808:	6864      	ldr	r4, [r4, #4]
   1080a:	aa44      	add	r2, sp, #272	; 0x110
   1080c:	f003 030f 	and.w	r3, r3, #15
   10810:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10814:	e953 0238 	ldrd	r0, r2, [r3, #-224]	; 0xe0
   10818:	ea4f 7ae4 	mov.w	sl, r4, asr #31
   1081c:	4020      	ands	r0, r4
   1081e:	ea02 020a 	and.w	r2, r2, sl
   10822:	e943 0238 	strd	r0, r2, [r3, #-224]	; 0xe0
			break;
   10826:	e51e      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST & SRC;
   10828:	7863      	ldrb	r3, [r4, #1]
   1082a:	a844      	add	r0, sp, #272	; 0x110
   1082c:	f003 020f 	and.w	r2, r3, #15
   10830:	a944      	add	r1, sp, #272	; 0x110
   10832:	091b      	lsrs	r3, r3, #4
   10834:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10838:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   1083c:	e953 4338 	ldrd	r4, r3, [r3, #-224]	; 0xe0
   10840:	f852 0ce0 	ldr.w	r0, [r2, #-224]
   10844:	4020      	ands	r0, r4
   10846:	f852 4cdc 	ldr.w	r4, [r2, #-220]
   1084a:	4023      	ands	r3, r4
   1084c:	e942 0338 	strd	r0, r3, [r2, #-224]	; 0xe0
			break;
   10850:	e509      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST << IMM;
   10852:	7862      	ldrb	r2, [r4, #1]
   10854:	6860      	ldr	r0, [r4, #4]
   10856:	ab44      	add	r3, sp, #272	; 0x110
   10858:	f002 020f 	and.w	r2, r2, #15
   1085c:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   10860:	e952 1338 	ldrd	r1, r3, [r2, #-224]	; 0xe0
   10864:	f1a0 0e20 	sub.w	lr, r0, #32
   10868:	fa01 fe0e 	lsl.w	lr, r1, lr
   1086c:	f1c0 0420 	rsb	r4, r0, #32
   10870:	4083      	lsls	r3, r0
   10872:	fa21 f404 	lsr.w	r4, r1, r4
   10876:	ea43 030e 	orr.w	r3, r3, lr
   1087a:	4323      	orrs	r3, r4
   1087c:	4081      	lsls	r1, r0
   1087e:	e942 1338 	strd	r1, r3, [r2, #-224]	; 0xe0
			break;
   10882:	e4f0      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST << SRC;
   10884:	7863      	ldrb	r3, [r4, #1]
   10886:	a944      	add	r1, sp, #272	; 0x110
   10888:	f003 020f 	and.w	r2, r3, #15
   1088c:	091b      	lsrs	r3, r3, #4
   1088e:	eb01 00c3 	add.w	r0, r1, r3, lsl #3
   10892:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10896:	e952 1338 	ldrd	r1, r3, [r2, #-224]	; 0xe0
   1089a:	f850 0ce0 	ldr.w	r0, [r0, #-224]
   1089e:	f1a0 0c20 	sub.w	ip, r0, #32
   108a2:	fa01 fc0c 	lsl.w	ip, r1, ip
   108a6:	f1c0 0420 	rsb	r4, r0, #32
   108aa:	4083      	lsls	r3, r0
   108ac:	fa21 f404 	lsr.w	r4, r1, r4
   108b0:	ea43 030c 	orr.w	r3, r3, ip
   108b4:	4323      	orrs	r3, r4
   108b6:	4081      	lsls	r1, r0
   108b8:	f1a2 0ee0 	sub.w	lr, r2, #224	; 0xe0
   108bc:	e942 1338 	strd	r1, r3, [r2, #-224]	; 0xe0
			break;
   108c0:	e4d1      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST >> IMM;
   108c2:	7863      	ldrb	r3, [r4, #1]
   108c4:	6860      	ldr	r0, [r4, #4]
   108c6:	aa44      	add	r2, sp, #272	; 0x110
   108c8:	f003 030f 	and.w	r3, r3, #15
   108cc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   108d0:	e953 2138 	ldrd	r2, r1, [r3, #-224]	; 0xe0
   108d4:	f1c0 0e20 	rsb	lr, r0, #32
   108d8:	fa01 fe0e 	lsl.w	lr, r1, lr
   108dc:	f1a0 0420 	sub.w	r4, r0, #32
   108e0:	40c2      	lsrs	r2, r0
   108e2:	fa21 f404 	lsr.w	r4, r1, r4
   108e6:	ea42 020e 	orr.w	r2, r2, lr
   108ea:	4322      	orrs	r2, r4
   108ec:	40c1      	lsrs	r1, r0
   108ee:	e943 2138 	strd	r2, r1, [r3, #-224]	; 0xe0
			break;
   108f2:	e4b8      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST >> SRC;
   108f4:	7863      	ldrb	r3, [r4, #1]
   108f6:	aa44      	add	r2, sp, #272	; 0x110
   108f8:	f003 010f 	and.w	r1, r3, #15
   108fc:	091b      	lsrs	r3, r3, #4
   108fe:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
   10902:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
   10906:	e951 3238 	ldrd	r3, r2, [r1, #-224]	; 0xe0
   1090a:	f850 0ce0 	ldr.w	r0, [r0, #-224]
   1090e:	f1c0 0c20 	rsb	ip, r0, #32
   10912:	fa02 fc0c 	lsl.w	ip, r2, ip
   10916:	f1a0 0420 	sub.w	r4, r0, #32
   1091a:	40c3      	lsrs	r3, r0
   1091c:	fa22 f404 	lsr.w	r4, r2, r4
   10920:	ea43 030c 	orr.w	r3, r3, ip
   10924:	4323      	orrs	r3, r4
   10926:	40c2      	lsrs	r2, r0
   10928:	f1a1 0ee0 	sub.w	lr, r1, #224	; 0xe0
   1092c:	e941 3238 	strd	r3, r2, [r1, #-224]	; 0xe0
			break;
   10930:	e499      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = -DST;
   10932:	7861      	ldrb	r1, [r4, #1]
   10934:	ab44      	add	r3, sp, #272	; 0x110
   10936:	f001 010f 	and.w	r1, r1, #15
   1093a:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   1093e:	e951 2338 	ldrd	r2, r3, [r1, #-224]	; 0xe0
   10942:	4252      	negs	r2, r2
   10944:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   10948:	e941 2338 	strd	r2, r3, [r1, #-224]	; 0xe0
			break;
   1094c:	e48b      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST % IMM;
   1094e:	f894 9001 	ldrb.w	r9, [r4, #1]
   10952:	6862      	ldr	r2, [r4, #4]
   10954:	ab44      	add	r3, sp, #272	; 0x110
   10956:	f009 090f 	and.w	r9, r9, #15
   1095a:	eb03 09c9 	add.w	r9, r3, r9, lsl #3
   1095e:	e959 0138 	ldrd	r0, r1, [r9, #-224]	; 0xe0
   10962:	17d3      	asrs	r3, r2, #31
   10964:	f7ef fef0 	bl	748 <__aeabi_uldivmod>
   10968:	e949 2338 	strd	r2, r3, [r9, #-224]	; 0xe0
			break;
   1096c:	e47b      	b.n	10266 <ebpf_vm_exec+0x20e>
			if (SRC == 0) {
   1096e:	7864      	ldrb	r4, [r4, #1]
   10970:	aa44      	add	r2, sp, #272	; 0x110
   10972:	0923      	lsrs	r3, r4, #4
   10974:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10978:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   1097c:	ea52 0103 	orrs.w	r1, r2, r3
   10980:	f000 8433 	beq.w	111ea <ebpf_vm_exec+0x1192>
			DST = DST % SRC;
   10984:	a944      	add	r1, sp, #272	; 0x110
   10986:	f004 040f 	and.w	r4, r4, #15
   1098a:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
   1098e:	e954 0138 	ldrd	r0, r1, [r4, #-224]	; 0xe0
   10992:	f7ef fed9 	bl	748 <__aeabi_uldivmod>
   10996:	e944 2338 	strd	r2, r3, [r4, #-224]	; 0xe0
			break;
   1099a:	e464      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST ^ IMM;
   1099c:	7863      	ldrb	r3, [r4, #1]
   1099e:	6864      	ldr	r4, [r4, #4]
   109a0:	aa44      	add	r2, sp, #272	; 0x110
   109a2:	f003 030f 	and.w	r3, r3, #15
   109a6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   109aa:	e953 0238 	ldrd	r0, r2, [r3, #-224]	; 0xe0
   109ae:	ea4f 7ae4 	mov.w	sl, r4, asr #31
   109b2:	4060      	eors	r0, r4
   109b4:	ea82 020a 	eor.w	r2, r2, sl
   109b8:	e943 0238 	strd	r0, r2, [r3, #-224]	; 0xe0
			break;
   109bc:	e453      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = DST ^ SRC;
   109be:	7863      	ldrb	r3, [r4, #1]
   109c0:	a844      	add	r0, sp, #272	; 0x110
   109c2:	f003 020f 	and.w	r2, r3, #15
   109c6:	a944      	add	r1, sp, #272	; 0x110
   109c8:	091b      	lsrs	r3, r3, #4
   109ca:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   109ce:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   109d2:	e953 4338 	ldrd	r4, r3, [r3, #-224]	; 0xe0
   109d6:	f852 0ce0 	ldr.w	r0, [r2, #-224]
   109da:	4060      	eors	r0, r4
   109dc:	f852 4cdc 	ldr.w	r4, [r2, #-220]
   109e0:	4063      	eors	r3, r4
   109e2:	e942 0338 	strd	r0, r3, [r2, #-224]	; 0xe0
			break;
   109e6:	e43e      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = IMM;
   109e8:	7863      	ldrb	r3, [r4, #1]
   109ea:	6860      	ldr	r0, [r4, #4]
   109ec:	f003 030f 	and.w	r3, r3, #15
   109f0:	aa44      	add	r2, sp, #272	; 0x110
   109f2:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   109f6:	17c1      	asrs	r1, r0, #31
   109f8:	e943 0138 	strd	r0, r1, [r3, #-224]	; 0xe0
			break;
   109fc:	e433      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = SRC;
   109fe:	7863      	ldrb	r3, [r4, #1]
   10a00:	a944      	add	r1, sp, #272	; 0x110
   10a02:	091a      	lsrs	r2, r3, #4
   10a04:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10a08:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   10a0c:	f003 030f 	and.w	r3, r3, #15
   10a10:	aa44      	add	r2, sp, #272	; 0x110
   10a12:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10a16:	e943 0138 	strd	r0, r1, [r3, #-224]	; 0xe0
			break;
   10a1a:	e424      	b.n	10266 <ebpf_vm_exec+0x20e>
			(*(s64 *)&DST) >>= IMM;
   10a1c:	7861      	ldrb	r1, [r4, #1]
   10a1e:	6860      	ldr	r0, [r4, #4]
   10a20:	f10d 0c30 	add.w	ip, sp, #48	; 0x30
   10a24:	f001 010f 	and.w	r1, r1, #15
   10a28:	eb0c 0ec1 	add.w	lr, ip, r1, lsl #3
   10a2c:	f85c 3031 	ldr.w	r3, [ip, r1, lsl #3]
   10a30:	f8de 2004 	ldr.w	r2, [lr, #4]
   10a34:	f1c0 0920 	rsb	r9, r0, #32
   10a38:	f1b0 0420 	subs.w	r4, r0, #32
   10a3c:	fa02 f909 	lsl.w	r9, r2, r9
   10a40:	fa23 f300 	lsr.w	r3, r3, r0
   10a44:	ea43 0309 	orr.w	r3, r3, r9
   10a48:	bf5c      	itt	pl
   10a4a:	fa42 f404 	asrpl.w	r4, r2, r4
   10a4e:	4323      	orrpl	r3, r4
   10a50:	4102      	asrs	r2, r0
   10a52:	f84c 3031 	str.w	r3, [ip, r1, lsl #3]
   10a56:	f8ce 2004 	str.w	r2, [lr, #4]
			break;
   10a5a:	e404      	b.n	10266 <ebpf_vm_exec+0x20e>
			DST = (s64) DST >> SRC;
   10a5c:	7863      	ldrb	r3, [r4, #1]
   10a5e:	aa44      	add	r2, sp, #272	; 0x110
   10a60:	f003 010f 	and.w	r1, r3, #15
   10a64:	091b      	lsrs	r3, r3, #4
   10a66:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
   10a6a:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
   10a6e:	f1a1 0ee0 	sub.w	lr, r1, #224	; 0xe0
   10a72:	f850 0ce0 	ldr.w	r0, [r0, #-224]
   10a76:	f8de 2004 	ldr.w	r2, [lr, #4]
   10a7a:	f851 3ce0 	ldr.w	r3, [r1, #-224]
   10a7e:	f1c0 0c20 	rsb	ip, r0, #32
   10a82:	f1b0 0420 	subs.w	r4, r0, #32
   10a86:	fa02 fc0c 	lsl.w	ip, r2, ip
   10a8a:	fa23 f300 	lsr.w	r3, r3, r0
   10a8e:	ea43 030c 	orr.w	r3, r3, ip
   10a92:	bf5c      	itt	pl
   10a94:	fa42 f404 	asrpl.w	r4, r2, r4
   10a98:	4323      	orrpl	r3, r4
   10a9a:	4102      	asrs	r2, r0
   10a9c:	f841 3ce0 	str.w	r3, [r1, #-224]
   10aa0:	f8ce 2004 	str.w	r2, [lr, #4]
			break;
   10aa4:	f7ff bbdf 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_LOAD(8);
   10aa8:	7863      	ldrb	r3, [r4, #1]
   10aaa:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
   10aae:	79b0      	ldrb	r0, [r6, #6]
   10ab0:	aa44      	add	r2, sp, #272	; 0x110
   10ab2:	091b      	lsrs	r3, r3, #4
   10ab4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10ab8:	2208      	movs	r2, #8
   10aba:	f853 ace0 	ldr.w	sl, [r3, #-224]
   10abe:	e9cd 8b00 	strd	r8, fp, [sp]
   10ac2:	463b      	mov	r3, r7
   10ac4:	eb09 010a 	add.w	r1, r9, sl
   10ac8:	f7ff fa6a 	bl	ffa0 <bounds_check.isra.0>
   10acc:	2800      	cmp	r0, #0
   10ace:	f000 838c 	beq.w	111ea <ebpf_vm_exec+0x1192>
			DST = *(u64*)(uintptr)(SRC + inst->offset);
   10ad2:	7861      	ldrb	r1, [r4, #1]
   10ad4:	ab44      	add	r3, sp, #272	; 0x110
   10ad6:	f001 010f 	and.w	r1, r1, #15
   10ada:	44d1      	add	r9, sl
   10adc:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   10ae0:	e9d9 2300 	ldrd	r2, r3, [r9]
   10ae4:	e941 2338 	strd	r2, r3, [r1, #-224]	; 0xe0
			break;
   10ae8:	f7ff bbbd 	b.w	10266 <ebpf_vm_exec+0x20e>
			DST = *(u32*)(uintptr)(SRC + inst->offset);
   10aec:	7863      	ldrb	r3, [r4, #1]
   10aee:	a844      	add	r0, sp, #272	; 0x110
   10af0:	f003 020f 	and.w	r2, r3, #15
   10af4:	091b      	lsrs	r3, r3, #4
   10af6:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   10afa:	a944      	add	r1, sp, #272	; 0x110
   10afc:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10b00:	f9b4 0002 	ldrsh.w	r0, [r4, #2]
   10b04:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10b08:	581b      	ldr	r3, [r3, r0]
   10b0a:	f842 3ce0 	str.w	r3, [r2, #-224]
   10b0e:	2300      	movs	r3, #0
   10b10:	f842 3cdc 	str.w	r3, [r2, #-220]
			break;
   10b14:	f7ff bba7 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_LOAD(2);
   10b18:	7863      	ldrb	r3, [r4, #1]
   10b1a:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
   10b1e:	79b0      	ldrb	r0, [r6, #6]
   10b20:	aa44      	add	r2, sp, #272	; 0x110
   10b22:	091b      	lsrs	r3, r3, #4
   10b24:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10b28:	2202      	movs	r2, #2
   10b2a:	f853 ace0 	ldr.w	sl, [r3, #-224]
   10b2e:	e9cd 8b00 	strd	r8, fp, [sp]
   10b32:	463b      	mov	r3, r7
   10b34:	eb09 010a 	add.w	r1, r9, sl
   10b38:	f7ff fa32 	bl	ffa0 <bounds_check.isra.0>
   10b3c:	2800      	cmp	r0, #0
   10b3e:	f000 8354 	beq.w	111ea <ebpf_vm_exec+0x1192>
			DST = *(u16*)(uintptr)(SRC + inst->offset);
   10b42:	7863      	ldrb	r3, [r4, #1]
   10b44:	44d1      	add	r9, sl
   10b46:	f003 030f 	and.w	r3, r3, #15
   10b4a:	aa44      	add	r2, sp, #272	; 0x110
   10b4c:	f8b9 0000 	ldrh.w	r0, [r9]
   10b50:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10b54:	2100      	movs	r1, #0
   10b56:	e943 0138 	strd	r0, r1, [r3, #-224]	; 0xe0
			break;
   10b5a:	f7ff bb84 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_LOAD(1);
   10b5e:	7863      	ldrb	r3, [r4, #1]
   10b60:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
   10b64:	79b0      	ldrb	r0, [r6, #6]
   10b66:	aa44      	add	r2, sp, #272	; 0x110
   10b68:	091b      	lsrs	r3, r3, #4
   10b6a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10b6e:	2201      	movs	r2, #1
   10b70:	f853 ace0 	ldr.w	sl, [r3, #-224]
   10b74:	e9cd 8b00 	strd	r8, fp, [sp]
   10b78:	463b      	mov	r3, r7
   10b7a:	eb09 010a 	add.w	r1, r9, sl
   10b7e:	f7ff fa0f 	bl	ffa0 <bounds_check.isra.0>
   10b82:	2800      	cmp	r0, #0
   10b84:	f000 8331 	beq.w	111ea <ebpf_vm_exec+0x1192>
			DST = *(u8*)(uintptr)(reg[inst->src] + inst->offset);
   10b88:	7863      	ldrb	r3, [r4, #1]
   10b8a:	44d1      	add	r9, sl
   10b8c:	f003 030f 	and.w	r3, r3, #15
   10b90:	aa44      	add	r2, sp, #272	; 0x110
   10b92:	f899 0000 	ldrb.w	r0, [r9]
   10b96:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10b9a:	2100      	movs	r1, #0
   10b9c:	e943 0138 	strd	r0, r1, [r3, #-224]	; 0xe0
			break;
   10ba0:	f7ff bb61 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_STORE(8);
   10ba4:	7863      	ldrb	r3, [r4, #1]
   10ba6:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
   10baa:	79b0      	ldrb	r0, [r6, #6]
   10bac:	aa44      	add	r2, sp, #272	; 0x110
   10bae:	091b      	lsrs	r3, r3, #4
   10bb0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10bb4:	2208      	movs	r2, #8
   10bb6:	f853 1ce0 	ldr.w	r1, [r3, #-224]
   10bba:	e9cd 8b00 	strd	r8, fp, [sp]
   10bbe:	463b      	mov	r3, r7
   10bc0:	4449      	add	r1, r9
   10bc2:	f7ff f9ed 	bl	ffa0 <bounds_check.isra.0>
   10bc6:	2800      	cmp	r0, #0
   10bc8:	f000 830f 	beq.w	111ea <ebpf_vm_exec+0x1192>
			*(u64*)(uintptr)(DST + inst->offset) = IMM;
   10bcc:	7863      	ldrb	r3, [r4, #1]
   10bce:	aa44      	add	r2, sp, #272	; 0x110
   10bd0:	f003 030f 	and.w	r3, r3, #15
   10bd4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10bd8:	6862      	ldr	r2, [r4, #4]
   10bda:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10bde:	4499      	add	r9, r3
   10be0:	17d3      	asrs	r3, r2, #31
   10be2:	e9c9 2300 	strd	r2, r3, [r9]
			break;
   10be6:	f7ff bb3e 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_STORE(4);
   10bea:	7863      	ldrb	r3, [r4, #1]
   10bec:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
   10bf0:	79b0      	ldrb	r0, [r6, #6]
   10bf2:	aa44      	add	r2, sp, #272	; 0x110
   10bf4:	091b      	lsrs	r3, r3, #4
   10bf6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10bfa:	2204      	movs	r2, #4
   10bfc:	f853 1ce0 	ldr.w	r1, [r3, #-224]
   10c00:	e9cd 8b00 	strd	r8, fp, [sp]
   10c04:	463b      	mov	r3, r7
   10c06:	4449      	add	r1, r9
   10c08:	f7ff f9ca 	bl	ffa0 <bounds_check.isra.0>
   10c0c:	2800      	cmp	r0, #0
   10c0e:	f000 82ec 	beq.w	111ea <ebpf_vm_exec+0x1192>
			*(u32*)(uintptr)(DST + inst->offset) = IMM;
   10c12:	7863      	ldrb	r3, [r4, #1]
   10c14:	aa44      	add	r2, sp, #272	; 0x110
   10c16:	f003 030f 	and.w	r3, r3, #15
   10c1a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10c1e:	6862      	ldr	r2, [r4, #4]
   10c20:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10c24:	f843 2009 	str.w	r2, [r3, r9]
			break;
   10c28:	f7ff bb1d 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_STORE(2);
   10c2c:	7863      	ldrb	r3, [r4, #1]
   10c2e:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
   10c32:	79b0      	ldrb	r0, [r6, #6]
   10c34:	aa44      	add	r2, sp, #272	; 0x110
   10c36:	091b      	lsrs	r3, r3, #4
   10c38:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10c3c:	2202      	movs	r2, #2
   10c3e:	f853 1ce0 	ldr.w	r1, [r3, #-224]
   10c42:	e9cd 8b00 	strd	r8, fp, [sp]
   10c46:	463b      	mov	r3, r7
   10c48:	4449      	add	r1, r9
   10c4a:	f7ff f9a9 	bl	ffa0 <bounds_check.isra.0>
   10c4e:	2800      	cmp	r0, #0
   10c50:	f000 82cb 	beq.w	111ea <ebpf_vm_exec+0x1192>
			*(u16*)(uintptr)(DST + inst->offset) = IMM;
   10c54:	7863      	ldrb	r3, [r4, #1]
   10c56:	aa44      	add	r2, sp, #272	; 0x110
   10c58:	f003 030f 	and.w	r3, r3, #15
   10c5c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10c60:	6862      	ldr	r2, [r4, #4]
   10c62:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10c66:	f823 2009 	strh.w	r2, [r3, r9]
			break;
   10c6a:	f7ff bafc 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_STORE(1);
   10c6e:	7863      	ldrb	r3, [r4, #1]
   10c70:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
   10c74:	79b0      	ldrb	r0, [r6, #6]
   10c76:	aa44      	add	r2, sp, #272	; 0x110
   10c78:	091b      	lsrs	r3, r3, #4
   10c7a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10c7e:	2201      	movs	r2, #1
   10c80:	f853 1ce0 	ldr.w	r1, [r3, #-224]
   10c84:	e9cd 8b00 	strd	r8, fp, [sp]
   10c88:	463b      	mov	r3, r7
   10c8a:	4449      	add	r1, r9
   10c8c:	f7ff f988 	bl	ffa0 <bounds_check.isra.0>
   10c90:	2800      	cmp	r0, #0
   10c92:	f000 82aa 	beq.w	111ea <ebpf_vm_exec+0x1192>
			*(u8*)(uintptr)(DST + inst->offset) = IMM;
   10c96:	7863      	ldrb	r3, [r4, #1]
   10c98:	aa44      	add	r2, sp, #272	; 0x110
   10c9a:	f003 030f 	and.w	r3, r3, #15
   10c9e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10ca2:	6862      	ldr	r2, [r4, #4]
   10ca4:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10ca8:	f803 2009 	strb.w	r2, [r3, r9]
			break;
   10cac:	f7ff badb 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_STORE(8);
   10cb0:	7863      	ldrb	r3, [r4, #1]
   10cb2:	f9b4 a002 	ldrsh.w	sl, [r4, #2]
   10cb6:	79b0      	ldrb	r0, [r6, #6]
   10cb8:	aa44      	add	r2, sp, #272	; 0x110
   10cba:	091b      	lsrs	r3, r3, #4
   10cbc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10cc0:	e953 9338 	ldrd	r9, r3, [r3, #-224]	; 0xe0
   10cc4:	2208      	movs	r2, #8
   10cc6:	930b      	str	r3, [sp, #44]	; 0x2c
   10cc8:	e9cd 8b00 	strd	r8, fp, [sp]
   10ccc:	463b      	mov	r3, r7
   10cce:	eb0a 0109 	add.w	r1, sl, r9
   10cd2:	f7ff f965 	bl	ffa0 <bounds_check.isra.0>
   10cd6:	2800      	cmp	r0, #0
   10cd8:	f000 8287 	beq.w	111ea <ebpf_vm_exec+0x1192>
			*(u64*)(uintptr)(DST + inst->offset) = SRC;
   10cdc:	7863      	ldrb	r3, [r4, #1]
   10cde:	aa44      	add	r2, sp, #272	; 0x110
   10ce0:	f003 030f 	and.w	r3, r3, #15
   10ce4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10ce8:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10cec:	449a      	add	sl, r3
   10cee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   10cf0:	f8ca 9000 	str.w	r9, [sl]
   10cf4:	f8ca 3004 	str.w	r3, [sl, #4]
			break;
   10cf8:	f7ff bab5 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_STORE(4);
   10cfc:	7863      	ldrb	r3, [r4, #1]
   10cfe:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
   10d02:	79b0      	ldrb	r0, [r6, #6]
   10d04:	aa44      	add	r2, sp, #272	; 0x110
   10d06:	091b      	lsrs	r3, r3, #4
   10d08:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10d0c:	2204      	movs	r2, #4
   10d0e:	f853 ace0 	ldr.w	sl, [r3, #-224]
   10d12:	e9cd 8b00 	strd	r8, fp, [sp]
   10d16:	463b      	mov	r3, r7
   10d18:	eb09 010a 	add.w	r1, r9, sl
   10d1c:	f7ff f940 	bl	ffa0 <bounds_check.isra.0>
   10d20:	2800      	cmp	r0, #0
   10d22:	f000 8262 	beq.w	111ea <ebpf_vm_exec+0x1192>
			*(u32*)(uintptr)(DST + inst->offset) = SRC;
   10d26:	7863      	ldrb	r3, [r4, #1]
   10d28:	aa44      	add	r2, sp, #272	; 0x110
   10d2a:	f003 030f 	and.w	r3, r3, #15
   10d2e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10d32:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10d36:	f843 a009 	str.w	sl, [r3, r9]
			break;
   10d3a:	f7ff ba94 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_STORE(2);
   10d3e:	7863      	ldrb	r3, [r4, #1]
   10d40:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
   10d44:	79b0      	ldrb	r0, [r6, #6]
   10d46:	aa44      	add	r2, sp, #272	; 0x110
   10d48:	091b      	lsrs	r3, r3, #4
   10d4a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10d4e:	2202      	movs	r2, #2
   10d50:	f853 ace0 	ldr.w	sl, [r3, #-224]
   10d54:	e9cd 8b00 	strd	r8, fp, [sp]
   10d58:	463b      	mov	r3, r7
   10d5a:	eb09 010a 	add.w	r1, r9, sl
   10d5e:	f7ff f91f 	bl	ffa0 <bounds_check.isra.0>
   10d62:	2800      	cmp	r0, #0
   10d64:	f000 8241 	beq.w	111ea <ebpf_vm_exec+0x1192>
			*(u16*)(uintptr)(DST + inst->offset) = SRC;
   10d68:	7863      	ldrb	r3, [r4, #1]
   10d6a:	aa44      	add	r2, sp, #272	; 0x110
   10d6c:	f003 030f 	and.w	r3, r3, #15
   10d70:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10d74:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10d78:	f823 a009 	strh.w	sl, [r3, r9]
			break;
   10d7c:	f7ff ba73 	b.w	10266 <ebpf_vm_exec+0x20e>
			BOUNDS_CHECK_STORE(1);
   10d80:	7863      	ldrb	r3, [r4, #1]
   10d82:	f9b4 9002 	ldrsh.w	r9, [r4, #2]
   10d86:	79b0      	ldrb	r0, [r6, #6]
   10d88:	aa44      	add	r2, sp, #272	; 0x110
   10d8a:	091b      	lsrs	r3, r3, #4
   10d8c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10d90:	2201      	movs	r2, #1
   10d92:	f853 ace0 	ldr.w	sl, [r3, #-224]
   10d96:	e9cd 8b00 	strd	r8, fp, [sp]
   10d9a:	463b      	mov	r3, r7
   10d9c:	eb09 010a 	add.w	r1, r9, sl
   10da0:	f7ff f8fe 	bl	ffa0 <bounds_check.isra.0>
   10da4:	2800      	cmp	r0, #0
   10da6:	f000 8220 	beq.w	111ea <ebpf_vm_exec+0x1192>
			*(u8*)(uintptr)(DST + inst->offset) = SRC;
   10daa:	7863      	ldrb	r3, [r4, #1]
   10dac:	aa44      	add	r2, sp, #272	; 0x110
   10dae:	f003 030f 	and.w	r3, r3, #15
   10db2:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10db6:	f853 3ce0 	ldr.w	r3, [r3, #-224]
   10dba:	f803 a009 	strb.w	sl, [r3, r9]
			break;
   10dbe:	f7ff ba52 	b.w	10266 <ebpf_vm_exec+0x20e>
			DST = (u64) (u32)IMM | ((u64) (u32)insts[pc++].imm << 32);
   10dc2:	7862      	ldrb	r2, [r4, #1]
   10dc4:	6860      	ldr	r0, [r4, #4]
   10dc6:	a944      	add	r1, sp, #272	; 0x110
   10dc8:	f002 020f 	and.w	r2, r2, #15
   10dcc:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10dd0:	990a      	ldr	r1, [sp, #40]	; 0x28
   10dd2:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
   10dd6:	3302      	adds	r3, #2
   10dd8:	6869      	ldr	r1, [r5, #4]
   10dda:	b29d      	uxth	r5, r3
   10ddc:	e942 0138 	strd	r0, r1, [r2, #-224]	; 0xe0
			break;
   10de0:	f7ff ba41 	b.w	10266 <ebpf_vm_exec+0x20e>
			pc += inst->offset;
   10de4:	8863      	ldrh	r3, [r4, #2]
   10de6:	441d      	add	r5, r3
   10de8:	b2ad      	uxth	r5, r5
			break;
   10dea:	f7ff ba3c 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST == SRC) {
   10dee:	7863      	ldrb	r3, [r4, #1]
   10df0:	a944      	add	r1, sp, #272	; 0x110
   10df2:	f003 020f 	and.w	r2, r3, #15
   10df6:	091b      	lsrs	r3, r3, #4
   10df8:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10dfc:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   10e00:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   10e04:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10e08:	4299      	cmp	r1, r3
   10e0a:	bf08      	it	eq
   10e0c:	4290      	cmpeq	r0, r2
   10e0e:	f47f aa2a 	bne.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10e12:	8863      	ldrh	r3, [r4, #2]
   10e14:	441d      	add	r5, r3
   10e16:	b2ad      	uxth	r5, r5
   10e18:	f7ff ba25 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST == IMM) {
   10e1c:	7863      	ldrb	r3, [r4, #1]
   10e1e:	6860      	ldr	r0, [r4, #4]
   10e20:	aa44      	add	r2, sp, #272	; 0x110
   10e22:	f003 030f 	and.w	r3, r3, #15
   10e26:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10e2a:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10e2e:	17c1      	asrs	r1, r0, #31
   10e30:	428b      	cmp	r3, r1
   10e32:	bf08      	it	eq
   10e34:	4282      	cmpeq	r2, r0
   10e36:	f47f aa16 	bne.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10e3a:	8863      	ldrh	r3, [r4, #2]
   10e3c:	441d      	add	r5, r3
   10e3e:	b2ad      	uxth	r5, r5
   10e40:	f7ff ba11 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST > (u32)IMM) {
   10e44:	7863      	ldrb	r3, [r4, #1]
   10e46:	6860      	ldr	r0, [r4, #4]
   10e48:	aa44      	add	r2, sp, #272	; 0x110
   10e4a:	f003 030f 	and.w	r3, r3, #15
   10e4e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10e52:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10e56:	2100      	movs	r1, #0
   10e58:	4299      	cmp	r1, r3
   10e5a:	bf08      	it	eq
   10e5c:	4290      	cmpeq	r0, r2
   10e5e:	f4bf aa02 	bcs.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10e62:	8863      	ldrh	r3, [r4, #2]
   10e64:	441d      	add	r5, r3
   10e66:	b2ad      	uxth	r5, r5
   10e68:	f7ff b9fd 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST > SRC) {
   10e6c:	7863      	ldrb	r3, [r4, #1]
   10e6e:	a944      	add	r1, sp, #272	; 0x110
   10e70:	f003 020f 	and.w	r2, r3, #15
   10e74:	091b      	lsrs	r3, r3, #4
   10e76:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10e7a:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   10e7e:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   10e82:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10e86:	428b      	cmp	r3, r1
   10e88:	bf08      	it	eq
   10e8a:	4282      	cmpeq	r2, r0
   10e8c:	f4bf a9eb 	bcs.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10e90:	8863      	ldrh	r3, [r4, #2]
   10e92:	441d      	add	r5, r3
   10e94:	b2ad      	uxth	r5, r5
   10e96:	f7ff b9e6 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST >= (u32)IMM) {
   10e9a:	7863      	ldrb	r3, [r4, #1]
   10e9c:	6860      	ldr	r0, [r4, #4]
   10e9e:	aa44      	add	r2, sp, #272	; 0x110
   10ea0:	f003 030f 	and.w	r3, r3, #15
   10ea4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10ea8:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10eac:	2100      	movs	r1, #0
   10eae:	428b      	cmp	r3, r1
   10eb0:	bf08      	it	eq
   10eb2:	4282      	cmpeq	r2, r0
   10eb4:	f4ff a9d7 	bcc.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10eb8:	8863      	ldrh	r3, [r4, #2]
   10eba:	441d      	add	r5, r3
   10ebc:	b2ad      	uxth	r5, r5
   10ebe:	f7ff b9d2 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST >= SRC) {
   10ec2:	7863      	ldrb	r3, [r4, #1]
   10ec4:	a944      	add	r1, sp, #272	; 0x110
   10ec6:	f003 020f 	and.w	r2, r3, #15
   10eca:	091b      	lsrs	r3, r3, #4
   10ecc:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10ed0:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   10ed4:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   10ed8:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10edc:	4299      	cmp	r1, r3
   10ede:	bf08      	it	eq
   10ee0:	4290      	cmpeq	r0, r2
   10ee2:	f4ff a9c0 	bcc.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10ee6:	8863      	ldrh	r3, [r4, #2]
   10ee8:	441d      	add	r5, r3
   10eea:	b2ad      	uxth	r5, r5
   10eec:	f7ff b9bb 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST < (u32)IMM) {
   10ef0:	7863      	ldrb	r3, [r4, #1]
   10ef2:	6860      	ldr	r0, [r4, #4]
   10ef4:	aa44      	add	r2, sp, #272	; 0x110
   10ef6:	f003 030f 	and.w	r3, r3, #15
   10efa:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10efe:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10f02:	2100      	movs	r1, #0
   10f04:	428b      	cmp	r3, r1
   10f06:	bf08      	it	eq
   10f08:	4282      	cmpeq	r2, r0
   10f0a:	f4bf a9ac 	bcs.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10f0e:	8863      	ldrh	r3, [r4, #2]
   10f10:	441d      	add	r5, r3
   10f12:	b2ad      	uxth	r5, r5
   10f14:	f7ff b9a7 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST < SRC) {
   10f18:	7863      	ldrb	r3, [r4, #1]
   10f1a:	a944      	add	r1, sp, #272	; 0x110
   10f1c:	f003 020f 	and.w	r2, r3, #15
   10f20:	091b      	lsrs	r3, r3, #4
   10f22:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10f26:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   10f2a:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   10f2e:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10f32:	4299      	cmp	r1, r3
   10f34:	bf08      	it	eq
   10f36:	4290      	cmpeq	r0, r2
   10f38:	f4bf a995 	bcs.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10f3c:	8863      	ldrh	r3, [r4, #2]
   10f3e:	441d      	add	r5, r3
   10f40:	b2ad      	uxth	r5, r5
   10f42:	f7ff b990 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST <= (u32)IMM) {
   10f46:	7863      	ldrb	r3, [r4, #1]
   10f48:	6860      	ldr	r0, [r4, #4]
   10f4a:	aa44      	add	r2, sp, #272	; 0x110
   10f4c:	f003 030f 	and.w	r3, r3, #15
   10f50:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10f54:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10f58:	2100      	movs	r1, #0
   10f5a:	4299      	cmp	r1, r3
   10f5c:	bf08      	it	eq
   10f5e:	4290      	cmpeq	r0, r2
   10f60:	f4ff a981 	bcc.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10f64:	8863      	ldrh	r3, [r4, #2]
   10f66:	441d      	add	r5, r3
   10f68:	b2ad      	uxth	r5, r5
   10f6a:	f7ff b97c 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST <= SRC) {
   10f6e:	7863      	ldrb	r3, [r4, #1]
   10f70:	a944      	add	r1, sp, #272	; 0x110
   10f72:	f003 020f 	and.w	r2, r3, #15
   10f76:	091b      	lsrs	r3, r3, #4
   10f78:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10f7c:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   10f80:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   10f84:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   10f88:	428b      	cmp	r3, r1
   10f8a:	bf08      	it	eq
   10f8c:	4282      	cmpeq	r2, r0
   10f8e:	f4ff a96a 	bcc.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10f92:	8863      	ldrh	r3, [r4, #2]
   10f94:	441d      	add	r5, r3
   10f96:	b2ad      	uxth	r5, r5
   10f98:	f7ff b965 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST & IMM) {
   10f9c:	7863      	ldrb	r3, [r4, #1]
   10f9e:	aa44      	add	r2, sp, #272	; 0x110
   10fa0:	f003 030f 	and.w	r3, r3, #15
   10fa4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   10fa8:	e953 0338 	ldrd	r0, r3, [r3, #-224]	; 0xe0
   10fac:	6862      	ldr	r2, [r4, #4]
   10fae:	ea4f 7ae2 	mov.w	sl, r2, asr #31
   10fb2:	ea0a 0303 	and.w	r3, sl, r3
   10fb6:	4002      	ands	r2, r0
   10fb8:	9206      	str	r2, [sp, #24]
   10fba:	9307      	str	r3, [sp, #28]
   10fbc:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   10fc0:	4313      	orrs	r3, r2
   10fc2:	f43f a950 	beq.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10fc6:	8863      	ldrh	r3, [r4, #2]
   10fc8:	441d      	add	r5, r3
   10fca:	b2ad      	uxth	r5, r5
   10fcc:	f7ff b94b 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST & SRC) {
   10fd0:	7863      	ldrb	r3, [r4, #1]
   10fd2:	a944      	add	r1, sp, #272	; 0x110
   10fd4:	f003 020f 	and.w	r2, r3, #15
   10fd8:	091b      	lsrs	r3, r3, #4
   10fda:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   10fde:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   10fe2:	e952 0238 	ldrd	r0, r2, [r2, #-224]	; 0xe0
   10fe6:	e953 1338 	ldrd	r1, r3, [r3, #-224]	; 0xe0
   10fea:	4013      	ands	r3, r2
   10fec:	4001      	ands	r1, r0
   10fee:	9108      	str	r1, [sp, #32]
   10ff0:	9309      	str	r3, [sp, #36]	; 0x24
   10ff2:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   10ff6:	4313      	orrs	r3, r2
   10ff8:	f43f a935 	beq.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   10ffc:	8863      	ldrh	r3, [r4, #2]
   10ffe:	441d      	add	r5, r3
   11000:	b2ad      	uxth	r5, r5
   11002:	f7ff b930 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST != IMM) {
   11006:	7863      	ldrb	r3, [r4, #1]
   11008:	6860      	ldr	r0, [r4, #4]
   1100a:	aa44      	add	r2, sp, #272	; 0x110
   1100c:	f003 030f 	and.w	r3, r3, #15
   11010:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   11014:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   11018:	17c1      	asrs	r1, r0, #31
   1101a:	428b      	cmp	r3, r1
   1101c:	bf08      	it	eq
   1101e:	4282      	cmpeq	r2, r0
   11020:	f43f a921 	beq.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   11024:	8863      	ldrh	r3, [r4, #2]
   11026:	441d      	add	r5, r3
   11028:	b2ad      	uxth	r5, r5
   1102a:	f7ff b91c 	b.w	10266 <ebpf_vm_exec+0x20e>
			if (DST != SRC) {
   1102e:	7863      	ldrb	r3, [r4, #1]
   11030:	a944      	add	r1, sp, #272	; 0x110
   11032:	f003 020f 	and.w	r2, r3, #15
   11036:	091b      	lsrs	r3, r3, #4
   11038:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   1103c:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   11040:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   11044:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   11048:	4299      	cmp	r1, r3
   1104a:	bf08      	it	eq
   1104c:	4290      	cmpeq	r0, r2
   1104e:	f43f a90a 	beq.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   11052:	8863      	ldrh	r3, [r4, #2]
   11054:	441d      	add	r5, r3
   11056:	b2ad      	uxth	r5, r5
   11058:	f7ff b905 	b.w	10266 <ebpf_vm_exec+0x20e>
			if ((s64)DST > (s64) IMM) {
   1105c:	7863      	ldrb	r3, [r4, #1]
   1105e:	6860      	ldr	r0, [r4, #4]
   11060:	aa44      	add	r2, sp, #272	; 0x110
   11062:	f003 030f 	and.w	r3, r3, #15
   11066:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1106a:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   1106e:	17c1      	asrs	r1, r0, #31
   11070:	4290      	cmp	r0, r2
   11072:	eb71 0303 	sbcs.w	r3, r1, r3
   11076:	f6bf a8f6 	bge.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   1107a:	8863      	ldrh	r3, [r4, #2]
   1107c:	441d      	add	r5, r3
   1107e:	b2ad      	uxth	r5, r5
   11080:	f7ff b8f1 	b.w	10266 <ebpf_vm_exec+0x20e>
			if ((s64)DST > (s64)SRC) {
   11084:	7863      	ldrb	r3, [r4, #1]
   11086:	a944      	add	r1, sp, #272	; 0x110
   11088:	f003 020f 	and.w	r2, r3, #15
   1108c:	091b      	lsrs	r3, r3, #4
   1108e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   11092:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   11096:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   1109a:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   1109e:	4282      	cmp	r2, r0
   110a0:	418b      	sbcs	r3, r1
   110a2:	f6bf a8e0 	bge.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   110a6:	8863      	ldrh	r3, [r4, #2]
   110a8:	441d      	add	r5, r3
   110aa:	b2ad      	uxth	r5, r5
   110ac:	f7ff b8db 	b.w	10266 <ebpf_vm_exec+0x20e>
			if ((s64)DST >= (s64) IMM) {
   110b0:	7863      	ldrb	r3, [r4, #1]
   110b2:	6860      	ldr	r0, [r4, #4]
   110b4:	aa44      	add	r2, sp, #272	; 0x110
   110b6:	f003 030f 	and.w	r3, r3, #15
   110ba:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   110be:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   110c2:	17c1      	asrs	r1, r0, #31
   110c4:	4282      	cmp	r2, r0
   110c6:	418b      	sbcs	r3, r1
   110c8:	f6ff a8cd 	blt.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   110cc:	8863      	ldrh	r3, [r4, #2]
   110ce:	441d      	add	r5, r3
   110d0:	b2ad      	uxth	r5, r5
   110d2:	f7ff b8c8 	b.w	10266 <ebpf_vm_exec+0x20e>
			if ((s64)DST >= (s64)SRC) {
   110d6:	7863      	ldrb	r3, [r4, #1]
   110d8:	a944      	add	r1, sp, #272	; 0x110
   110da:	f003 020f 	and.w	r2, r3, #15
   110de:	091b      	lsrs	r3, r3, #4
   110e0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   110e4:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   110e8:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   110ec:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   110f0:	4290      	cmp	r0, r2
   110f2:	eb71 0303 	sbcs.w	r3, r1, r3
   110f6:	f6ff a8b6 	blt.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   110fa:	8863      	ldrh	r3, [r4, #2]
   110fc:	441d      	add	r5, r3
   110fe:	b2ad      	uxth	r5, r5
   11100:	f7ff b8b1 	b.w	10266 <ebpf_vm_exec+0x20e>
			if ((s64)DST < (s64) IMM) {
   11104:	7863      	ldrb	r3, [r4, #1]
   11106:	6860      	ldr	r0, [r4, #4]
   11108:	aa44      	add	r2, sp, #272	; 0x110
   1110a:	f003 030f 	and.w	r3, r3, #15
   1110e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   11112:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   11116:	17c1      	asrs	r1, r0, #31
   11118:	4282      	cmp	r2, r0
   1111a:	418b      	sbcs	r3, r1
   1111c:	f6bf a8a3 	bge.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   11120:	8863      	ldrh	r3, [r4, #2]
   11122:	441d      	add	r5, r3
   11124:	b2ad      	uxth	r5, r5
   11126:	f7ff b89e 	b.w	10266 <ebpf_vm_exec+0x20e>
			if ((s64)DST < (s64)SRC) {
   1112a:	7863      	ldrb	r3, [r4, #1]
   1112c:	a944      	add	r1, sp, #272	; 0x110
   1112e:	f003 020f 	and.w	r2, r3, #15
   11132:	091b      	lsrs	r3, r3, #4
   11134:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   11138:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   1113c:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   11140:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   11144:	4290      	cmp	r0, r2
   11146:	eb71 0303 	sbcs.w	r3, r1, r3
   1114a:	f6bf a88c 	bge.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   1114e:	8863      	ldrh	r3, [r4, #2]
   11150:	441d      	add	r5, r3
   11152:	b2ad      	uxth	r5, r5
   11154:	f7ff b887 	b.w	10266 <ebpf_vm_exec+0x20e>
			if ((s64)DST <= (s64) IMM) {
   11158:	7863      	ldrb	r3, [r4, #1]
   1115a:	6860      	ldr	r0, [r4, #4]
   1115c:	aa44      	add	r2, sp, #272	; 0x110
   1115e:	f003 030f 	and.w	r3, r3, #15
   11162:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   11166:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   1116a:	17c1      	asrs	r1, r0, #31
   1116c:	4290      	cmp	r0, r2
   1116e:	eb71 0303 	sbcs.w	r3, r1, r3
   11172:	f6ff a878 	blt.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   11176:	8863      	ldrh	r3, [r4, #2]
   11178:	441d      	add	r5, r3
   1117a:	b2ad      	uxth	r5, r5
   1117c:	f7ff b873 	b.w	10266 <ebpf_vm_exec+0x20e>
			if ((s64)DST <= (s64)SRC) {
   11180:	7863      	ldrb	r3, [r4, #1]
   11182:	a944      	add	r1, sp, #272	; 0x110
   11184:	f003 020f 	and.w	r2, r3, #15
   11188:	091b      	lsrs	r3, r3, #4
   1118a:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   1118e:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
   11192:	e952 0138 	ldrd	r0, r1, [r2, #-224]	; 0xe0
   11196:	e953 2338 	ldrd	r2, r3, [r3, #-224]	; 0xe0
   1119a:	4282      	cmp	r2, r0
   1119c:	418b      	sbcs	r3, r1
   1119e:	f6ff a862 	blt.w	10266 <ebpf_vm_exec+0x20e>
				pc += inst->offset;
   111a2:	8863      	ldrh	r3, [r4, #2]
   111a4:	441d      	add	r5, r3
   111a6:	b2ad      	uxth	r5, r5
   111a8:	f7ff b85d 	b.w	10266 <ebpf_vm_exec+0x20e>
			reg[0] = vm->helper_func->ext_funcs[inst->imm](reg[1], reg[2], reg[3], reg[4], reg[5]);
   111ac:	68b3      	ldr	r3, [r6, #8]
   111ae:	6860      	ldr	r0, [r4, #4]
   111b0:	6819      	ldr	r1, [r3, #0]
   111b2:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
   111b6:	e9cd 2304 	strd	r2, r3, [sp, #16]
   111ba:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
   111be:	e9cd 2302 	strd	r2, r3, [sp, #8]
   111c2:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
   111c6:	e9cd 2300 	strd	r2, r3, [sp]
   111ca:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
   111ce:	f851 4020 	ldr.w	r4, [r1, r0, lsl #2]
   111d2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   111d6:	47a0      	blx	r4
   111d8:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
			break;
   111dc:	f7ff b843 	b.w	10266 <ebpf_vm_exec+0x20e>
			return reg[0];
   111e0:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
}
   111e4:	b045      	add	sp, #276	; 0x114
   111e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				return -1;
   111ea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   111ee:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   111f2:	e7f7      	b.n	111e4 <ebpf_vm_exec+0x118c>

000111f4 <binary_search>:
#include <string.h>
// #include "hotpatch/include/utils.h"

#define MAP_GROW 4

static int binary_search(void **arr, int size, uint32_t val) {
   111f4:	b530      	push	{r4, r5, lr}
	int start = 0;
	int end = size - 1;
   111f6:	3901      	subs	r1, #1
	int start = 0;
   111f8:	2400      	movs	r4, #0
	while (start <= end) {
   111fa:	428c      	cmp	r4, r1
   111fc:	dd03      	ble.n	11206 <binary_search+0x12>
			end = mid - 1;
		} else {
			start = mid + 1;
		}
	}
	return -1;
   111fe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
   11202:	4618      	mov	r0, r3
   11204:	bd30      	pop	{r4, r5, pc}
		int mid = (start + end) / 2;
   11206:	1863      	adds	r3, r4, r1
   11208:	105b      	asrs	r3, r3, #1
		if (m == val) {
   1120a:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
   1120e:	4295      	cmp	r5, r2
   11210:	d0f7      	beq.n	11202 <binary_search+0xe>
			end = mid - 1;
   11212:	bf8c      	ite	hi
   11214:	f103 31ff 	addhi.w	r1, r3, #4294967295	; 0xffffffff
			start = mid + 1;
   11218:	1c5c      	addls	r4, r3, #1
   1121a:	e7ee      	b.n	111fa <binary_search+0x6>

0001121c <arraymap_new>:
	if (key < arr->cur_size) {
		arr->vals[key] = NULL;
	}
}

arraymap *arraymap_new(int initial_size) {
   1121c:	b538      	push	{r3, r4, r5, lr}
   1121e:	4605      	mov	r5, r0
	arraymap *map = ebpf_malloc(sizeof(arraymap));
   11220:	200c      	movs	r0, #12
   11222:	f7f2 fb05 	bl	3830 <ebpf_malloc>
	map->cur_size = 0;
   11226:	2300      	movs	r3, #0
	map->max_size = initial_size;
   11228:	8005      	strh	r5, [r0, #0]
	map->keys = ebpf_malloc(initial_size * sizeof(void *));
   1122a:	00ad      	lsls	r5, r5, #2
	arraymap *map = ebpf_malloc(sizeof(arraymap));
   1122c:	4604      	mov	r4, r0
	map->cur_size = 0;
   1122e:	8043      	strh	r3, [r0, #2]
	map->keys = ebpf_malloc(initial_size * sizeof(void *));
   11230:	4628      	mov	r0, r5
   11232:	f7f2 fafd 	bl	3830 <ebpf_malloc>
   11236:	6060      	str	r0, [r4, #4]
	map->vals = ebpf_malloc(initial_size * sizeof(void *));
   11238:	4628      	mov	r0, r5
   1123a:	f7f2 faf9 	bl	3830 <ebpf_malloc>
   1123e:	60a0      	str	r0, [r4, #8]
	return map;
}
   11240:	4620      	mov	r0, r4
   11242:	bd38      	pop	{r3, r4, r5, pc}

00011244 <arraymap_destroy>:

void arraymap_destroy(arraymap *map) {
   11244:	b510      	push	{r4, lr}
   11246:	4604      	mov	r4, r0
	ebpf_free(map->keys);
   11248:	6840      	ldr	r0, [r0, #4]
   1124a:	f7fe fea5 	bl	ff98 <ebpf_free>
	ebpf_free(map->vals);
   1124e:	68a0      	ldr	r0, [r4, #8]
   11250:	f7fe fea2 	bl	ff98 <ebpf_free>
	ebpf_free(map);
   11254:	4620      	mov	r0, r4
}
   11256:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ebpf_free(map);
   1125a:	f7fe be9d 	b.w	ff98 <ebpf_free>

0001125e <arraymap_set>:

int arraymap_set(arraymap *map, void *key, void *val) {
   1125e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11262:	4617      	mov	r7, r2
	if (map->cur_size == 0) {
   11264:	8842      	ldrh	r2, [r0, #2]
int arraymap_set(arraymap *map, void *key, void *val) {
   11266:	4604      	mov	r4, r0
   11268:	460e      	mov	r6, r1
   1126a:	6840      	ldr	r0, [r0, #4]
	if (map->cur_size == 0) {
   1126c:	b942      	cbnz	r2, 11280 <arraymap_set+0x22>
		map->keys[0] = key;
   1126e:	6001      	str	r1, [r0, #0]
		map->vals[0] = val;
   11270:	68a3      	ldr	r3, [r4, #8]
   11272:	601f      	str	r7, [r3, #0]
		map->cur_size++;
   11274:	2301      	movs	r3, #1
   11276:	8063      	strh	r3, [r4, #2]
		return 0;
   11278:	4615      	mov	r5, r2
	map->keys[insert] = key;
	map->vals[insert] = val;
	map->cur_size++;
	//DEBUG_LOG("%u insert: %d sz: %d\n", (uint32_t) key, insert, map->cur_size);
	return insert;
}
   1127a:	4628      	mov	r0, r5
   1127c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	int insert = lower_bound(map->keys, map->cur_size, (uint32_t) key);
   11280:	4615      	mov	r5, r2
	int start = 0;
   11282:	2100      	movs	r1, #0
	while (start + 1 < end) {
   11284:	1c4b      	adds	r3, r1, #1
   11286:	42ab      	cmp	r3, r5
   11288:	db09      	blt.n	1129e <arraymap_set+0x40>
	if ((uint32_t)(map->keys[insert]) == (uint32_t) key) {
   1128a:	f850 3025 	ldr.w	r3, [r0, r5, lsl #2]
   1128e:	42b3      	cmp	r3, r6
   11290:	ea4f 0985 	mov.w	r9, r5, lsl #2
   11294:	d10e      	bne.n	112b4 <arraymap_set+0x56>
		map->vals[insert] = val;
   11296:	68a3      	ldr	r3, [r4, #8]
   11298:	f843 7025 	str.w	r7, [r3, r5, lsl #2]
		return;
   1129c:	e7ed      	b.n	1127a <arraymap_set+0x1c>
		mid = (start + end) / 2;
   1129e:	194b      	adds	r3, r1, r5
   112a0:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
   112a4:	105b      	asrs	r3, r3, #1
		if ((uint32_t) arr[mid] < val) { // (start, mid]
   112a6:	f850 c023 	ldr.w	ip, [r0, r3, lsl #2]
   112aa:	4566      	cmp	r6, ip
		mid = (start + end) / 2;
   112ac:	bf94      	ite	ls
   112ae:	461d      	movls	r5, r3
   112b0:	4619      	movhi	r1, r3
   112b2:	e7e7      	b.n	11284 <arraymap_set+0x26>
	if (map->cur_size >= map->max_size) {
   112b4:	8823      	ldrh	r3, [r4, #0]
   112b6:	429a      	cmp	r2, r3
   112b8:	d314      	bcc.n	112e4 <arraymap_set+0x86>
		int new_size = map->max_size + MAP_GROW;
   112ba:	f103 0804 	add.w	r8, r3, #4
		int ori_size = sizeof(darray) + map->max_size * sizeof(void *);
   112be:	f103 0a02 	add.w	sl, r3, #2
   112c2:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
		map->keys = ebpf_realloc(map->keys, ori_size, new_size * sizeof(void *));
   112c6:	ea4f 0b88 	mov.w	fp, r8, lsl #2
   112ca:	465a      	mov	r2, fp
   112cc:	4651      	mov	r1, sl
   112ce:	f7f2 fab7 	bl	3840 <ebpf_realloc>
		map->vals = ebpf_realloc(map->vals, ori_size, new_size * sizeof(void *));
   112d2:	465a      	mov	r2, fp
		map->keys = ebpf_realloc(map->keys, ori_size, new_size * sizeof(void *));
   112d4:	6060      	str	r0, [r4, #4]
		map->vals = ebpf_realloc(map->vals, ori_size, new_size * sizeof(void *));
   112d6:	4651      	mov	r1, sl
   112d8:	68a0      	ldr	r0, [r4, #8]
   112da:	f7f2 fab1 	bl	3840 <ebpf_realloc>
		map->max_size = new_size;
   112de:	f8a4 8000 	strh.w	r8, [r4]
		map->vals = ebpf_realloc(map->vals, ori_size, new_size * sizeof(void *));
   112e2:	60a0      	str	r0, [r4, #8]
	for (int i = map->cur_size; i > insert; i--) {
   112e4:	f8b4 c002 	ldrh.w	ip, [r4, #2]
   112e8:	4663      	mov	r3, ip
   112ea:	42ab      	cmp	r3, r5
   112ec:	6861      	ldr	r1, [r4, #4]
   112ee:	dc08      	bgt.n	11302 <arraymap_set+0xa4>
	map->keys[insert] = key;
   112f0:	f841 6009 	str.w	r6, [r1, r9]
	map->vals[insert] = val;
   112f4:	68a3      	ldr	r3, [r4, #8]
	map->cur_size++;
   112f6:	f10c 0201 	add.w	r2, ip, #1
	map->vals[insert] = val;
   112fa:	f843 7009 	str.w	r7, [r3, r9]
	map->cur_size++;
   112fe:	8062      	strh	r2, [r4, #2]
	return insert;
   11300:	e7bb      	b.n	1127a <arraymap_set+0x1c>
		map->keys[i] = map->keys[i - 1];
   11302:	0098      	lsls	r0, r3, #2
   11304:	3804      	subs	r0, #4
   11306:	580a      	ldr	r2, [r1, r0]
   11308:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		map->vals[i] = map->vals[i - 1];
   1130c:	68a1      	ldr	r1, [r4, #8]
   1130e:	5808      	ldr	r0, [r1, r0]
   11310:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
   11314:	3b01      	subs	r3, #1
   11316:	e7e8      	b.n	112ea <arraymap_set+0x8c>

00011318 <arraymap_get>:

void* arraymap_get(arraymap *map, void * key) {
   11318:	b510      	push	{r4, lr}
	int idx = binary_search(map->keys, map->cur_size, (uint32_t) key);
   1131a:	460a      	mov	r2, r1
void* arraymap_get(arraymap *map, void * key) {
   1131c:	4604      	mov	r4, r0
	int idx = binary_search(map->keys, map->cur_size, (uint32_t) key);
   1131e:	8841      	ldrh	r1, [r0, #2]
   11320:	6840      	ldr	r0, [r0, #4]
   11322:	f7ff ff67 	bl	111f4 <binary_search>
	// DEBUG_LOG("search: %d key: %u sz: %d %d\n", idx, key, map->cur_size);
	if (idx != -1) {
   11326:	1c43      	adds	r3, r0, #1
		return map->vals[idx];
   11328:	bf16      	itet	ne
   1132a:	68a3      	ldrne	r3, [r4, #8]
	}
	return NULL;
   1132c:	2000      	moveq	r0, #0
		return map->vals[idx];
   1132e:	f853 0020 	ldrne.w	r0, [r3, r0, lsl #2]
}
   11332:	bd10      	pop	{r4, pc}

00011334 <arraymap_iter_val>:
	}
	return map->keys[idx];
}

void* arraymap_iter_val(arraymap *map, int idx) {
	if (idx < 0 || idx >= map->cur_size) {
   11334:	2900      	cmp	r1, #0
   11336:	db06      	blt.n	11346 <arraymap_iter_val+0x12>
   11338:	8843      	ldrh	r3, [r0, #2]
   1133a:	428b      	cmp	r3, r1
   1133c:	dd03      	ble.n	11346 <arraymap_iter_val+0x12>
		return NULL;
	}
	return map->vals[idx];
   1133e:	6883      	ldr	r3, [r0, #8]
   11340:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
   11344:	4770      	bx	lr
		return NULL;
   11346:	2000      	movs	r0, #0
}
   11348:	4770      	bx	lr

0001134a <jit_mem_free>:

void jit_mem_free(jit_mem *mem) {
	mem->code_size = 0;
   1134a:	2300      	movs	r3, #0
	mem->jit_code = NULL;
   1134c:	e9c0 3300 	strd	r3, r3, [r0]
	mem->jmp_offsets = NULL;
   11350:	6083      	str	r3, [r0, #8]
}
   11352:	4770      	bx	lr

00011354 <jit_state_set_mem>:

#endif

void jit_state_set_mem(jit_state *state, jit_mem *mem) {
	state->jmem = mem;
	state->jit_code = (uint8_t *) ((uint32_t) mem->jit_code & (~0x3));
   11354:	680b      	ldr	r3, [r1, #0]
	state->jmem = mem;
   11356:	6241      	str	r1, [r0, #36]	; 0x24
	state->jit_code = (uint8_t *) ((uint32_t) mem->jit_code & (~0x3));
   11358:	f023 0303 	bic.w	r3, r3, #3
   1135c:	6083      	str	r3, [r0, #8]
	state->offsets = (uint32_t *) mem->jmp_offsets;
   1135e:	688b      	ldr	r3, [r1, #8]
   11360:	61c3      	str	r3, [r0, #28]
}
   11362:	4770      	bx	lr

00011364 <gen_jit_code>:

void gen_jit_code(struct ebpf_vm *vm) {
   11364:	b510      	push	{r4, lr}
	if (vm->jmem != NULL) {
   11366:	6903      	ldr	r3, [r0, #16]
void gen_jit_code(struct ebpf_vm *vm) {
   11368:	b08c      	sub	sp, #48	; 0x30
   1136a:	4604      	mov	r4, r0
	if (vm->jmem != NULL) {
   1136c:	b11b      	cbz	r3, 11376 <gen_jit_code+0x12>
	mem->code_size = 0;
   1136e:	2200      	movs	r2, #0
	mem->jit_code = NULL;
   11370:	e9c3 2200 	strd	r2, r2, [r3]
	mem->jmp_offsets = NULL;
   11374:	609a      	str	r2, [r3, #8]
		jit_mem_free(vm->jmem);
	}
	vm->jmem = jit_mem_allocate(vm->num_insts);
   11376:	88a0      	ldrh	r0, [r4, #4]
   11378:	f7f2 fb08 	bl	398c <jit_mem_allocate>
	jit_state state;
	state.insts = vm->insts;
   1137c:	6823      	ldr	r3, [r4, #0]
   1137e:	9301      	str	r3, [sp, #4]
	state.inst_num = vm->num_insts;
   11380:	88a3      	ldrh	r3, [r4, #4]
   11382:	9302      	str	r3, [sp, #8]
	state.idx = 0;
   11384:	2300      	movs	r3, #0
   11386:	9305      	str	r3, [sp, #20]
	//state.jit_code = (uint8_t *) ((uint32_t) vm->jmem->jit_code & (~0x3));
	state.err_line = 0;
   11388:	9307      	str	r3, [sp, #28]
	state.__bpf_call_base = vm->helper_func->ext_funcs;
   1138a:	68a3      	ldr	r3, [r4, #8]
	vm->jmem = jit_mem_allocate(vm->num_insts);
   1138c:	6120      	str	r0, [r4, #16]
   1138e:	4601      	mov	r1, r0
	state.__bpf_call_base = vm->helper_func->ext_funcs;
   11390:	681b      	ldr	r3, [r3, #0]
   11392:	9309      	str	r3, [sp, #36]	; 0x24
	jit_state_set_mem(&state, vm->jmem);
   11394:	a801      	add	r0, sp, #4
   11396:	f7ff ffdd 	bl	11354 <jit_state_set_mem>
	jit_compile(&state);
   1139a:	a801      	add	r0, sp, #4
   1139c:	f7f3 fcea 	bl	4d74 <jit_compile>
	vm->jit_func = (ebpf_jit_fn) ((uint32_t) vm->jmem->jit_code | 0x1);
   113a0:	6923      	ldr	r3, [r4, #16]
   113a2:	681b      	ldr	r3, [r3, #0]
   113a4:	f043 0301 	orr.w	r3, r3, #1
   113a8:	60e3      	str	r3, [r4, #12]

#ifdef SYS_CORTEX_M4
	__asm__("DSB");
   113aa:	f3bf 8f4f 	dsb	sy
	__asm__("ISB");
   113ae:	f3bf 8f6f 	isb	sy
#endif
	jit_dump_inst(&state);
   113b2:	a801      	add	r0, sp, #4
   113b4:	f7f2 fe08 	bl	3fc8 <jit_dump_inst>
#ifdef LINUX_TEST
	// jit_dump_inst(&state);
#endif
}
   113b8:	b00c      	add	sp, #48	; 0x30
   113ba:	bd10      	pop	{r4, pc}

000113bc <jit_mem_statistic>:

int jit_mem_statistic(struct ebpf_vm *vm) {
	int code_size = vm->num_insts * 4;
   113bc:	8880      	ldrh	r0, [r0, #4]
	int jit_size = 10 * vm->num_insts + 16;
	int offset_size = 4 * vm->num_insts + 16;
	int mem = code_size + jit_size + offset_size;
	return code_size;
}
   113be:	0080      	lsls	r0, r0, #2
   113c0:	4770      	bx	lr

000113c2 <emit2>:

static inline void
emit_bytes(struct jit_state *state, void *data, uint32_t len) 
{
    // my_printf("emit_bytes: %s 0x%x\n", state->jit_code, *((uint16_t*) data));
    if (state->needGen) {
   113c2:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
   113c6:	b113      	cbz	r3, 113ce <emit2+0xc>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   113c8:	6882      	ldr	r2, [r0, #8]
   113ca:	6903      	ldr	r3, [r0, #16]
   113cc:	52d1      	strh	r1, [r2, r3]
    // uint8_t *d = (uint8_t *) data;
    // for (int i = 0; i < len; i++) {
    //     state->jit_code[state->idx + i] = d[i];
    //     my_printf("state->jit_code[%d] = 0x%x\n", state->idx + i, d[i]);
    // }
    state->idx += len;
   113ce:	6903      	ldr	r3, [r0, #16]
   113d0:	3302      	adds	r3, #2
   113d2:	6103      	str	r3, [r0, #16]
static inline void
emit2(struct jit_state *state, uint16_t x)
{
    emit_bytes(state, &x, sizeof(x));
    //state->inst_loc += 1;
}
   113d4:	4770      	bx	lr

000113d6 <emit4>:

// little edian
static inline void
emit4(struct jit_state *state, uint32_t x)
{
   113d6:	b538      	push	{r3, r4, r5, lr}
   113d8:	460c      	mov	r4, r1
    uint16_t *u2 = (uint16_t *) (&x);
    emit2(state, u2[1]);
   113da:	0c09      	lsrs	r1, r1, #16
   113dc:	f7ff fff1 	bl	113c2 <emit2>
    emit2(state, u2[0]);
   113e0:	b2a1      	uxth	r1, r4
    // emit_bytes(state, &u2[1], sizeof(u2[1]));
    // emit_bytes(state, &u2[0], sizeof(u2[0]));
}
   113e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    emit2(state, u2[0]);
   113e6:	f7ff bfec 	b.w	113c2 <emit2>

000113ea <arm_bpf_get_reg32>:
	if (is_stacked(reg)) {
   113ea:	1e0b      	subs	r3, r1, #0
static int8_t arm_bpf_get_reg32(jit_state *state, s8 reg, s8 tmp) {
   113ec:	b510      	push	{r4, lr}
   113ee:	4614      	mov	r4, r2
	if (is_stacked(reg)) {
   113f0:	da04      	bge.n	113fc <arm_bpf_get_reg32+0x12>
        _emit_ldr_i(state, tmp, ARM_FP, off);
   113f2:	220b      	movs	r2, #11
   113f4:	4621      	mov	r1, r4
   113f6:	f7f2 faf9 	bl	39ec <_emit_ldr_i>
		reg = tmp;
   113fa:	4623      	mov	r3, r4
}
   113fc:	4618      	mov	r0, r3
   113fe:	bd10      	pop	{r4, pc}

00011400 <_emit_str_i>:
    u8 P = off != 0;
   11400:	2b00      	cmp	r3, #0
static void _emit_str_i(jit_state *state, const s8 RnSrc, const s8 Rt,  s16 off) {
   11402:	b430      	push	{r4, r5}
    u8 U = off > 0, W = 0;
   11404:	bfcc      	ite	gt
   11406:	2501      	movgt	r5, #1
   11408:	2500      	movle	r5, #0
    u8 flag = 0b1000 | (P << 2) | (U << 1) | (W);
   1140a:	bf14      	ite	ne
   1140c:	2404      	movne	r4, #4
   1140e:	2400      	moveq	r4, #0
   11410:	ea44 0445 	orr.w	r4, r4, r5, lsl #1
    u32 inst = (THUMB2_STR_IMM)  | (RnSrc << 16) | (Rt << 12) | (flag << 8) | (imm8);
   11414:	f044 0408 	orr.w	r4, r4, #8
   11418:	0312      	lsls	r2, r2, #12
    u8 imm8 = off > 0 ? off : -off;
   1141a:	2b00      	cmp	r3, #0
    u32 inst = (THUMB2_STR_IMM)  | (RnSrc << 16) | (Rt << 12) | (flag << 8) | (imm8);
   1141c:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
    u8 imm8 = off > 0 ? off : -off;
   11420:	bfb8      	it	lt
   11422:	425b      	neglt	r3, r3
    u32 inst = (THUMB2_STR_IMM)  | (RnSrc << 16) | (Rt << 12) | (flag << 8) | (imm8);
   11424:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   11428:	b2da      	uxtb	r2, r3
   1142a:	4311      	orrs	r1, r2
    emit4(state, inst);
   1142c:	f041 4178 	orr.w	r1, r1, #4160749568	; 0xf8000000
   11430:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
}
   11434:	bc30      	pop	{r4, r5}
    emit4(state, inst);
   11436:	f7ff bfce 	b.w	113d6 <emit4>

0001143a <_emit_strd_i.constprop.27>:
static void _emit_strd_i(jit_state *state, const s8 RnSrc[], const s8 RtDst,  s16 off) {
   1143a:	b410      	push	{r4}
    u32 P = offImm8 != 0;
   1143c:	2a00      	cmp	r2, #0
    u32 imm8 = offImm8 > 0 ? offImm8 : -offImm8;
   1143e:	ea82 74e2 	eor.w	r4, r2, r2, asr #31
   11442:	eba4 74e2 	sub.w	r4, r4, r2, asr #31
    u32 inst = (THUMB2_STRD_IMM) | (P << 24) | (U << 23) | (W << 22) | 
   11446:	bf18      	it	ne
   11448:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
    u32 U = offImm8 > 0, W = 0;
   1144c:	bfcc      	ite	gt
   1144e:	2201      	movgt	r2, #1
   11450:	2200      	movle	r2, #0
    u32 inst = (THUMB2_STRD_IMM) | (P << 24) | (U << 23) | (W << 22) | 
   11452:	bf08      	it	eq
   11454:	2300      	moveq	r3, #0
   11456:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
        (RtDst << 16) | (RnSrc[1] << 12) | (RnSrc[0] << 8) | (imm8);
   1145a:	f991 2000 	ldrsb.w	r2, [r1]
   1145e:	f991 1001 	ldrsb.w	r1, [r1, #1]
    imm8 = (imm8 >> 2) & 0xff;
   11462:	f3c4 0487 	ubfx	r4, r4, #2, #8
    u32 inst = (THUMB2_STRD_IMM) | (P << 24) | (U << 23) | (W << 22) | 
   11466:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1146a:	4323      	orrs	r3, r4
   1146c:	ea43 3101 	orr.w	r1, r3, r1, lsl #12
    emit4(state, _thumb32_STRD_IMM_T1(RnSrc, RtDst, off));
   11470:	f041 4168 	orr.w	r1, r1, #3892314112	; 0xe8000000
   11474:	f441 0196 	orr.w	r1, r1, #4915200	; 0x4b0000
}
   11478:	bc10      	pop	{r4}
    emit4(state, _thumb32_STRD_IMM_T1(RnSrc, RtDst, off));
   1147a:	f7ff bfac 	b.w	113d6 <emit4>

0001147e <_emit_ldrd_i.constprop.29>:
static void _emit_ldrd_i(jit_state *state, const s8 Rt[], const s8 Rn, s16 off) {
   1147e:	b410      	push	{r4}
    u32 P = offImm8 != 0, U = offImm8 > 0, W = 0;
   11480:	2a00      	cmp	r2, #0
    u32 imm8 = offImm8 > 0 ? offImm8 : -offImm8;
   11482:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
   11486:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
    u32 P = offImm8 != 0, U = offImm8 > 0, W = 0;
   1148a:	bfcc      	ite	gt
   1148c:	2401      	movgt	r4, #1
   1148e:	2400      	movle	r4, #0
    u32 flag = 0b0010 | (P << 3) | (U << 2) | W;
   11490:	bf14      	ite	ne
   11492:	2208      	movne	r2, #8
   11494:	2200      	moveq	r2, #0
   11496:	ea42 0284 	orr.w	r2, r2, r4, lsl #2
    u32 inst = (THUMB2_LDRD_IMM) | (flag << 21) | (Rn << 16) | (Rt[1] << 12) | (Rt[0] << 8) | (imm8);
   1149a:	f991 4001 	ldrsb.w	r4, [r1, #1]
   1149e:	f991 1000 	ldrsb.w	r1, [r1]
   114a2:	0209      	lsls	r1, r1, #8
   114a4:	ea41 3104 	orr.w	r1, r1, r4, lsl #12
   114a8:	ea41 5142 	orr.w	r1, r1, r2, lsl #21
    imm8 = (imm8 >> 2) & 0xff;
   114ac:	f3c3 0387 	ubfx	r3, r3, #2, #8
    u32 inst = (THUMB2_LDRD_IMM) | (flag << 21) | (Rn << 16) | (Rt[1] << 12) | (Rt[0] << 8) | (imm8);
   114b0:	4319      	orrs	r1, r3
    emit4(state, _thumb32_LDRD_IMM_T1(Rt, Rn, off));
   114b2:	f041 4168 	orr.w	r1, r1, #3892314112	; 0xe8000000
   114b6:	f441 01b6 	orr.w	r1, r1, #5963776	; 0x5b0000
}
   114ba:	bc10      	pop	{r4}
    emit4(state, _thumb32_LDRD_IMM_T1(Rt, Rn, off));
   114bc:	f7ff bf8b 	b.w	113d6 <emit4>

000114c0 <arm_bpf_get_reg64>:
static const s8 *arm_bpf_get_reg64(jit_state *state, const s8 *reg, const s8 *tmp) {
   114c0:	b510      	push	{r4, lr}
   114c2:	4614      	mov	r4, r2
    if (is_stacked(reg[1])) {
   114c4:	f991 2001 	ldrsb.w	r2, [r1, #1]
   114c8:	2a00      	cmp	r2, #0
   114ca:	da03      	bge.n	114d4 <arm_bpf_get_reg64+0x14>
        _emit_ldrd_i(state, tmp, ARM_FP, off);
   114cc:	4621      	mov	r1, r4
   114ce:	f7ff ffd6 	bl	1147e <_emit_ldrd_i.constprop.29>
        reg = tmp;
   114d2:	4621      	mov	r1, r4
}
   114d4:	4608      	mov	r0, r1
   114d6:	bd10      	pop	{r4, pc}

000114d8 <_emit_mov_reg>:
    if (dst != ARM_SP && src != ARM_SP) {
   114d8:	2a0d      	cmp	r2, #13
static void _emit_mov_reg(jit_state *state, s8 src, s8 dst) {
   114da:	4603      	mov	r3, r0
    if (dst != ARM_SP && src != ARM_SP) {
   114dc:	d00e      	beq.n	114fc <_emit_mov_reg+0x24>
   114de:	290d      	cmp	r1, #13
   114e0:	d00c      	beq.n	114fc <_emit_mov_reg+0x24>
    return (THUMB2_MOV_REG) | (D << 7) | (Rm << 3) | (Rd3);
   114e2:	00c9      	lsls	r1, r1, #3
   114e4:	f3c2 03c0 	ubfx	r3, r2, #3, #1
   114e8:	ea41 13c3 	orr.w	r3, r1, r3, lsl #7
   114ec:	f002 0107 	and.w	r1, r2, #7
   114f0:	4319      	orrs	r1, r3
   114f2:	f441 418c 	orr.w	r1, r1, #17920	; 0x4600
        emit2(state, _thumb16_MOV_REG_T1(dst, src));
   114f6:	b289      	uxth	r1, r1
   114f8:	f7ff bf63 	b.w	113c2 <emit2>
    return (THUMB2_MOVW_REG) | (flagS << 20) | (Rd << 8) | (Rm);
   114fc:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
    emit4(state, _thumb32_MOVW_REG_T3(dst, src, FLAG_NOS));
   11500:	f041 416a 	orr.w	r1, r1, #3925868544	; 0xea000000
   11504:	f441 019e 	orr.w	r1, r1, #5177344	; 0x4f0000
   11508:	4618      	mov	r0, r3
   1150a:	f7ff bf64 	b.w	113d6 <emit4>

0001150e <arm_bpf_put_reg32>:
	if (is_stacked(reg)) {
   1150e:	1e0b      	subs	r3, r1, #0
static void arm_bpf_put_reg32(jit_state *state, s8 reg, s8 src) {
   11510:	b410      	push	{r4}
   11512:	4614      	mov	r4, r2
	if (is_stacked(reg)) {
   11514:	da03      	bge.n	1151e <arm_bpf_put_reg32+0x10>
        _emit_str_i(state, ARM_FP, src, off);
   11516:	210b      	movs	r1, #11
}
   11518:	bc10      	pop	{r4}
        _emit_str_i(state, ARM_FP, src, off);
   1151a:	f7ff bf71 	b.w	11400 <_emit_str_i>
	} else if (reg != src) {
   1151e:	4293      	cmp	r3, r2
   11520:	d004      	beq.n	1152c <arm_bpf_put_reg32+0x1e>
        _emit_mov_reg(state, src, reg);
   11522:	4621      	mov	r1, r4
   11524:	461a      	mov	r2, r3
}
   11526:	bc10      	pop	{r4}
        _emit_mov_reg(state, src, reg);
   11528:	f7ff bfd6 	b.w	114d8 <_emit_mov_reg>
}
   1152c:	bc10      	pop	{r4}
   1152e:	4770      	bx	lr

00011530 <emit_a32_mov_reg>:
static void emit_a32_mov_reg(jit_state *state, s8 src, s8 dst) {
   11530:	b538      	push	{r3, r4, r5, lr}
   11532:	4615      	mov	r5, r2
	s8 rt = arm_bpf_get_reg32(state, src, tmp[0]);
   11534:	2207      	movs	r2, #7
static void emit_a32_mov_reg(jit_state *state, s8 src, s8 dst) {
   11536:	4604      	mov	r4, r0
	s8 rt = arm_bpf_get_reg32(state, src, tmp[0]);
   11538:	f7ff ff57 	bl	113ea <arm_bpf_get_reg32>
	arm_bpf_put_reg32(state, dst, rt);
   1153c:	4629      	mov	r1, r5
   1153e:	4602      	mov	r2, r0
   11540:	4620      	mov	r0, r4
}
   11542:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	arm_bpf_put_reg32(state, dst, rt);
   11546:	f7ff bfe2 	b.w	1150e <arm_bpf_put_reg32>

0001154a <arm_bpf_put_reg64>:
static void arm_bpf_put_reg64(jit_state *state, const s8 *reg, const s8 *src) {
   1154a:	b570      	push	{r4, r5, r6, lr}
   1154c:	4614      	mov	r4, r2
	if (is_stacked(reg[1])) {
   1154e:	f991 2001 	ldrsb.w	r2, [r1, #1]
   11552:	2a00      	cmp	r2, #0
static void arm_bpf_put_reg64(jit_state *state, const s8 *reg, const s8 *src) {
   11554:	4606      	mov	r6, r0
   11556:	460d      	mov	r5, r1
	if (is_stacked(reg[1])) {
   11558:	da04      	bge.n	11564 <arm_bpf_put_reg64+0x1a>
        _emit_strd_i(state, src, ARM_FP, off);
   1155a:	4621      	mov	r1, r4
}
   1155c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _emit_strd_i(state, src, ARM_FP, off);
   11560:	f7ff bf6b 	b.w	1143a <_emit_strd_i.constprop.27>
		if (reg[1] != src[1]) {
   11564:	f994 1001 	ldrsb.w	r1, [r4, #1]
   11568:	428a      	cmp	r2, r1
   1156a:	d001      	beq.n	11570 <arm_bpf_put_reg64+0x26>
            emit_a32_mov_reg(state, src[1], reg[1]);
   1156c:	f7ff ffe0 	bl	11530 <emit_a32_mov_reg>
        if (reg[0] != src[0]) {
   11570:	f995 2000 	ldrsb.w	r2, [r5]
   11574:	f994 1000 	ldrsb.w	r1, [r4]
   11578:	428a      	cmp	r2, r1
   1157a:	d004      	beq.n	11586 <arm_bpf_put_reg64+0x3c>
            emit_a32_mov_reg(state, src[0], reg[0]);
   1157c:	4630      	mov	r0, r6
}
   1157e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            emit_a32_mov_reg(state, src[0], reg[0]);
   11582:	f7ff bfd5 	b.w	11530 <emit_a32_mov_reg>
}
   11586:	bd70      	pop	{r4, r5, r6, pc}

00011588 <emit_mov_imm>:
	if (val <= imm8 && val >= 0 && rd < 8) {
   11588:	2aff      	cmp	r2, #255	; 0xff
{
   1158a:	b570      	push	{r4, r5, r6, lr}
   1158c:	b293      	uxth	r3, r2
   1158e:	4606      	mov	r6, r0
   11590:	4614      	mov	r4, r2
   11592:	ea4f 2501 	mov.w	r5, r1, lsl #8
	if (val <= imm8 && val >= 0 && rd < 8) {
   11596:	d809      	bhi.n	115ac <emit_mov_imm+0x24>
   11598:	2907      	cmp	r1, #7
   1159a:	d807      	bhi.n	115ac <emit_mov_imm+0x24>
        uint16_t inst = 0x2000 | (rd << 8) | (val);
   1159c:	ea43 0105 	orr.w	r1, r3, r5
        emit2(state, inst);
   115a0:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
}
   115a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        emit2(state, inst);
   115a8:	f7ff bf0b 	b.w	113c2 <emit2>
        uint32_t inst = 0xf2400000 | (i << 26) | (i4 << 16) | (i3 << 12) | (rd << 8) | i8;
   115ac:	f3c4 2102 	ubfx	r1, r4, #8, #3
   115b0:	b2da      	uxtb	r2, r3
   115b2:	ea45 3101 	orr.w	r1, r5, r1, lsl #12
   115b6:	4311      	orrs	r1, r2
   115b8:	0b1b      	lsrs	r3, r3, #12
   115ba:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   115be:	f3c4 23c0 	ubfx	r3, r4, #11, #1
   115c2:	ea41 6183 	orr.w	r1, r1, r3, lsl #26
        emit4(state, inst);
   115c6:	f041 4172 	orr.w	r1, r1, #4060086272	; 0xf2000000
   115ca:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
   115ce:	4630      	mov	r0, r6
   115d0:	f7ff ff01 	bl	113d6 <emit4>
        if (val > 0xffff) { // movt
   115d4:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
   115d8:	d316      	bcc.n	11608 <emit_mov_imm+0x80>
            v1 = val >> 16;
   115da:	0c24      	lsrs	r4, r4, #16
   115dc:	b2a3      	uxth	r3, r4
            inst = 0xf2c00000 | (i << 26) | (i4 << 16) | (i3 << 12) | (rd << 8) | i8;
   115de:	f3c4 2102 	ubfx	r1, r4, #8, #3
   115e2:	ea45 3101 	orr.w	r1, r5, r1, lsl #12
   115e6:	b2dd      	uxtb	r5, r3
   115e8:	4329      	orrs	r1, r5
   115ea:	0b1b      	lsrs	r3, r3, #12
   115ec:	f3c4 24c0 	ubfx	r4, r4, #11, #1
   115f0:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   115f4:	ea41 6184 	orr.w	r1, r1, r4, lsl #26
            emit4(state, inst);
   115f8:	f041 4172 	orr.w	r1, r1, #4060086272	; 0xf2000000
   115fc:	f441 0140 	orr.w	r1, r1, #12582912	; 0xc00000
}
   11600:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            emit4(state, inst);
   11604:	f7ff bee7 	b.w	113d6 <emit4>
}
   11608:	bd70      	pop	{r4, r5, r6, pc}

0001160a <emit_mov_se_imm64.part.9>:
        if (is64 && (val & (1<<31))) // < 0
   1160a:	2a00      	cmp	r2, #0
        emit_mov_i64(state, dst, val64);
   1160c:	bfb4      	ite	lt
   1160e:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   11612:	2300      	movge	r3, #0
   11614:	f7f2 ba36 	b.w	3a84 <emit_mov_i64>

00011618 <emit_mov_se_imm64>:
static void emit_mov_se_imm64(jit_state *state, const bool is64, const s8 dst[], const u32 val) {
   11618:	b410      	push	{r4}
   1161a:	4614      	mov	r4, r2
   1161c:	461a      	mov	r2, r3
    if (is64) {
   1161e:	b119      	cbz	r1, 11628 <emit_mov_se_imm64+0x10>
   11620:	4621      	mov	r1, r4
}
   11622:	bc10      	pop	{r4}
   11624:	f7ff bff1 	b.w	1160a <emit_mov_se_imm64.part.9>
        emit_mov_imm(state, dst[1], val);
   11628:	7861      	ldrb	r1, [r4, #1]
}
   1162a:	bc10      	pop	{r4}
        emit_mov_imm(state, dst[1], val);
   1162c:	f7ff bfac 	b.w	11588 <emit_mov_imm>

00011630 <emit_alu32_imm>:
static void emit_alu32_imm(jit_state *state, const s8 dst, const u16 val, const u8 op) {
   11630:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11634:	4617      	mov	r7, r2
    s8 rd = arm_bpf_get_reg32(state, dst, tmp[0]);
   11636:	2207      	movs	r2, #7
static void emit_alu32_imm(jit_state *state, const s8 dst, const u16 val, const u8 op) {
   11638:	4698      	mov	r8, r3
   1163a:	4605      	mov	r5, r0
   1163c:	460e      	mov	r6, r1
    s8 rd = arm_bpf_get_reg32(state, dst, tmp[0]);
   1163e:	f7ff fed4 	bl	113ea <arm_bpf_get_reg32>
    switch (op) {
   11642:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
    s8 rd = arm_bpf_get_reg32(state, dst, tmp[0]);
   11646:	4604      	mov	r4, r0
    switch (op) {
   11648:	d020      	beq.n	1168c <emit_alu32_imm+0x5c>
   1164a:	d809      	bhi.n	11660 <emit_alu32_imm+0x30>
   1164c:	f1b8 0f60 	cmp.w	r8, #96	; 0x60
   11650:	d013      	beq.n	1167a <emit_alu32_imm+0x4a>
    arm_bpf_put_reg32(state, dst, rd);
   11652:	4622      	mov	r2, r4
   11654:	4631      	mov	r1, r6
   11656:	4628      	mov	r0, r5
}
   11658:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    arm_bpf_put_reg32(state, dst, rd);
   1165c:	f7ff bf57 	b.w	1150e <arm_bpf_put_reg32>
    switch (op) {
   11660:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
   11664:	d019      	beq.n	1169a <emit_alu32_imm+0x6a>
   11666:	f1b8 0fc0 	cmp.w	r8, #192	; 0xc0
   1166a:	d1f2      	bne.n	11652 <emit_alu32_imm+0x22>
        emit2(state, (0x1000) | (val << 6) | (rd << 3) | (rd));
   1166c:	00c1      	lsls	r1, r0, #3
   1166e:	ea41 1187 	orr.w	r1, r1, r7, lsl #6
   11672:	4301      	orrs	r1, r0
   11674:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
   11678:	e003      	b.n	11682 <emit_alu32_imm+0x52>
        emit2(state, (0x0000) | (val << 6) | (rd << 3) | (rd));
   1167a:	ea40 1187 	orr.w	r1, r0, r7, lsl #6
   1167e:	ea41 01c0 	orr.w	r1, r1, r0, lsl #3
        emit2(state, (0x4240) | (rd << 3) | (rd));
   11682:	b289      	uxth	r1, r1
   11684:	4628      	mov	r0, r5
   11686:	f7ff fe9c 	bl	113c2 <emit2>
        break;
   1168a:	e7e2      	b.n	11652 <emit_alu32_imm+0x22>
        emit2(state, (0x0800) | (val << 6) | (rd << 3) | (rd));
   1168c:	00c1      	lsls	r1, r0, #3
   1168e:	ea41 1187 	orr.w	r1, r1, r7, lsl #6
   11692:	4301      	orrs	r1, r0
   11694:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
   11698:	e7f3      	b.n	11682 <emit_alu32_imm+0x52>
        emit2(state, (0x4240) | (rd << 3) | (rd));
   1169a:	ea40 01c0 	orr.w	r1, r0, r0, lsl #3
   1169e:	f441 4184 	orr.w	r1, r1, #16896	; 0x4200
   116a2:	f041 0140 	orr.w	r1, r1, #64	; 0x40
   116a6:	e7ec      	b.n	11682 <emit_alu32_imm+0x52>

000116a8 <_emit_cmp_reg>:
    if (Rn < 0x8 && Rm < 0x8) {
   116a8:	2907      	cmp	r1, #7
static void inline _emit_cmp_reg(jit_state *state, const s8 Rn, const s8 Rm) {
   116aa:	b410      	push	{r4}
   116ac:	ea4f 03c2 	mov.w	r3, r2, lsl #3
   116b0:	4604      	mov	r4, r0
    if (Rn < 0x8 && Rm < 0x8) {
   116b2:	dc08      	bgt.n	116c6 <_emit_cmp_reg+0x1e>
   116b4:	2a07      	cmp	r2, #7
   116b6:	dc06      	bgt.n	116c6 <_emit_cmp_reg+0x1e>
    return (THUMB2_CMP_REG_T1) | (Rm << 3) | (Rn);
   116b8:	4319      	orrs	r1, r3
   116ba:	f441 4185 	orr.w	r1, r1, #17024	; 0x4280
        emit2(state, _thumb16_CMP_REG_T1(Rn, Rm));
   116be:	b289      	uxth	r1, r1
}
   116c0:	bc10      	pop	{r4}
        emit2(state, _thumb16_CMP_REG_T2(Rn, Rm));
   116c2:	f7ff be7e 	b.w	113c2 <emit2>
    u16 N = (Rn & 0b1000) >> 3;
   116c6:	b2c9      	uxtb	r1, r1
    return (THUMB2_CMP_REG_T2) | (N << 7) | (Rm << 3) | (Rn3);
   116c8:	f3c1 02c0 	ubfx	r2, r1, #3, #1
   116cc:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
   116d0:	f001 0107 	and.w	r1, r1, #7
   116d4:	4319      	orrs	r1, r3
   116d6:	f441 418a 	orr.w	r1, r1, #17664	; 0x4500
   116da:	b289      	uxth	r1, r1
   116dc:	4620      	mov	r0, r4
   116de:	e7ef      	b.n	116c0 <_emit_cmp_reg+0x18>

000116e0 <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
   116e0:	b570      	push	{r4, r5, r6, lr}
   116e2:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
   116e4:	f990 000b 	ldrsb.w	r0, [r0, #11]
   116e8:	250c      	movs	r5, #12
   116ea:	434d      	muls	r5, r1
		&p->levels[level].bits : p->levels[level].bits_p;
   116ec:	4288      	cmp	r0, r1
   116ee:	eb06 0405 	add.w	r4, r6, r5
   116f2:	bfb8      	it	lt
   116f4:	5974      	ldrlt	r4, [r6, r5]

	*word = &bitarray[bn / 32];
   116f6:	2a00      	cmp	r2, #0
   116f8:	4610      	mov	r0, r2
   116fa:	bfb8      	it	lt
   116fc:	f102 001f 	addlt.w	r0, r2, #31
   11700:	1140      	asrs	r0, r0, #5
   11702:	eb04 0180 	add.w	r1, r4, r0, lsl #2
   11706:	6019      	str	r1, [r3, #0]

	return bn & 0x1f;
}
   11708:	f002 001f 	and.w	r0, r2, #31
   1170c:	bd70      	pop	{r4, r5, r6, pc}

0001170e <set_free_bit>:

static void set_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
   1170e:	b507      	push	{r0, r1, r2, lr}
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
   11710:	ab01      	add	r3, sp, #4
   11712:	f7ff ffe5 	bl	116e0 <get_bit_ptr>

	*word |= (1<<bit);
   11716:	9a01      	ldr	r2, [sp, #4]
   11718:	2301      	movs	r3, #1
   1171a:	fa03 f000 	lsl.w	r0, r3, r0
   1171e:	6813      	ldr	r3, [r2, #0]
   11720:	4303      	orrs	r3, r0
   11722:	6013      	str	r3, [r2, #0]
}
   11724:	b003      	add	sp, #12
   11726:	f85d fb04 	ldr.w	pc, [sp], #4

0001172a <clear_free_bit>:

static void clear_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
   1172a:	b507      	push	{r0, r1, r2, lr}
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
   1172c:	ab01      	add	r3, sp, #4
   1172e:	f7ff ffd7 	bl	116e0 <get_bit_ptr>

	*word &= ~(1<<bit);
   11732:	9a01      	ldr	r2, [sp, #4]
   11734:	2301      	movs	r3, #1
   11736:	fa03 f000 	lsl.w	r0, r3, r0
   1173a:	6813      	ldr	r3, [r2, #0]
   1173c:	ea23 0300 	bic.w	r3, r3, r0
   11740:	6013      	str	r3, [r2, #0]
}
   11742:	b003      	add	sp, #12
   11744:	f85d fb04 	ldr.w	pc, [sp], #4

00011748 <block_fits>:
	return p->n_max * p->max_sz;
}

static bool block_fits(struct sys_mem_pool_base *p,
		       int lvl, int bn, size_t *lsizes)
{
   11748:	b570      	push	{r4, r5, r6, lr}
	u8_t *parent, *block_end;
	size_t parent_sz;

	block_end = (u8_t *)block_ptr(p, lsizes[lvl], bn) + lsizes[lvl];
   1174a:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
   1174e:	6804      	ldr	r4, [r0, #0]
   11750:	fb02 5505 	mla	r5, r2, r5, r5
   11754:	008e      	lsls	r6, r1, #2
   11756:	4425      	add	r5, r4

	if (lvl == 0) {
   11758:	b941      	cbnz	r1, 1176c <block_fits+0x24>
	return p->n_max * p->max_sz;
   1175a:	8903      	ldrh	r3, [r0, #8]
   1175c:	6840      	ldr	r0, [r0, #4]
   1175e:	4358      	muls	r0, r3
	} else {
		parent_sz = lsizes[lvl - 1];
		parent = block_ptr(p, lsizes[lvl - 1], bn / 4);
	}

	return block_end <= (parent + parent_sz);
   11760:	4420      	add	r0, r4
}
   11762:	4285      	cmp	r5, r0
   11764:	bf8c      	ite	hi
   11766:	2000      	movhi	r0, #0
   11768:	2001      	movls	r0, #1
   1176a:	bd70      	pop	{r4, r5, r6, pc}
		parent_sz = lsizes[lvl - 1];
   1176c:	4433      	add	r3, r6
		parent = block_ptr(p, lsizes[lvl - 1], bn / 4);
   1176e:	2a00      	cmp	r2, #0
		parent_sz = lsizes[lvl - 1];
   11770:	f853 0c04 	ldr.w	r0, [r3, #-4]
		parent = block_ptr(p, lsizes[lvl - 1], bn / 4);
   11774:	bfb8      	it	lt
   11776:	3203      	addlt	r2, #3
   11778:	1092      	asrs	r2, r2, #2
	return (u8_t *)p->buf + lsz * block;
   1177a:	fb00 4402 	mla	r4, r0, r2, r4
   1177e:	e7ef      	b.n	11760 <block_fits+0x18>

00011780 <pool_irq_lock.isra.2.part.3>:
   11780:	f04f 0320 	mov.w	r3, #32
   11784:	f3ef 8011 	mrs	r0, BASEPRI
   11788:	f383 8811 	msr	BASEPRI, r3
   1178c:	f3bf 8f6f 	isb	sy
	if (p->flags & SYS_MEM_POOL_KERNEL) {
		return irq_lock();
	} else {
		return 0;
	}
}
   11790:	4770      	bx	lr

00011792 <pool_irq_unlock.isra.4>:

static inline void pool_irq_unlock(struct sys_mem_pool_base *p, int key)
{
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   11792:	07c3      	lsls	r3, r0, #31
   11794:	d503      	bpl.n	1179e <pool_irq_unlock.isra.4+0xc>
	__asm__ volatile(
   11796:	f381 8811 	msr	BASEPRI, r1
   1179a:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}
}
   1179e:	4770      	bx	lr

000117a0 <z_sys_mem_pool_base_init>:
{
   117a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   117a4:	6843      	ldr	r3, [r0, #4]
   117a6:	8906      	ldrh	r6, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   117a8:	6805      	ldr	r5, [r0, #0]
	for (i = 0; i < p->n_levels; i++) {
   117aa:	f890 c00a 	ldrb.w	ip, [r0, #10]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   117ae:	435e      	muls	r6, r3
	p->max_inline_level = -1;
   117b0:	22ff      	movs	r2, #255	; 0xff
{
   117b2:	4604      	mov	r4, r0
	p->max_inline_level = -1;
   117b4:	72c2      	strb	r2, [r0, #11]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   117b6:	4435      	add	r5, r6
	for (i = 0; i < p->n_levels; i++) {
   117b8:	2000      	movs	r0, #0
		sys_dlist_init(&p->levels[i].free_list);
   117ba:	f04f 0e0c 	mov.w	lr, #12
	for (i = 0; i < p->n_levels; i++) {
   117be:	4584      	cmp	ip, r0
   117c0:	dc05      	bgt.n	117ce <z_sys_mem_pool_base_init+0x2e>
	for (i = 0; i < p->n_max; i++) {
   117c2:	2500      	movs	r5, #0
   117c4:	8923      	ldrh	r3, [r4, #8]
   117c6:	42ab      	cmp	r3, r5
   117c8:	dc21      	bgt.n	1180e <z_sys_mem_pool_base_init+0x6e>
}
   117ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		sys_dlist_init(&p->levels[i].free_list);
   117ce:	f8d4 800c 	ldr.w	r8, [r4, #12]
		int nblocks = buflen / sz;
   117d2:	fbb6 f1f3 	udiv	r1, r6, r3
		sys_dlist_init(&p->levels[i].free_list);
   117d6:	fb0e f700 	mul.w	r7, lr, r0
   117da:	eb08 0207 	add.w	r2, r8, r7
   117de:	f102 0904 	add.w	r9, r2, #4
		if (nblocks < 32) {
   117e2:	291f      	cmp	r1, #31
	list->tail = (sys_dnode_t *)list;
   117e4:	e9c2 9901 	strd	r9, r9, [r2, #4]
   117e8:	dc06      	bgt.n	117f8 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
   117ea:	72e0      	strb	r0, [r4, #11]
		sz = _ALIGN4(sz / 4);
   117ec:	089b      	lsrs	r3, r3, #2
   117ee:	3303      	adds	r3, #3
   117f0:	f023 0303 	bic.w	r3, r3, #3
	for (i = 0; i < p->n_levels; i++) {
   117f4:	3001      	adds	r0, #1
   117f6:	e7e2      	b.n	117be <z_sys_mem_pool_base_init+0x1e>
			bits += (nblocks + 31)/32;
   117f8:	f111 021f 	adds.w	r2, r1, #31
   117fc:	bf48      	it	mi
   117fe:	f101 023e 	addmi.w	r2, r1, #62	; 0x3e
   11802:	1152      	asrs	r2, r2, #5
			p->levels[i].bits_p = bits;
   11804:	f848 5007 	str.w	r5, [r8, r7]
			bits += (nblocks + 31)/32;
   11808:	eb05 0582 	add.w	r5, r5, r2, lsl #2
   1180c:	e7ee      	b.n	117ec <z_sys_mem_pool_base_init+0x4c>
	return (u8_t *)p->buf + lsz * block;
   1180e:	6862      	ldr	r2, [r4, #4]
		sys_dlist_append(&p->levels[0].free_list, block);
   11810:	68e3      	ldr	r3, [r4, #12]
	return (u8_t *)p->buf + lsz * block;
   11812:	6820      	ldr	r0, [r4, #0]
   11814:	436a      	muls	r2, r5
   11816:	1881      	adds	r1, r0, r2
		sys_dlist_append(&p->levels[0].free_list, block);
   11818:	1d1e      	adds	r6, r3, #4
	node->next = list;
   1181a:	5086      	str	r6, [r0, r2]
	node->prev = list->tail;
   1181c:	689a      	ldr	r2, [r3, #8]
   1181e:	604a      	str	r2, [r1, #4]
	list->tail->next = node;
   11820:	689a      	ldr	r2, [r3, #8]
		set_free_bit(p, 0, i);
   11822:	4620      	mov	r0, r4
   11824:	6011      	str	r1, [r2, #0]
	list->tail = node;
   11826:	6099      	str	r1, [r3, #8]
   11828:	462a      	mov	r2, r5
   1182a:	2100      	movs	r1, #0
   1182c:	f7ff ff6f 	bl	1170e <set_free_bit>
	for (i = 0; i < p->n_max; i++) {
   11830:	3501      	adds	r5, #1
   11832:	e7c7      	b.n	117c4 <z_sys_mem_pool_base_init+0x24>

00011834 <z_sys_mem_pool_block_alloc>:
	return block;
}

int z_sys_mem_pool_block_alloc(struct sys_mem_pool_base *p, size_t size,
			      u32_t *level_p, u32_t *block_p, void **data_p)
{
   11834:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11838:	b089      	sub	sp, #36	; 0x24
	int i, from_l, alloc_l = -1;
	unsigned int key;
	void *data = NULL;
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   1183a:	7a85      	ldrb	r5, [r0, #10]
{
   1183c:	af00      	add	r7, sp, #0
   1183e:	e9c7 3201 	strd	r3, r2, [r7, #4]
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   11842:	00ab      	lsls	r3, r5, #2
   11844:	3307      	adds	r3, #7
   11846:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   1184a:	ebad 0d03 	sub.w	sp, sp, r3
   1184e:	46e9      	mov	r9, sp
	 * want to allocate and the smallest one with a free entry
	 * from which we can split an allocation if needed.  Along the
	 * way, we populate an array of sizes for each level so we
	 * don't need to waste RAM storing it.
	 */
	lsizes[0] = p->max_sz;
   11850:	464a      	mov	r2, r9
   11852:	6843      	ldr	r3, [r0, #4]
   11854:	f842 3904 	str.w	r3, [r2], #-4
{
   11858:	4604      	mov	r4, r0
	for (i = 0; i < p->n_levels; i++) {
   1185a:	2000      	movs	r0, #0
   1185c:	4285      	cmp	r5, r0
   1185e:	f100 36ff 	add.w	r6, r0, #4294967295	; 0xffffffff
   11862:	dd0a      	ble.n	1187a <z_sys_mem_pool_block_alloc+0x46>
		if (i > 0) {
   11864:	b128      	cbz	r0, 11872 <z_sys_mem_pool_block_alloc+0x3e>
			lsizes[i] = _ALIGN4(lsizes[i-1] / 4);
   11866:	6813      	ldr	r3, [r2, #0]
   11868:	089b      	lsrs	r3, r3, #2
   1186a:	3303      	adds	r3, #3
   1186c:	f023 0303 	bic.w	r3, r3, #3
   11870:	6053      	str	r3, [r2, #4]
		}

		if (lsizes[i] < size) {
   11872:	f852 3f04 	ldr.w	r3, [r2, #4]!
   11876:	428b      	cmp	r3, r1
   11878:	d207      	bcs.n	1188a <z_sys_mem_pool_block_alloc+0x56>
		}

		alloc_l = i;
	}

	if (alloc_l < 0) {
   1187a:	1c73      	adds	r3, r6, #1
   1187c:	d107      	bne.n	1188e <z_sys_mem_pool_block_alloc+0x5a>
		*data_p = NULL;
   1187e:	6cba      	ldr	r2, [r7, #72]	; 0x48
   11880:	2300      	movs	r3, #0
   11882:	6013      	str	r3, [r2, #0]
	pool_irq_unlock(p, key);

	*data_p = data;

	if (data == NULL) {
		return -ENOMEM;
   11884:	f06f 000b 	mvn.w	r0, #11
   11888:	e03f      	b.n	1190a <z_sys_mem_pool_block_alloc+0xd6>
	for (i = 0; i < p->n_levels; i++) {
   1188a:	3001      	adds	r0, #1
   1188c:	e7e6      	b.n	1185c <z_sys_mem_pool_block_alloc+0x28>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   1188e:	7c20      	ldrb	r0, [r4, #16]
   11890:	f010 0001 	ands.w	r0, r0, #1
   11894:	d001      	beq.n	1189a <z_sys_mem_pool_block_alloc+0x66>
   11896:	f7ff ff73 	bl	11780 <pool_irq_lock.isra.2.part.3>
   1189a:	68e2      	ldr	r2, [r4, #12]
	key = pool_irq_lock(p);
   1189c:	61f8      	str	r0, [r7, #28]
	for (i = alloc_l; i >= 0; i--) {
   1189e:	230c      	movs	r3, #12
   118a0:	fb03 2306 	mla	r3, r3, r6, r2
	block = sys_dlist_get(&p->levels[l].free_list);
   118a4:	46b2      	mov	sl, r6
	return list->head == list;
   118a6:	461a      	mov	r2, r3
   118a8:	f852 5f04 	ldr.w	r5, [r2, #4]!

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   118ac:	4295      	cmp	r5, r2
   118ae:	d073      	beq.n	11998 <z_sys_mem_pool_block_alloc+0x164>
	node->prev->next = node->next;
   118b0:	e9d5 3100 	ldrd	r3, r1, [r5]
   118b4:	600b      	str	r3, [r1, #0]
	node->next->prev = node->prev;
   118b6:	6059      	str	r1, [r3, #4]
	node->next = NULL;
   118b8:	2300      	movs	r3, #0
	node->prev = NULL;
   118ba:	e9c5 3300 	strd	r3, r3, [r5]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   118be:	6823      	ldr	r3, [r4, #0]
		data = block_alloc(p, i, lsizes[i]);
   118c0:	f859 202a 	ldr.w	r2, [r9, sl, lsl #2]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   118c4:	1aeb      	subs	r3, r5, r3
		clear_free_bit(p, l, block_num(p, block, lsz));
   118c6:	4651      	mov	r1, sl
   118c8:	fb93 f2f2 	sdiv	r2, r3, r2
   118cc:	4620      	mov	r0, r4
   118ce:	f7ff ff2c 	bl	1172a <clear_free_bit>
		if (data != NULL) {
   118d2:	eb09 038a 	add.w	r3, r9, sl, lsl #2
   118d6:	f10a 0801 	add.w	r8, sl, #1
   118da:	61bb      	str	r3, [r7, #24]
			for (from_l = i; from_l < alloc_l; from_l++) {
   118dc:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   118e0:	42b3      	cmp	r3, r6
   118e2:	db16      	blt.n	11912 <z_sys_mem_pool_block_alloc+0xde>
	pool_irq_unlock(p, key);
   118e4:	69f9      	ldr	r1, [r7, #28]
   118e6:	7c20      	ldrb	r0, [r4, #16]
   118e8:	f7ff ff53 	bl	11792 <pool_irq_unlock.isra.4>
	*data_p = data;
   118ec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   118ee:	601d      	str	r5, [r3, #0]
	if (data == NULL) {
   118f0:	2d00      	cmp	r5, #0
   118f2:	d0c7      	beq.n	11884 <z_sys_mem_pool_block_alloc+0x50>
	}

	*level_p = alloc_l;
   118f4:	68bb      	ldr	r3, [r7, #8]
   118f6:	601e      	str	r6, [r3, #0]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   118f8:	6823      	ldr	r3, [r4, #0]
   118fa:	1aed      	subs	r5, r5, r3
   118fc:	f859 3026 	ldr.w	r3, [r9, r6, lsl #2]
   11900:	fb95 f5f3 	sdiv	r5, r5, r3
	*block_p = block_num(p, data, lsizes[alloc_l]);
   11904:	687b      	ldr	r3, [r7, #4]

	return 0;
   11906:	2000      	movs	r0, #0
	*block_p = block_num(p, data, lsizes[alloc_l]);
   11908:	601d      	str	r5, [r3, #0]
}
   1190a:	3724      	adds	r7, #36	; 0x24
   1190c:	46bd      	mov	sp, r7
   1190e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	bn = block_num(p, block, lsizes[l]);
   11912:	69bb      	ldr	r3, [r7, #24]
   11914:	f853 2b04 	ldr.w	r2, [r3], #4
   11918:	61bb      	str	r3, [r7, #24]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   1191a:	6823      	ldr	r3, [r4, #0]
   1191c:	1aeb      	subs	r3, r5, r3
   1191e:	fb93 f3f2 	sdiv	r3, r3, r2
		int lbn = 4*bn + i;
   11922:	009b      	lsls	r3, r3, #2
   11924:	613b      	str	r3, [r7, #16]
   11926:	230c      	movs	r3, #12
   11928:	fb03 f308 	mul.w	r3, r3, r8
   1192c:	617b      	str	r3, [r7, #20]
	for (i = 1; i < 4; i++) {
   1192e:	f04f 0a01 	mov.w	sl, #1
		int lbn = 4*bn + i;
   11932:	693b      	ldr	r3, [r7, #16]
   11934:	eb0a 0b03 	add.w	fp, sl, r3
		int lsz = lsizes[l + 1];
   11938:	69bb      	ldr	r3, [r7, #24]
		set_free_bit(p, l + 1, lbn);
   1193a:	465a      	mov	r2, fp
		int lsz = lsizes[l + 1];
   1193c:	681b      	ldr	r3, [r3, #0]
   1193e:	60fb      	str	r3, [r7, #12]
		set_free_bit(p, l + 1, lbn);
   11940:	4641      	mov	r1, r8
   11942:	4620      	mov	r0, r4
   11944:	f7ff fee3 	bl	1170e <set_free_bit>
		if (block_fits(p, l + 1, lbn, lsizes)) {
   11948:	464b      	mov	r3, r9
   1194a:	465a      	mov	r2, fp
   1194c:	4641      	mov	r1, r8
   1194e:	4620      	mov	r0, r4
   11950:	f7ff fefa 	bl	11748 <block_fits>
   11954:	b168      	cbz	r0, 11972 <z_sys_mem_pool_block_alloc+0x13e>
		void *block2 = (lsz * i) + (char *)block;
   11956:	68fb      	ldr	r3, [r7, #12]
			sys_dlist_append(&p->levels[l + 1].free_list, block2);
   11958:	6978      	ldr	r0, [r7, #20]
		void *block2 = (lsz * i) + (char *)block;
   1195a:	fb0a f203 	mul.w	r2, sl, r3
			sys_dlist_append(&p->levels[l + 1].free_list, block2);
   1195e:	68e3      	ldr	r3, [r4, #12]
   11960:	4403      	add	r3, r0
		void *block2 = (lsz * i) + (char *)block;
   11962:	18a9      	adds	r1, r5, r2
			sys_dlist_append(&p->levels[l + 1].free_list, block2);
   11964:	1d18      	adds	r0, r3, #4
	node->next = list;
   11966:	50a8      	str	r0, [r5, r2]
	node->prev = list->tail;
   11968:	689a      	ldr	r2, [r3, #8]
   1196a:	604a      	str	r2, [r1, #4]
	list->tail->next = node;
   1196c:	689a      	ldr	r2, [r3, #8]
   1196e:	6011      	str	r1, [r2, #0]
	list->tail = node;
   11970:	6099      	str	r1, [r3, #8]
	for (i = 1; i < 4; i++) {
   11972:	f10a 0a01 	add.w	sl, sl, #1
   11976:	f1ba 0f04 	cmp.w	sl, #4
   1197a:	d1da      	bne.n	11932 <z_sys_mem_pool_block_alloc+0xfe>
				pool_irq_unlock(p, key);
   1197c:	7c20      	ldrb	r0, [r4, #16]
   1197e:	69f9      	ldr	r1, [r7, #28]
   11980:	f7ff ff07 	bl	11792 <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   11984:	7c20      	ldrb	r0, [r4, #16]
   11986:	f010 0001 	ands.w	r0, r0, #1
   1198a:	d001      	beq.n	11990 <z_sys_mem_pool_block_alloc+0x15c>
   1198c:	f7ff fef8 	bl	11780 <pool_irq_lock.isra.2.part.3>
				key = pool_irq_lock(p);
   11990:	61f8      	str	r0, [r7, #28]
   11992:	f108 0801 	add.w	r8, r8, #1
   11996:	e7a1      	b.n	118dc <z_sys_mem_pool_block_alloc+0xa8>
	for (i = alloc_l; i >= 0; i--) {
   11998:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   1199c:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
   119a0:	f1a3 030c 	sub.w	r3, r3, #12
   119a4:	f47f af7f 	bne.w	118a6 <z_sys_mem_pool_block_alloc+0x72>
   119a8:	2500      	movs	r5, #0
   119aa:	e79b      	b.n	118e4 <z_sys_mem_pool_block_alloc+0xb0>

000119ac <z_sys_mem_pool_block_free>:

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
   119ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   119b0:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   119b2:	7a83      	ldrb	r3, [r0, #10]
   119b4:	009b      	lsls	r3, r3, #2
   119b6:	3307      	adds	r3, #7
   119b8:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
{
   119bc:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   119be:	ebad 0d03 	sub.w	sp, sp, r3
   119c2:	46ea      	mov	sl, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
   119c4:	6843      	ldr	r3, [r0, #4]
   119c6:	f8ca 3000 	str.w	r3, [sl]
{
   119ca:	4605      	mov	r5, r0
	for (i = 1; i <= level; i++) {
   119cc:	4654      	mov	r4, sl
   119ce:	2001      	movs	r0, #1
   119d0:	4281      	cmp	r1, r0
   119d2:	d214      	bcs.n	119fe <z_sys_mem_pool_block_free+0x52>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   119d4:	7c28      	ldrb	r0, [r5, #16]
   119d6:	f010 0001 	ands.w	r0, r0, #1
		lsizes[i] = _ALIGN4(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
   119da:	460e      	mov	r6, r1
   119dc:	4690      	mov	r8, r2
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   119de:	d001      	beq.n	119e4 <z_sys_mem_pool_block_free+0x38>
   119e0:	f7ff fece 	bl	11780 <pool_irq_lock.isra.2.part.3>
	unsigned int key = pool_irq_lock(p);
   119e4:	4604      	mov	r4, r0
	while (level >= 0) {
   119e6:	2e00      	cmp	r6, #0
   119e8:	da12      	bge.n	11a10 <z_sys_mem_pool_block_free+0x64>
	return -1;
   119ea:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	pool_irq_unlock(p, key);
   119ee:	4621      	mov	r1, r4
   119f0:	7c28      	ldrb	r0, [r5, #16]
   119f2:	f7ff fece 	bl	11792 <pool_irq_unlock.isra.4>
}
   119f6:	3714      	adds	r7, #20
   119f8:	46bd      	mov	sp, r7
   119fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = _ALIGN4(lsizes[i-1] / 4);
   119fe:	6823      	ldr	r3, [r4, #0]
   11a00:	089b      	lsrs	r3, r3, #2
   11a02:	3303      	adds	r3, #3
   11a04:	f023 0303 	bic.w	r3, r3, #3
   11a08:	f844 3f04 	str.w	r3, [r4, #4]!
	for (i = 1; i <= level; i++) {
   11a0c:	3001      	adds	r0, #1
   11a0e:	e7df      	b.n	119d0 <z_sys_mem_pool_block_free+0x24>
		int i, lsz = lsizes[level];
   11a10:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
   11a14:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
   11a16:	fb03 fb08 	mul.w	fp, r3, r8
   11a1a:	682b      	ldr	r3, [r5, #0]
   11a1c:	603b      	str	r3, [r7, #0]
		set_free_bit(p, level, bn);
   11a1e:	4642      	mov	r2, r8
   11a20:	4631      	mov	r1, r6
   11a22:	4628      	mov	r0, r5
	return (u8_t *)p->buf + lsz * block;
   11a24:	eb03 090b 	add.w	r9, r3, fp
		set_free_bit(p, level, bn);
   11a28:	f7ff fe71 	bl	1170e <set_free_bit>
		sys_dlist_append(&p->levels[level].free_list, block);
   11a2c:	68ea      	ldr	r2, [r5, #12]
   11a2e:	230c      	movs	r3, #12
   11a30:	fb03 2206 	mla	r2, r3, r6, r2
	node->next = list;
   11a34:	683b      	ldr	r3, [r7, #0]
   11a36:	1d11      	adds	r1, r2, #4
   11a38:	f843 100b 	str.w	r1, [r3, fp]
	node->prev = list->tail;
   11a3c:	6893      	ldr	r3, [r2, #8]
   11a3e:	f8c9 3004 	str.w	r3, [r9, #4]
	list->tail->next = node;
   11a42:	6893      	ldr	r3, [r2, #8]
   11a44:	f8c3 9000 	str.w	r9, [r3]
	list->tail = node;
   11a48:	f8c2 9008 	str.w	r9, [r2, #8]
		pool_irq_unlock(p, key);
   11a4c:	7c28      	ldrb	r0, [r5, #16]
   11a4e:	4621      	mov	r1, r4
   11a50:	f7ff fe9f 	bl	11792 <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   11a54:	7c28      	ldrb	r0, [r5, #16]
   11a56:	f010 0001 	ands.w	r0, r0, #1
   11a5a:	d001      	beq.n	11a60 <z_sys_mem_pool_block_free+0xb4>
   11a5c:	f7ff fe90 	bl	11780 <pool_irq_lock.isra.2.part.3>
		key = pool_irq_lock(p);
   11a60:	4604      	mov	r4, r0
		if (level == 0 || partner_bits(p, level, bn) != 0xf) {
   11a62:	2e00      	cmp	r6, #0
   11a64:	d0c3      	beq.n	119ee <z_sys_mem_pool_block_free+0x42>
	int bit = get_bit_ptr(p, level, bn, &word);
   11a66:	f107 030c 	add.w	r3, r7, #12
   11a6a:	4642      	mov	r2, r8
   11a6c:	4631      	mov	r1, r6
   11a6e:	4628      	mov	r0, r5
   11a70:	f7ff fe36 	bl	116e0 <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
   11a74:	68fa      	ldr	r2, [r7, #12]
   11a76:	2800      	cmp	r0, #0
   11a78:	bfb8      	it	lt
   11a7a:	3003      	addlt	r0, #3
   11a7c:	f020 0303 	bic.w	r3, r0, #3
   11a80:	6810      	ldr	r0, [r2, #0]
   11a82:	40d8      	lsrs	r0, r3
   11a84:	f000 000f 	and.w	r0, r0, #15
		if (level == 0 || partner_bits(p, level, bn) != 0xf) {
   11a88:	280f      	cmp	r0, #15
   11a8a:	d1b0      	bne.n	119ee <z_sys_mem_pool_block_free+0x42>
			int b = (bn & ~3) + i;
   11a8c:	f028 0303 	bic.w	r3, r8, #3
		for (i = 0; i < 4; i++) {
   11a90:	f04f 0b00 	mov.w	fp, #0
			int b = (bn & ~3) + i;
   11a94:	603b      	str	r3, [r7, #0]
   11a96:	683b      	ldr	r3, [r7, #0]
   11a98:	eb03 090b 	add.w	r9, r3, fp
			if (block_fits(p, level, b, lsizes)) {
   11a9c:	464a      	mov	r2, r9
   11a9e:	4653      	mov	r3, sl
   11aa0:	4631      	mov	r1, r6
   11aa2:	4628      	mov	r0, r5
   11aa4:	f7ff fe50 	bl	11748 <block_fits>
   11aa8:	b190      	cbz	r0, 11ad0 <z_sys_mem_pool_block_free+0x124>
				clear_free_bit(p, level, b);
   11aaa:	464a      	mov	r2, r9
   11aac:	4628      	mov	r0, r5
   11aae:	f7ff fe3c 	bl	1172a <clear_free_bit>
	return (u8_t *)p->buf + lsz * block;
   11ab2:	687b      	ldr	r3, [r7, #4]
   11ab4:	fb03 f909 	mul.w	r9, r3, r9
   11ab8:	682b      	ldr	r3, [r5, #0]
   11aba:	eb03 0209 	add.w	r2, r3, r9
	node->prev->next = node->next;
   11abe:	f853 1009 	ldr.w	r1, [r3, r9]
   11ac2:	6850      	ldr	r0, [r2, #4]
   11ac4:	6001      	str	r1, [r0, #0]
	node->next->prev = node->prev;
   11ac6:	6048      	str	r0, [r1, #4]
	node->next = NULL;
   11ac8:	2100      	movs	r1, #0
   11aca:	f843 1009 	str.w	r1, [r3, r9]
	node->prev = NULL;
   11ace:	6051      	str	r1, [r2, #4]
		for (i = 0; i < 4; i++) {
   11ad0:	f10b 0b01 	add.w	fp, fp, #1
   11ad4:	f1bb 0f04 	cmp.w	fp, #4
   11ad8:	d1dd      	bne.n	11a96 <z_sys_mem_pool_block_free+0xea>
		bn = bn / 4;
   11ada:	f1b8 0f00 	cmp.w	r8, #0
   11ade:	bfb8      	it	lt
   11ae0:	f108 0803 	addlt.w	r8, r8, #3
		level = level - 1;
   11ae4:	3e01      	subs	r6, #1
		bn = bn / 4;
   11ae6:	ea4f 08a8 	mov.w	r8, r8, asr #2
   11aea:	e77c      	b.n	119e6 <z_sys_mem_pool_block_free+0x3a>

00011aec <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   11aec:	b508      	push	{r3, lr}
   11aee:	4604      	mov	r4, r0
   11af0:	4608      	mov	r0, r1
   11af2:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   11af4:	461a      	mov	r2, r3
   11af6:	47a0      	blx	r4
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
   11af8:	f7fd fd80 	bl	f5fc <z_impl_k_current_get>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
   11afc:	f7f8 fa3a 	bl	9f74 <z_impl_k_thread_abort>

00011b00 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   11b00:	b510      	push	{r4, lr}
   11b02:	4604      	mov	r4, r0
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
   11b04:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   11b08:	4620      	mov	r0, r4
   11b0a:	f003 fffa 	bl	15b02 <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   11b0e:	4603      	mov	r3, r0
   11b10:	2800      	cmp	r0, #0
   11b12:	d0f7      	beq.n	11b04 <z_work_q_main+0x4>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   11b14:	3308      	adds	r3, #8
			continue;
		}

		handler = work->handler;
   11b16:	6842      	ldr	r2, [r0, #4]
   11b18:	f3bf 8f5b 	dmb	ish
   11b1c:	e853 1f00 	ldrex	r1, [r3]
   11b20:	f021 0c01 	bic.w	ip, r1, #1
   11b24:	e843 ce00 	strex	lr, ip, [r3]
   11b28:	f1be 0f00 	cmp.w	lr, #0
   11b2c:	d1f6      	bne.n	11b1c <z_work_q_main+0x1c>
   11b2e:	f3bf 8f5b 	dmb	ish

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   11b32:	07cb      	lsls	r3, r1, #31
   11b34:	d500      	bpl.n	11b38 <z_work_q_main+0x38>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   11b36:	4790      	blx	r2
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)
   11b38:	f7fd fca4 	bl	f484 <z_impl_k_yield>
   11b3c:	e7e2      	b.n	11b04 <z_work_q_main+0x4>

00011b3e <z_arch_printk_char_out>:
}
   11b3e:	2000      	movs	r0, #0
   11b40:	4770      	bx	lr

00011b42 <print_err>:
{
   11b42:	b570      	push	{r4, r5, r6, lr}
   11b44:	4604      	mov	r4, r0
   11b46:	460d      	mov	r5, r1
	out('E', ctx);
   11b48:	2045      	movs	r0, #69	; 0x45
   11b4a:	47a0      	blx	r4
	out('R', ctx);
   11b4c:	4629      	mov	r1, r5
   11b4e:	2052      	movs	r0, #82	; 0x52
   11b50:	47a0      	blx	r4
	out('R', ctx);
   11b52:	4629      	mov	r1, r5
   11b54:	4623      	mov	r3, r4
   11b56:	2052      	movs	r0, #82	; 0x52
}
   11b58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   11b5c:	4718      	bx	r3

00011b5e <z_vprintk>:
{
   11b5e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11b62:	b08b      	sub	sp, #44	; 0x2c
   11b64:	461c      	mov	r4, r3
	int long_ctr = 0;
   11b66:	f04f 0900 	mov.w	r9, #0
   11b6a:	1e53      	subs	r3, r2, #1
{
   11b6c:	4605      	mov	r5, r0
   11b6e:	460e      	mov	r6, r1
   11b70:	9303      	str	r3, [sp, #12]
	int min_width = -1;
   11b72:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
   11b76:	464f      	mov	r7, r9
			might_format = 0;
   11b78:	f04f 0b00 	mov.w	fp, #0
						break;
   11b7c:	e007      	b.n	11b8e <z_vprintk+0x30>
		if (!might_format) {
   11b7e:	f1bb 0f00 	cmp.w	fp, #0
   11b82:	d10d      	bne.n	11ba0 <z_vprintk+0x42>
			if (*fmt != '%') {
   11b84:	2825      	cmp	r0, #37	; 0x25
   11b86:	f000 812e 	beq.w	11de6 <z_vprintk+0x288>
				out((int)*fmt, ctx);
   11b8a:	4631      	mov	r1, r6
   11b8c:	47a8      	blx	r5
	while (*fmt) {
   11b8e:	9b03      	ldr	r3, [sp, #12]
   11b90:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   11b94:	9303      	str	r3, [sp, #12]
   11b96:	2800      	cmp	r0, #0
   11b98:	d1f1      	bne.n	11b7e <z_vprintk+0x20>
}
   11b9a:	b00b      	add	sp, #44	; 0x2c
   11b9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
   11ba0:	2864      	cmp	r0, #100	; 0x64
   11ba2:	d05f      	beq.n	11c64 <z_vprintk+0x106>
   11ba4:	d819      	bhi.n	11bda <z_vprintk+0x7c>
   11ba6:	2839      	cmp	r0, #57	; 0x39
   11ba8:	d80a      	bhi.n	11bc0 <z_vprintk+0x62>
   11baa:	2831      	cmp	r0, #49	; 0x31
   11bac:	d24e      	bcs.n	11c4c <z_vprintk+0xee>
   11bae:	282d      	cmp	r0, #45	; 0x2d
   11bb0:	f000 8120 	beq.w	11df4 <z_vprintk+0x296>
   11bb4:	2830      	cmp	r0, #48	; 0x30
   11bb6:	d03d      	beq.n	11c34 <z_vprintk+0xd6>
   11bb8:	2825      	cmp	r0, #37	; 0x25
   11bba:	d107      	bne.n	11bcc <z_vprintk+0x6e>
				out((int)'%', ctx);
   11bbc:	4631      	mov	r1, r6
   11bbe:	e110      	b.n	11de2 <z_vprintk+0x284>
			switch (*fmt) {
   11bc0:	2858      	cmp	r0, #88	; 0x58
   11bc2:	f000 80a3 	beq.w	11d0c <z_vprintk+0x1ae>
   11bc6:	2863      	cmp	r0, #99	; 0x63
   11bc8:	f000 8108 	beq.w	11ddc <z_vprintk+0x27e>
				out((int)'%', ctx);
   11bcc:	4631      	mov	r1, r6
   11bce:	2025      	movs	r0, #37	; 0x25
   11bd0:	47a8      	blx	r5
				out((int)*fmt, ctx);
   11bd2:	9b03      	ldr	r3, [sp, #12]
   11bd4:	4631      	mov	r1, r6
   11bd6:	7818      	ldrb	r0, [r3, #0]
   11bd8:	e103      	b.n	11de2 <z_vprintk+0x284>
			switch (*fmt) {
   11bda:	2870      	cmp	r0, #112	; 0x70
   11bdc:	f000 808d 	beq.w	11cfa <z_vprintk+0x19c>
   11be0:	d806      	bhi.n	11bf0 <z_vprintk+0x92>
   11be2:	2869      	cmp	r0, #105	; 0x69
   11be4:	d03e      	beq.n	11c64 <z_vprintk+0x106>
   11be6:	286c      	cmp	r0, #108	; 0x6c
   11be8:	d039      	beq.n	11c5e <z_vprintk+0x100>
   11bea:	2868      	cmp	r0, #104	; 0x68
   11bec:	d0cf      	beq.n	11b8e <z_vprintk+0x30>
   11bee:	e7ed      	b.n	11bcc <z_vprintk+0x6e>
   11bf0:	2875      	cmp	r0, #117	; 0x75
   11bf2:	d06b      	beq.n	11ccc <z_vprintk+0x16e>
   11bf4:	d81a      	bhi.n	11c2c <z_vprintk+0xce>
   11bf6:	2873      	cmp	r0, #115	; 0x73
   11bf8:	d1e8      	bne.n	11bcc <z_vprintk+0x6e>
				char *s = va_arg(ap, char *);
   11bfa:	f854 bb04 	ldr.w	fp, [r4], #4
				while (*s)
   11bfe:	46da      	mov	sl, fp
   11c00:	4652      	mov	r2, sl
   11c02:	f81a 0b01 	ldrb.w	r0, [sl], #1
   11c06:	2800      	cmp	r0, #0
   11c08:	f040 80e5 	bne.w	11dd6 <z_vprintk+0x278>
				if (padding == PAD_SPACE_AFTER) {
   11c0c:	2f03      	cmp	r7, #3
   11c0e:	f040 80f5 	bne.w	11dfc <z_vprintk+0x29e>
					int remaining = min_width - (s - start);
   11c12:	eba2 0b0b 	sub.w	fp, r2, fp
   11c16:	eba8 0b0b 	sub.w	fp, r8, fp
					while (remaining-- > 0) {
   11c1a:	f1bb 0f00 	cmp.w	fp, #0
   11c1e:	ddab      	ble.n	11b78 <z_vprintk+0x1a>
						out(' ', ctx);
   11c20:	4631      	mov	r1, r6
   11c22:	2020      	movs	r0, #32
   11c24:	47a8      	blx	r5
   11c26:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
   11c2a:	e7f6      	b.n	11c1a <z_vprintk+0xbc>
			switch (*fmt) {
   11c2c:	2878      	cmp	r0, #120	; 0x78
   11c2e:	d06d      	beq.n	11d0c <z_vprintk+0x1ae>
   11c30:	287a      	cmp	r0, #122	; 0x7a
   11c32:	e7db      	b.n	11bec <z_vprintk+0x8e>
				if (min_width < 0 && padding == PAD_NONE) {
   11c34:	f1b8 0f00 	cmp.w	r8, #0
   11c38:	da0b      	bge.n	11c52 <z_vprintk+0xf4>
   11c3a:	2f00      	cmp	r7, #0
   11c3c:	f000 80dc 	beq.w	11df8 <z_vprintk+0x29a>
					min_width = *fmt - '0';
   11c40:	f1a0 0830 	sub.w	r8, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
   11c44:	2f00      	cmp	r7, #0
   11c46:	bf08      	it	eq
   11c48:	2702      	moveq	r7, #2
   11c4a:	e7a0      	b.n	11b8e <z_vprintk+0x30>
				if (min_width < 0) {
   11c4c:	f1b8 0f00 	cmp.w	r8, #0
   11c50:	dbf6      	blt.n	11c40 <z_vprintk+0xe2>
					min_width = 10 * min_width + *fmt - '0';
   11c52:	220a      	movs	r2, #10
   11c54:	fb02 0808 	mla	r8, r2, r8, r0
   11c58:	f1a8 0830 	sub.w	r8, r8, #48	; 0x30
   11c5c:	e7f2      	b.n	11c44 <z_vprintk+0xe6>
				long_ctr++;
   11c5e:	f109 0901 	add.w	r9, r9, #1
   11c62:	e794      	b.n	11b8e <z_vprintk+0x30>
				if (long_ctr == 0) {
   11c64:	f1b9 0f00 	cmp.w	r9, #0
   11c68:	d114      	bne.n	11c94 <z_vprintk+0x136>
					long ld = va_arg(ap, long);
   11c6a:	f854 ab04 	ldr.w	sl, [r4], #4
				if (d < 0) {
   11c6e:	f1ba 0f00 	cmp.w	sl, #0
   11c72:	da06      	bge.n	11c82 <z_vprintk+0x124>
					out((int)'-', ctx);
   11c74:	4631      	mov	r1, r6
   11c76:	202d      	movs	r0, #45	; 0x2d
   11c78:	47a8      	blx	r5
					d = -d;
   11c7a:	f1ca 0a00 	rsb	sl, sl, #0
					min_width--;
   11c7e:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
				_printk_dec_ulong(out, ctx, d, padding,
   11c82:	f8cd 8000 	str.w	r8, [sp]
   11c86:	463b      	mov	r3, r7
   11c88:	4652      	mov	r2, sl
				_printk_dec_ulong(out, ctx, u, padding,
   11c8a:	4631      	mov	r1, r6
   11c8c:	4628      	mov	r0, r5
   11c8e:	f7f3 fba7 	bl	53e0 <_printk_dec_ulong>
				break;
   11c92:	e771      	b.n	11b78 <z_vprintk+0x1a>
				} else if (long_ctr == 1) {
   11c94:	f1b9 0f01 	cmp.w	r9, #1
   11c98:	d0e7      	beq.n	11c6a <z_vprintk+0x10c>
					long long lld = va_arg(ap, long long);
   11c9a:	3407      	adds	r4, #7
   11c9c:	f024 0407 	bic.w	r4, r4, #7
   11ca0:	e8f4 ab02 	ldrd	sl, fp, [r4], #8
					if (lld > INT32_MAX ||
   11ca4:	f11a 4300 	adds.w	r3, sl, #2147483648	; 0x80000000
   11ca8:	9306      	str	r3, [sp, #24]
   11caa:	f14b 0300 	adc.w	r3, fp, #0
   11cae:	9307      	str	r3, [sp, #28]
   11cb0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   11cb4:	2300      	movs	r3, #0
   11cb6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   11cba:	428b      	cmp	r3, r1
   11cbc:	bf08      	it	eq
   11cbe:	4282      	cmpeq	r2, r0
   11cc0:	d2d5      	bcs.n	11c6e <z_vprintk+0x110>
						print_err(out, ctx);
   11cc2:	4631      	mov	r1, r6
   11cc4:	4628      	mov	r0, r5
   11cc6:	f7ff ff3c 	bl	11b42 <print_err>
   11cca:	e755      	b.n	11b78 <z_vprintk+0x1a>
				if (long_ctr == 0) {
   11ccc:	f1b9 0f00 	cmp.w	r9, #0
   11cd0:	d105      	bne.n	11cde <z_vprintk+0x180>
					long lu = va_arg(ap, unsigned long);
   11cd2:	f854 2b04 	ldr.w	r2, [r4], #4
				_printk_dec_ulong(out, ctx, u, padding,
   11cd6:	f8cd 8000 	str.w	r8, [sp]
   11cda:	463b      	mov	r3, r7
   11cdc:	e7d5      	b.n	11c8a <z_vprintk+0x12c>
				} else if (long_ctr == 1) {
   11cde:	f1b9 0f01 	cmp.w	r9, #1
   11ce2:	d0f6      	beq.n	11cd2 <z_vprintk+0x174>
					unsigned long long llu =
   11ce4:	3407      	adds	r4, #7
   11ce6:	f024 0407 	bic.w	r4, r4, #7
   11cea:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > INT32_MAX) {
   11cee:	2b00      	cmp	r3, #0
   11cf0:	bf08      	it	eq
   11cf2:	f1b2 4f00 	cmpeq.w	r2, #2147483648	; 0x80000000
   11cf6:	d3ee      	bcc.n	11cd6 <z_vprintk+0x178>
   11cf8:	e7e3      	b.n	11cc2 <z_vprintk+0x164>
				  out('0', ctx);
   11cfa:	4631      	mov	r1, r6
   11cfc:	2030      	movs	r0, #48	; 0x30
   11cfe:	47a8      	blx	r5
				  out('x', ctx);
   11d00:	4631      	mov	r1, r6
   11d02:	2078      	movs	r0, #120	; 0x78
   11d04:	47a8      	blx	r5
				  min_width = 8;
   11d06:	f04f 0808 	mov.w	r8, #8
				  padding = PAD_ZERO_BEFORE;
   11d0a:	2701      	movs	r7, #1
				if (long_ctr < 2) {
   11d0c:	f1b9 0f01 	cmp.w	r9, #1
   11d10:	dc26      	bgt.n	11d60 <z_vprintk+0x202>
					x = va_arg(ap, unsigned long);
   11d12:	f854 3b04 	ldr.w	r3, [r4], #4
   11d16:	9308      	str	r3, [sp, #32]
   11d18:	2300      	movs	r3, #0
	int remaining = 16; /* 16 digits max */
   11d1a:	2210      	movs	r2, #16
	int digits = 0;
   11d1c:	f04f 0a00 	mov.w	sl, #0
					x = va_arg(ap, unsigned long long);
   11d20:	9304      	str	r3, [sp, #16]
	int found_largest_digit = 0;
   11d22:	f8cd a014 	str.w	sl, [sp, #20]
	int size = sizeof(num) * 2;
   11d26:	4611      	mov	r1, r2
		char nibble = (num >> ((size - 1) << 2) & 0xf);
   11d28:	1e4b      	subs	r3, r1, #1
   11d2a:	0098      	lsls	r0, r3, #2
   11d2c:	9302      	str	r3, [sp, #8]
   11d2e:	9b08      	ldr	r3, [sp, #32]
   11d30:	f1c0 0e20 	rsb	lr, r0, #32
   11d34:	f1a0 0c20 	sub.w	ip, r0, #32
   11d38:	fa23 f000 	lsr.w	r0, r3, r0
   11d3c:	9b04      	ldr	r3, [sp, #16]
   11d3e:	fa03 fe0e 	lsl.w	lr, r3, lr
   11d42:	ea40 000e 	orr.w	r0, r0, lr
   11d46:	fa23 fc0c 	lsr.w	ip, r3, ip
   11d4a:	ea40 000c 	orr.w	r0, r0, ip
		if (nibble != 0 || found_largest_digit != 0 || size == 1) {
   11d4e:	f010 000f 	ands.w	r0, r0, #15
   11d52:	d112      	bne.n	11d7a <z_vprintk+0x21c>
   11d54:	9b05      	ldr	r3, [sp, #20]
   11d56:	b90b      	cbnz	r3, 11d5c <z_vprintk+0x1fe>
   11d58:	2901      	cmp	r1, #1
   11d5a:	d12c      	bne.n	11db6 <z_vprintk+0x258>
			nibble += nibble > 9 ? 87 : 48;
   11d5c:	2130      	movs	r1, #48	; 0x30
   11d5e:	e010      	b.n	11d82 <z_vprintk+0x224>
					x = va_arg(ap, unsigned long long);
   11d60:	3407      	adds	r4, #7
   11d62:	f024 0207 	bic.w	r2, r4, #7
   11d66:	4614      	mov	r4, r2
   11d68:	f854 3b08 	ldr.w	r3, [r4], #8
   11d6c:	9308      	str	r3, [sp, #32]
   11d6e:	6853      	ldr	r3, [r2, #4]
   11d70:	e7d3      	b.n	11d1a <z_vprintk+0x1bc>
			found_largest_digit = 1;
   11d72:	f8cd b014 	str.w	fp, [sp, #20]
		char nibble = (num >> ((size - 1) << 2) & 0xf);
   11d76:	9902      	ldr	r1, [sp, #8]
   11d78:	e7d6      	b.n	11d28 <z_vprintk+0x1ca>
			nibble += nibble > 9 ? 87 : 48;
   11d7a:	2809      	cmp	r0, #9
   11d7c:	bf8c      	ite	hi
   11d7e:	2157      	movhi	r1, #87	; 0x57
   11d80:	2130      	movls	r1, #48	; 0x30
   11d82:	4408      	add	r0, r1
			out((int)nibble, ctx);
   11d84:	b240      	sxtb	r0, r0
   11d86:	4631      	mov	r1, r6
   11d88:	9205      	str	r2, [sp, #20]
   11d8a:	47a8      	blx	r5
	for (; size != 0; size--) {
   11d8c:	9b02      	ldr	r3, [sp, #8]
   11d8e:	9a05      	ldr	r2, [sp, #20]
			digits++;
   11d90:	f10a 0a01 	add.w	sl, sl, #1
	for (; size != 0; size--) {
   11d94:	2b00      	cmp	r3, #0
   11d96:	d1ec      	bne.n	11d72 <z_vprintk+0x214>
	if (padding == PAD_SPACE_AFTER) {
   11d98:	2f03      	cmp	r7, #3
   11d9a:	f47f aeed 	bne.w	11b78 <z_vprintk+0x1a>
		remaining = min_width * 2 - digits;
   11d9e:	ebca 0a48 	rsb	sl, sl, r8, lsl #1
		while (remaining-- > 0) {
   11da2:	f1ba 0f00 	cmp.w	sl, #0
   11da6:	f77f aee7 	ble.w	11b78 <z_vprintk+0x1a>
			out(' ', ctx);
   11daa:	4631      	mov	r1, r6
   11dac:	2020      	movs	r0, #32
   11dae:	47a8      	blx	r5
   11db0:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   11db4:	e7f5      	b.n	11da2 <z_vprintk+0x244>
		if (remaining-- <= min_width) {
   11db6:	1e53      	subs	r3, r2, #1
   11db8:	4590      	cmp	r8, r2
   11dba:	9309      	str	r3, [sp, #36]	; 0x24
   11dbc:	db04      	blt.n	11dc8 <z_vprintk+0x26a>
			if (padding == PAD_ZERO_BEFORE) {
   11dbe:	2f01      	cmp	r7, #1
   11dc0:	d104      	bne.n	11dcc <z_vprintk+0x26e>
				out('0', ctx);
   11dc2:	4631      	mov	r1, r6
   11dc4:	2030      	movs	r0, #48	; 0x30
				out(' ', ctx);
   11dc6:	47a8      	blx	r5
					x = va_arg(ap, unsigned long);
   11dc8:	9a09      	ldr	r2, [sp, #36]	; 0x24
   11dca:	e7d4      	b.n	11d76 <z_vprintk+0x218>
			} else if (padding == PAD_SPACE_BEFORE) {
   11dcc:	2f02      	cmp	r7, #2
   11dce:	d1fb      	bne.n	11dc8 <z_vprintk+0x26a>
				out(' ', ctx);
   11dd0:	4631      	mov	r1, r6
   11dd2:	2020      	movs	r0, #32
   11dd4:	e7f7      	b.n	11dc6 <z_vprintk+0x268>
					out((int)(*s++), ctx);
   11dd6:	4631      	mov	r1, r6
   11dd8:	47a8      	blx	r5
   11dda:	e711      	b.n	11c00 <z_vprintk+0xa2>
				out(c, ctx);
   11ddc:	f854 0b04 	ldr.w	r0, [r4], #4
   11de0:	4631      	mov	r1, r6
				out((int)*fmt, ctx);
   11de2:	47a8      	blx	r5
				break;
   11de4:	e6c8      	b.n	11b78 <z_vprintk+0x1a>
				long_ctr = 0;
   11de6:	46d9      	mov	r9, fp
				padding = PAD_NONE;
   11de8:	465f      	mov	r7, fp
				min_width = -1;
   11dea:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
				might_format = 1;
   11dee:	f04f 0b01 	mov.w	fp, #1
   11df2:	e6cc      	b.n	11b8e <z_vprintk+0x30>
				padding = PAD_SPACE_AFTER;
   11df4:	2703      	movs	r7, #3
   11df6:	e6ca      	b.n	11b8e <z_vprintk+0x30>
					padding = PAD_ZERO_BEFORE;
   11df8:	2701      	movs	r7, #1
   11dfa:	e6c8      	b.n	11b8e <z_vprintk+0x30>
			might_format = 0;
   11dfc:	4683      	mov	fp, r0
		++fmt;
   11dfe:	e6c6      	b.n	11b8e <z_vprintk+0x30>

00011e00 <printk>:
{
   11e00:	b40f      	push	{r0, r1, r2, r3}
   11e02:	b507      	push	{r0, r1, r2, lr}
   11e04:	a904      	add	r1, sp, #16
   11e06:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   11e0a:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   11e0c:	f7f3 fb3e 	bl	548c <vprintk>
}
   11e10:	b003      	add	sp, #12
   11e12:	f85d eb04 	ldr.w	lr, [sp], #4
   11e16:	b004      	add	sp, #16
   11e18:	4770      	bx	lr

00011e1a <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);

GEN_ABS_SYM_END
   11e1a:	4770      	bx	lr

00011e1c <nrfx_isr>:

#include <nrfx.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   11e1c:	4700      	bx	r0

00011e1e <nrf_usbd_task_trigger>:
    return (volatile uint32_t*)(((uint8_t *)NRF_USBD) + (uint32_t)offset);
   11e1e:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
   11e22:	f500 301c 	add.w	r0, r0, #159744	; 0x27000
    *(nrf_usbd_getRegPtr((uint32_t)task)) = 1UL;
   11e26:	2301      	movs	r3, #1
   11e28:	6003      	str	r3, [r0, #0]
  __ASM volatile ("isb 0xF":::"memory");
   11e2a:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
   11e2e:	f3bf 8f4f 	dsb	sy
}
   11e32:	4770      	bx	lr

00011e34 <ev_started_handler>:
}
   11e34:	4770      	bx	lr

00011e36 <ep2bit>:
{
   11e36:	b508      	push	{r3, lr}
    NRFX_USBD_ASSERT_EP_VALID(ep);
   11e38:	f000 030f 	and.w	r3, r0, #15
   11e3c:	2b08      	cmp	r3, #8
   11e3e:	d901      	bls.n	11e44 <ep2bit+0xe>
   11e40:	f7f3 fd8e 	bl	5960 <ep2bit.part.6>
    return NRFX_USBD_EP_BITPOS(ep);
   11e44:	b243      	sxtb	r3, r0
   11e46:	2b00      	cmp	r3, #0
   11e48:	bfb4      	ite	lt
   11e4a:	2000      	movlt	r0, #0
   11e4c:	2010      	movge	r0, #16
   11e4e:	f003 030f 	and.w	r3, r3, #15
}
   11e52:	4418      	add	r0, r3
   11e54:	bd08      	pop	{r3, pc}

00011e56 <nrf_usbd_epin_dma_handler>:
{
   11e56:	b510      	push	{r4, lr}
   11e58:	4604      	mov	r4, r0
    usbd_dma_pending_clear();
   11e5a:	f7f3 fc77 	bl	574c <usbd_dma_pending_clear>
    usbd_ep_state_t * p_state = ep_state_access(ep);
   11e5e:	f7f3 fd6b 	bl	5938 <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   11e62:	7b83      	ldrb	r3, [r0, #14]
   11e64:	2b03      	cmp	r3, #3
   11e66:	d10a      	bne.n	11e7e <nrf_usbd_epin_dma_handler+0x28>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   11e68:	4620      	mov	r0, r4
   11e6a:	f7ff ffe4 	bl	11e36 <ep2bit>
   11e6e:	2301      	movs	r3, #1
   11e70:	fa03 f000 	lsl.w	r0, r3, r0
   11e74:	43c0      	mvns	r0, r0
}
   11e76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   11e7a:	f7f3 be6b 	b.w	5b54 <atomic_and.constprop.25>
    else if (p_state->handler.feeder == NULL)
   11e7e:	6803      	ldr	r3, [r0, #0]
   11e80:	2b00      	cmp	r3, #0
   11e82:	d0f1      	beq.n	11e68 <nrf_usbd_epin_dma_handler+0x12>
}
   11e84:	bd10      	pop	{r4, pc}

00011e86 <ev_dma_epin7_handler>:
static void ev_dma_epin7_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN7 ); }
   11e86:	2087      	movs	r0, #135	; 0x87
   11e88:	f7ff bfe5 	b.w	11e56 <nrf_usbd_epin_dma_handler>

00011e8c <ev_dma_epin6_handler>:
static void ev_dma_epin6_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN6 ); }
   11e8c:	2086      	movs	r0, #134	; 0x86
   11e8e:	f7ff bfe2 	b.w	11e56 <nrf_usbd_epin_dma_handler>

00011e92 <ev_dma_epin5_handler>:
static void ev_dma_epin5_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN5 ); }
   11e92:	2085      	movs	r0, #133	; 0x85
   11e94:	f7ff bfdf 	b.w	11e56 <nrf_usbd_epin_dma_handler>

00011e98 <ev_dma_epin4_handler>:
static void ev_dma_epin4_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN4 ); }
   11e98:	2084      	movs	r0, #132	; 0x84
   11e9a:	f7ff bfdc 	b.w	11e56 <nrf_usbd_epin_dma_handler>

00011e9e <ev_dma_epin3_handler>:
static void ev_dma_epin3_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN3 ); }
   11e9e:	2083      	movs	r0, #131	; 0x83
   11ea0:	f7ff bfd9 	b.w	11e56 <nrf_usbd_epin_dma_handler>

00011ea4 <ev_dma_epin2_handler>:
static void ev_dma_epin2_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN2 ); }
   11ea4:	2082      	movs	r0, #130	; 0x82
   11ea6:	f7ff bfd6 	b.w	11e56 <nrf_usbd_epin_dma_handler>

00011eaa <ev_dma_epin1_handler>:
static void ev_dma_epin1_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN1 ); }
   11eaa:	2081      	movs	r0, #129	; 0x81
   11eac:	f7ff bfd3 	b.w	11e56 <nrf_usbd_epin_dma_handler>

00011eb0 <nrfx_usbd_ep_status_get>:
{
   11eb0:	b510      	push	{r4, lr}
   11eb2:	460c      	mov	r4, r1
    usbd_ep_state_t const * p_state = ep_state_access(ep);
   11eb4:	f7f3 fd40 	bl	5938 <ep_state_access>
	__asm__ volatile(
   11eb8:	f04f 0220 	mov.w	r2, #32
   11ebc:	f3ef 8311 	mrs	r3, BASEPRI
   11ec0:	f382 8811 	msr	BASEPRI, r2
   11ec4:	f3bf 8f6f 	isb	sy
    *p_size = p_state->transfer_cnt;
   11ec8:	6882      	ldr	r2, [r0, #8]
   11eca:	6022      	str	r2, [r4, #0]
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   11ecc:	6802      	ldr	r2, [r0, #0]
   11ece:	b92a      	cbnz	r2, 11edc <nrfx_usbd_ep_status_get+0x2c>
   11ed0:	7b80      	ldrb	r0, [r0, #14]
	__asm__ volatile(
   11ed2:	f383 8811 	msr	BASEPRI, r3
   11ed6:	f3bf 8f6f 	isb	sy
}
   11eda:	bd10      	pop	{r4, pc}
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   11edc:	2004      	movs	r0, #4
   11ede:	e7f8      	b.n	11ed2 <nrfx_usbd_ep_status_get+0x22>

00011ee0 <ev_dma_epout7_handler>:
static void ev_dma_epout7_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT7); }
   11ee0:	2007      	movs	r0, #7
   11ee2:	f7f4 baa9 	b.w	6438 <nrf_usbd_epout_dma_handler>

00011ee6 <ev_dma_epout6_handler>:
static void ev_dma_epout6_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT6); }
   11ee6:	2006      	movs	r0, #6
   11ee8:	f7f4 baa6 	b.w	6438 <nrf_usbd_epout_dma_handler>

00011eec <ev_dma_epout5_handler>:
static void ev_dma_epout5_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT5); }
   11eec:	2005      	movs	r0, #5
   11eee:	f7f4 baa3 	b.w	6438 <nrf_usbd_epout_dma_handler>

00011ef2 <ev_dma_epout4_handler>:
static void ev_dma_epout4_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT4); }
   11ef2:	2004      	movs	r0, #4
   11ef4:	f7f4 baa0 	b.w	6438 <nrf_usbd_epout_dma_handler>

00011ef8 <ev_dma_epout3_handler>:
static void ev_dma_epout3_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT3); }
   11ef8:	2003      	movs	r0, #3
   11efa:	f7f4 ba9d 	b.w	6438 <nrf_usbd_epout_dma_handler>

00011efe <ev_dma_epout2_handler>:
static void ev_dma_epout2_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT2); }
   11efe:	2002      	movs	r0, #2
   11f00:	f7f4 ba9a 	b.w	6438 <nrf_usbd_epout_dma_handler>

00011f04 <ev_dma_epout1_handler>:
static void ev_dma_epout1_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT1); }
   11f04:	2001      	movs	r0, #1
   11f06:	f7f4 ba97 	b.w	6438 <nrf_usbd_epout_dma_handler>

00011f0a <nrfx_usbd_setup_data_clear>:
{
   11f0a:	b508      	push	{r3, lr}
   11f0c:	f7f3 fc0e 	bl	572c <nrfx_usbd_errata_type_52840_eng_b>
    if (nrfx_usbd_errata_104())
   11f10:	b958      	cbnz	r0, 11f2a <nrfx_usbd_setup_data_clear+0x20>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   11f12:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
   11f16:	b672      	cpsid	i
        nrf_usbd_task_trigger(NRF_USBD_TASK_EP0RCVOUT);
   11f18:	204c      	movs	r0, #76	; 0x4c
   11f1a:	f7ff ff80 	bl	11e1e <nrf_usbd_task_trigger>
        nrf_usbd_task_trigger(NRF_USBD_TASK_EP0RCVOUT);
   11f1e:	204c      	movs	r0, #76	; 0x4c
   11f20:	f7ff ff7d 	bl	11e1e <nrf_usbd_task_trigger>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   11f24:	f382 8810 	msr	PRIMASK, r2
}
   11f28:	bd08      	pop	{r3, pc}
        nrf_usbd_task_trigger(NRF_USBD_TASK_EP0RCVOUT);
   11f2a:	204c      	movs	r0, #76	; 0x4c
}
   11f2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_usbd_task_trigger(NRF_USBD_TASK_EP0RCVOUT);
   11f30:	f7ff bf75 	b.w	11e1e <nrf_usbd_task_trigger>

00011f34 <nrfx_usbd_setup_clear>:
    nrf_usbd_task_trigger(NRF_USBD_TASK_EP0STATUS);
   11f34:	2050      	movs	r0, #80	; 0x50
   11f36:	f7ff bf72 	b.w	11e1e <nrf_usbd_task_trigger>

00011f3a <nrfx_usbd_setup_stall>:
    nrf_usbd_task_trigger(NRF_USBD_TASK_EP0STALL);
   11f3a:	2054      	movs	r0, #84	; 0x54
   11f3c:	f7ff bf6f 	b.w	11e1e <nrf_usbd_task_trigger>

00011f40 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   11f40:	2300      	movs	r3, #0
	list->head = NULL;
   11f42:	e9c0 3300 	strd	r3, r3, [r0]
}
   11f46:	4770      	bx	lr

00011f48 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   11f48:	6803      	ldr	r3, [r0, #0]
   11f4a:	b923      	cbnz	r3, 11f56 <log_list_add_tail+0xe>
		list->head = msg;
   11f4c:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   11f4e:	2300      	movs	r3, #0
	list->tail = msg;
   11f50:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   11f52:	600b      	str	r3, [r1, #0]
}
   11f54:	4770      	bx	lr
		list->tail->next = msg;
   11f56:	6843      	ldr	r3, [r0, #4]
   11f58:	6019      	str	r1, [r3, #0]
   11f5a:	e7f8      	b.n	11f4e <log_list_add_tail+0x6>

00011f5c <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   11f5c:	6800      	ldr	r0, [r0, #0]
   11f5e:	4770      	bx	lr

00011f60 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
	struct log_msg *msg = list->head;
   11f60:	6803      	ldr	r3, [r0, #0]

	if (list->head != NULL) {
   11f62:	b10b      	cbz	r3, 11f68 <log_list_head_get+0x8>
		list->head = list->head->next;
   11f64:	681a      	ldr	r2, [r3, #0]
   11f66:	6002      	str	r2, [r0, #0]
	}

	return msg;
}
   11f68:	4618      	mov	r0, r3
   11f6a:	4770      	bx	lr

00011f6c <dummy_timestamp>:
}
   11f6c:	2000      	movs	r0, #0
   11f6e:	4770      	bx	lr

00011f70 <timestamp_get>:
		return k_cycle_get_32();
   11f70:	f7f7 bd30 	b.w	99d4 <z_timer_cycle_get_32>

00011f74 <log_0>:
{
   11f74:	b538      	push	{r3, r4, r5, lr}
   11f76:	4605      	mov	r5, r0
   11f78:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   11f7a:	f7f4 fe39 	bl	6bf0 <z_log_msg_std_alloc>

	if (msg != NULL) {
   11f7e:	b128      	cbz	r0, 11f8c <log_0+0x18>
		msg->str = str;
   11f80:	6105      	str	r5, [r0, #16]
	msg_finalize(msg, src_level);
   11f82:	4621      	mov	r1, r4
}
   11f84:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	msg_finalize(msg, src_level);
   11f88:	f7f4 bf06 	b.w	6d98 <msg_finalize>
}
   11f8c:	bd38      	pop	{r3, r4, r5, pc}

00011f8e <log_1>:
{
   11f8e:	b570      	push	{r4, r5, r6, lr}
   11f90:	4604      	mov	r4, r0
   11f92:	460e      	mov	r6, r1
   11f94:	4615      	mov	r5, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       u32_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   11f96:	f7f4 fe2b 	bl	6bf0 <z_log_msg_std_alloc>

	if (msg != NULL) {
   11f9a:	b158      	cbz	r0, 11fb4 <log_1+0x26>
		msg->str = str;
   11f9c:	6104      	str	r4, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   11f9e:	7a44      	ldrb	r4, [r0, #9]
		msg->payload.single.args[0] = arg1;
   11fa0:	6146      	str	r6, [r0, #20]
		msg->hdr.params.std.nargs = 1U;
   11fa2:	2201      	movs	r2, #1
   11fa4:	f362 1407 	bfi	r4, r2, #4, #4
   11fa8:	7244      	strb	r4, [r0, #9]
	msg_finalize(msg, src_level);
   11faa:	4629      	mov	r1, r5
}
   11fac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	msg_finalize(msg, src_level);
   11fb0:	f7f4 bef2 	b.w	6d98 <msg_finalize>
}
   11fb4:	bd70      	pop	{r4, r5, r6, pc}

00011fb6 <log_2>:
{
   11fb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11fba:	4605      	mov	r5, r0
   11fbc:	4688      	mov	r8, r1
   11fbe:	4617      	mov	r7, r2
   11fc0:	461e      	mov	r6, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       u32_t arg1,
					       u32_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   11fc2:	f7f4 fe15 	bl	6bf0 <z_log_msg_std_alloc>

	if (msg != NULL) {
   11fc6:	b160      	cbz	r0, 11fe2 <log_2+0x2c>
		msg->str = str;
   11fc8:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 2U;
   11fca:	7a45      	ldrb	r5, [r0, #9]
   11fcc:	2302      	movs	r3, #2
   11fce:	f363 1507 	bfi	r5, r3, #4, #4
   11fd2:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   11fd4:	e9c0 8705 	strd	r8, r7, [r0, #20]
	msg_finalize(msg, src_level);
   11fd8:	4631      	mov	r1, r6
}
   11fda:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	msg_finalize(msg, src_level);
   11fde:	f7f4 bedb 	b.w	6d98 <msg_finalize>
}
   11fe2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00011fe6 <log_3>:
{
   11fe6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11fea:	4605      	mov	r5, r0
   11fec:	4689      	mov	r9, r1
   11fee:	4690      	mov	r8, r2
   11ff0:	461f      	mov	r7, r3
   11ff2:	f8bd 6020 	ldrh.w	r6, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       u32_t arg1,
					       u32_t arg2,
					       u32_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   11ff6:	f7f4 fdfb 	bl	6bf0 <z_log_msg_std_alloc>

	if (msg != NULL) {
   11ffa:	b168      	cbz	r0, 12018 <log_3+0x32>
		msg->str = str;
   11ffc:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 3U;
   11ffe:	7a45      	ldrb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
		msg->payload.single.args[2] = arg3;
   12000:	61c7      	str	r7, [r0, #28]
		msg->hdr.params.std.nargs = 3U;
   12002:	2303      	movs	r3, #3
   12004:	f363 1507 	bfi	r5, r3, #4, #4
   12008:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[1] = arg2;
   1200a:	e9c0 9805 	strd	r9, r8, [r0, #20]
	msg_finalize(msg, src_level);
   1200e:	4631      	mov	r1, r6
}
   12010:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	msg_finalize(msg, src_level);
   12014:	f7f4 bec0 	b.w	6d98 <msg_finalize>
}
   12018:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0001201c <log_n>:
{
   1201c:	b510      	push	{r4, lr}
   1201e:	461c      	mov	r4, r3
	struct log_msg *msg = log_msg_create_n(str, args, narg);
   12020:	f000 f89b 	bl	1215a <log_msg_create_n>
	if (msg == NULL) {
   12024:	b120      	cbz	r0, 12030 <log_n+0x14>
	msg_finalize(msg, src_level);
   12026:	4621      	mov	r1, r4
}
   12028:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	msg_finalize(msg, src_level);
   1202c:	f7f4 beb4 	b.w	6d98 <msg_finalize>
}
   12030:	bd10      	pop	{r4, pc}

00012032 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   12032:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   12036:	461c      	mov	r4, r3
	u32_t available_len = msg->hdr.params.hexdump.length;
   12038:	8903      	ldrh	r3, [r0, #8]
{
   1203a:	f89d 7020 	ldrb.w	r7, [sp, #32]
	u32_t available_len = msg->hdr.params.hexdump.length;
   1203e:	089b      	lsrs	r3, r3, #2
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
   12040:	42a3      	cmp	r3, r4
{
   12042:	460e      	mov	r6, r1
	if (offset >= available_len) {
   12044:	d803      	bhi.n	1204e <log_msg_hexdump_data_op+0x1c>
		*length = 0;
   12046:	2300      	movs	r3, #0
   12048:	6013      	str	r3, [r2, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
   1204a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
   1204e:	6811      	ldr	r1, [r2, #0]
   12050:	4421      	add	r1, r4
   12052:	4299      	cmp	r1, r3
		*length = available_len - offset;
   12054:	bf84      	itt	hi
   12056:	1b19      	subhi	r1, r3, r4
   12058:	6011      	strhi	r1, [r2, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   1205a:	2b0c      	cmp	r3, #12
	req_len = *length;
   1205c:	f8d2 9000 	ldr.w	r9, [r2]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   12060:	d928      	bls.n	120b4 <log_msg_hexdump_data_op+0x82>
	if (offset < chunk_len) {
   12062:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
   12064:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
   12068:	d82b      	bhi.n	120c2 <log_msg_hexdump_data_op+0x90>
		head_data = msg->payload.ext.data.bytes;
   1206a:	3018      	adds	r0, #24
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   1206c:	2308      	movs	r3, #8
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   1206e:	454b      	cmp	r3, r9
   12070:	bf28      	it	cs
   12072:	464b      	movcs	r3, r9
   12074:	461d      	mov	r5, r3
		if (put_op) {
   12076:	4420      	add	r0, r4
   12078:	461a      	mov	r2, r3
   1207a:	b1ff      	cbz	r7, 120bc <log_msg_hexdump_data_op+0x8a>
   1207c:	4631      	mov	r1, r6
   1207e:	f7f0 f879 	bl	2174 <memcpy>
		req_len -= cpy_len;
   12082:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   12086:	442e      	add	r6, r5
	while (req_len > 0) {
   12088:	f1b9 0f00 	cmp.w	r9, #0
   1208c:	d0dd      	beq.n	1204a <log_msg_hexdump_data_op+0x18>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   1208e:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   12092:	454d      	cmp	r5, r9
   12094:	bf28      	it	cs
   12096:	464d      	movcs	r5, r9
		if (put_op) {
   12098:	1d20      	adds	r0, r4, #4
   1209a:	4440      	add	r0, r8
   1209c:	462a      	mov	r2, r5
   1209e:	b1bf      	cbz	r7, 120d0 <log_msg_hexdump_data_op+0x9e>
   120a0:	4631      	mov	r1, r6
   120a2:	f7f0 f867 	bl	2174 <memcpy>
		req_len -= cpy_len;
   120a6:	eba9 0905 	sub.w	r9, r9, r5
		cont = cont->next;
   120aa:	f8d8 8000 	ldr.w	r8, [r8]
		data += cpy_len;
   120ae:	442e      	add	r6, r5
		offset = 0;
   120b0:	2400      	movs	r4, #0
   120b2:	e7e9      	b.n	12088 <log_msg_hexdump_data_op+0x56>
		head_data = msg->payload.single.bytes;
   120b4:	3014      	adds	r0, #20
	struct log_msg_cont *cont = NULL;
   120b6:	f04f 0800 	mov.w	r8, #0
   120ba:	e7d8      	b.n	1206e <log_msg_hexdump_data_op+0x3c>
   120bc:	4601      	mov	r1, r0
   120be:	4630      	mov	r0, r6
   120c0:	e7dd      	b.n	1207e <log_msg_hexdump_data_op+0x4c>
		offset -= chunk_len;
   120c2:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
   120c4:	2c1b      	cmp	r4, #27
   120c6:	d9df      	bls.n	12088 <log_msg_hexdump_data_op+0x56>
			cont = cont->next;
   120c8:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
   120cc:	3c1c      	subs	r4, #28
   120ce:	e7f9      	b.n	120c4 <log_msg_hexdump_data_op+0x92>
   120d0:	4601      	mov	r1, r0
   120d2:	4630      	mov	r0, r6
   120d4:	e7e5      	b.n	120a2 <log_msg_hexdump_data_op+0x70>

000120d6 <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   120d6:	3004      	adds	r0, #4
   120d8:	f3bf 8f5b 	dmb	ish
   120dc:	e850 3f00 	ldrex	r3, [r0]
   120e0:	3301      	adds	r3, #1
   120e2:	e840 3200 	strex	r2, r3, [r0]
   120e6:	2a00      	cmp	r2, #0
   120e8:	d1f8      	bne.n	120dc <log_msg_get+0x6>
   120ea:	f3bf 8f5b 	dmb	ish
}
   120ee:	4770      	bx	lr

000120f0 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   120f0:	7a40      	ldrb	r0, [r0, #9]
}
   120f2:	0900      	lsrs	r0, r0, #4
   120f4:	4770      	bx	lr

000120f6 <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
   120f6:	7a43      	ldrb	r3, [r0, #9]
   120f8:	091b      	lsrs	r3, r3, #4
   120fa:	428b      	cmp	r3, r1
   120fc:	d916      	bls.n	1212c <log_msg_arg_get+0x36>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   120fe:	2b03      	cmp	r3, #3
   12100:	d803      	bhi.n	1210a <log_msg_arg_get+0x14>
		arg = msg->payload.single.args[arg_idx];
   12102:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   12106:	6948      	ldr	r0, [r1, #20]
   12108:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   1210a:	2901      	cmp	r1, #1
   1210c:	d803      	bhi.n	12116 <log_msg_arg_get+0x20>
		return msg->payload.ext.data.args[arg_idx];
   1210e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   12112:	6988      	ldr	r0, [r1, #24]
   12114:	4770      	bx	lr
	cont = msg->payload.ext.next;
   12116:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   12118:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   1211a:	2906      	cmp	r1, #6
   1211c:	d803      	bhi.n	12126 <log_msg_arg_get+0x30>
	return cont->payload.args[arg_idx];
   1211e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   12122:	6848      	ldr	r0, [r1, #4]
   12124:	4770      	bx	lr
		arg_idx -= ARGS_CONT_MSG;
   12126:	3907      	subs	r1, #7
		cont = cont->next;
   12128:	681b      	ldr	r3, [r3, #0]
   1212a:	e7f6      	b.n	1211a <log_msg_arg_get+0x24>
		return 0;
   1212c:	2000      	movs	r0, #0
}
   1212e:	4770      	bx	lr

00012130 <log_msg_put>:
{
   12130:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   12132:	1d02      	adds	r2, r0, #4
   12134:	f3bf 8f5b 	dmb	ish
   12138:	e852 1f00 	ldrex	r1, [r2]
   1213c:	3901      	subs	r1, #1
   1213e:	e842 1c00 	strex	ip, r1, [r2]
   12142:	f1bc 0f00 	cmp.w	ip, #0
   12146:	d1f7      	bne.n	12138 <log_msg_put+0x8>
   12148:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
   1214c:	685b      	ldr	r3, [r3, #4]
   1214e:	b90b      	cbnz	r3, 12154 <log_msg_put+0x24>
		msg_free(msg);
   12150:	f7f4 bf9e 	b.w	7090 <msg_free>
}
   12154:	4770      	bx	lr

00012156 <log_msg_str_get>:
}
   12156:	6900      	ldr	r0, [r0, #16]
   12158:	4770      	bx	lr

0001215a <log_msg_create_n>:
{
   1215a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1215e:	4682      	mov	sl, r0
   12160:	4688      	mov	r8, r1
   12162:	4615      	mov	r5, r2
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   12164:	f7f4 ff82 	bl	706c <log_msg_chunk_alloc>
	if (msg != NULL) {
   12168:	4604      	mov	r4, r0
   1216a:	b330      	cbz	r0, 121ba <log_msg_create_n+0x60>
		msg->hdr.ref_cnt = 1;
   1216c:	2301      	movs	r3, #1
		msg->hdr.params.raw = 0U;
   1216e:	2600      	movs	r6, #0
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   12170:	2d03      	cmp	r5, #3
		msg->hdr.ref_cnt = 1;
   12172:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   12174:	8106      	strh	r6, [r0, #8]
   12176:	d909      	bls.n	1218c <log_msg_create_n+0x32>
	msg->hdr.params.generic.ext = 1;
   12178:	2202      	movs	r2, #2
   1217a:	8102      	strh	r2, [r0, #8]
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
   1217c:	f1a5 0902 	sub.w	r9, r5, #2
	next = &msg->payload.ext.next;
   12180:	f100 0b14 	add.w	fp, r0, #20
	*next = NULL;
   12184:	6146      	str	r6, [r0, #20]
	while (n > 0) {
   12186:	f1b9 0f00 	cmp.w	r9, #0
   1218a:	dc0e      	bgt.n	121aa <log_msg_create_n+0x50>
		msg->hdr.params.std.nargs = nargs;
   1218c:	7a63      	ldrb	r3, [r4, #9]
		msg->str = str;
   1218e:	f8c4 a010 	str.w	sl, [r4, #16]
		msg->hdr.params.std.nargs = nargs;
   12192:	f365 1307 	bfi	r3, r5, #4, #4
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   12196:	2d03      	cmp	r5, #3
		msg->hdr.params.std.nargs = nargs;
   12198:	7263      	strb	r3, [r4, #9]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   1219a:	d818      	bhi.n	121ce <log_msg_create_n+0x74>
   1219c:	00aa      	lsls	r2, r5, #2
   1219e:	4641      	mov	r1, r8
   121a0:	f104 0014 	add.w	r0, r4, #20
   121a4:	f7ef ffe6 	bl	2174 <memcpy>
   121a8:	e007      	b.n	121ba <log_msg_create_n+0x60>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
   121aa:	f7f4 ff5f 	bl	706c <log_msg_chunk_alloc>
		if (cont == NULL) {
   121ae:	4607      	mov	r7, r0
   121b0:	b930      	cbnz	r0, 121c0 <log_msg_create_n+0x66>
			msg_free(msg);
   121b2:	4620      	mov	r0, r4
   121b4:	f7f4 ff6c 	bl	7090 <msg_free>
			return NULL;
   121b8:	463c      	mov	r4, r7
}
   121ba:	4620      	mov	r0, r4
   121bc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*next = cont;
   121c0:	f8cb 0000 	str.w	r0, [fp]
		cont->next = NULL;
   121c4:	f1a9 0907 	sub.w	r9, r9, #7
   121c8:	6006      	str	r6, [r0, #0]
		next = &cont->next;
   121ca:	4683      	mov	fp, r0
		n -= ARGS_CONT_MSG;
   121cc:	e7db      	b.n	12186 <log_msg_create_n+0x2c>
   121ce:	f8d8 3000 	ldr.w	r3, [r8]
   121d2:	61a3      	str	r3, [r4, #24]
   121d4:	f8d8 3004 	ldr.w	r3, [r8, #4]
	struct log_msg_cont *cont = msg->payload.ext.next;
   121d8:	6967      	ldr	r7, [r4, #20]
   121da:	61e3      	str	r3, [r4, #28]
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
   121dc:	3d02      	subs	r5, #2
		args += LOG_MSG_NARGS_HEAD_CHUNK;
   121de:	f108 0808 	add.w	r8, r8, #8
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
   121e2:	2d07      	cmp	r5, #7
   121e4:	462e      	mov	r6, r5
   121e6:	bf28      	it	cs
   121e8:	2607      	movcs	r6, #7
		(void)memcpy(cont->payload.args, args,
   121ea:	ea4f 0986 	mov.w	r9, r6, lsl #2
   121ee:	4641      	mov	r1, r8
   121f0:	1d38      	adds	r0, r7, #4
   121f2:	464a      	mov	r2, r9
   121f4:	f7ef ffbe 	bl	2174 <memcpy>
	while (nargs != 0U) {
   121f8:	1bad      	subs	r5, r5, r6
		args += cpy_args;
   121fa:	44c8      	add	r8, r9
		cont = cont->next;
   121fc:	683f      	ldr	r7, [r7, #0]
	while (nargs != 0U) {
   121fe:	d1f0      	bne.n	121e2 <log_msg_create_n+0x88>
   12200:	e7db      	b.n	121ba <log_msg_create_n+0x60>

00012202 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
   12202:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   12204:	2400      	movs	r4, #0
   12206:	9400      	str	r4, [sp, #0]
   12208:	f7ff ff13 	bl	12032 <log_msg_hexdump_data_op>
}
   1220c:	b002      	add	sp, #8
   1220e:	bd10      	pop	{r4, pc}

00012210 <buffer_write>:
{
   12210:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12212:	4606      	mov	r6, r0
   12214:	460d      	mov	r5, r1
   12216:	4614      	mov	r4, r2
   12218:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   1221a:	4621      	mov	r1, r4
   1221c:	4628      	mov	r0, r5
   1221e:	463a      	mov	r2, r7
   12220:	47b0      	blx	r6
	} while (len != 0);
   12222:	1a24      	subs	r4, r4, r0
		buf += processed;
   12224:	4405      	add	r5, r0
	} while (len != 0);
   12226:	d1f8      	bne.n	1221a <buffer_write+0xa>
}
   12228:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001222a <std_print>:
{
   1222a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1222e:	b08e      	sub	sp, #56	; 0x38
   12230:	af0e      	add	r7, sp, #56	; 0x38
   12232:	4681      	mov	r9, r0
   12234:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
   12236:	f7ff ff8e 	bl	12156 <log_msg_str_get>
   1223a:	4606      	mov	r6, r0
	u32_t nargs = log_msg_nargs_get(msg);
   1223c:	4648      	mov	r0, r9
   1223e:	f7ff ff57 	bl	120f0 <log_msg_nargs_get>
	u32_t *args = alloca(sizeof(u32_t)*nargs);
   12242:	0083      	lsls	r3, r0, #2
   12244:	3307      	adds	r3, #7
   12246:	f023 0307 	bic.w	r3, r3, #7
   1224a:	ebad 0d03 	sub.w	sp, sp, r3
	u32_t nargs = log_msg_nargs_get(msg);
   1224e:	4682      	mov	sl, r0
	u32_t *args = alloca(sizeof(u32_t)*nargs);
   12250:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
   12252:	f04f 0800 	mov.w	r8, #0
   12256:	45d0      	cmp	r8, sl
   12258:	d116      	bne.n	12288 <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
   1225a:	4648      	mov	r0, r9
   1225c:	f7ff ff48 	bl	120f0 <log_msg_nargs_get>
   12260:	280f      	cmp	r0, #15
   12262:	d81e      	bhi.n	122a2 <std_print+0x78>
   12264:	e8df f010 	tbh	[pc, r0, lsl #1]
   12268:	00200019 	.word	0x00200019
   1226c:	002d0026 	.word	0x002d0026
   12270:	00410036 	.word	0x00410036
   12274:	005d004e 	.word	0x005d004e
   12278:	0081006e 	.word	0x0081006e
   1227c:	00ad0096 	.word	0x00ad0096
   12280:	00e100c6 	.word	0x00e100c6
   12284:	011d00fe 	.word	0x011d00fe
		args[i] = log_msg_arg_get(msg, i);
   12288:	4641      	mov	r1, r8
   1228a:	4648      	mov	r0, r9
   1228c:	f7ff ff33 	bl	120f6 <log_msg_arg_get>
   12290:	f844 0028 	str.w	r0, [r4, r8, lsl #2]
	for (i = 0; i < nargs; i++) {
   12294:	f108 0801 	add.w	r8, r8, #1
   12298:	e7dd      	b.n	12256 <std_print+0x2c>
		print_formatted(log_output, str);
   1229a:	4631      	mov	r1, r6
   1229c:	4628      	mov	r0, r5
   1229e:	f7f4 ff29 	bl	70f4 <print_formatted>
}
   122a2:	46bd      	mov	sp, r7
   122a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, str, args[0]);
   122a8:	6822      	ldr	r2, [r4, #0]
   122aa:	4631      	mov	r1, r6
   122ac:	4628      	mov	r0, r5
   122ae:	f7f4 ff21 	bl	70f4 <print_formatted>
		break;
   122b2:	e7f6      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1]);
   122b4:	e9d4 2300 	ldrd	r2, r3, [r4]
   122b8:	4631      	mov	r1, r6
   122ba:	4628      	mov	r0, r5
   122bc:	f7f4 ff1a 	bl	70f4 <print_formatted>
		break;
   122c0:	e7ef      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2]);
   122c2:	68a3      	ldr	r3, [r4, #8]
   122c4:	9300      	str	r3, [sp, #0]
   122c6:	e9d4 2300 	ldrd	r2, r3, [r4]
   122ca:	4631      	mov	r1, r6
   122cc:	4628      	mov	r0, r5
   122ce:	f7f4 ff11 	bl	70f4 <print_formatted>
		break;
   122d2:	e7e6      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   122d4:	68e3      	ldr	r3, [r4, #12]
   122d6:	9301      	str	r3, [sp, #4]
   122d8:	68a3      	ldr	r3, [r4, #8]
   122da:	9300      	str	r3, [sp, #0]
   122dc:	e9d4 2300 	ldrd	r2, r3, [r4]
   122e0:	4631      	mov	r1, r6
   122e2:	4628      	mov	r0, r5
   122e4:	f7f4 ff06 	bl	70f4 <print_formatted>
		break;
   122e8:	e7db      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   122ea:	6923      	ldr	r3, [r4, #16]
   122ec:	9302      	str	r3, [sp, #8]
   122ee:	68e3      	ldr	r3, [r4, #12]
   122f0:	9301      	str	r3, [sp, #4]
   122f2:	68a3      	ldr	r3, [r4, #8]
   122f4:	9300      	str	r3, [sp, #0]
   122f6:	e9d4 2300 	ldrd	r2, r3, [r4]
   122fa:	4631      	mov	r1, r6
   122fc:	4628      	mov	r0, r5
   122fe:	f7f4 fef9 	bl	70f4 <print_formatted>
		break;
   12302:	e7ce      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   12304:	6963      	ldr	r3, [r4, #20]
   12306:	9303      	str	r3, [sp, #12]
   12308:	6923      	ldr	r3, [r4, #16]
   1230a:	9302      	str	r3, [sp, #8]
   1230c:	68e3      	ldr	r3, [r4, #12]
   1230e:	9301      	str	r3, [sp, #4]
   12310:	68a3      	ldr	r3, [r4, #8]
   12312:	9300      	str	r3, [sp, #0]
   12314:	e9d4 2300 	ldrd	r2, r3, [r4]
   12318:	4631      	mov	r1, r6
   1231a:	4628      	mov	r0, r5
   1231c:	f7f4 feea 	bl	70f4 <print_formatted>
		break;
   12320:	e7bf      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   12322:	69a3      	ldr	r3, [r4, #24]
   12324:	9304      	str	r3, [sp, #16]
   12326:	6963      	ldr	r3, [r4, #20]
   12328:	9303      	str	r3, [sp, #12]
   1232a:	6923      	ldr	r3, [r4, #16]
   1232c:	9302      	str	r3, [sp, #8]
   1232e:	68e3      	ldr	r3, [r4, #12]
   12330:	9301      	str	r3, [sp, #4]
   12332:	68a3      	ldr	r3, [r4, #8]
   12334:	9300      	str	r3, [sp, #0]
   12336:	e9d4 2300 	ldrd	r2, r3, [r4]
   1233a:	4631      	mov	r1, r6
   1233c:	4628      	mov	r0, r5
   1233e:	f7f4 fed9 	bl	70f4 <print_formatted>
		break;
   12342:	e7ae      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   12344:	69e3      	ldr	r3, [r4, #28]
   12346:	9305      	str	r3, [sp, #20]
   12348:	69a3      	ldr	r3, [r4, #24]
   1234a:	9304      	str	r3, [sp, #16]
   1234c:	6963      	ldr	r3, [r4, #20]
   1234e:	9303      	str	r3, [sp, #12]
   12350:	6923      	ldr	r3, [r4, #16]
   12352:	9302      	str	r3, [sp, #8]
   12354:	68e3      	ldr	r3, [r4, #12]
   12356:	9301      	str	r3, [sp, #4]
   12358:	68a3      	ldr	r3, [r4, #8]
   1235a:	9300      	str	r3, [sp, #0]
   1235c:	e9d4 2300 	ldrd	r2, r3, [r4]
   12360:	4631      	mov	r1, r6
   12362:	4628      	mov	r0, r5
   12364:	f7f4 fec6 	bl	70f4 <print_formatted>
		break;
   12368:	e79b      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   1236a:	6a23      	ldr	r3, [r4, #32]
   1236c:	9306      	str	r3, [sp, #24]
   1236e:	69e3      	ldr	r3, [r4, #28]
   12370:	9305      	str	r3, [sp, #20]
   12372:	69a3      	ldr	r3, [r4, #24]
   12374:	9304      	str	r3, [sp, #16]
   12376:	6963      	ldr	r3, [r4, #20]
   12378:	9303      	str	r3, [sp, #12]
   1237a:	6923      	ldr	r3, [r4, #16]
   1237c:	9302      	str	r3, [sp, #8]
   1237e:	68e3      	ldr	r3, [r4, #12]
   12380:	9301      	str	r3, [sp, #4]
   12382:	68a3      	ldr	r3, [r4, #8]
   12384:	9300      	str	r3, [sp, #0]
   12386:	e9d4 2300 	ldrd	r2, r3, [r4]
   1238a:	4631      	mov	r1, r6
   1238c:	4628      	mov	r0, r5
   1238e:	f7f4 feb1 	bl	70f4 <print_formatted>
		break;
   12392:	e786      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   12394:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12396:	9307      	str	r3, [sp, #28]
   12398:	6a23      	ldr	r3, [r4, #32]
   1239a:	9306      	str	r3, [sp, #24]
   1239c:	69e3      	ldr	r3, [r4, #28]
   1239e:	9305      	str	r3, [sp, #20]
   123a0:	69a3      	ldr	r3, [r4, #24]
   123a2:	9304      	str	r3, [sp, #16]
   123a4:	6963      	ldr	r3, [r4, #20]
   123a6:	9303      	str	r3, [sp, #12]
   123a8:	6923      	ldr	r3, [r4, #16]
   123aa:	9302      	str	r3, [sp, #8]
   123ac:	68e3      	ldr	r3, [r4, #12]
   123ae:	9301      	str	r3, [sp, #4]
   123b0:	68a3      	ldr	r3, [r4, #8]
   123b2:	9300      	str	r3, [sp, #0]
   123b4:	e9d4 2300 	ldrd	r2, r3, [r4]
   123b8:	4631      	mov	r1, r6
   123ba:	4628      	mov	r0, r5
   123bc:	f7f4 fe9a 	bl	70f4 <print_formatted>
		break;
   123c0:	e76f      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   123c2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   123c4:	9308      	str	r3, [sp, #32]
   123c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   123c8:	9307      	str	r3, [sp, #28]
   123ca:	6a23      	ldr	r3, [r4, #32]
   123cc:	9306      	str	r3, [sp, #24]
   123ce:	69e3      	ldr	r3, [r4, #28]
   123d0:	9305      	str	r3, [sp, #20]
   123d2:	69a3      	ldr	r3, [r4, #24]
   123d4:	9304      	str	r3, [sp, #16]
   123d6:	6963      	ldr	r3, [r4, #20]
   123d8:	9303      	str	r3, [sp, #12]
   123da:	6923      	ldr	r3, [r4, #16]
   123dc:	9302      	str	r3, [sp, #8]
   123de:	68e3      	ldr	r3, [r4, #12]
   123e0:	9301      	str	r3, [sp, #4]
   123e2:	68a3      	ldr	r3, [r4, #8]
   123e4:	9300      	str	r3, [sp, #0]
   123e6:	e9d4 2300 	ldrd	r2, r3, [r4]
   123ea:	4631      	mov	r1, r6
   123ec:	4628      	mov	r0, r5
   123ee:	f7f4 fe81 	bl	70f4 <print_formatted>
		break;
   123f2:	e756      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   123f4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   123f6:	9309      	str	r3, [sp, #36]	; 0x24
   123f8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   123fa:	9308      	str	r3, [sp, #32]
   123fc:	6a63      	ldr	r3, [r4, #36]	; 0x24
   123fe:	9307      	str	r3, [sp, #28]
   12400:	6a23      	ldr	r3, [r4, #32]
   12402:	9306      	str	r3, [sp, #24]
   12404:	69e3      	ldr	r3, [r4, #28]
   12406:	9305      	str	r3, [sp, #20]
   12408:	69a3      	ldr	r3, [r4, #24]
   1240a:	9304      	str	r3, [sp, #16]
   1240c:	6963      	ldr	r3, [r4, #20]
   1240e:	9303      	str	r3, [sp, #12]
   12410:	6923      	ldr	r3, [r4, #16]
   12412:	9302      	str	r3, [sp, #8]
   12414:	68e3      	ldr	r3, [r4, #12]
   12416:	9301      	str	r3, [sp, #4]
   12418:	68a3      	ldr	r3, [r4, #8]
   1241a:	9300      	str	r3, [sp, #0]
   1241c:	e9d4 2300 	ldrd	r2, r3, [r4]
   12420:	4631      	mov	r1, r6
   12422:	4628      	mov	r0, r5
   12424:	f7f4 fe66 	bl	70f4 <print_formatted>
		break;
   12428:	e73b      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   1242a:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1242c:	930a      	str	r3, [sp, #40]	; 0x28
   1242e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   12430:	9309      	str	r3, [sp, #36]	; 0x24
   12432:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   12434:	9308      	str	r3, [sp, #32]
   12436:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12438:	9307      	str	r3, [sp, #28]
   1243a:	6a23      	ldr	r3, [r4, #32]
   1243c:	9306      	str	r3, [sp, #24]
   1243e:	69e3      	ldr	r3, [r4, #28]
   12440:	9305      	str	r3, [sp, #20]
   12442:	69a3      	ldr	r3, [r4, #24]
   12444:	9304      	str	r3, [sp, #16]
   12446:	6963      	ldr	r3, [r4, #20]
   12448:	9303      	str	r3, [sp, #12]
   1244a:	6923      	ldr	r3, [r4, #16]
   1244c:	9302      	str	r3, [sp, #8]
   1244e:	68e3      	ldr	r3, [r4, #12]
   12450:	9301      	str	r3, [sp, #4]
   12452:	68a3      	ldr	r3, [r4, #8]
   12454:	9300      	str	r3, [sp, #0]
   12456:	e9d4 2300 	ldrd	r2, r3, [r4]
   1245a:	4631      	mov	r1, r6
   1245c:	4628      	mov	r0, r5
   1245e:	f7f4 fe49 	bl	70f4 <print_formatted>
		break;
   12462:	e71e      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   12464:	6b63      	ldr	r3, [r4, #52]	; 0x34
   12466:	930b      	str	r3, [sp, #44]	; 0x2c
   12468:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1246a:	930a      	str	r3, [sp, #40]	; 0x28
   1246c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   1246e:	9309      	str	r3, [sp, #36]	; 0x24
   12470:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   12472:	9308      	str	r3, [sp, #32]
   12474:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12476:	9307      	str	r3, [sp, #28]
   12478:	6a23      	ldr	r3, [r4, #32]
   1247a:	9306      	str	r3, [sp, #24]
   1247c:	69e3      	ldr	r3, [r4, #28]
   1247e:	9305      	str	r3, [sp, #20]
   12480:	69a3      	ldr	r3, [r4, #24]
   12482:	9304      	str	r3, [sp, #16]
   12484:	6963      	ldr	r3, [r4, #20]
   12486:	9303      	str	r3, [sp, #12]
   12488:	6923      	ldr	r3, [r4, #16]
   1248a:	9302      	str	r3, [sp, #8]
   1248c:	68e3      	ldr	r3, [r4, #12]
   1248e:	9301      	str	r3, [sp, #4]
   12490:	68a3      	ldr	r3, [r4, #8]
   12492:	9300      	str	r3, [sp, #0]
   12494:	e9d4 2300 	ldrd	r2, r3, [r4]
   12498:	4631      	mov	r1, r6
   1249a:	4628      	mov	r0, r5
   1249c:	f7f4 fe2a 	bl	70f4 <print_formatted>
		break;
   124a0:	e6ff      	b.n	122a2 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   124a2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   124a4:	930c      	str	r3, [sp, #48]	; 0x30
   124a6:	6b63      	ldr	r3, [r4, #52]	; 0x34
   124a8:	930b      	str	r3, [sp, #44]	; 0x2c
   124aa:	6b23      	ldr	r3, [r4, #48]	; 0x30
   124ac:	930a      	str	r3, [sp, #40]	; 0x28
   124ae:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   124b0:	9309      	str	r3, [sp, #36]	; 0x24
   124b2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   124b4:	9308      	str	r3, [sp, #32]
   124b6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   124b8:	9307      	str	r3, [sp, #28]
   124ba:	6a23      	ldr	r3, [r4, #32]
   124bc:	9306      	str	r3, [sp, #24]
   124be:	69e3      	ldr	r3, [r4, #28]
   124c0:	9305      	str	r3, [sp, #20]
   124c2:	69a3      	ldr	r3, [r4, #24]
   124c4:	9304      	str	r3, [sp, #16]
   124c6:	6963      	ldr	r3, [r4, #20]
   124c8:	9303      	str	r3, [sp, #12]
   124ca:	6923      	ldr	r3, [r4, #16]
   124cc:	9302      	str	r3, [sp, #8]
   124ce:	68e3      	ldr	r3, [r4, #12]
   124d0:	9301      	str	r3, [sp, #4]
   124d2:	68a3      	ldr	r3, [r4, #8]
   124d4:	9300      	str	r3, [sp, #0]
   124d6:	e9d4 2300 	ldrd	r2, r3, [r4]
   124da:	4631      	mov	r1, r6
   124dc:	4628      	mov	r0, r5
   124de:	f7f4 fe09 	bl	70f4 <print_formatted>
}
   124e2:	e6de      	b.n	122a2 <std_print+0x78>

000124e4 <log_output_flush>:
		     log_output->control_block->offset,
   124e4:	6842      	ldr	r2, [r0, #4]
	buffer_write(log_output->func, log_output->buf,
   124e6:	6881      	ldr	r1, [r0, #8]
{
   124e8:	b510      	push	{r4, lr}
   124ea:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
   124ec:	e9d2 2300 	ldrd	r2, r3, [r2]
   124f0:	6800      	ldr	r0, [r0, #0]
   124f2:	f7ff fe8d 	bl	12210 <buffer_write>
	log_output->control_block->offset = 0;
   124f6:	6863      	ldr	r3, [r4, #4]
   124f8:	2200      	movs	r2, #0
   124fa:	601a      	str	r2, [r3, #0]
}
   124fc:	bd10      	pop	{r4, pc}

000124fe <out_func>:
{
   124fe:	b508      	push	{r3, lr}
	out_ctx->buf[out_ctx->control_block->offset] = (u8_t)c;
   12500:	e9d1 3201 	ldrd	r3, r2, [r1, #4]
   12504:	681b      	ldr	r3, [r3, #0]
   12506:	54d0      	strb	r0, [r2, r3]
	out_ctx->control_block->offset++;
   12508:	684a      	ldr	r2, [r1, #4]
   1250a:	6813      	ldr	r3, [r2, #0]
   1250c:	3301      	adds	r3, #1
   1250e:	6013      	str	r3, [r2, #0]
	if (out_ctx->control_block->offset == out_ctx->size) {
   12510:	68ca      	ldr	r2, [r1, #12]
   12512:	4293      	cmp	r3, r2
   12514:	d102      	bne.n	1251c <out_func+0x1e>
		log_output_flush(out_ctx);
   12516:	4608      	mov	r0, r1
   12518:	f7ff ffe4 	bl	124e4 <log_output_flush>
}
   1251c:	2000      	movs	r0, #0
   1251e:	bd08      	pop	{r3, pc}

00012520 <char_out>:
{
   12520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12522:	460d      	mov	r5, r1
   12524:	4616      	mov	r6, r2
	for (size_t i = 0; i < length; i++) {
   12526:	4604      	mov	r4, r0
   12528:	1847      	adds	r7, r0, r1
   1252a:	42bc      	cmp	r4, r7
   1252c:	d101      	bne.n	12532 <char_out+0x12>
}
   1252e:	4628      	mov	r0, r5
   12530:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	api->poll_out(dev, out_char);
   12532:	6873      	ldr	r3, [r6, #4]
   12534:	f814 1b01 	ldrb.w	r1, [r4], #1
   12538:	685b      	ldr	r3, [r3, #4]
   1253a:	4630      	mov	r0, r6
   1253c:	4798      	blx	r3
   1253e:	e7f4      	b.n	1252a <char_out+0xa>

00012540 <z_impl_uart_irq_tx_disable>:
	if (api->irq_tx_disable) {
   12540:	6843      	ldr	r3, [r0, #4]
   12542:	6a1b      	ldr	r3, [r3, #32]
   12544:	b103      	cbz	r3, 12548 <z_impl_uart_irq_tx_disable+0x8>
		api->irq_tx_disable(dev);
   12546:	4718      	bx	r3
}
   12548:	4770      	bx	lr

0001254a <tty_putchar>:
{
   1254a:	b538      	push	{r3, r4, r5, lr}
   1254c:	4604      	mov	r4, r0
   1254e:	460d      	mov	r5, r1
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
   12550:	302c      	adds	r0, #44	; 0x2c
   12552:	6a41      	ldr	r1, [r0, #36]	; 0x24
   12554:	f7fd f884 	bl	f660 <z_impl_k_sem_take>
	if (res < 0) {
   12558:	2800      	cmp	r0, #0
   1255a:	db18      	blt.n	1258e <tty_putchar+0x44>
	__asm__ volatile(
   1255c:	f04f 0320 	mov.w	r3, #32
   12560:	f3ef 8211 	mrs	r2, BASEPRI
   12564:	f383 8811 	msr	BASEPRI, r3
   12568:	f3bf 8f6f 	isb	sy
	tx_next = tty->tx_put + 1;
   1256c:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
	if (tx_next >= tty->tx_ringbuf_sz) {
   12570:	6ca0      	ldr	r0, [r4, #72]	; 0x48
	tx_next = tty->tx_put + 1;
   12572:	1c4b      	adds	r3, r1, #1
		tx_next = 0;
   12574:	4298      	cmp	r0, r3
   12576:	bf98      	it	ls
   12578:	2300      	movls	r3, #0
	if (tx_next == tty->tx_get) {
   1257a:	f8b4 004c 	ldrh.w	r0, [r4, #76]	; 0x4c
   1257e:	4298      	cmp	r0, r3
   12580:	d106      	bne.n	12590 <tty_putchar+0x46>
	__asm__ volatile(
   12582:	f382 8811 	msr	BASEPRI, r2
   12586:	f3bf 8f6f 	isb	sy
		return -ENOSPC;
   1258a:	f06f 001b 	mvn.w	r0, #27
}
   1258e:	bd38      	pop	{r3, r4, r5, pc}
	tty->tx_ringbuf[tty->tx_put] = c;
   12590:	6c60      	ldr	r0, [r4, #68]	; 0x44
   12592:	5445      	strb	r5, [r0, r1]
	tty->tx_put = tx_next;
   12594:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
   12598:	f382 8811 	msr	BASEPRI, r2
   1259c:	f3bf 8f6f 	isb	sy
	uart_irq_tx_enable(tty->uart_dev);
   125a0:	6820      	ldr	r0, [r4, #0]
	if (api->irq_tx_enable) {
   125a2:	6843      	ldr	r3, [r0, #4]
   125a4:	69db      	ldr	r3, [r3, #28]
   125a6:	b113      	cbz	r3, 125ae <tty_putchar+0x64>
		api->irq_tx_enable(dev);
   125a8:	4798      	blx	r3
	return 0;
   125aa:	2000      	movs	r0, #0
   125ac:	e7ef      	b.n	1258e <tty_putchar+0x44>
   125ae:	4618      	mov	r0, r3
   125b0:	e7ed      	b.n	1258e <tty_putchar+0x44>

000125b2 <tty_uart_isr>:
{
   125b2:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct device *dev = tty->uart_dev;
   125b4:	6805      	ldr	r5, [r0, #0]
	if (api->irq_update) {
   125b6:	686b      	ldr	r3, [r5, #4]
   125b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
{
   125ba:	4604      	mov	r4, r0
   125bc:	b10b      	cbz	r3, 125c2 <tty_uart_isr+0x10>
		return api->irq_update(dev);
   125be:	4628      	mov	r0, r5
   125c0:	4798      	blx	r3
	if (api->irq_rx_ready) {
   125c2:	686b      	ldr	r3, [r5, #4]
   125c4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   125c6:	b31b      	cbz	r3, 12610 <tty_uart_isr+0x5e>
		return api->irq_rx_ready(dev);
   125c8:	4628      	mov	r0, r5
   125ca:	4798      	blx	r3
	if (uart_irq_rx_ready(dev)) {
   125cc:	b300      	cbz	r0, 12610 <tty_uart_isr+0x5e>
	k_sem_give(&tty->rx_sem);
   125ce:	1d26      	adds	r6, r4, #4
	if (api->fifo_read) {
   125d0:	686b      	ldr	r3, [r5, #4]
   125d2:	699b      	ldr	r3, [r3, #24]
   125d4:	b1e3      	cbz	r3, 12610 <tty_uart_isr+0x5e>
		return api->fifo_read(dev, rx_data, size);
   125d6:	2201      	movs	r2, #1
   125d8:	f10d 0107 	add.w	r1, sp, #7
   125dc:	4628      	mov	r0, r5
   125de:	4798      	blx	r3
			if (uart_fifo_read(dev, &c, 1) == 0) {
   125e0:	b1b0      	cbz	r0, 12610 <tty_uart_isr+0x5e>
	int rx_next = tty->rx_put + 1;
   125e2:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
	if (rx_next >= tty->rx_ringbuf_sz) {
   125e4:	6a21      	ldr	r1, [r4, #32]
	int rx_next = tty->rx_put + 1;
   125e6:	1c53      	adds	r3, r2, #1
		rx_next = 0;
   125e8:	4299      	cmp	r1, r3
   125ea:	bf98      	it	ls
   125ec:	2300      	movls	r3, #0
	if (rx_next == tty->rx_get) {
   125ee:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
   125f0:	4299      	cmp	r1, r3
   125f2:	d104      	bne.n	125fe <tty_uart_isr+0x4c>
		tty_putchar(tty, '~');
   125f4:	217e      	movs	r1, #126	; 0x7e
   125f6:	4620      	mov	r0, r4
   125f8:	f7ff ffa7 	bl	1254a <tty_putchar>
		return 1;
   125fc:	e7e8      	b.n	125d0 <tty_uart_isr+0x1e>
	tty->rx_ringbuf[tty->rx_put] = c;
   125fe:	69e1      	ldr	r1, [r4, #28]
			tty_irq_input_hook(tty, c);
   12600:	f89d 0007 	ldrb.w	r0, [sp, #7]
	tty->rx_ringbuf[tty->rx_put] = c;
   12604:	5488      	strb	r0, [r1, r2]
	tty->rx_put = rx_next;
   12606:	84e3      	strh	r3, [r4, #38]	; 0x26
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
   12608:	4630      	mov	r0, r6
   1260a:	f7fc fffd 	bl	f608 <z_impl_k_sem_give>
	return 1;
   1260e:	e7df      	b.n	125d0 <tty_uart_isr+0x1e>
	if (api->irq_tx_ready) {
   12610:	686b      	ldr	r3, [r5, #4]
   12612:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   12614:	b15b      	cbz	r3, 1262e <tty_uart_isr+0x7c>
		return api->irq_tx_ready(dev);
   12616:	4628      	mov	r0, r5
   12618:	4798      	blx	r3
	if (uart_irq_tx_ready(dev)) {
   1261a:	b140      	cbz	r0, 1262e <tty_uart_isr+0x7c>
		if (tty->tx_get == tty->tx_put) {
   1261c:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
   12620:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
   12624:	429a      	cmp	r2, r3
   12626:	d104      	bne.n	12632 <tty_uart_isr+0x80>

K_SYSCALL_DECLARE2(K_SYSCALL_UART_CONFIG_GET, uart_config_get, int, struct device *, dev, struct uart_config *, cfg)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_UART_IRQ_TX_ENABLE, uart_irq_tx_enable, struct device *, dev)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_UART_IRQ_TX_DISABLE, uart_irq_tx_disable, struct device *, dev)
   12628:	4628      	mov	r0, r5
   1262a:	f7ff ff89 	bl	12540 <z_impl_uart_irq_tx_disable>
}
   1262e:	b002      	add	sp, #8
   12630:	bd70      	pop	{r4, r5, r6, pc}
			uart_fifo_fill(dev, &tty->tx_ringbuf[tty->tx_get++], 1);
   12632:	1c5a      	adds	r2, r3, #1
   12634:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
	if (api->fifo_fill) {
   12638:	686a      	ldr	r2, [r5, #4]
   1263a:	6c61      	ldr	r1, [r4, #68]	; 0x44
   1263c:	6956      	ldr	r6, [r2, #20]
   1263e:	b11e      	cbz	r6, 12648 <tty_uart_isr+0x96>
		return api->fifo_fill(dev, tx_data, size);
   12640:	2201      	movs	r2, #1
   12642:	4419      	add	r1, r3
   12644:	4628      	mov	r0, r5
   12646:	47b0      	blx	r6
			if (tty->tx_get >= tty->tx_ringbuf_sz) {
   12648:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   1264a:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
   1264e:	429a      	cmp	r2, r3
				tty->tx_get = 0U;
   12650:	bf24      	itt	cs
   12652:	2300      	movcs	r3, #0
   12654:	f8a4 304c 	strhcs.w	r3, [r4, #76]	; 0x4c
   12658:	f104 002c 	add.w	r0, r4, #44	; 0x2c
   1265c:	f7fc ffd4 	bl	f608 <z_impl_k_sem_give>
}
   12660:	e7e5      	b.n	1262e <tty_uart_isr+0x7c>

00012662 <tty_write>:
	if (tty->tx_ringbuf_sz == 0U) {
   12662:	6c83      	ldr	r3, [r0, #72]	; 0x48
{
   12664:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12668:	4680      	mov	r8, r0
   1266a:	460e      	mov	r6, r1
   1266c:	4617      	mov	r7, r2
	if (tty->tx_ringbuf_sz == 0U) {
   1266e:	b9fb      	cbnz	r3, 126b0 <tty_write+0x4e>
   12670:	188c      	adds	r4, r1, r2
		while (size--) {
   12672:	42a6      	cmp	r6, r4
   12674:	d103      	bne.n	1267e <tty_write+0x1c>
		return out_size;
   12676:	463d      	mov	r5, r7
}
   12678:	4628      	mov	r0, r5
   1267a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			uart_poll_out(tty->uart_dev, *p++);
   1267e:	f8d8 0000 	ldr.w	r0, [r8]
	api->poll_out(dev, out_char);
   12682:	f816 1b01 	ldrb.w	r1, [r6], #1
   12686:	6843      	ldr	r3, [r0, #4]
   12688:	685b      	ldr	r3, [r3, #4]
   1268a:	4798      	blx	r3
   1268c:	e7f1      	b.n	12672 <tty_write+0x10>
		res = tty_putchar(tty, *p++);
   1268e:	5d31      	ldrb	r1, [r6, r4]
   12690:	4640      	mov	r0, r8
   12692:	f7ff ff5a 	bl	1254a <tty_putchar>
		if (res < 0) {
   12696:	1e05      	subs	r5, r0, #0
   12698:	da05      	bge.n	126a6 <tty_write+0x44>
			if (out_size == 0) {
   1269a:	b93c      	cbnz	r4, 126ac <tty_write+0x4a>
				errno = -res;
   1269c:	f000 fceb 	bl	13076 <__errno>
   126a0:	426b      	negs	r3, r5
   126a2:	6003      	str	r3, [r0, #0]
				return res;
   126a4:	e7e8      	b.n	12678 <tty_write+0x16>
		out_size++;
   126a6:	3401      	adds	r4, #1
	while (size--) {
   126a8:	42bc      	cmp	r4, r7
   126aa:	d1f0      	bne.n	1268e <tty_write+0x2c>
	return out_size;
   126ac:	4625      	mov	r5, r4
   126ae:	e7e3      	b.n	12678 <tty_write+0x16>
	size_t out_size = 0;
   126b0:	2400      	movs	r4, #0
   126b2:	e7f9      	b.n	126a8 <tty_write+0x46>

000126b4 <tty_read>:
{
   126b4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	if (tty->rx_ringbuf_sz == 0U) {
   126b8:	6a04      	ldr	r4, [r0, #32]
{
   126ba:	4605      	mov	r5, r0
   126bc:	460e      	mov	r6, r1
   126be:	4690      	mov	r8, r2
	if (tty->rx_ringbuf_sz == 0U) {
   126c0:	2c00      	cmp	r4, #0
   126c2:	d155      	bne.n	12770 <tty_read+0xbc>
	u32_t timeout = tty->rx_timeout;
   126c4:	6a87      	ldr	r7, [r0, #40]	; 0x28
	while (size) {
   126c6:	f1b8 0f00 	cmp.w	r8, #0
   126ca:	d010      	beq.n	126ee <tty_read+0x3a>
		res = uart_poll_in(tty->uart_dev, &c);
   126cc:	6828      	ldr	r0, [r5, #0]
	return api->poll_in(dev, p_char);
   126ce:	6843      	ldr	r3, [r0, #4]
   126d0:	f10d 0107 	add.w	r1, sp, #7
   126d4:	681b      	ldr	r3, [r3, #0]
   126d6:	4798      	blx	r3
		if (res <= -2) {
   126d8:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   126dc:	4681      	mov	r9, r0
   126de:	da0a      	bge.n	126f6 <tty_read+0x42>
			if (out_size == 0) {
   126e0:	b92c      	cbnz	r4, 126ee <tty_read+0x3a>
				errno = res;
   126e2:	f000 fcc8 	bl	13076 <__errno>
				return -1;
   126e6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
				errno = res;
   126ea:	f8c0 9000 	str.w	r9, [r0]
}
   126ee:	4620      	mov	r0, r4
   126f0:	b002      	add	sp, #8
   126f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (res == 0) {
   126f6:	b958      	cbnz	r0, 12710 <tty_read+0x5c>
			*p++ = c;
   126f8:	f89d 3007 	ldrb.w	r3, [sp, #7]
   126fc:	f806 3b01 	strb.w	r3, [r6], #1
		if (size == 0 || (timeout != K_FOREVER && timeout-- == 0U)) {
   12700:	f1b8 0801 	subs.w	r8, r8, #1
			out_size++;
   12704:	f104 0401 	add.w	r4, r4, #1
		if (size == 0 || (timeout != K_FOREVER && timeout-- == 0U)) {
   12708:	d0f1      	beq.n	126ee <tty_read+0x3a>
   1270a:	1c7b      	adds	r3, r7, #1
   1270c:	d102      	bne.n	12714 <tty_read+0x60>
   1270e:	e7da      	b.n	126c6 <tty_read+0x12>
   12710:	1c7a      	adds	r2, r7, #1
   12712:	d003      	beq.n	1271c <tty_read+0x68>
   12714:	1e7b      	subs	r3, r7, #1
   12716:	2f00      	cmp	r7, #0
   12718:	d0e9      	beq.n	126ee <tty_read+0x3a>
   1271a:	461f      	mov	r7, r3
		if (res == -1) {
   1271c:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   12720:	d1d1      	bne.n	126c6 <tty_read+0x12>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
   12722:	2001      	movs	r0, #1
   12724:	f7fc fef8 	bl	f518 <z_impl_k_sleep>
   12728:	e7cd      	b.n	126c6 <tty_read+0x12>
K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
   1272a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
   1272c:	4648      	mov	r0, r9
   1272e:	f7fc ff97 	bl	f660 <z_impl_k_sem_take>
	if (res < 0) {
   12732:	1e04      	subs	r4, r0, #0
   12734:	db21      	blt.n	1277a <tty_read+0xc6>
	__asm__ volatile(
   12736:	f04f 0320 	mov.w	r3, #32
   1273a:	f3ef 8011 	mrs	r0, BASEPRI
   1273e:	f383 8811 	msr	BASEPRI, r3
   12742:	f3bf 8f6f 	isb	sy
	c = tty->rx_ringbuf[tty->rx_get++];
   12746:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   12748:	69ea      	ldr	r2, [r5, #28]
   1274a:	1c4b      	adds	r3, r1, #1
   1274c:	b29b      	uxth	r3, r3
   1274e:	84ab      	strh	r3, [r5, #36]	; 0x24
   12750:	5c51      	ldrb	r1, [r2, r1]
	if (tty->rx_get >= tty->rx_ringbuf_sz) {
   12752:	6a2a      	ldr	r2, [r5, #32]
   12754:	4293      	cmp	r3, r2
		tty->rx_get = 0U;
   12756:	bf28      	it	cs
   12758:	f8a5 a024 	strhcs.w	sl, [r5, #36]	; 0x24
	__asm__ volatile(
   1275c:	f380 8811 	msr	BASEPRI, r0
   12760:	f3bf 8f6f 	isb	sy
		*p++ = (u8_t)res;
   12764:	55f1      	strb	r1, [r6, r7]
		out_size++;
   12766:	3701      	adds	r7, #1
	while (size--) {
   12768:	4547      	cmp	r7, r8
   1276a:	d1de      	bne.n	1272a <tty_read+0x76>
	return out_size;
   1276c:	463c      	mov	r4, r7
   1276e:	e7be      	b.n	126ee <tty_read+0x3a>
	size_t out_size = 0;
   12770:	2700      	movs	r7, #0
	res = k_sem_take(&tty->rx_sem, tty->rx_timeout);
   12772:	f100 0904 	add.w	r9, r0, #4
		tty->rx_get = 0U;
   12776:	46ba      	mov	sl, r7
   12778:	e7f6      	b.n	12768 <tty_read+0xb4>
			if (out_size == 0) {
   1277a:	2f00      	cmp	r7, #0
   1277c:	d1f6      	bne.n	1276c <tty_read+0xb8>
				errno = -res;
   1277e:	f000 fc7a 	bl	13076 <__errno>
   12782:	4263      	negs	r3, r4
   12784:	6003      	str	r3, [r0, #0]
				return res;
   12786:	e7b2      	b.n	126ee <tty_read+0x3a>

00012788 <tty_set_rx_buf>:

int tty_set_rx_buf(struct tty_serial *tty, void *buf, size_t size)
{
   12788:	b570      	push	{r4, r5, r6, lr}
   1278a:	4604      	mov	r4, r0
	uart_irq_rx_disable(tty->uart_dev);
   1278c:	6800      	ldr	r0, [r0, #0]
	if (api->irq_rx_disable) {
   1278e:	6843      	ldr	r3, [r0, #4]
   12790:	6adb      	ldr	r3, [r3, #44]	; 0x2c
{
   12792:	460e      	mov	r6, r1
   12794:	4615      	mov	r5, r2
   12796:	b103      	cbz	r3, 1279a <tty_set_rx_buf+0x12>
		api->irq_rx_disable(dev);
   12798:	4798      	blx	r3

	tty->rx_ringbuf = buf;
	tty->rx_ringbuf_sz = size;
   1279a:	e9c4 6507 	strd	r6, r5, [r4, #28]

	if (size > 0) {
   1279e:	b155      	cbz	r5, 127b6 <tty_set_rx_buf+0x2e>
K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)
   127a0:	1d20      	adds	r0, r4, #4
   127a2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   127a6:	2100      	movs	r1, #0
   127a8:	f003 fafa 	bl	15da0 <z_impl_k_sem_init>
		k_sem_init(&tty->rx_sem, 0, UINT_MAX);
		uart_irq_rx_enable(tty->uart_dev);
   127ac:	6820      	ldr	r0, [r4, #0]
	if (api->irq_rx_enable) {
   127ae:	6843      	ldr	r3, [r0, #4]
   127b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   127b2:	b103      	cbz	r3, 127b6 <tty_set_rx_buf+0x2e>
		api->irq_rx_enable(dev);
   127b4:	4798      	blx	r3
	}

	return 0;
}
   127b6:	2000      	movs	r0, #0
   127b8:	bd70      	pop	{r4, r5, r6, pc}

000127ba <tty_set_tx_buf>:

int tty_set_tx_buf(struct tty_serial *tty, void *buf, size_t size)
{
   127ba:	b570      	push	{r4, r5, r6, lr}
   127bc:	4604      	mov	r4, r0
   127be:	6800      	ldr	r0, [r0, #0]
   127c0:	4615      	mov	r5, r2
   127c2:	460e      	mov	r6, r1
   127c4:	f7ff febc 	bl	12540 <z_impl_uart_irq_tx_disable>
   127c8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   127cc:	f104 002c 	add.w	r0, r4, #44	; 0x2c
	uart_irq_tx_disable(tty->uart_dev);

	tty->tx_ringbuf = buf;
	tty->tx_ringbuf_sz = size;
   127d0:	e9c4 6511 	strd	r6, r5, [r4, #68]	; 0x44
   127d4:	18a9      	adds	r1, r5, r2
   127d6:	f003 fae3 	bl	15da0 <z_impl_k_sem_init>
	/* New buffer is initially empty, no need to re-enable interrupts,
	 * it will be done when needed (on first output char).
	 */

	return 0;
}
   127da:	2000      	movs	r0, #0
   127dc:	bd70      	pop	{r4, r5, r6, pc}

000127de <decode_delta>:
{
   127de:	b570      	push	{r4, r5, r6, lr}
   127e0:	f8bd 4010 	ldrh.w	r4, [sp, #16]
   127e4:	9d06      	ldr	r5, [sp, #24]
	if (opt == COAP_OPTION_EXT_13) {
   127e6:	2c0d      	cmp	r4, #13
   127e8:	d111      	bne.n	1280e <decode_delta+0x30>
		*hdr_len = 1U;
   127ea:	2401      	movs	r4, #1
   127ec:	802c      	strh	r4, [r5, #0]
	if (max_len - offset < 1) {
   127ee:	1a5c      	subs	r4, r3, r1
   127f0:	2c00      	cmp	r4, #0
   127f2:	dc02      	bgt.n	127fa <decode_delta+0x1c>
			return -EINVAL;
   127f4:	f06f 0015 	mvn.w	r0, #21
}
   127f8:	bd70      	pop	{r4, r5, r6, pc}
	*value = data[offset++];
   127fa:	1c4d      	adds	r5, r1, #1
   127fc:	b2ad      	uxth	r5, r5
   127fe:	5c44      	ldrb	r4, [r0, r1]
	*pos = offset;
   12800:	8015      	strh	r5, [r2, #0]
		if (ret < 0) {
   12802:	1b58      	subs	r0, r3, r5
   12804:	d4f6      	bmi.n	127f4 <decode_delta+0x16>
		opt = val + COAP_OPTION_EXT_13;
   12806:	340d      	adds	r4, #13
	*opt_ext = opt;
   12808:	9b05      	ldr	r3, [sp, #20]
   1280a:	801c      	strh	r4, [r3, #0]
	return ret;
   1280c:	e7f4      	b.n	127f8 <decode_delta+0x1a>
	} else if (opt == COAP_OPTION_EXT_14) {
   1280e:	2c0e      	cmp	r4, #14
   12810:	d113      	bne.n	1283a <decode_delta+0x5c>
		*hdr_len = 2U;
   12812:	2402      	movs	r4, #2
   12814:	802c      	strh	r4, [r5, #0]
	if (max_len - offset < 2) {
   12816:	1a5c      	subs	r4, r3, r1
   12818:	2c01      	cmp	r4, #1
   1281a:	ddeb      	ble.n	127f4 <decode_delta+0x16>
	*value = data[offset++] << 8;
   1281c:	5c46      	ldrb	r6, [r0, r1]
	*value |= data[offset++];
   1281e:	1c8d      	adds	r5, r1, #2
	*value = data[offset++] << 8;
   12820:	3101      	adds	r1, #1
	*value |= data[offset++];
   12822:	b289      	uxth	r1, r1
   12824:	b2ad      	uxth	r5, r5
   12826:	5c44      	ldrb	r4, [r0, r1]
	*pos = offset;
   12828:	8015      	strh	r5, [r2, #0]
		if (ret < 0) {
   1282a:	1b58      	subs	r0, r3, r5
	*value |= data[offset++];
   1282c:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
		if (ret < 0) {
   12830:	d4e0      	bmi.n	127f4 <decode_delta+0x16>
		opt = val + COAP_OPTION_EXT_269;
   12832:	f204 140d 	addw	r4, r4, #269	; 0x10d
   12836:	b2a4      	uxth	r4, r4
   12838:	e7e6      	b.n	12808 <decode_delta+0x2a>
	} else if (opt == COAP_OPTION_EXT_15) {
   1283a:	2c0f      	cmp	r4, #15
   1283c:	d0da      	beq.n	127f4 <decode_delta+0x16>
	int ret = 0;
   1283e:	2000      	movs	r0, #0
   12840:	e7e2      	b.n	12808 <decode_delta+0x2a>

00012842 <coap_packet_parse>:

int coap_packet_parse(struct coap_packet *cpkt, u8_t *data, u16_t len,
		      struct coap_option *options, u8_t opt_num)
{
   12842:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12846:	b086      	sub	sp, #24
   12848:	4688      	mov	r8, r1
   1284a:	4617      	mov	r7, r2
   1284c:	461d      	mov	r5, r3
   1284e:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
	u16_t delta;
	u8_t num;
	u8_t tkl;
	int ret;

	if (!cpkt || !data) {
   12852:	4604      	mov	r4, r0
   12854:	b920      	cbnz	r0, 12860 <coap_packet_parse+0x1e>
		return -EINVAL;
   12856:	f06f 0015 	mvn.w	r0, #21
	cpkt->opt_len = opt_len;
	cpkt->delta = delta;
	cpkt->offset = offset;

	return 0;
}
   1285a:	b006      	add	sp, #24
   1285c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!cpkt || !data) {
   12860:	2900      	cmp	r1, #0
   12862:	d0f8      	beq.n	12856 <coap_packet_parse+0x14>
	if (len < BASIC_HEADER_SIZE) {
   12864:	2a03      	cmp	r2, #3
   12866:	d9f6      	bls.n	12856 <coap_packet_parse+0x14>
	if (options) {
   12868:	b123      	cbz	r3, 12874 <coap_packet_parse+0x32>
__ssp_bos_icheck3(memset, void *, int)
   1286a:	0132      	lsls	r2, r6, #4
   1286c:	2100      	movs	r1, #0
   1286e:	4618      	mov	r0, r3
   12870:	f7ef fcbb 	bl	21ea <memset>
	cpkt->offset = 0U;
   12874:	2000      	movs	r0, #0
	cpkt->data = data;
   12876:	f8c4 8000 	str.w	r8, [r4]
	cpkt->offset = 0U;
   1287a:	80a0      	strh	r0, [r4, #4]
	cpkt->max_len = len;
   1287c:	80e7      	strh	r7, [r4, #6]
	cpkt->opt_len = 0U;
   1287e:	8160      	strh	r0, [r4, #10]
	cpkt->hdr_len = 0U;
   12880:	7220      	strb	r0, [r4, #8]
	cpkt->delta = 0U;
   12882:	81a0      	strh	r0, [r4, #12]
	tkl = cpkt->data[0] & 0x0f;
   12884:	f898 3000 	ldrb.w	r3, [r8]
   12888:	f003 030f 	and.w	r3, r3, #15
	if (tkl > 8) {
   1288c:	2b08      	cmp	r3, #8
   1288e:	d8e2      	bhi.n	12856 <coap_packet_parse+0x14>
	cpkt->hdr_len = BASIC_HEADER_SIZE + tkl;
   12890:	3304      	adds	r3, #4
   12892:	7223      	strb	r3, [r4, #8]
	if (cpkt->hdr_len > len) {
   12894:	b29b      	uxth	r3, r3
   12896:	42bb      	cmp	r3, r7
   12898:	d8dd      	bhi.n	12856 <coap_packet_parse+0x14>
	cpkt->offset = cpkt->hdr_len;
   1289a:	80a3      	strh	r3, [r4, #4]
	if (cpkt->hdr_len == len) {
   1289c:	d0dd      	beq.n	1285a <coap_packet_parse+0x18>
	offset = cpkt->offset;
   1289e:	f8ad 3014 	strh.w	r3, [sp, #20]
	opt_len = 0U;
   128a2:	f8ad 0012 	strh.w	r0, [sp, #18]
	delta = 0U;
   128a6:	f8ad 0016 	strh.w	r0, [sp, #22]
	num = 0U;
   128aa:	4607      	mov	r7, r0
		ret = parse_option(cpkt->data, offset, &offset, cpkt->max_len,
   128ac:	f10d 0812 	add.w	r8, sp, #18
		option = num < opt_num ? &options[num++] : NULL;
   128b0:	42b7      	cmp	r7, r6
   128b2:	bf34      	ite	cc
   128b4:	eb05 1307 	addcc.w	r3, r5, r7, lsl #4
   128b8:	2300      	movcs	r3, #0
		ret = parse_option(cpkt->data, offset, &offset, cpkt->max_len,
   128ba:	e9cd 8301 	strd	r8, r3, [sp, #4]
   128be:	f10d 0316 	add.w	r3, sp, #22
		option = num < opt_num ? &options[num++] : NULL;
   128c2:	bf38      	it	cc
   128c4:	1c7a      	addcc	r2, r7, #1
		ret = parse_option(cpkt->data, offset, &offset, cpkt->max_len,
   128c6:	9300      	str	r3, [sp, #0]
		option = num < opt_num ? &options[num++] : NULL;
   128c8:	bf38      	it	cc
   128ca:	b2d7      	uxtbcc	r7, r2
		ret = parse_option(cpkt->data, offset, &offset, cpkt->max_len,
   128cc:	88e3      	ldrh	r3, [r4, #6]
   128ce:	f8bd 1014 	ldrh.w	r1, [sp, #20]
   128d2:	6820      	ldr	r0, [r4, #0]
   128d4:	aa05      	add	r2, sp, #20
   128d6:	f7f4 fe6f 	bl	75b8 <parse_option>
		if (ret < 0) {
   128da:	2800      	cmp	r0, #0
   128dc:	dbbd      	blt.n	1285a <coap_packet_parse+0x18>
		} else if (ret == 0) {
   128de:	d1e7      	bne.n	128b0 <coap_packet_parse+0x6e>
	cpkt->opt_len = opt_len;
   128e0:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   128e4:	8163      	strh	r3, [r4, #10]
	cpkt->delta = delta;
   128e6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   128ea:	81a3      	strh	r3, [r4, #12]
	cpkt->offset = offset;
   128ec:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   128f0:	80a3      	strh	r3, [r4, #4]
	return 0;
   128f2:	e7b2      	b.n	1285a <coap_packet_parse+0x18>

000128f4 <z_fdtable_call_ioctl>:
 * @param request ioctl request number
 * @param ... Variadic arguments to ioctl
 */
static inline int z_fdtable_call_ioctl(const struct fd_op_vtable *vtable, void *obj,
				       unsigned long request, ...)
{
   128f4:	b40c      	push	{r2, r3}
   128f6:	b513      	push	{r0, r1, r4, lr}
   128f8:	aa04      	add	r2, sp, #16
   128fa:	460c      	mov	r4, r1
	va_list args;
	int res;

	va_start(args, request);
	res = vtable->ioctl(obj, request, args);
   128fc:	6883      	ldr	r3, [r0, #8]
{
   128fe:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, request);
   12902:	9201      	str	r2, [sp, #4]
	res = vtable->ioctl(obj, request, args);
   12904:	4620      	mov	r0, r4
   12906:	4798      	blx	r3
	va_end(args);

	return res;
}
   12908:	b002      	add	sp, #8
   1290a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1290e:	b002      	add	sp, #8
   12910:	4770      	bx	lr

00012912 <zsock_received_cb>:
{
   12912:	b570      	push	{r4, r5, r6, lr}
   12914:	4604      	mov	r4, r0
   12916:	f100 065c 	add.w	r6, r0, #92	; 0x5c
	if (!pkt) {
   1291a:	460d      	mov	r5, r1
   1291c:	b999      	cbnz	r1, 12946 <zsock_received_cb+0x34>
	return z_queue_node_peek(sys_sflist_peek_tail(&queue->data_q), false);
   1291e:	6e00      	ldr	r0, [r0, #96]	; 0x60
   12920:	f003 f8bc 	bl	15a9c <z_queue_node_peek>
		if (!last_pkt) {
   12924:	b940      	cbnz	r0, 12938 <zsock_received_cb+0x26>
static inline void sock_set_flag(struct net_context *ctx, uintptr_t mask,
				 uintptr_t flag)
{
	uintptr_t val = POINTER_TO_UINT(ctx->socket_data);

	val = (val & ~mask) | flag;
   12926:	6da3      	ldr	r3, [r4, #88]	; 0x58
   12928:	f043 0301 	orr.w	r3, r3, #1
	(ctx)->socket_data = UINT_TO_POINTER(val);
   1292c:	65a3      	str	r3, [r4, #88]	; 0x58
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_QUEUE_CANCEL_WAIT, k_queue_cancel_wait, struct k_queue *, queue)
   1292e:	4630      	mov	r0, r6
}
   12930:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   12934:	f003 b8c6 	b.w	15ac4 <z_impl_k_queue_cancel_wait>
	pkt->sent_or_eof = eof;
   12938:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   1293c:	f043 0302 	orr.w	r3, r3, #2
   12940:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
   12944:	bd70      	pop	{r4, r5, r6, pc}
   12946:	f891 3041 	ldrb.w	r3, [r1, #65]	; 0x41
   1294a:	f36f 0341 	bfc	r3, #1, #1
   1294e:	f881 3041 	strb.w	r3, [r1, #65]	; 0x41
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
   12952:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
   12956:	f3c3 1381 	ubfx	r3, r3, #6, #2
	if (net_context_get_type(ctx) == SOCK_STREAM) {
   1295a:	2b01      	cmp	r3, #1
   1295c:	d106      	bne.n	1296c <zsock_received_cb+0x5a>
		net_context_update_recv_wnd(ctx, -net_pkt_remaining_data(pkt));
   1295e:	4608      	mov	r0, r1
   12960:	f001 fb5e 	bl	14020 <net_pkt_remaining_data>
   12964:	4241      	negs	r1, r0
   12966:	4620      	mov	r0, r4
   12968:	f000 ffd6 	bl	13918 <net_context_update_recv_wnd>
	k_fifo_put(&ctx->recv_q, pkt);
   1296c:	4629      	mov	r1, r5
   1296e:	4630      	mov	r0, r6
}
   12970:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_fifo_put(&ctx->recv_q, pkt);
   12974:	f003 b8bb 	b.w	15aee <k_queue_append>

00012978 <sock_getsockopt_vmeth>:
   12978:	b508      	push	{r3, lr}
   1297a:	f000 fb7c 	bl	13076 <__errno>
   1297e:	236d      	movs	r3, #109	; 0x6d
   12980:	6003      	str	r3, [r0, #0]
   12982:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   12986:	bd08      	pop	{r3, pc}

00012988 <z_impl_zsock_socket>:
	return zsock_socket_internal(family, type, proto);
   12988:	f7f4 bedc 	b.w	7744 <zsock_socket_internal>

0001298c <zsock_close_ctx>:
{
   1298c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
   1298e:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
	if (net_context_get_state(ctx) == NET_CONTEXT_LISTENING) {
   12992:	f3c3 0341 	ubfx	r3, r3, #1, #2
   12996:	2b03      	cmp	r3, #3
		(void)net_context_accept(ctx, NULL, K_NO_WAIT, NULL);
   12998:	f04f 0300 	mov.w	r3, #0
{
   1299c:	4605      	mov	r5, r0
		(void)net_context_accept(ctx, NULL, K_NO_WAIT, NULL);
   1299e:	461a      	mov	r2, r3
   129a0:	4619      	mov	r1, r3
	if (net_context_get_state(ctx) == NET_CONTEXT_LISTENING) {
   129a2:	d11c      	bne.n	129de <zsock_close_ctx+0x52>
		(void)net_context_accept(ctx, NULL, K_NO_WAIT, NULL);
   129a4:	f000 ff3e 	bl	13824 <net_context_accept>
   129a8:	f8b5 606e 	ldrh.w	r6, [r5, #110]	; 0x6e
	while ((p = k_fifo_get(&ctx->recv_q, K_NO_WAIT)) != NULL) {
   129ac:	f105 075c 	add.w	r7, r5, #92	; 0x5c
	return (enum net_context_state)
   129b0:	f3c6 0641 	ubfx	r6, r6, #1, #2
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
   129b4:	2100      	movs	r1, #0
   129b6:	4638      	mov	r0, r7
   129b8:	f003 f8a3 	bl	15b02 <z_impl_k_queue_get>
   129bc:	4604      	mov	r4, r0
   129be:	b988      	cbnz	r0, 129e4 <zsock_close_ctx+0x58>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_QUEUE_CANCEL_WAIT, k_queue_cancel_wait, struct k_queue *, queue)
   129c0:	4638      	mov	r0, r7
   129c2:	f003 f87f 	bl	15ac4 <z_impl_k_queue_cancel_wait>
	SET_ERRNO(net_context_put(ctx));
   129c6:	4628      	mov	r0, r5
   129c8:	f7f8 f980 	bl	accc <net_context_put>
   129cc:	1e05      	subs	r5, r0, #0
   129ce:	da11      	bge.n	129f4 <zsock_close_ctx+0x68>
   129d0:	f000 fb51 	bl	13076 <__errno>
   129d4:	426d      	negs	r5, r5
   129d6:	6005      	str	r5, [r0, #0]
   129d8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   129dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		(void)net_context_recv(ctx, NULL, K_NO_WAIT, NULL);
   129de:	f7f8 fa21 	bl	ae24 <net_context_recv>
   129e2:	e7e1      	b.n	129a8 <zsock_close_ctx+0x1c>
		if (is_listen) {
   129e4:	2e03      	cmp	r6, #3
   129e6:	d102      	bne.n	129ee <zsock_close_ctx+0x62>
			net_context_put(p);
   129e8:	f7f8 f970 	bl	accc <net_context_put>
   129ec:	e7e2      	b.n	129b4 <zsock_close_ctx+0x28>
			net_pkt_unref(p);
   129ee:	f001 f9b2 	bl	13d56 <net_pkt_unref>
   129f2:	e7df      	b.n	129b4 <zsock_close_ctx+0x28>
	return 0;
   129f4:	4620      	mov	r0, r4
   129f6:	e7f1      	b.n	129dc <zsock_close_ctx+0x50>

000129f8 <sock_ioctl_vmeth>:
	return zsock_sendto_ctx(obj, buffer, count, 0, NULL, 0);
}

static int sock_ioctl_vmeth(void *obj, unsigned int request, va_list args)
{
	switch (request) {
   129f8:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
{
   129fc:	b510      	push	{r4, lr}
   129fe:	4603      	mov	r3, r0
	switch (request) {
   12a00:	d03b      	beq.n	12a7a <sock_ioctl_vmeth+0x82>
   12a02:	d807      	bhi.n	12a14 <sock_ioctl_vmeth+0x1c>
   12a04:	2903      	cmp	r1, #3
   12a06:	d026      	beq.n	12a56 <sock_ioctl_vmeth+0x5e>
   12a08:	2904      	cmp	r1, #4
   12a0a:	d029      	beq.n	12a60 <sock_ioctl_vmeth+0x68>

		return zsock_poll_update_ctx(obj, pfd, pev);
	}

	default:
		errno = EOPNOTSUPP;
   12a0c:	f000 fb33 	bl	13076 <__errno>
   12a10:	235f      	movs	r3, #95	; 0x5f
   12a12:	e042      	b.n	12a9a <sock_ioctl_vmeth+0xa2>
	switch (request) {
   12a14:	f240 1003 	movw	r0, #259	; 0x103
   12a18:	4281      	cmp	r1, r0
   12a1a:	d032      	beq.n	12a82 <sock_ioctl_vmeth+0x8a>
   12a1c:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
   12a20:	d1f4      	bne.n	12a0c <sock_ioctl_vmeth+0x14>
		pev = va_arg(args, struct k_poll_event **);
   12a22:	e9d2 1000 	ldrd	r1, r0, [r2]
	if (pfd->events & ZSOCK_POLLOUT) {
   12a26:	888c      	ldrh	r4, [r1, #4]
   12a28:	0762      	lsls	r2, r4, #29
		pfd->revents |= ZSOCK_POLLOUT;
   12a2a:	bf42      	ittt	mi
   12a2c:	88ca      	ldrhmi	r2, [r1, #6]
   12a2e:	f042 0204 	orrmi.w	r2, r2, #4
   12a32:	80ca      	strhmi	r2, [r1, #6]
	if (pfd->events & ZSOCK_POLLIN) {
   12a34:	07e2      	lsls	r2, r4, #31
   12a36:	d511      	bpl.n	12a5c <sock_ioctl_vmeth+0x64>
		if ((*pev)->state != K_POLL_STATE_NOT_READY || sock_is_eof(ctx)) {
   12a38:	6802      	ldr	r2, [r0, #0]
   12a3a:	68d4      	ldr	r4, [r2, #12]
   12a3c:	f414 3ff8 	tst.w	r4, #126976	; 0x1f000
   12a40:	d102      	bne.n	12a48 <sock_ioctl_vmeth+0x50>
}

static inline uintptr_t sock_get_flag(struct net_context *ctx, uintptr_t mask)
{
	return POINTER_TO_UINT(ctx->socket_data) & mask;
   12a42:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   12a44:	07db      	lsls	r3, r3, #31
   12a46:	d503      	bpl.n	12a50 <sock_ioctl_vmeth+0x58>
			pfd->revents |= ZSOCK_POLLIN;
   12a48:	88cb      	ldrh	r3, [r1, #6]
   12a4a:	f043 0301 	orr.w	r3, r3, #1
   12a4e:	80cb      	strh	r3, [r1, #6]
		(*pev)++;
   12a50:	3214      	adds	r2, #20
   12a52:	6002      	str	r2, [r0, #0]
   12a54:	e002      	b.n	12a5c <sock_ioctl_vmeth+0x64>
   12a56:	6d83      	ldr	r3, [r0, #88]	; 0x58
		if (sock_is_nonblock(obj)) {
   12a58:	079c      	lsls	r4, r3, #30
   12a5a:	d43f      	bmi.n	12adc <sock_ioctl_vmeth+0xe4>
		return zsock_poll_update_ctx(obj, pfd, pev);
   12a5c:	2000      	movs	r0, #0
   12a5e:	e00b      	b.n	12a78 <sock_ioctl_vmeth+0x80>
		if (flags & O_NONBLOCK) {
   12a60:	6810      	ldr	r0, [r2, #0]
   12a62:	6d9a      	ldr	r2, [r3, #88]	; 0x58
   12a64:	f410 4080 	ands.w	r0, r0, #16384	; 0x4000
   12a68:	f022 0202 	bic.w	r2, r2, #2
   12a6c:	d003      	beq.n	12a76 <sock_ioctl_vmeth+0x7e>
	val = (val & ~mask) | flag;
   12a6e:	f042 0202 	orr.w	r2, r2, #2
	(ctx)->socket_data = UINT_TO_POINTER(val);
   12a72:	659a      	str	r2, [r3, #88]	; 0x58
   12a74:	e7f2      	b.n	12a5c <sock_ioctl_vmeth+0x64>
   12a76:	659a      	str	r2, [r3, #88]	; 0x58
		return -1;
	}
}
   12a78:	bd10      	pop	{r4, pc}
   12a7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return zsock_close_ctx(obj);
   12a7e:	f7ff bf85 	b.w	1298c <zsock_close_ctx>
		return zsock_poll_prepare_ctx(obj, pfd, pev, pev_end);
   12a82:	6811      	ldr	r1, [r2, #0]
	if (pfd->events & ZSOCK_POLLIN) {
   12a84:	8889      	ldrh	r1, [r1, #4]
   12a86:	07c8      	lsls	r0, r1, #31
   12a88:	d521      	bpl.n	12ace <sock_ioctl_vmeth+0xd6>
		pev = va_arg(args, struct k_poll_event **);
   12a8a:	6851      	ldr	r1, [r2, #4]
		if (*pev == pev_end) {
   12a8c:	6892      	ldr	r2, [r2, #8]
   12a8e:	6808      	ldr	r0, [r1, #0]
   12a90:	4282      	cmp	r2, r0
   12a92:	d106      	bne.n	12aa2 <sock_ioctl_vmeth+0xaa>
			errno = ENOMEM;
   12a94:	f000 faef 	bl	13076 <__errno>
   12a98:	230c      	movs	r3, #12
		errno = EOPNOTSUPP;
   12a9a:	6003      	str	r3, [r0, #0]
		return -1;
   12a9c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   12aa0:	e7ea      	b.n	12a78 <sock_ioctl_vmeth+0x80>
		(*pev)->obj = &ctx->recv_q;
   12aa2:	f103 025c 	add.w	r2, r3, #92	; 0x5c
   12aa6:	6102      	str	r2, [r0, #16]
		(*pev)->type = K_POLL_TYPE_FIFO_DATA_AVAILABLE;
   12aa8:	680a      	ldr	r2, [r1, #0]
   12aaa:	7b50      	ldrb	r0, [r2, #13]
   12aac:	2404      	movs	r4, #4
   12aae:	f364 0003 	bfi	r0, r4, #0, #4
   12ab2:	7350      	strb	r0, [r2, #13]
		(*pev)->mode = K_POLL_MODE_NOTIFY_ONLY;
   12ab4:	680a      	ldr	r2, [r1, #0]
   12ab6:	7b90      	ldrb	r0, [r2, #14]
   12ab8:	f36f 0041 	bfc	r0, #1, #1
   12abc:	7390      	strb	r0, [r2, #14]
		(*pev)->state = K_POLL_STATE_NOT_READY;
   12abe:	680a      	ldr	r2, [r1, #0]
   12ac0:	68d0      	ldr	r0, [r2, #12]
   12ac2:	f36f 3010 	bfc	r0, #12, #5
   12ac6:	60d0      	str	r0, [r2, #12]
		(*pev)++;
   12ac8:	680a      	ldr	r2, [r1, #0]
   12aca:	3214      	adds	r2, #20
   12acc:	600a      	str	r2, [r1, #0]
	return POINTER_TO_UINT(ctx->socket_data) & mask;
   12ace:	6d9b      	ldr	r3, [r3, #88]	; 0x58
	if (sock_is_eof(ctx)) {
   12ad0:	07d9      	lsls	r1, r3, #31
   12ad2:	d5c3      	bpl.n	12a5c <sock_ioctl_vmeth+0x64>
		errno = EALREADY;
   12ad4:	f000 facf 	bl	13076 <__errno>
   12ad8:	2378      	movs	r3, #120	; 0x78
   12ada:	e7de      	b.n	12a9a <sock_ioctl_vmeth+0xa2>
		    return O_NONBLOCK;
   12adc:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   12ae0:	e7ca      	b.n	12a78 <sock_ioctl_vmeth+0x80>

00012ae2 <z_impl_zsock_close>:
{
   12ae2:	b537      	push	{r0, r1, r2, r4, r5, lr}
	void *ctx = z_get_fd_obj_and_vtable(sock, &vtable);
   12ae4:	a901      	add	r1, sp, #4
{
   12ae6:	4605      	mov	r5, r0
	void *ctx = z_get_fd_obj_and_vtable(sock, &vtable);
   12ae8:	f7f2 fc2a 	bl	5340 <z_get_fd_obj_and_vtable>
	if (ctx == NULL) {
   12aec:	4604      	mov	r4, r0
   12aee:	b150      	cbz	r0, 12b06 <z_impl_zsock_close+0x24>
	z_free_fd(sock);
   12af0:	4628      	mov	r0, r5
   12af2:	f7f2 fc65 	bl	53c0 <z_free_fd>
	return z_fdtable_call_ioctl(vtable, ctx, ZFD_IOCTL_CLOSE);
   12af6:	f44f 7280 	mov.w	r2, #256	; 0x100
   12afa:	4621      	mov	r1, r4
   12afc:	9801      	ldr	r0, [sp, #4]
   12afe:	f7ff fef9 	bl	128f4 <z_fdtable_call_ioctl>
}
   12b02:	b003      	add	sp, #12
   12b04:	bd30      	pop	{r4, r5, pc}
		return -1;
   12b06:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   12b0a:	e7fa      	b.n	12b02 <z_impl_zsock_close+0x20>

00012b0c <sock_bind_vmeth>:

static int sock_bind_vmeth(void *obj, const struct sockaddr *addr,
			   socklen_t addrlen)
{
	return zsock_bind_ctx(obj, addr, addrlen);
   12b0c:	f7f4 be56 	b.w	77bc <zsock_bind_ctx>

00012b10 <sock_connect_vmeth>:
}

static int sock_connect_vmeth(void *obj, const struct sockaddr *addr,
			      socklen_t addrlen)
{
	return zsock_connect_ctx(obj, addr, addrlen);
   12b10:	f7f4 be78 	b.w	7804 <zsock_connect_ctx>

00012b14 <z_impl_zsock_connect>:
{
   12b14:	b537      	push	{r0, r1, r2, r4, r5, lr}
   12b16:	460c      	mov	r4, r1
	return z_get_fd_obj_and_vtable(sock,
   12b18:	a901      	add	r1, sp, #4
{
   12b1a:	4615      	mov	r5, r2
	return z_get_fd_obj_and_vtable(sock,
   12b1c:	f7f2 fc10 	bl	5340 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(connect, sock, addr, addrlen);
   12b20:	b138      	cbz	r0, 12b32 <z_impl_zsock_connect+0x1e>
   12b22:	9b01      	ldr	r3, [sp, #4]
   12b24:	691b      	ldr	r3, [r3, #16]
   12b26:	b123      	cbz	r3, 12b32 <z_impl_zsock_connect+0x1e>
   12b28:	462a      	mov	r2, r5
   12b2a:	4621      	mov	r1, r4
   12b2c:	4798      	blx	r3
}
   12b2e:	b003      	add	sp, #12
   12b30:	bd30      	pop	{r4, r5, pc}
	VTABLE_CALL(connect, sock, addr, addrlen);
   12b32:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   12b36:	e7fa      	b.n	12b2e <z_impl_zsock_connect+0x1a>

00012b38 <sock_listen_vmeth>:
}

static int sock_listen_vmeth(void *obj, int backlog)
{
	return zsock_listen_ctx(obj, backlog);
   12b38:	f7f4 be84 	b.w	7844 <zsock_listen_ctx>

00012b3c <sock_accept_vmeth>:
}

static int sock_accept_vmeth(void *obj, struct sockaddr *addr,
			     socklen_t *addrlen)
{
	return zsock_accept_ctx(obj, addr, addrlen);
   12b3c:	f7f4 be9c 	b.w	7878 <zsock_accept_ctx>

00012b40 <sock_sendto_vmeth>:

static ssize_t sock_sendto_vmeth(void *obj, const void *buf, size_t len,
				 int flags, const struct sockaddr *dest_addr,
				 socklen_t addrlen)
{
	return zsock_sendto_ctx(obj, buf, len, flags, dest_addr, addrlen);
   12b40:	f7f4 beda 	b.w	78f8 <zsock_sendto_ctx>

00012b44 <sock_write_vmeth>:
{
   12b44:	b507      	push	{r0, r1, r2, lr}
	return zsock_sendto_ctx(obj, buffer, count, 0, NULL, 0);
   12b46:	2300      	movs	r3, #0
   12b48:	e9cd 3300 	strd	r3, r3, [sp]
   12b4c:	f7f4 fed4 	bl	78f8 <zsock_sendto_ctx>
}
   12b50:	b003      	add	sp, #12
   12b52:	f85d fb04 	ldr.w	pc, [sp], #4

00012b56 <z_impl_zsock_sendto>:
{
   12b56:	b5f0      	push	{r4, r5, r6, r7, lr}
   12b58:	b085      	sub	sp, #20
   12b5a:	460d      	mov	r5, r1
	return z_get_fd_obj_and_vtable(sock,
   12b5c:	a903      	add	r1, sp, #12
{
   12b5e:	4616      	mov	r6, r2
   12b60:	461f      	mov	r7, r3
	return z_get_fd_obj_and_vtable(sock,
   12b62:	f7f2 fbed 	bl	5340 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(sendto, sock, buf, len, flags, dest_addr, addrlen);
   12b66:	b160      	cbz	r0, 12b82 <z_impl_zsock_sendto+0x2c>
   12b68:	9b03      	ldr	r3, [sp, #12]
   12b6a:	69dc      	ldr	r4, [r3, #28]
   12b6c:	b14c      	cbz	r4, 12b82 <z_impl_zsock_sendto+0x2c>
   12b6e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12b70:	9301      	str	r3, [sp, #4]
   12b72:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   12b74:	9300      	str	r3, [sp, #0]
   12b76:	4632      	mov	r2, r6
   12b78:	463b      	mov	r3, r7
   12b7a:	4629      	mov	r1, r5
   12b7c:	47a0      	blx	r4
}
   12b7e:	b005      	add	sp, #20
   12b80:	bdf0      	pop	{r4, r5, r6, r7, pc}
	VTABLE_CALL(sendto, sock, buf, len, flags, dest_addr, addrlen);
   12b82:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   12b86:	e7fa      	b.n	12b7e <z_impl_zsock_sendto+0x28>

00012b88 <zsock_recvfrom_ctx>:
{
   12b88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12b8c:	b08f      	sub	sp, #60	; 0x3c
   12b8e:	4605      	mov	r5, r0
   12b90:	9102      	str	r1, [sp, #8]
   12b92:	4698      	mov	r8, r3
   12b94:	e9dd 7a18 	ldrd	r7, sl, [sp, #96]	; 0x60
	if (max_len == 0) {
   12b98:	4691      	mov	r9, r2
   12b9a:	b922      	cbnz	r2, 12ba6 <zsock_recvfrom_ctx+0x1e>
		return 0;
   12b9c:	2400      	movs	r4, #0
}
   12b9e:	4620      	mov	r0, r4
   12ba0:	b00f      	add	sp, #60	; 0x3c
   12ba2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	enum net_sock_type sock_type = net_context_get_type(ctx);
   12ba6:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
   12baa:	f3c3 1281 	ubfx	r2, r3, #6, #2
	if (sock_type == SOCK_DGRAM) {
   12bae:	2a02      	cmp	r2, #2
   12bb0:	f040 80bc 	bne.w	12d2c <zsock_recvfrom_ctx+0x1a4>
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   12bb4:	f018 0f40 	tst.w	r8, #64	; 0x40
   12bb8:	bf03      	ittte	eq
   12bba:	6d84      	ldreq	r4, [r0, #88]	; 0x58
   12bbc:	f084 0402 	eoreq.w	r4, r4, #2
   12bc0:	f344 0440 	sbfxeq	r4, r4, #1, #1
		timeout = K_NO_WAIT;
   12bc4:	2400      	movne	r4, #0
	if (flags & ZSOCK_MSG_PEEK) {
   12bc6:	f018 0302 	ands.w	r3, r8, #2
   12bca:	f100 065c 	add.w	r6, r0, #92	; 0x5c
   12bce:	9303      	str	r3, [sp, #12]
   12bd0:	d02a      	beq.n	12c28 <zsock_recvfrom_ctx+0xa0>
	struct k_poll_event events[] = {
   12bd2:	2210      	movs	r2, #16
   12bd4:	2100      	movs	r1, #0
   12bd6:	a809      	add	r0, sp, #36	; 0x24
   12bd8:	f7ef fb07 	bl	21ea <memset>
   12bdc:	2304      	movs	r3, #4
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
   12bde:	4622      	mov	r2, r4
   12be0:	2101      	movs	r1, #1
   12be2:	a809      	add	r0, sp, #36	; 0x24
   12be4:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
   12be8:	960d      	str	r6, [sp, #52]	; 0x34
   12bea:	f7fd f815 	bl	fc18 <z_impl_k_poll>
		if (res && res != -EAGAIN && res != -EINTR) {
   12bee:	f100 030b 	add.w	r3, r0, #11
   12bf2:	2b0b      	cmp	r3, #11
   12bf4:	4604      	mov	r4, r0
   12bf6:	d806      	bhi.n	12c06 <zsock_recvfrom_ctx+0x7e>
   12bf8:	f640 0181 	movw	r1, #2177	; 0x881
   12bfc:	40d9      	lsrs	r1, r3
   12bfe:	43c9      	mvns	r1, r1
   12c00:	f011 0101 	ands.w	r1, r1, #1
   12c04:	d004      	beq.n	12c10 <zsock_recvfrom_ctx+0x88>
			errno = -res;
   12c06:	f000 fa36 	bl	13076 <__errno>
   12c0a:	4264      	negs	r4, r4
   12c0c:	6004      	str	r4, [r0, #0]
			return -1;
   12c0e:	e008      	b.n	12c22 <zsock_recvfrom_ctx+0x9a>
	return z_queue_node_peek(sys_sflist_peek_head(&queue->data_q), false);
   12c10:	6de8      	ldr	r0, [r5, #92]	; 0x5c
   12c12:	f002 ff43 	bl	15a9c <z_queue_node_peek>
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
   12c16:	4606      	mov	r6, r0
	if (!pkt) {
   12c18:	b958      	cbnz	r0, 12c32 <zsock_recvfrom_ctx+0xaa>
		errno = EAGAIN;
   12c1a:	f000 fa2c 	bl	13076 <__errno>
   12c1e:	230b      	movs	r3, #11
   12c20:	6003      	str	r3, [r0, #0]
		return -1;
   12c22:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   12c26:	e7ba      	b.n	12b9e <zsock_recvfrom_ctx+0x16>
   12c28:	4621      	mov	r1, r4
   12c2a:	4630      	mov	r0, r6
   12c2c:	f002 ff69 	bl	15b02 <z_impl_k_queue_get>
   12c30:	e7f1      	b.n	12c16 <zsock_recvfrom_ctx+0x8e>
	backup->pos = pkt->cursor.pos;
   12c32:	e9d0 8306 	ldrd	r8, r3, [r0, #24]
   12c36:	9301      	str	r3, [sp, #4]
	if (src_addr && addrlen) {
   12c38:	b1f7      	cbz	r7, 12c78 <zsock_recvfrom_ctx+0xf0>
   12c3a:	f1ba 0f00 	cmp.w	sl, #0
   12c3e:	d01b      	beq.n	12c78 <zsock_recvfrom_ctx+0xf0>
		rv = sock_get_pkt_src_addr(pkt, net_context_get_ip_proto(ctx),
   12c40:	f8b5 306c 	ldrh.w	r3, [r5, #108]	; 0x6c
   12c44:	9304      	str	r3, [sp, #16]
   12c46:	f8da 4000 	ldr.w	r4, [sl]
	net_pkt_cursor_init(pkt);
   12c4a:	f001 f8f8 	bl	13e3e <net_pkt_cursor_init>
	return pkt->family;
   12c4e:	f896 3043 	ldrb.w	r3, [r6, #67]	; 0x43
   12c52:	f3c3 0342 	ubfx	r3, r3, #1, #3
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   12c56:	2b01      	cmp	r3, #1
	addr->sa_family = net_pkt_family(pkt);
   12c58:	803b      	strh	r3, [r7, #0]
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   12c5a:	d01f      	beq.n	12c9c <zsock_recvfrom_ctx+0x114>
		ret = -ENOTSUP;
   12c5c:	f06f 0485 	mvn.w	r4, #133	; 0x85
	pkt->cursor.pos = backup->pos;
   12c60:	9b01      	ldr	r3, [sp, #4]
	pkt->cursor.buf = backup->buf;
   12c62:	f8c6 8018 	str.w	r8, [r6, #24]
	pkt->cursor.pos = backup->pos;
   12c66:	61f3      	str	r3, [r6, #28]
		if (rv < 0) {
   12c68:	2c00      	cmp	r4, #0
   12c6a:	d1cc      	bne.n	12c06 <zsock_recvfrom_ctx+0x7e>
		if (src_addr->sa_family == AF_INET) {
   12c6c:	883b      	ldrh	r3, [r7, #0]
   12c6e:	2b01      	cmp	r3, #1
   12c70:	d149      	bne.n	12d06 <zsock_recvfrom_ctx+0x17e>
			*addrlen = sizeof(struct sockaddr_in);
   12c72:	2308      	movs	r3, #8
			*addrlen = sizeof(struct sockaddr_in6);
   12c74:	f8ca 3000 	str.w	r3, [sl]
	recv_len = net_pkt_remaining_data(pkt);
   12c78:	4630      	mov	r0, r6
   12c7a:	f001 f9d1 	bl	14020 <net_pkt_remaining_data>
	if (recv_len > max_len) {
   12c7e:	4581      	cmp	r9, r0
   12c80:	464c      	mov	r4, r9
   12c82:	bf28      	it	cs
   12c84:	4604      	movcs	r4, r0
	if (net_pkt_read(pkt, buf, recv_len)) {
   12c86:	4622      	mov	r2, r4
   12c88:	9902      	ldr	r1, [sp, #8]
   12c8a:	4630      	mov	r0, r6
   12c8c:	f001 f964 	bl	13f58 <net_pkt_read>
   12c90:	2800      	cmp	r0, #0
   12c92:	d040      	beq.n	12d16 <zsock_recvfrom_ctx+0x18e>
			errno = ENOBUFS;
   12c94:	f000 f9ef 	bl	13076 <__errno>
   12c98:	2369      	movs	r3, #105	; 0x69
   12c9a:	e7c1      	b.n	12c20 <zsock_recvfrom_ctx+0x98>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access,
   12c9c:	2300      	movs	r3, #0
   12c9e:	2514      	movs	r5, #20
		if (addrlen < sizeof(struct sockaddr_in)) {
   12ca0:	2c07      	cmp	r4, #7
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access,
   12ca2:	e9cd 3509 	strd	r3, r5, [sp, #36]	; 0x24
		if (addrlen < sizeof(struct sockaddr_in)) {
   12ca6:	d925      	bls.n	12cf4 <zsock_recvfrom_ctx+0x16c>
		ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(
   12ca8:	f10d 0b24 	add.w	fp, sp, #36	; 0x24
   12cac:	4659      	mov	r1, fp
   12cae:	4630      	mov	r0, r6
   12cb0:	f7f8 fd76 	bl	b7a0 <net_pkt_get_data>
		if (!ipv4_hdr || net_pkt_acknowledge_data(pkt, &ipv4_access)) {
   12cb4:	b910      	cbnz	r0, 12cbc <zsock_recvfrom_ctx+0x134>
			ret = -ENOBUFS;
   12cb6:	f06f 0468 	mvn.w	r4, #104	; 0x68
   12cba:	e7d1      	b.n	12c60 <zsock_recvfrom_ctx+0xd8>
   12cbc:	9005      	str	r0, [sp, #20]
	return net_pkt_skip(pkt, access->size);
   12cbe:	990a      	ldr	r1, [sp, #40]	; 0x28
   12cc0:	4630      	mov	r0, r6
   12cc2:	f001 f933 	bl	13f2c <net_pkt_skip>
		if (!ipv4_hdr || net_pkt_acknowledge_data(pkt, &ipv4_access)) {
   12cc6:	4604      	mov	r4, r0
   12cc8:	2800      	cmp	r0, #0
   12cca:	d1f4      	bne.n	12cb6 <zsock_recvfrom_ctx+0x12e>
		net_ipaddr_copy(&addr4->sin_addr, &ipv4_hdr->src);
   12ccc:	9b05      	ldr	r3, [sp, #20]
		rv = sock_get_pkt_src_addr(pkt, net_context_get_ip_proto(ctx),
   12cce:	f89d 2010 	ldrb.w	r2, [sp, #16]
		net_ipaddr_copy(&addr4->sin_addr, &ipv4_hdr->src);
   12cd2:	68db      	ldr	r3, [r3, #12]
   12cd4:	607b      	str	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
   12cd6:	2a11      	cmp	r2, #17
   12cd8:	d10f      	bne.n	12cfa <zsock_recvfrom_ctx+0x172>
		NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   12cda:	ab07      	add	r3, sp, #28
   12cdc:	9309      	str	r3, [sp, #36]	; 0x24
   12cde:	2308      	movs	r3, #8
   12ce0:	930a      	str	r3, [sp, #40]	; 0x28
		udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt,
   12ce2:	4659      	mov	r1, fp
		tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt,
   12ce4:	4630      	mov	r0, r6
   12ce6:	f7f8 fd5b 	bl	b7a0 <net_pkt_get_data>
		if (!tcp_hdr) {
   12cea:	2800      	cmp	r0, #0
   12cec:	d0e3      	beq.n	12cb6 <zsock_recvfrom_ctx+0x12e>
		*port = tcp_hdr->src_port;
   12cee:	8803      	ldrh	r3, [r0, #0]
   12cf0:	807b      	strh	r3, [r7, #2]
   12cf2:	e7b5      	b.n	12c60 <zsock_recvfrom_ctx+0xd8>
			ret = -EINVAL;
   12cf4:	f06f 0415 	mvn.w	r4, #21
   12cf8:	e7b2      	b.n	12c60 <zsock_recvfrom_ctx+0xd8>
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
   12cfa:	2a06      	cmp	r2, #6
   12cfc:	d1ae      	bne.n	12c5c <zsock_recvfrom_ctx+0xd4>
		NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   12cfe:	e9cd b507 	strd	fp, r5, [sp, #28]
		tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt,
   12d02:	a907      	add	r1, sp, #28
   12d04:	e7ee      	b.n	12ce4 <zsock_recvfrom_ctx+0x15c>
		} else if (src_addr->sa_family == AF_INET6) {
   12d06:	2b02      	cmp	r3, #2
   12d08:	d101      	bne.n	12d0e <zsock_recvfrom_ctx+0x186>
			*addrlen = sizeof(struct sockaddr_in6);
   12d0a:	2318      	movs	r3, #24
   12d0c:	e7b2      	b.n	12c74 <zsock_recvfrom_ctx+0xec>
			errno = ENOTSUP;
   12d0e:	f000 f9b2 	bl	13076 <__errno>
   12d12:	2386      	movs	r3, #134	; 0x86
   12d14:	e784      	b.n	12c20 <zsock_recvfrom_ctx+0x98>
	if (!(flags & ZSOCK_MSG_PEEK)) {
   12d16:	9b03      	ldr	r3, [sp, #12]
   12d18:	b91b      	cbnz	r3, 12d22 <zsock_recvfrom_ctx+0x19a>
		net_pkt_unref(pkt);
   12d1a:	4630      	mov	r0, r6
   12d1c:	f001 f81b 	bl	13d56 <net_pkt_unref>
   12d20:	e73d      	b.n	12b9e <zsock_recvfrom_ctx+0x16>
	pkt->cursor.pos = backup->pos;
   12d22:	9b01      	ldr	r3, [sp, #4]
	pkt->cursor.buf = backup->buf;
   12d24:	f8c6 8018 	str.w	r8, [r6, #24]
	pkt->cursor.pos = backup->pos;
   12d28:	61f3      	str	r3, [r6, #28]
	return recv_len;
   12d2a:	e738      	b.n	12b9e <zsock_recvfrom_ctx+0x16>
	} else if (sock_type == SOCK_STREAM) {
   12d2c:	2a01      	cmp	r2, #1
   12d2e:	f47f af35 	bne.w	12b9c <zsock_recvfrom_ctx+0x14>
	if (!net_context_is_used(ctx)) {
   12d32:	07d9      	lsls	r1, r3, #31
   12d34:	d403      	bmi.n	12d3e <zsock_recvfrom_ctx+0x1b6>
		errno = EBADF;
   12d36:	f000 f99e 	bl	13076 <__errno>
   12d3a:	2309      	movs	r3, #9
   12d3c:	e770      	b.n	12c20 <zsock_recvfrom_ctx+0x98>
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   12d3e:	6d87      	ldr	r7, [r0, #88]	; 0x58
   12d40:	f018 0f40 	tst.w	r8, #64	; 0x40
   12d44:	bf06      	itte	eq
   12d46:	f087 0702 	eoreq.w	r7, r7, #2
   12d4a:	f347 0740 	sbfxeq	r7, r7, #1, #1
		timeout = K_NO_WAIT;
   12d4e:	2700      	movne	r7, #0
		res = k_fifo_wait_non_empty(&ctx->recv_q, timeout);
   12d50:	f100 0b5c 	add.w	fp, r0, #92	; 0x5c
   12d54:	6da9      	ldr	r1, [r5, #88]	; 0x58
		if (sock_is_eof(ctx)) {
   12d56:	f011 0101 	ands.w	r1, r1, #1
   12d5a:	f47f af1f 	bne.w	12b9c <zsock_recvfrom_ctx+0x14>
	struct k_poll_event events[] = {
   12d5e:	2210      	movs	r2, #16
   12d60:	a809      	add	r0, sp, #36	; 0x24
   12d62:	f7ef fa42 	bl	21ea <memset>
   12d66:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   12d6a:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
   12d6e:	2204      	movs	r2, #4
   12d70:	f362 0303 	bfi	r3, r2, #0, #4
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
   12d74:	2101      	movs	r1, #1
   12d76:	463a      	mov	r2, r7
   12d78:	a809      	add	r0, sp, #36	; 0x24
   12d7a:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
   12d7e:	f7fc ff4b 	bl	fc18 <z_impl_k_poll>
		if (res && res != -EAGAIN && res != -EINTR) {
   12d82:	f100 030b 	add.w	r3, r0, #11
   12d86:	2b0b      	cmp	r3, #11
   12d88:	4604      	mov	r4, r0
   12d8a:	f63f af3c 	bhi.w	12c06 <zsock_recvfrom_ctx+0x7e>
   12d8e:	f640 0181 	movw	r1, #2177	; 0x881
   12d92:	40d9      	lsrs	r1, r3
   12d94:	43c9      	mvns	r1, r1
   12d96:	f011 0101 	ands.w	r1, r1, #1
   12d9a:	f47f af34 	bne.w	12c06 <zsock_recvfrom_ctx+0x7e>
   12d9e:	6de8      	ldr	r0, [r5, #92]	; 0x5c
   12da0:	f002 fe7c 	bl	15a9c <z_queue_node_peek>
		if (!pkt) {
   12da4:	4606      	mov	r6, r0
   12da6:	b920      	cbnz	r0, 12db2 <zsock_recvfrom_ctx+0x22a>
   12da8:	6dab      	ldr	r3, [r5, #88]	; 0x58
			if (sock_is_eof(ctx)) {
   12daa:	07da      	lsls	r2, r3, #31
   12dac:	f53f aef6 	bmi.w	12b9c <zsock_recvfrom_ctx+0x14>
   12db0:	e733      	b.n	12c1a <zsock_recvfrom_ctx+0x92>
	backup->buf = pkt->cursor.buf;
   12db2:	6983      	ldr	r3, [r0, #24]
   12db4:	9301      	str	r3, [sp, #4]
	backup->pos = pkt->cursor.pos;
   12db6:	69c3      	ldr	r3, [r0, #28]
   12db8:	9303      	str	r3, [sp, #12]
		data_len = net_pkt_remaining_data(pkt);
   12dba:	f001 f931 	bl	14020 <net_pkt_remaining_data>
		if (recv_len > max_len) {
   12dbe:	4581      	cmp	r9, r0
   12dc0:	464c      	mov	r4, r9
   12dc2:	bf28      	it	cs
   12dc4:	4604      	movcs	r4, r0
   12dc6:	9004      	str	r0, [sp, #16]
		if (net_pkt_read(pkt, buf, recv_len)) {
   12dc8:	4622      	mov	r2, r4
   12dca:	9902      	ldr	r1, [sp, #8]
   12dcc:	4630      	mov	r0, r6
   12dce:	f001 f8c3 	bl	13f58 <net_pkt_read>
   12dd2:	9b04      	ldr	r3, [sp, #16]
   12dd4:	2800      	cmp	r0, #0
   12dd6:	f47f af5d 	bne.w	12c94 <zsock_recvfrom_ctx+0x10c>
		if (!(flags & ZSOCK_MSG_PEEK)) {
   12dda:	f018 0a02 	ands.w	sl, r8, #2
   12dde:	d11b      	bne.n	12e18 <zsock_recvfrom_ctx+0x290>
			if (recv_len == data_len) {
   12de0:	4599      	cmp	r9, r3
   12de2:	d30e      	bcc.n	12e02 <zsock_recvfrom_ctx+0x27a>
K_SYSCALL_DECLARE2(K_SYSCALL_K_QUEUE_GET, k_queue_get, void *, struct k_queue *, queue, s32_t, timeout)
   12de4:	4651      	mov	r1, sl
   12de6:	4658      	mov	r0, fp
   12de8:	f002 fe8b 	bl	15b02 <z_impl_k_queue_get>
	return pkt->sent_or_eof;
   12dec:	f896 3041 	ldrb.w	r3, [r6, #65]	; 0x41
				if (net_pkt_eof(pkt)) {
   12df0:	079b      	lsls	r3, r3, #30
	val = (val & ~mask) | flag;
   12df2:	bf42      	ittt	mi
   12df4:	6dab      	ldrmi	r3, [r5, #88]	; 0x58
   12df6:	f043 0301 	orrmi.w	r3, r3, #1
	(ctx)->socket_data = UINT_TO_POINTER(val);
   12dfa:	65ab      	strmi	r3, [r5, #88]	; 0x58
				net_pkt_unref(pkt);
   12dfc:	4630      	mov	r0, r6
   12dfe:	f000 ffaa 	bl	13d56 <net_pkt_unref>
	} while (recv_len == 0);
   12e02:	2c00      	cmp	r4, #0
   12e04:	d0a6      	beq.n	12d54 <zsock_recvfrom_ctx+0x1cc>
	if (!(flags & ZSOCK_MSG_PEEK)) {
   12e06:	f1ba 0f00 	cmp.w	sl, #0
   12e0a:	f47f aec8 	bne.w	12b9e <zsock_recvfrom_ctx+0x16>
		net_context_update_recv_wnd(ctx, recv_len);
   12e0e:	4621      	mov	r1, r4
   12e10:	4628      	mov	r0, r5
   12e12:	f000 fd81 	bl	13918 <net_context_update_recv_wnd>
	return recv_len;
   12e16:	e6c2      	b.n	12b9e <zsock_recvfrom_ctx+0x16>
	pkt->cursor.buf = backup->buf;
   12e18:	9b01      	ldr	r3, [sp, #4]
   12e1a:	61b3      	str	r3, [r6, #24]
	pkt->cursor.pos = backup->pos;
   12e1c:	9b03      	ldr	r3, [sp, #12]
   12e1e:	61f3      	str	r3, [r6, #28]
   12e20:	e7ef      	b.n	12e02 <zsock_recvfrom_ctx+0x27a>

00012e22 <sock_recvfrom_vmeth>:

static ssize_t sock_recvfrom_vmeth(void *obj, void *buf, size_t max_len,
				   int flags, struct sockaddr *src_addr,
				   socklen_t *addrlen)
{
	return zsock_recvfrom_ctx(obj, buf, max_len, flags,
   12e22:	f7ff beb1 	b.w	12b88 <zsock_recvfrom_ctx>

00012e26 <sock_read_vmeth>:
{
   12e26:	b507      	push	{r0, r1, r2, lr}
	return zsock_recvfrom_ctx(obj, buffer, count, 0, NULL, 0);
   12e28:	2300      	movs	r3, #0
   12e2a:	e9cd 3300 	strd	r3, r3, [sp]
   12e2e:	f7ff feab 	bl	12b88 <zsock_recvfrom_ctx>
}
   12e32:	b003      	add	sp, #12
   12e34:	f85d fb04 	ldr.w	pc, [sp], #4

00012e38 <z_impl_zsock_recvfrom>:
{
   12e38:	b5f0      	push	{r4, r5, r6, r7, lr}
   12e3a:	b085      	sub	sp, #20
   12e3c:	460d      	mov	r5, r1
	return z_get_fd_obj_and_vtable(sock,
   12e3e:	a903      	add	r1, sp, #12
{
   12e40:	4616      	mov	r6, r2
   12e42:	461f      	mov	r7, r3
	return z_get_fd_obj_and_vtable(sock,
   12e44:	f7f2 fa7c 	bl	5340 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(recvfrom, sock, buf, max_len, flags, src_addr, addrlen);
   12e48:	b160      	cbz	r0, 12e64 <z_impl_zsock_recvfrom+0x2c>
   12e4a:	9b03      	ldr	r3, [sp, #12]
   12e4c:	6a1c      	ldr	r4, [r3, #32]
   12e4e:	b14c      	cbz	r4, 12e64 <z_impl_zsock_recvfrom+0x2c>
   12e50:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12e52:	9301      	str	r3, [sp, #4]
   12e54:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   12e56:	9300      	str	r3, [sp, #0]
   12e58:	4632      	mov	r2, r6
   12e5a:	463b      	mov	r3, r7
   12e5c:	4629      	mov	r1, r5
   12e5e:	47a0      	blx	r4
}
   12e60:	b005      	add	sp, #20
   12e62:	bdf0      	pop	{r4, r5, r6, r7, pc}
	VTABLE_CALL(recvfrom, sock, buf, max_len, flags, src_addr, addrlen);
   12e64:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   12e68:	e7fa      	b.n	12e60 <z_impl_zsock_recvfrom+0x28>

00012e6a <z_impl_zsock_inet_pton>:
{
   12e6a:	b508      	push	{r3, lr}
	if (net_addr_pton(family, src, dst) == 0) {
   12e6c:	f001 f983 	bl	14176 <net_addr_pton>
}
   12e70:	fab0 f080 	clz	r0, r0
   12e74:	0940      	lsrs	r0, r0, #5
   12e76:	bd08      	pop	{r3, pc}

00012e78 <zsock_setsockopt_ctx>:
	switch (level) {
   12e78:	2906      	cmp	r1, #6
{
   12e7a:	b508      	push	{r3, lr}
	switch (level) {
   12e7c:	d00c      	beq.n	12e98 <zsock_setsockopt_ctx+0x20>
   12e7e:	2929      	cmp	r1, #41	; 0x29
   12e80:	d00c      	beq.n	12e9c <zsock_setsockopt_ctx+0x24>
   12e82:	2901      	cmp	r1, #1
   12e84:	d101      	bne.n	12e8a <zsock_setsockopt_ctx+0x12>
		switch (optname) {
   12e86:	2a02      	cmp	r2, #2
   12e88:	d00a      	beq.n	12ea0 <zsock_setsockopt_ctx+0x28>
	errno = ENOPROTOOPT;
   12e8a:	f000 f8f4 	bl	13076 <__errno>
   12e8e:	236d      	movs	r3, #109	; 0x6d
   12e90:	6003      	str	r3, [r0, #0]
   12e92:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   12e96:	bd08      	pop	{r3, pc}
		switch (optname) {
   12e98:	2a01      	cmp	r2, #1
   12e9a:	e7f5      	b.n	12e88 <zsock_setsockopt_ctx+0x10>
		switch (optname) {
   12e9c:	2a1a      	cmp	r2, #26
   12e9e:	e7f3      	b.n	12e88 <zsock_setsockopt_ctx+0x10>
			return 0;
   12ea0:	2000      	movs	r0, #0
   12ea2:	e7f8      	b.n	12e96 <zsock_setsockopt_ctx+0x1e>

00012ea4 <sock_setsockopt_vmeth>:
}

static int sock_setsockopt_vmeth(void *obj, int level, int optname,
				 const void *optval, socklen_t optlen)
{
	return zsock_setsockopt_ctx(obj, level, optname, optval, optlen);
   12ea4:	f7ff bfe8 	b.w	12e78 <zsock_setsockopt_ctx>

00012ea8 <usb_transfer_sync_cb>:
	pdata->tsize = size;
   12ea8:	f842 1b04 	str.w	r1, [r2], #4
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
   12eac:	4610      	mov	r0, r2
   12eae:	f7fc bbab 	b.w	f608 <z_impl_k_sem_give>

00012eb2 <usb_transfer_work>:
{
   12eb2:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	if (trans->status != -EBUSY) {
   12eb6:	f850 3c30 	ldr.w	r3, [r0, #-48]
	ep = trans->ep;
   12eba:	f810 5c34 	ldrb.w	r5, [r0, #-52]
	if (trans->status != -EBUSY) {
   12ebe:	3310      	adds	r3, #16
{
   12ec0:	4604      	mov	r4, r0
	if (trans->status != -EBUSY) {
   12ec2:	d110      	bne.n	12ee6 <usb_transfer_work+0x34>
	if (trans->flags & USB_TRANS_WRITE) {
   12ec4:	68c3      	ldr	r3, [r0, #12]
   12ec6:	f850 2c28 	ldr.w	r2, [r0, #-40]
   12eca:	0799      	lsls	r1, r3, #30
   12ecc:	d53b      	bpl.n	12f46 <usb_transfer_work+0x94>
		if (!trans->bsize) {
   12ece:	b9fa      	cbnz	r2, 12f10 <usb_transfer_work+0x5e>
			if (!(trans->flags & USB_TRANS_NO_ZLP)) {
   12ed0:	f013 0304 	ands.w	r3, r3, #4
   12ed4:	d104      	bne.n	12ee0 <usb_transfer_work+0x2e>
				usb_dc_ep_write(ep, NULL, 0, NULL);
   12ed6:	461a      	mov	r2, r3
   12ed8:	4619      	mov	r1, r3
   12eda:	4628      	mov	r0, r5
   12edc:	f7f6 fb88 	bl	95f0 <usb_dc_ep_write>
			trans->status = 0;
   12ee0:	2300      	movs	r3, #0
			trans->status = -EINVAL;
   12ee2:	f844 3c30 	str.w	r3, [r4, #-48]
	if (trans->status != -EBUSY && trans->cb) { /* Transfer complete */
   12ee6:	f854 3c30 	ldr.w	r3, [r4, #-48]
   12eea:	3310      	adds	r3, #16
   12eec:	d00d      	beq.n	12f0a <usb_transfer_work+0x58>
   12eee:	f854 6c20 	ldr.w	r6, [r4, #-32]
   12ef2:	b156      	cbz	r6, 12f0a <usb_transfer_work+0x58>
		int tsize = trans->tsize;
   12ef4:	f854 7c24 	ldr.w	r7, [r4, #-36]
		void *priv = trans->priv;
   12ef8:	f854 8c1c 	ldr.w	r8, [r4, #-28]
		if (k_is_in_isr()) {
   12efc:	f7fc fbec 	bl	f6d8 <k_is_in_isr>
   12f00:	2800      	cmp	r0, #0
   12f02:	d04b      	beq.n	12f9c <usb_transfer_work+0xea>
	k_work_submit_to_queue(&k_sys_work_q, work);
   12f04:	4620      	mov	r0, r4
   12f06:	f7f4 fead 	bl	7c64 <k_work_submit_to_queue.constprop.9>
}
   12f0a:	b002      	add	sp, #8
   12f0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = usb_dc_ep_write(ep, trans->buffer, trans->bsize, &bytes);
   12f10:	f850 1c2c 	ldr.w	r1, [r0, #-44]
   12f14:	ab01      	add	r3, sp, #4
   12f16:	4628      	mov	r0, r5
   12f18:	f7f6 fb6a 	bl	95f0 <usb_dc_ep_write>
		if (ret) {
   12f1c:	b110      	cbz	r0, 12f24 <usb_transfer_work+0x72>
			trans->status = -EINVAL;
   12f1e:	f06f 0315 	mvn.w	r3, #21
   12f22:	e7de      	b.n	12ee2 <usb_transfer_work+0x30>
		trans->buffer += bytes;
   12f24:	9a01      	ldr	r2, [sp, #4]
   12f26:	f854 3c2c 	ldr.w	r3, [r4, #-44]
   12f2a:	4413      	add	r3, r2
   12f2c:	f844 3c2c 	str.w	r3, [r4, #-44]
		trans->bsize -= bytes;
   12f30:	f854 3c28 	ldr.w	r3, [r4, #-40]
   12f34:	1a9b      	subs	r3, r3, r2
   12f36:	f844 3c28 	str.w	r3, [r4, #-40]
		trans->tsize += bytes;
   12f3a:	f854 3c24 	ldr.w	r3, [r4, #-36]
   12f3e:	4413      	add	r3, r2
   12f40:	f844 3c24 	str.w	r3, [r4, #-36]
   12f44:	e7cf      	b.n	12ee6 <usb_transfer_work+0x34>
		ret = usb_dc_ep_read_wait(ep, trans->buffer, trans->bsize,
   12f46:	f850 1c2c 	ldr.w	r1, [r0, #-44]
   12f4a:	ab01      	add	r3, sp, #4
   12f4c:	4628      	mov	r0, r5
   12f4e:	f7f6 fbcf 	bl	96f0 <usb_dc_ep_read_wait>
		if (ret) {
   12f52:	2800      	cmp	r0, #0
   12f54:	d1e3      	bne.n	12f1e <usb_transfer_work+0x6c>
		trans->buffer += bytes;
   12f56:	9e01      	ldr	r6, [sp, #4]
   12f58:	f854 3c2c 	ldr.w	r3, [r4, #-44]
   12f5c:	4433      	add	r3, r6
   12f5e:	f844 3c2c 	str.w	r3, [r4, #-44]
		trans->bsize -= bytes;
   12f62:	f854 3c28 	ldr.w	r3, [r4, #-40]
   12f66:	1b9b      	subs	r3, r3, r6
   12f68:	f844 3c28 	str.w	r3, [r4, #-40]
		trans->tsize += bytes;
   12f6c:	f854 3c24 	ldr.w	r3, [r4, #-36]
   12f70:	4433      	add	r3, r6
   12f72:	f844 3c24 	str.w	r3, [r4, #-36]
		if (!bytes || (bytes % usb_dc_ep_mps(ep)) || !trans->bsize) {
   12f76:	2e00      	cmp	r6, #0
   12f78:	d0b2      	beq.n	12ee0 <usb_transfer_work+0x2e>
   12f7a:	4628      	mov	r0, r5
   12f7c:	f7f6 fc50 	bl	9820 <usb_dc_ep_mps>
   12f80:	fbb6 f3f0 	udiv	r3, r6, r0
   12f84:	fb03 6010 	mls	r0, r3, r0, r6
   12f88:	2800      	cmp	r0, #0
   12f8a:	d1a9      	bne.n	12ee0 <usb_transfer_work+0x2e>
   12f8c:	f854 3c28 	ldr.w	r3, [r4, #-40]
   12f90:	2b00      	cmp	r3, #0
   12f92:	d0a5      	beq.n	12ee0 <usb_transfer_work+0x2e>
		usb_dc_ep_read_continue(ep);
   12f94:	4628      	mov	r0, r5
   12f96:	f7f6 fbef 	bl	9778 <usb_dc_ep_read_continue>
   12f9a:	e7a4      	b.n	12ee6 <usb_transfer_work+0x34>
		trans->cb = NULL;
   12f9c:	f844 0c20 	str.w	r0, [r4, #-32]
   12fa0:	f1a4 0018 	sub.w	r0, r4, #24
   12fa4:	f7fc fb30 	bl	f608 <z_impl_k_sem_give>
		cb(ep, tsize, priv);
   12fa8:	4642      	mov	r2, r8
   12faa:	4639      	mov	r1, r7
   12fac:	4628      	mov	r0, r5
   12fae:	47b0      	blx	r6
   12fb0:	e7ab      	b.n	12f0a <usb_transfer_work+0x58>

00012fb2 <usb_update_sn_string_descriptor>:
}
   12fb2:	2000      	movs	r0, #0
   12fb4:	4770      	bx	lr

00012fb6 <z_impl_uart_poll_out>:
	api->poll_out(dev, out_char);
   12fb6:	6843      	ldr	r3, [r0, #4]
   12fb8:	685b      	ldr	r3, [r3, #4]
   12fba:	4718      	bx	r3

00012fbc <debug_hook_out_nop>:
}
   12fbc:	2000      	movs	r0, #0
   12fbe:	4770      	bx	lr

00012fc0 <clock_control_init>:

static int clock_control_init(struct device *dev)
{
   12fc0:	b508      	push	{r3, lr}
	 * for 16 MHz clock. The vector is also shared for other power related
	 * features. Hence, design a better way to init IRQISR when adding
	 * power peripheral driver and/or new SoC series.
	 * NOTE: Currently the operations here are idempotent.
	 */
	IRQ_CONNECT(DT_NORDIC_NRF_CLOCK_0_IRQ_0,
   12fc2:	2200      	movs	r2, #0
   12fc4:	4610      	mov	r0, r2
   12fc6:	2101      	movs	r1, #1
   12fc8:	f7f6 ff12 	bl	9df0 <z_irq_priority_set>
		    DT_NORDIC_NRF_CLOCK_0_IRQ_0_PRIORITY,
		    nrf_power_clock_isr, 0, 0);

	irq_enable(DT_NORDIC_NRF_CLOCK_0_IRQ_0);
   12fcc:	2000      	movs	r0, #0
   12fce:	f7f6 fedd 	bl	9d8c <z_arch_irq_enable>

	return 0;
}
   12fd2:	2000      	movs	r0, #0
   12fd4:	bd08      	pop	{r3, pc}

00012fd6 <nrf5_power_usb_power_int_enable>:

	mask = NRF_POWER_INT_USBDETECTED_MASK |
	       NRF_POWER_INT_USBREMOVED_MASK |
	       NRF_POWER_INT_USBPWRRDY_MASK;

	if (enable) {
   12fd6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   12fda:	f44f 7260 	mov.w	r2, #896	; 0x380
   12fde:	b120      	cbz	r0, 12fea <nrf5_power_usb_power_int_enable+0x14>
    NRF_POWER->INTENSET = int_mask;
   12fe0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_power_int_enable(mask);
		irq_enable(DT_NORDIC_NRF_CLOCK_0_IRQ_0);
   12fe4:	2000      	movs	r0, #0
   12fe6:	f7f6 bed1 	b.w	9d8c <z_arch_irq_enable>
    NRF_POWER->INTENCLR = int_mask;
   12fea:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	} else {
		nrf_power_int_disable(mask);
	}
}
   12fee:	4770      	bx	lr

00012ff0 <usb_dc_ep_read>:
{
   12ff0:	b570      	push	{r4, r5, r6, lr}
   12ff2:	4604      	mov	r4, r0
   12ff4:	460e      	mov	r6, r1
   12ff6:	4615      	mov	r5, r2
	ret = usb_dc_ep_read_wait(ep, data, max_data_len, read_bytes);
   12ff8:	f7f6 fb7a 	bl	96f0 <usb_dc_ep_read_wait>
	if (ret) {
   12ffc:	b930      	cbnz	r0, 1300c <usb_dc_ep_read+0x1c>
	if (!data && !max_data_len) {
   12ffe:	b906      	cbnz	r6, 13002 <usb_dc_ep_read+0x12>
   13000:	b125      	cbz	r5, 1300c <usb_dc_ep_read+0x1c>
	ret = usb_dc_ep_read_continue(ep);
   13002:	4620      	mov	r0, r4
}
   13004:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = usb_dc_ep_read_continue(ep);
   13008:	f7f6 bbb6 	b.w	9778 <usb_dc_ep_read_continue>
}
   1300c:	bd70      	pop	{r4, r5, r6, pc}

0001300e <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
   1300e:	4770      	bx	lr

00013010 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   13010:	4770      	bx	lr

00013012 <z_irq_spurious>:
 * @return N/A
 */
void z_irq_spurious(void *unused)
{
	ARG_UNUSED(unused);
	__reserved();
   13012:	f7f6 bf3b 	b.w	9e8c <__bus_fault>

00013016 <z_do_kernel_oops>:

void z_do_kernel_oops(const NANO_ESF *esf)
{
   13016:	4601      	mov	r1, r0
	z_NanoFatalErrorHandler(esf->r0, esf);
   13018:	6800      	ldr	r0, [r0, #0]
   1301a:	f7f6 bf4b 	b.w	9eb4 <z_NanoFatalErrorHandler>

0001301e <__nmi>:
 *
 * @return N/A
 */

void __nmi(void)
{
   1301e:	b508      	push	{r3, lr}
	handler();
   13020:	f7f7 f804 	bl	a02c <z_SysNmiOnReset>
	z_ExcExit();
}
   13024:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_ExcExit();
   13028:	f7f6 bcee 	b.w	9a08 <_IntExit>

0001302c <z_arch_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arch_configure_dynamic_mpu_regions(struct k_thread *thread)
{
   1302c:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
   1302e:	2100      	movs	r1, #0
   13030:	a801      	add	r0, sp, #4
   13032:	f7f7 f8e3 	bl	a1fc <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
   13036:	b003      	add	sp, #12
   13038:	f85d fb04 	ldr.w	pc, [sp], #4

0001303c <_stdout_hook_default>:
}
   1303c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   13040:	4770      	bx	lr

00013042 <_stdin_hook_default>:
}
   13042:	2000      	movs	r0, #0
   13044:	4770      	bx	lr

00013046 <_read>:
{
   13046:	4608      	mov	r0, r1
	return z_impl_zephyr_read_stdin(buf, nbytes);
   13048:	4611      	mov	r1, r2
   1304a:	f7f7 b8f3 	b.w	a234 <z_impl_zephyr_read_stdin>

0001304e <_write>:
{
   1304e:	4608      	mov	r0, r1
	return z_impl_zephyr_write_stdout(buf, nbytes);
   13050:	4611      	mov	r1, r2
   13052:	f7f7 b903 	b.w	a25c <z_impl_zephyr_write_stdout>

00013056 <_close>:
   13056:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1305a:	4770      	bx	lr

0001305c <_lseek>:
}
   1305c:	2000      	movs	r0, #0
   1305e:	4770      	bx	lr

00013060 <_isatty>:
}
   13060:	2001      	movs	r0, #1
   13062:	4770      	bx	lr

00013064 <_kill>:
}
   13064:	2000      	movs	r0, #0
   13066:	4770      	bx	lr

00013068 <_getpid>:
}
   13068:	2000      	movs	r0, #0
   1306a:	4770      	bx	lr

0001306c <_fstat>:
	st->st_mode = S_IFCHR;
   1306c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   13070:	604b      	str	r3, [r1, #4]
}
   13072:	2000      	movs	r0, #0
   13074:	4770      	bx	lr

00013076 <__errno>:

#ifdef __cplusplus
extern "C" {
#endif

K_SYSCALL_DECLARE0(K_SYSCALL_Z_ERRNO, z_errno, int *)
   13076:	f7fb bcdb 	b.w	ea30 <z_impl_z_errno>

0001307a <fixed_data_unref>:
}
   1307a:	4770      	bx	lr

0001307c <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1307c:	6983      	ldr	r3, [r0, #24]
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   1307e:	685b      	ldr	r3, [r3, #4]
   13080:	460a      	mov	r2, r1
   13082:	6819      	ldr	r1, [r3, #0]
   13084:	f7f7 b942 	b.w	a30c <net_buf_alloc_len>

00013088 <net_buf_frag_last>:

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
	NET_BUF_ASSERT(buf);

	while (buf->frags) {
   13088:	6803      	ldr	r3, [r0, #0]
   1308a:	b903      	cbnz	r3, 1308e <net_buf_frag_last+0x6>
		buf = buf->frags;
	}

	return buf;
}
   1308c:	4770      	bx	lr
   1308e:	4618      	mov	r0, r3
   13090:	e7fa      	b.n	13088 <net_buf_frag_last>

00013092 <net_buf_frag_insert>:
void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
	NET_BUF_ASSERT(parent);
	NET_BUF_ASSERT(frag);

	if (parent->frags) {
   13092:	6802      	ldr	r2, [r0, #0]
{
   13094:	b510      	push	{r4, lr}
	if (parent->frags) {
   13096:	b11a      	cbz	r2, 130a0 <net_buf_frag_insert+0xe>
   13098:	460b      	mov	r3, r1
	while (buf->frags) {
   1309a:	681c      	ldr	r4, [r3, #0]
   1309c:	b914      	cbnz	r4, 130a4 <net_buf_frag_insert+0x12>
		net_buf_frag_last(frag)->frags = parent->frags;
   1309e:	601a      	str	r2, [r3, #0]
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
   130a0:	6001      	str	r1, [r0, #0]
}
   130a2:	bd10      	pop	{r4, pc}
	while (buf->frags) {
   130a4:	4623      	mov	r3, r4
   130a6:	e7f8      	b.n	1309a <net_buf_frag_insert+0x8>

000130a8 <net_buf_simple_add>:
	return buf->data + buf->len;
   130a8:	8883      	ldrh	r3, [r0, #4]
   130aa:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   130ac:	4419      	add	r1, r3
   130ae:	8081      	strh	r1, [r0, #4]
	return tail;
}
   130b0:	18d0      	adds	r0, r2, r3
   130b2:	4770      	bx	lr

000130b4 <net_buf_simple_pull>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(buf->len >= len);

	buf->len -= len;
   130b4:	8883      	ldrh	r3, [r0, #4]
   130b6:	1a5b      	subs	r3, r3, r1
   130b8:	8083      	strh	r3, [r0, #4]
	return buf->data += len;
   130ba:	6803      	ldr	r3, [r0, #0]
   130bc:	4419      	add	r1, r3
   130be:	6001      	str	r1, [r0, #0]
}
   130c0:	4608      	mov	r0, r1
   130c2:	4770      	bx	lr

000130c4 <sys_slist_remove>:
Z_GENLIST_REMOVE(slist, snode)
   130c4:	6813      	ldr	r3, [r2, #0]
   130c6:	b939      	cbnz	r1, 130d8 <sys_slist_remove+0x14>
   130c8:	6841      	ldr	r1, [r0, #4]
	list->head = node;
   130ca:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   130cc:	428a      	cmp	r2, r1
   130ce:	d100      	bne.n	130d2 <sys_slist_remove+0xe>
	list->tail = node;
   130d0:	6043      	str	r3, [r0, #4]
	parent->next = child;
   130d2:	2300      	movs	r3, #0
   130d4:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   130d6:	4770      	bx	lr
	parent->next = child;
   130d8:	600b      	str	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   130da:	6843      	ldr	r3, [r0, #4]
   130dc:	429a      	cmp	r2, r3
	list->tail = node;
   130de:	bf08      	it	eq
   130e0:	6041      	streq	r1, [r0, #4]
   130e2:	e7f6      	b.n	130d2 <sys_slist_remove+0xe>

000130e4 <arp_entry_find>:
{
   130e4:	b530      	push	{r4, r5, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(list, entry, node) {
   130e6:	6800      	ldr	r0, [r0, #0]
   130e8:	b908      	cbnz	r0, 130ee <arp_entry_find+0xa>
	return NULL;
   130ea:	2000      	movs	r0, #0
}
   130ec:	bd30      	pop	{r4, r5, pc}
		if (entry->iface == iface &&
   130ee:	6904      	ldr	r4, [r0, #16]
   130f0:	42a1      	cmp	r1, r4
   130f2:	d103      	bne.n	130fc <arp_entry_find+0x18>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   130f4:	6945      	ldr	r5, [r0, #20]
   130f6:	6814      	ldr	r4, [r2, #0]
   130f8:	42a5      	cmp	r5, r4
   130fa:	d0f7      	beq.n	130ec <arp_entry_find+0x8>
		if (previous) {
   130fc:	2b00      	cmp	r3, #0
   130fe:	d0f2      	beq.n	130e6 <arp_entry_find+0x2>
			*previous = &entry->node;
   13100:	6018      	str	r0, [r3, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   13102:	e7f0      	b.n	130e6 <arp_entry_find+0x2>

00013104 <if_get_addr.isra.16>:
	if (!ipv4) {
   13104:	b190      	cbz	r0, 1312c <if_get_addr.isra.16+0x28>
		if (ipv4->unicast[i].is_used &&
   13106:	7a83      	ldrb	r3, [r0, #10]
   13108:	f3c3 0340 	ubfx	r3, r3, #1, #1
   1310c:	b16b      	cbz	r3, 1312a <if_get_addr.isra.16+0x26>
   1310e:	8803      	ldrh	r3, [r0, #0]
   13110:	2b01      	cmp	r3, #1
   13112:	d10a      	bne.n	1312a <if_get_addr.isra.16+0x26>
		    ipv4->unicast[i].address.family == AF_INET &&
   13114:	f990 3009 	ldrsb.w	r3, [r0, #9]
   13118:	2b01      	cmp	r3, #1
   1311a:	d106      	bne.n	1312a <if_get_addr.isra.16+0x26>
		    ipv4->unicast[i].addr_state == NET_ADDR_PREFERRED &&
   1311c:	b119      	cbz	r1, 13126 <if_get_addr.isra.16+0x22>
   1311e:	680a      	ldr	r2, [r1, #0]
   13120:	6843      	ldr	r3, [r0, #4]
		    (!addr ||
   13122:	429a      	cmp	r2, r3
   13124:	d101      	bne.n	1312a <if_get_addr.isra.16+0x26>
			return &ipv4->unicast[i].address.in_addr;
   13126:	3004      	adds	r0, #4
   13128:	4770      	bx	lr
		return NULL;
   1312a:	2000      	movs	r0, #0
}
   1312c:	4770      	bx	lr

0001312e <arp_entry_cleanup>:
{
   1312e:	b510      	push	{r4, lr}
   13130:	4604      	mov	r4, r0
	if (pending) {
   13132:	b111      	cbz	r1, 1313a <arp_entry_cleanup+0xc>
		net_pkt_unref(entry->pending);
   13134:	6980      	ldr	r0, [r0, #24]
   13136:	f000 fe0e 	bl	13d56 <net_pkt_unref>
	entry->iface = NULL;
   1313a:	2300      	movs	r3, #0
   1313c:	6123      	str	r3, [r4, #16]
   1313e:	6163      	str	r3, [r4, #20]
   13140:	61a3      	str	r3, [r4, #24]
   13142:	83a3      	strh	r3, [r4, #28]
}
   13144:	bd10      	pop	{r4, pc}

00013146 <net_arp_input>:
{
   13146:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
   13148:	6942      	ldr	r2, [r0, #20]
{
   1314a:	460e      	mov	r6, r1
   1314c:	4605      	mov	r5, r0
	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
   1314e:	4611      	mov	r1, r2
	size_t bytes = 0;
   13150:	2300      	movs	r3, #0
	while (buf) {
   13152:	b941      	cbnz	r1, 13166 <net_arp_input+0x20>
	return pkt->frags->data;
   13154:	6894      	ldr	r4, [r2, #8]
				    (net_pkt_ip_data(pkt) - (u8_t *)eth_hdr))) {
   13156:	1ba2      	subs	r2, r4, r6
	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
   13158:	f1c2 021c 	rsb	r2, r2, #28
   1315c:	429a      	cmp	r2, r3
   1315e:	d906      	bls.n	1316e <net_arp_input+0x28>
		return NET_DROP;
   13160:	2002      	movs	r0, #2
}
   13162:	b003      	add	sp, #12
   13164:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bytes += buf->len;
   13166:	8988      	ldrh	r0, [r1, #12]
		buf = buf->frags;
   13168:	6809      	ldr	r1, [r1, #0]
		bytes += buf->len;
   1316a:	4403      	add	r3, r0
		buf = buf->frags;
   1316c:	e7f1      	b.n	13152 <net_arp_input+0xc>
	if (ntohs(arp_hdr->hwtype) != NET_ARP_HTYPE_ETH ||
   1316e:	8822      	ldrh	r2, [r4, #0]
   13170:	0213      	lsls	r3, r2, #8
   13172:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
   13176:	b21b      	sxth	r3, r3
   13178:	2b01      	cmp	r3, #1
   1317a:	d1f1      	bne.n	13160 <net_arp_input+0x1a>
	    ntohs(arp_hdr->protocol) != NET_ETH_PTYPE_IP ||
   1317c:	8862      	ldrh	r2, [r4, #2]
   1317e:	0213      	lsls	r3, r2, #8
   13180:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
	if (ntohs(arp_hdr->hwtype) != NET_ARP_HTYPE_ETH ||
   13184:	b21b      	sxth	r3, r3
   13186:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
   1318a:	d1e9      	bne.n	13160 <net_arp_input+0x1a>
	    ntohs(arp_hdr->protocol) != NET_ETH_PTYPE_IP ||
   1318c:	7927      	ldrb	r7, [r4, #4]
   1318e:	2f06      	cmp	r7, #6
   13190:	d1e6      	bne.n	13160 <net_arp_input+0x1a>
	    arp_hdr->hwlen != sizeof(struct net_eth_addr) ||
   13192:	7963      	ldrb	r3, [r4, #5]
   13194:	2b04      	cmp	r3, #4
   13196:	d1e3      	bne.n	13160 <net_arp_input+0x1a>
	    arp_hdr->protolen != NET_ARP_IPV4_PTYPE_SIZE ||
   13198:	7ba3      	ldrb	r3, [r4, #14]
   1319a:	2b7f      	cmp	r3, #127	; 0x7f
   1319c:	d0e0      	beq.n	13160 <net_arp_input+0x1a>
	switch (ntohs(arp_hdr->opcode)) {
   1319e:	88e2      	ldrh	r2, [r4, #6]
   131a0:	0213      	lsls	r3, r2, #8
   131a2:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
   131a6:	b21b      	sxth	r3, r3
   131a8:	2b01      	cmp	r3, #1
   131aa:	d007      	beq.n	131bc <net_arp_input+0x76>
   131ac:	2b02      	cmp	r3, #2
   131ae:	f000 80a5 	beq.w	132fc <net_arp_input+0x1b6>
	net_pkt_unref(pkt);
   131b2:	4628      	mov	r0, r5
   131b4:	f000 fdcf 	bl	13d56 <net_pkt_unref>
	return NET_OK;
   131b8:	2000      	movs	r0, #0
   131ba:	e7d2      	b.n	13162 <net_arp_input+0x1c>
				   net_eth_broadcast_addr(),
   131bc:	f7f7 fc26 	bl	aa0c <net_eth_broadcast_addr>
			if (memcmp(&eth_hdr->dst,
   131c0:	463a      	mov	r2, r7
   131c2:	4601      	mov	r1, r0
   131c4:	4630      	mov	r0, r6
   131c6:	f7ee ffc7 	bl	2158 <memcmp>
   131ca:	b9d0      	cbnz	r0, 13202 <net_arp_input+0xbc>
				   net_eth_broadcast_addr(),
   131cc:	f7f7 fc1e 	bl	aa0c <net_eth_broadcast_addr>
			    memcmp(&arp_hdr->dst_hwaddr,
   131d0:	463a      	mov	r2, r7
   131d2:	4601      	mov	r1, r0
   131d4:	f104 0012 	add.w	r0, r4, #18
   131d8:	f7ee ffbe 	bl	2158 <memcmp>
				   sizeof(struct net_eth_addr)) == 0 &&
   131dc:	b988      	cbnz	r0, 13202 <net_arp_input+0xbc>
			    memcmp(&arp_hdr->dst_ipaddr, &arp_hdr->src_ipaddr,
   131de:	f104 070e 	add.w	r7, r4, #14
   131e2:	2204      	movs	r2, #4
   131e4:	4639      	mov	r1, r7
   131e6:	f104 0018 	add.w	r0, r4, #24
   131ea:	f7ee ffb5 	bl	2158 <memcmp>
				   sizeof(struct net_eth_addr)) == 0 &&
   131ee:	b940      	cbnz	r0, 13202 <net_arp_input+0xbc>
				arp_update(net_pkt_iface(pkt),
   131f0:	9000      	str	r0, [sp, #0]
   131f2:	2301      	movs	r3, #1
   131f4:	f104 0208 	add.w	r2, r4, #8
   131f8:	4639      	mov	r1, r7
			arp_update(net_pkt_iface(pkt),
   131fa:	6a68      	ldr	r0, [r5, #36]	; 0x24
   131fc:	f7f7 f972 	bl	a4e4 <arp_update>
   13200:	e7d7      	b.n	131b2 <net_arp_input+0x6c>
		if (memcmp(&eth_hdr->dst, net_eth_broadcast_addr(),
   13202:	f7f7 fc03 	bl	aa0c <net_eth_broadcast_addr>
   13206:	2206      	movs	r2, #6
   13208:	4601      	mov	r1, r0
   1320a:	4630      	mov	r0, r6
   1320c:	f7ee ffa4 	bl	2158 <memcmp>
   13210:	b938      	cbnz	r0, 13222 <net_arp_input+0xdc>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
   13212:	f8d4 300e 	ldr.w	r3, [r4, #14]
   13216:	ba1b      	rev	r3, r3
   13218:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
			   sizeof(struct net_eth_addr)) == 0 &&
   1321c:	f1b3 4f60 	cmp.w	r3, #3758096384	; 0xe0000000
   13220:	d09e      	beq.n	13160 <net_arp_input+0x1a>
		addr = if_get_addr(net_pkt_iface(pkt), &arp_hdr->dst_ipaddr);
   13222:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   13224:	f104 0118 	add.w	r1, r4, #24
   13228:	6858      	ldr	r0, [r3, #4]
   1322a:	f7ff ff6b 	bl	13104 <if_get_addr.isra.16>
		if (!addr) {
   1322e:	2800      	cmp	r0, #0
   13230:	d096      	beq.n	13160 <net_arp_input+0x1a>
		if (memcmp(&eth_hdr->src, &arp_hdr->src_hwaddr,
   13232:	3606      	adds	r6, #6
   13234:	f104 0708 	add.w	r7, r4, #8
   13238:	2206      	movs	r2, #6
   1323a:	4639      	mov	r1, r7
   1323c:	4630      	mov	r0, r6
   1323e:	f7ee ff8b 	bl	2158 <memcmp>
   13242:	b998      	cbnz	r0, 1326c <net_arp_input+0x126>
	return false;
}

static inline bool net_eth_is_addr_unspecified(struct net_eth_addr *addr)
{
	if (addr->addr[0] == 0x00 &&
   13244:	7ca3      	ldrb	r3, [r4, #18]
   13246:	b98b      	cbnz	r3, 1326c <net_arp_input+0x126>
   13248:	7ce3      	ldrb	r3, [r4, #19]
   1324a:	b97b      	cbnz	r3, 1326c <net_arp_input+0x126>
	    addr->addr[1] == 0x00 &&
   1324c:	7d23      	ldrb	r3, [r4, #20]
   1324e:	b96b      	cbnz	r3, 1326c <net_arp_input+0x126>
	    addr->addr[2] == 0x00 &&
   13250:	7d63      	ldrb	r3, [r4, #21]
   13252:	b95b      	cbnz	r3, 1326c <net_arp_input+0x126>
	    addr->addr[3] == 0x00 &&
   13254:	7da3      	ldrb	r3, [r4, #22]
   13256:	b94b      	cbnz	r3, 1326c <net_arp_input+0x126>
	    addr->addr[4] == 0x00 &&
   13258:	7de3      	ldrb	r3, [r4, #23]
   1325a:	b93b      	cbnz	r3, 1326c <net_arp_input+0x126>
			arp_update(net_pkt_iface(pkt),
   1325c:	2201      	movs	r2, #1
   1325e:	9200      	str	r2, [sp, #0]
   13260:	f104 010e 	add.w	r1, r4, #14
   13264:	463a      	mov	r2, r7
   13266:	6a68      	ldr	r0, [r5, #36]	; 0x24
   13268:	f7f7 f93c 	bl	a4e4 <arp_update>
		reply = arp_prepare_reply(net_pkt_iface(pkt), pkt, eth_hdr);
   1326c:	6a6f      	ldr	r7, [r5, #36]	; 0x24
	pkt = net_pkt_alloc_with_buffer(iface, sizeof(struct net_arp_hdr),
   1326e:	2364      	movs	r3, #100	; 0x64
   13270:	9300      	str	r3, [sp, #0]
   13272:	2300      	movs	r3, #0
   13274:	461a      	mov	r2, r3
   13276:	211c      	movs	r1, #28
   13278:	4638      	mov	r0, r7
   1327a:	f7f8 fa83 	bl	b784 <net_pkt_alloc_with_buffer>
	if (!pkt) {
   1327e:	4604      	mov	r4, r0
   13280:	2800      	cmp	r0, #0
   13282:	d096      	beq.n	131b2 <net_arp_input+0x6c>
	net_buf_add(pkt->buffer, sizeof(struct net_arp_hdr));
   13284:	6940      	ldr	r0, [r0, #20]
   13286:	211c      	movs	r1, #28
   13288:	3008      	adds	r0, #8
   1328a:	f7ff ff0d 	bl	130a8 <net_buf_simple_add>
	return pkt->frags->data;
   1328e:	6963      	ldr	r3, [r4, #20]
   13290:	696a      	ldr	r2, [r5, #20]
   13292:	689b      	ldr	r3, [r3, #8]
   13294:	6890      	ldr	r0, [r2, #8]
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
   13296:	2201      	movs	r2, #1
   13298:	705a      	strb	r2, [r3, #1]
   1329a:	2100      	movs	r1, #0
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
   1329c:	2208      	movs	r2, #8
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
   1329e:	7019      	strb	r1, [r3, #0]
	hdr->protocol = htons(NET_ETH_PTYPE_IP);
   132a0:	709a      	strb	r2, [r3, #2]
   132a2:	70d9      	strb	r1, [r3, #3]
	hdr->opcode = htons(NET_ARP_REPLY);
   132a4:	7199      	strb	r1, [r3, #6]
	hdr->hwlen = sizeof(struct net_eth_addr);
   132a6:	2206      	movs	r2, #6
	hdr->opcode = htons(NET_ARP_REPLY);
   132a8:	2102      	movs	r1, #2
	hdr->protolen = sizeof(struct in_addr);
   132aa:	f04f 0c04 	mov.w	ip, #4
	hdr->hwlen = sizeof(struct net_eth_addr);
   132ae:	711a      	strb	r2, [r3, #4]
	hdr->protolen = sizeof(struct in_addr);
   132b0:	f883 c005 	strb.w	ip, [r3, #5]
	hdr->opcode = htons(NET_ARP_REPLY);
   132b4:	71d9      	strb	r1, [r3, #7]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   132b6:	f8d6 c000 	ldr.w	ip, [r6]
   132ba:	f8c3 c012 	str.w	ip, [r3, #18]
	memcpy(&hdr->dst_hwaddr.addr, &eth_query->src.addr,
   132be:	f103 0112 	add.w	r1, r3, #18
   132c2:	88b6      	ldrh	r6, [r6, #4]
   132c4:	808e      	strh	r6, [r1, #4]
	memcpy(&hdr->src_hwaddr.addr, net_if_get_link_addr(iface)->addr,
   132c6:	683e      	ldr	r6, [r7, #0]
   132c8:	6936      	ldr	r6, [r6, #16]
   132ca:	f8d6 c000 	ldr.w	ip, [r6]
   132ce:	f8c3 c008 	str.w	ip, [r3, #8]
   132d2:	88b6      	ldrh	r6, [r6, #4]
   132d4:	819e      	strh	r6, [r3, #12]
	net_ipaddr_copy(&hdr->dst_ipaddr, &query->src_ipaddr);
   132d6:	f8d0 600e 	ldr.w	r6, [r0, #14]
   132da:	619e      	str	r6, [r3, #24]
	net_ipaddr_copy(&hdr->src_ipaddr, &query->dst_ipaddr);
   132dc:	6980      	ldr	r0, [r0, #24]
   132de:	f8c3 000e 	str.w	r0, [r3, #14]
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
   132e2:	683b      	ldr	r3, [r7, #0]
			net_if_queue_tx(net_pkt_iface(reply), reply);
   132e4:	6a60      	ldr	r0, [r4, #36]	; 0x24
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
   132e6:	691b      	ldr	r3, [r3, #16]
   132e8:	62e3      	str	r3, [r4, #44]	; 0x2c
	net_pkt_lladdr_dst(pkt)->addr = (u8_t *)&hdr->dst_hwaddr.addr;
   132ea:	6361      	str	r1, [r4, #52]	; 0x34
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
   132ec:	f884 2030 	strb.w	r2, [r4, #48]	; 0x30
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
   132f0:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
			net_if_queue_tx(net_pkt_iface(reply), reply);
   132f4:	4621      	mov	r1, r4
   132f6:	f7f7 fe9d 	bl	b034 <net_if_queue_tx>
   132fa:	e75a      	b.n	131b2 <net_arp_input+0x6c>
		if (net_ipv4_is_my_addr(&arp_hdr->dst_ipaddr)) {
   132fc:	f104 0618 	add.w	r6, r4, #24
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
   13300:	4630      	mov	r0, r6
   13302:	f7f7 ff49 	bl	b198 <net_if_ipv4_addr_lookup>
   13306:	2800      	cmp	r0, #0
   13308:	bf14      	ite	ne
   1330a:	2001      	movne	r0, #1
   1330c:	2000      	moveq	r0, #0
	if (!ret) {
   1330e:	d110      	bne.n	13332 <net_arp_input+0x1ec>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   13310:	f7f8 fc20 	bl	bb54 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   13314:	69a2      	ldr	r2, [r4, #24]
   13316:	6803      	ldr	r3, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   13318:	429a      	cmp	r2, r3
   1331a:	d106      	bne.n	1332a <net_arp_input+0x1e4>
			arp_update(net_pkt_iface(pkt),
   1331c:	2300      	movs	r3, #0
   1331e:	9300      	str	r3, [sp, #0]
   13320:	f104 0208 	add.w	r2, r4, #8
   13324:	f104 010e 	add.w	r1, r4, #14
   13328:	e767      	b.n	131fa <net_arp_input+0xb4>
	return net_if_ipv4_is_addr_bcast(iface, addr);
   1332a:	4631      	mov	r1, r6
   1332c:	2000      	movs	r0, #0
   1332e:	f7f7 feb3 	bl	b098 <net_if_ipv4_is_addr_bcast>
		if (net_ipv4_is_my_addr(&arp_hdr->dst_ipaddr)) {
   13332:	2800      	cmp	r0, #0
   13334:	f43f af3d 	beq.w	131b2 <net_arp_input+0x6c>
   13338:	e7f0      	b.n	1331c <net_arp_input+0x1d6>

0001333a <net_eth_get_hw_capabilities>:
	return iface->if_dev->dev;
   1333a:	6803      	ldr	r3, [r0, #0]
   1333c:	6818      	ldr	r0, [r3, #0]
enum ethernet_hw_caps net_eth_get_hw_capabilities(struct net_if *iface)
{
	const struct ethernet_api *eth =
		(struct ethernet_api *)net_if_get_device(iface)->driver_api;

	if (!eth->get_capabilities) {
   1333e:	6843      	ldr	r3, [r0, #4]
   13340:	68db      	ldr	r3, [r3, #12]
   13342:	b103      	cbz	r3, 13346 <net_eth_get_hw_capabilities+0xc>
		return (enum ethernet_hw_caps)0;
	}

	return eth->get_capabilities(net_if_get_device(iface));
   13344:	4718      	bx	r3
}
   13346:	4618      	mov	r0, r3
   13348:	4770      	bx	lr

0001334a <ethernet_flags>:
	return iface->if_dev->l2_data;
   1334a:	6803      	ldr	r3, [r0, #0]

enum net_l2_flags ethernet_flags(struct net_if *iface)
{
	struct ethernet_context *ctx = net_if_l2_data(iface);

	return ctx->ethernet_l2_flags;
   1334c:	689b      	ldr	r3, [r3, #8]
}
   1334e:	7c18      	ldrb	r0, [r3, #16]
   13350:	4770      	bx	lr

00013352 <ethernet_enable>:
{
   13352:	b538      	push	{r3, r4, r5, lr}
	return iface->if_dev->dev;
   13354:	6803      	ldr	r3, [r0, #0]
   13356:	681a      	ldr	r2, [r3, #0]
   13358:	4605      	mov	r5, r0
	const struct ethernet_api *eth =
   1335a:	6854      	ldr	r4, [r2, #4]
	if (!state) {
   1335c:	b941      	cbnz	r1, 13370 <ethernet_enable+0x1e>
		net_arp_clear_cache(iface);
   1335e:	f7f7 fa25 	bl	a7ac <net_arp_clear_cache>
		if (eth->stop) {
   13362:	68a3      	ldr	r3, [r4, #8]
   13364:	b113      	cbz	r3, 1336c <ethernet_enable+0x1a>
   13366:	682a      	ldr	r2, [r5, #0]
			eth->stop(net_if_get_device(iface));
   13368:	6810      	ldr	r0, [r2, #0]
			eth->start(net_if_get_device(iface));
   1336a:	4798      	blx	r3
}
   1336c:	2000      	movs	r0, #0
   1336e:	bd38      	pop	{r3, r4, r5, pc}
		if (eth->start) {
   13370:	6863      	ldr	r3, [r4, #4]
   13372:	2b00      	cmp	r3, #0
   13374:	d0fa      	beq.n	1336c <ethernet_enable+0x1a>
			eth->start(net_if_get_device(iface));
   13376:	4610      	mov	r0, r2
   13378:	e7f7      	b.n	1336a <ethernet_enable+0x18>

0001337a <ethernet_recv>:
{
   1337a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1337c:	694b      	ldr	r3, [r1, #20]
   1337e:	689d      	ldr	r5, [r3, #8]
	u16_t type = ntohs(hdr->type);
   13380:	89ab      	ldrh	r3, [r5, #12]
   13382:	021e      	lsls	r6, r3, #8
   13384:	ea46 2613 	orr.w	r6, r6, r3, lsr #8
   13388:	b2b6      	uxth	r6, r6
	switch (type) {
   1338a:	f640 0306 	movw	r3, #2054	; 0x806
   1338e:	429e      	cmp	r6, r3
{
   13390:	460c      	mov	r4, r1
	switch (type) {
   13392:	d006      	beq.n	133a2 <ethernet_recv+0x28>
   13394:	f248 63dd 	movw	r3, #34525	; 0x86dd
   13398:	429e      	cmp	r6, r3
   1339a:	d035      	beq.n	13408 <ethernet_recv+0x8e>
   1339c:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
   133a0:	d141      	bne.n	13426 <ethernet_recv+0xac>
	pkt->family = family;
   133a2:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   133a6:	2701      	movs	r7, #1
   133a8:	f367 0343 	bfi	r3, r7, #1, #3
   133ac:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	lladdr->addr = hdr->src.addr;
   133b0:	1dab      	adds	r3, r5, #6
   133b2:	62e3      	str	r3, [r4, #44]	; 0x2c
	lladdr->len = sizeof(struct net_eth_addr);
   133b4:	f240 3306 	movw	r3, #774	; 0x306
   133b8:	8623      	strh	r3, [r4, #48]	; 0x30
	lladdr->addr = hdr->dst.addr;
   133ba:	6365      	str	r5, [r4, #52]	; 0x34
	lladdr->len = sizeof(struct net_eth_addr);
   133bc:	8723      	strh	r3, [r4, #56]	; 0x38
	if (addr->addr[0] == 0xff &&
   133be:	782b      	ldrb	r3, [r5, #0]
   133c0:	2bff      	cmp	r3, #255	; 0xff
   133c2:	d125      	bne.n	13410 <ethernet_recv+0x96>
   133c4:	786b      	ldrb	r3, [r5, #1]
   133c6:	2bff      	cmp	r3, #255	; 0xff
   133c8:	d129      	bne.n	1341e <ethernet_recv+0xa4>
	    addr->addr[1] == 0xff &&
   133ca:	78ab      	ldrb	r3, [r5, #2]
   133cc:	2bff      	cmp	r3, #255	; 0xff
   133ce:	d126      	bne.n	1341e <ethernet_recv+0xa4>
	    addr->addr[2] == 0xff &&
   133d0:	78eb      	ldrb	r3, [r5, #3]
   133d2:	2bff      	cmp	r3, #255	; 0xff
   133d4:	d123      	bne.n	1341e <ethernet_recv+0xa4>
	    addr->addr[3] == 0xff &&
   133d6:	792b      	ldrb	r3, [r5, #4]
   133d8:	2bff      	cmp	r3, #255	; 0xff
   133da:	d120      	bne.n	1341e <ethernet_recv+0xa4>
	    addr->addr[4] == 0xff &&
   133dc:	796b      	ldrb	r3, [r5, #5]
   133de:	2bff      	cmp	r3, #255	; 0xff
   133e0:	d11d      	bne.n	1341e <ethernet_recv+0xa4>
	ethernet_update_rx_stats(iface, pkt, net_pkt_get_len(pkt));
   133e2:	6960      	ldr	r0, [r4, #20]
   133e4:	4603      	mov	r3, r0
	while (buf) {
   133e6:	bb53      	cbnz	r3, 1343e <ethernet_recv+0xc4>
	net_buf_pull(pkt->frags, hdr_len);
   133e8:	210e      	movs	r1, #14
   133ea:	3008      	adds	r0, #8
   133ec:	f7ff fe62 	bl	130b4 <net_buf_simple_pull>
	if (family == AF_INET && type == NET_ETH_PTYPE_ARP) {
   133f0:	2f01      	cmp	r7, #1
   133f2:	d126      	bne.n	13442 <ethernet_recv+0xc8>
   133f4:	f640 0306 	movw	r3, #2054	; 0x806
   133f8:	429e      	cmp	r6, r3
   133fa:	d122      	bne.n	13442 <ethernet_recv+0xc8>
		return net_arp_input(pkt, hdr);
   133fc:	4629      	mov	r1, r5
   133fe:	4620      	mov	r0, r4
}
   13400:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		return net_arp_input(pkt, hdr);
   13404:	f7ff be9f 	b.w	13146 <net_arp_input>
   13408:	f891 3043 	ldrb.w	r3, [r1, #67]	; 0x43
   1340c:	2702      	movs	r7, #2
   1340e:	e7cb      	b.n	133a8 <ethernet_recv+0x2e>
	if (addr->addr[0] == 0x01 &&
   13410:	2b01      	cmp	r3, #1
   13412:	d104      	bne.n	1341e <ethernet_recv+0xa4>
   13414:	786b      	ldrb	r3, [r5, #1]
   13416:	b913      	cbnz	r3, 1341e <ethernet_recv+0xa4>
	    addr->addr[1] == 0x00 &&
   13418:	78ab      	ldrb	r3, [r5, #2]
   1341a:	2b5e      	cmp	r3, #94	; 0x5e
   1341c:	e7e0      	b.n	133e0 <ethernet_recv+0x66>
	    !net_linkaddr_cmp(net_if_get_link_addr(iface), lladdr)) {
   1341e:	6803      	ldr	r3, [r0, #0]
 * @return True if the addresses are the same, false otherwise.
 */
static inline bool net_linkaddr_cmp(struct net_linkaddr *lladdr1,
				    struct net_linkaddr *lladdr2)
{
	if (!lladdr1 || !lladdr2) {
   13420:	f113 0f10 	cmn.w	r3, #16
   13424:	d101      	bne.n	1342a <ethernet_recv+0xb0>
	return NET_DROP;
   13426:	2002      	movs	r0, #2
   13428:	e021      	b.n	1346e <ethernet_recv+0xf4>
		return false;
	}

	if (lladdr1->len != lladdr2->len) {
   1342a:	7d1a      	ldrb	r2, [r3, #20]
   1342c:	2a06      	cmp	r2, #6
   1342e:	d1fa      	bne.n	13426 <ethernet_recv+0xac>
		return false;
	}

	return !memcmp(lladdr1->addr, lladdr2->addr, lladdr1->len);
   13430:	4629      	mov	r1, r5
   13432:	6918      	ldr	r0, [r3, #16]
   13434:	f7ee fe90 	bl	2158 <memcmp>
		    (struct net_eth_addr *)lladdr->addr) &&
   13438:	2800      	cmp	r0, #0
   1343a:	d0d2      	beq.n	133e2 <ethernet_recv+0x68>
   1343c:	e7f3      	b.n	13426 <ethernet_recv+0xac>
		buf = buf->frags;
   1343e:	681b      	ldr	r3, [r3, #0]
   13440:	e7d1      	b.n	133e6 <ethernet_recv+0x6c>
	return pkt->family;
   13442:	6962      	ldr	r2, [r4, #20]
   13444:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   13448:	6891      	ldr	r1, [r2, #8]
	if (net_pkt_family(pkt) == AF_INET) {
   1344a:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1344e:	2b01      	cmp	r3, #1
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
   13450:	bf15      	itete	ne
   13452:	8889      	ldrhne	r1, [r1, #4]
		len = ntohs(NET_IPV4_HDR(pkt)->len);
   13454:	8849      	ldrheq	r1, [r1, #2]
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
   13456:	020b      	lslne	r3, r1, #8
		len = ntohs(NET_IPV4_HDR(pkt)->len);
   13458:	020b      	lsleq	r3, r1, #8
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
   1345a:	bf16      	itet	ne
   1345c:	ea43 2311 	orrne.w	r3, r3, r1, lsr #8
		len = ntohs(NET_IPV4_HDR(pkt)->len);
   13460:	ea43 2311 	orreq.w	r3, r3, r1, lsr #8
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
   13464:	3328      	addne	r3, #40	; 0x28
   13466:	b29b      	uxth	r3, r3
	if (len < NET_ETH_MINIMAL_FRAME_SIZE - sizeof(struct net_eth_hdr)) {
   13468:	2b2d      	cmp	r3, #45	; 0x2d
   1346a:	d901      	bls.n	13470 <ethernet_recv+0xf6>
	return NET_CONTINUE;
   1346c:	2001      	movs	r0, #1
}
   1346e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (frag->len < len) {
   13470:	8991      	ldrh	r1, [r2, #12]
   13472:	428b      	cmp	r3, r1
				frag->len = len;
   13474:	bf98      	it	ls
   13476:	8193      	strhls	r3, [r2, #12]
		for (frag = pkt->frags; frag; frag = frag->frags) {
   13478:	6812      	ldr	r2, [r2, #0]
				len -= frag->len;
   1347a:	bf86      	itte	hi
   1347c:	1a5b      	subhi	r3, r3, r1
   1347e:	b29b      	uxthhi	r3, r3
				len = 0U;
   13480:	2300      	movls	r3, #0
		for (frag = pkt->frags; frag; frag = frag->frags) {
   13482:	2a00      	cmp	r2, #0
   13484:	d1f4      	bne.n	13470 <ethernet_recv+0xf6>
   13486:	e7f1      	b.n	1346c <ethernet_recv+0xf2>

00013488 <ethernet_init>:
	return iface->if_dev->l2_data;
   13488:	6803      	ldr	r3, [r0, #0]
	return net_mgmt(NET_REQUEST_ETHERNET_SET_PROMISC_MODE, iface,
			&params, sizeof(struct ethernet_req_params));
}

void ethernet_init(struct net_if *iface)
{
   1348a:	b510      	push	{r4, lr}
   1348c:	689c      	ldr	r4, [r3, #8]
	int i;
#endif

	NET_DBG("Initializing Ethernet L2 %p for iface %p", ctx, iface);

	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
   1348e:	2301      	movs	r3, #1
   13490:	7423      	strb	r3, [r4, #16]

	if (net_eth_get_hw_capabilities(iface) & ETHERNET_PROMISC_MODE) {
   13492:	f7ff ff52 	bl	1333a <net_eth_get_hw_capabilities>
   13496:	0543      	lsls	r3, r0, #21
		ctx->ethernet_l2_flags |= NET_L2_PROMISC_MODE;
   13498:	bf42      	ittt	mi
   1349a:	7c23      	ldrbmi	r3, [r4, #16]
   1349c:	f043 0304 	orrmi.w	r3, r3, #4
   134a0:	7423      	strbmi	r3, [r4, #16]
			break;
		}
	}
#endif

	net_arp_init();
   134a2:	f7f7 f9e1 	bl	a868 <net_arp_init>

	ctx->is_init = true;
   134a6:	2301      	movs	r3, #1
   134a8:	7463      	strb	r3, [r4, #17]
}
   134aa:	bd10      	pop	{r4, pc}

000134ac <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
   134ac:	6800      	ldr	r0, [r0, #0]
   134ae:	ba00      	rev	r0, r0
   134b0:	f000 4060 	and.w	r0, r0, #3758096384	; 0xe0000000
}
   134b4:	f100 5300 	add.w	r3, r0, #536870912	; 0x20000000
   134b8:	4258      	negs	r0, r3
   134ba:	4158      	adcs	r0, r3
   134bc:	4770      	bx	lr

000134be <k_mutex_lock.constprop.26>:
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
   134be:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   134c2:	f7fb bcd3 	b.w	ee6c <z_impl_k_mutex_lock>

000134c6 <net_context_ref>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   134c6:	1d03      	adds	r3, r0, #4
   134c8:	f3bf 8f5b 	dmb	ish
   134cc:	e853 0f00 	ldrex	r0, [r3]
   134d0:	1c42      	adds	r2, r0, #1
   134d2:	e843 2100 	strex	r1, r2, [r3]
   134d6:	2900      	cmp	r1, #0
   134d8:	d1f8      	bne.n	134cc <net_context_ref+0x6>
   134da:	f3bf 8f5b 	dmb	ish
}
   134de:	3001      	adds	r0, #1
   134e0:	4770      	bx	lr

000134e2 <net_context_unref>:
{
   134e2:	b538      	push	{r3, r4, r5, lr}
   134e4:	4604      	mov	r4, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   134e6:	1d03      	adds	r3, r0, #4
   134e8:	f3bf 8f5b 	dmb	ish
   134ec:	e853 0f00 	ldrex	r0, [r3]
   134f0:	1e42      	subs	r2, r0, #1
   134f2:	e843 2100 	strex	r1, r2, [r3]
   134f6:	2900      	cmp	r1, #0
   134f8:	d1f8      	bne.n	134ec <net_context_unref+0xa>
   134fa:	f3bf 8f5b 	dmb	ish
	if (old_rc != 1) {
   134fe:	2801      	cmp	r0, #1
   13500:	d001      	beq.n	13506 <net_context_unref+0x24>
		return old_rc - 1;
   13502:	3801      	subs	r0, #1
}
   13504:	bd38      	pop	{r3, r4, r5, pc}
	k_mutex_lock(&context->lock, K_FOREVER);
   13506:	f104 0508 	add.w	r5, r4, #8
   1350a:	4628      	mov	r0, r5
   1350c:	f7ff ffd7 	bl	134be <k_mutex_lock.constprop.26>
	net_tcp_unref(context);
   13510:	4620      	mov	r0, r4
   13512:	f7f9 fd69 	bl	cfe8 <net_tcp_unref>
	if (context->conn_handler) {
   13516:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   13518:	b118      	cbz	r0, 13522 <net_context_unref+0x40>
		net_conn_unregister(context->conn_handler);
   1351a:	f7f8 fcef 	bl	befc <net_conn_unregister>
		context->conn_handler = NULL;
   1351e:	2300      	movs	r3, #0
   13520:	62e3      	str	r3, [r4, #44]	; 0x2c
	context->flags &= ~NET_CONTEXT_IN_USE;
   13522:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
   13526:	f023 0307 	bic.w	r3, r3, #7
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
   1352a:	4628      	mov	r0, r5
   1352c:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
   13530:	f7fb fd0c 	bl	ef4c <z_impl_k_mutex_unlock>
   13534:	2000      	movs	r0, #0
   13536:	e7e5      	b.n	13504 <net_context_unref+0x22>

00013538 <bind_default>:
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
   13538:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
	if (family == AF_INET) {
   1353c:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   13540:	2b01      	cmp	r3, #1
{
   13542:	b513      	push	{r0, r1, r4, lr}
   13544:	4604      	mov	r4, r0
	if (family == AF_INET) {
   13546:	d112      	bne.n	1356e <bind_default+0x36>
		if (net_sin_ptr(&context->local)->sin_addr) {
   13548:	6a02      	ldr	r2, [r0, #32]
   1354a:	b972      	cbnz	r2, 1356a <bind_default+0x32>
			find_available_port(context,
   1354c:	4669      	mov	r1, sp
		addr4.sin_addr.s_addr = INADDR_ANY;
   1354e:	9201      	str	r2, [sp, #4]
		addr4.sin_family = AF_INET;
   13550:	f8ad 3000 	strh.w	r3, [sp]
			find_available_port(context,
   13554:	f7f7 fa8e 	bl	aa74 <find_available_port>
		return net_context_bind(context, (struct sockaddr *)&addr4,
   13558:	2208      	movs	r2, #8
		addr4.sin_port =
   1355a:	f8ad 0002 	strh.w	r0, [sp, #2]
		return net_context_bind(context, (struct sockaddr *)&addr4,
   1355e:	4669      	mov	r1, sp
   13560:	4620      	mov	r0, r4
   13562:	f7f7 fbd7 	bl	ad14 <net_context_bind>
}
   13566:	b002      	add	sp, #8
   13568:	bd10      	pop	{r4, pc}
			return 0;
   1356a:	2000      	movs	r0, #0
   1356c:	e7fb      	b.n	13566 <bind_default+0x2e>
	return -EINVAL;
   1356e:	f06f 0015 	mvn.w	r0, #21
   13572:	e7f8      	b.n	13566 <bind_default+0x2e>

00013574 <net_context_listen>:
{
   13574:	b538      	push	{r3, r4, r5, lr}
	if (!net_context_is_used(context)) {
   13576:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
   1357a:	07db      	lsls	r3, r3, #31
{
   1357c:	4605      	mov	r5, r0
	if (!net_context_is_used(context)) {
   1357e:	d513      	bpl.n	135a8 <net_context_listen+0x34>
	k_mutex_lock(&context->lock, K_FOREVER);
   13580:	f100 0408 	add.w	r4, r0, #8
   13584:	4620      	mov	r0, r4
   13586:	f7ff ff9a 	bl	134be <k_mutex_lock.constprop.26>
	if (net_tcp_listen(context) >= 0) {
   1358a:	4628      	mov	r0, r5
   1358c:	f001 fd01 	bl	14f92 <net_tcp_listen>
   13590:	2800      	cmp	r0, #0
   13592:	4620      	mov	r0, r4
   13594:	db03      	blt.n	1359e <net_context_listen+0x2a>
   13596:	f7fb fcd9 	bl	ef4c <z_impl_k_mutex_unlock>
		return 0;
   1359a:	2000      	movs	r0, #0
}
   1359c:	bd38      	pop	{r3, r4, r5, pc}
   1359e:	f7fb fcd5 	bl	ef4c <z_impl_k_mutex_unlock>
	return -EOPNOTSUPP;
   135a2:	f06f 005e 	mvn.w	r0, #94	; 0x5e
   135a6:	e7f9      	b.n	1359c <net_context_listen+0x28>
		return -EBADF;
   135a8:	f06f 0008 	mvn.w	r0, #8
   135ac:	e7f6      	b.n	1359c <net_context_listen+0x28>

000135ae <net_context_create_ipv4_new>:
{
   135ae:	b570      	push	{r4, r5, r6, lr}
   135b0:	460c      	mov	r4, r1
   135b2:	4606      	mov	r6, r0
   135b4:	461d      	mov	r5, r3
	if (!src) {
   135b6:	4611      	mov	r1, r2
   135b8:	b902      	cbnz	r2, 135bc <net_context_create_ipv4_new+0xe>
		src = ((struct sockaddr_in_ptr *)&context->local)->sin_addr;
   135ba:	6a01      	ldr	r1, [r0, #32]
	return UNALIGNED_GET(&addr->s_addr) == 0;
   135bc:	680b      	ldr	r3, [r1, #0]
	if (net_ipv4_is_addr_unspecified(src)
   135be:	b11b      	cbz	r3, 135c8 <net_context_create_ipv4_new+0x1a>
	    || net_ipv4_is_addr_mcast(src)) {
   135c0:	4608      	mov	r0, r1
   135c2:	f7ff ff73 	bl	134ac <net_ipv4_is_addr_mcast>
   135c6:	b130      	cbz	r0, 135d6 <net_context_create_ipv4_new+0x28>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
   135c8:	4629      	mov	r1, r5
   135ca:	6a60      	ldr	r0, [r4, #36]	; 0x24
   135cc:	f7f7 fd96 	bl	b0fc <net_if_ipv4_select_src_addr>
   135d0:	6803      	ldr	r3, [r0, #0]
   135d2:	4601      	mov	r1, r0
		if (net_ipv4_is_addr_unspecified(src)) {
   135d4:	b14b      	cbz	r3, 135ea <net_context_create_ipv4_new+0x3c>
	net_pkt_set_ipv4_ttl(pkt, net_context_get_ipv4_ttl(context));
   135d6:	f896 3071 	ldrb.w	r3, [r6, #113]	; 0x71
	pkt->ipv4_ttl = ttl;
   135da:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	return net_ipv4_create(pkt, src, dst);
   135de:	462a      	mov	r2, r5
   135e0:	4620      	mov	r0, r4
}
   135e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return net_ipv4_create(pkt, src, dst);
   135e6:	f001 b81f 	b.w	14628 <net_ipv4_create>
}
   135ea:	f06f 0015 	mvn.w	r0, #21
   135ee:	bd70      	pop	{r4, r5, r6, pc}

000135f0 <context_sendto.isra.23>:
static int context_sendto(struct net_context *context,
   135f0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   135f4:	461f      	mov	r7, r3
	if (!net_context_is_used(context)) {
   135f6:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
static int context_sendto(struct net_context *context,
   135fa:	4693      	mov	fp, r2
	if (!net_context_is_used(context)) {
   135fc:	07da      	lsls	r2, r3, #31
static int context_sendto(struct net_context *context,
   135fe:	4605      	mov	r5, r0
   13600:	468a      	mov	sl, r1
   13602:	e9dd 890d 	ldrd	r8, r9, [sp, #52]	; 0x34
	if (!net_context_is_used(context)) {
   13606:	f140 8093 	bpl.w	13730 <context_sendto.isra.23+0x140>
	if (!dst_addr &&
   1360a:	2f00      	cmp	r7, #0
   1360c:	f000 8096 	beq.w	1373c <context_sendto.isra.23+0x14c>
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   13610:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   13614:	2b01      	cmp	r3, #1
   13616:	f040 808e 	bne.w	13736 <context_sendto.isra.23+0x146>
		if (addrlen < sizeof(struct sockaddr_in)) {
   1361a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1361c:	2b07      	cmp	r3, #7
   1361e:	f240 808a 	bls.w	13736 <context_sendto.isra.23+0x146>
		if (!addr4->sin_addr.s_addr) {
   13622:	687b      	ldr	r3, [r7, #4]
   13624:	2b00      	cmp	r3, #0
   13626:	f000 8089 	beq.w	1373c <context_sendto.isra.23+0x14c>
	return net_if_get_by_index(context->iface);
   1362a:	f990 0070 	ldrsb.w	r0, [r0, #112]	; 0x70
   1362e:	f7f7 fef9 	bl	b424 <net_if_get_by_index>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
   13632:	f8b5 206e 	ldrh.w	r2, [r5, #110]	; 0x6e
	pkt = net_pkt_alloc_with_buffer(net_context_get_iface(context), len,
   13636:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1363a:	9300      	str	r3, [sp, #0]
   1363c:	f3c2 02c2 	ubfx	r2, r2, #3, #3
   13640:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
   13644:	4659      	mov	r1, fp
   13646:	f7f8 f89d 	bl	b784 <net_pkt_alloc_with_buffer>
	if (pkt) {
   1364a:	4606      	mov	r6, r0
   1364c:	2800      	cmp	r0, #0
   1364e:	d078      	beq.n	13742 <context_sendto.isra.23+0x152>
	pkt->context = ctx;
   13650:	6205      	str	r5, [r0, #32]
	tmp_len = net_pkt_available_payload_buffer(
   13652:	f895 106c 	ldrb.w	r1, [r5, #108]	; 0x6c
   13656:	f000 fbc0 	bl	13dda <net_pkt_available_payload_buffer>
	    net_context_get_ip_proto(context) == IPPROTO_UDP) {
   1365a:	f8b5 306c 	ldrh.w	r3, [r5, #108]	; 0x6c
	context->send_cb = cb;
   1365e:	f8c5 8034 	str.w	r8, [r5, #52]	; 0x34
   13662:	4583      	cmp	fp, r0
   13664:	bf28      	it	cs
   13666:	4683      	movcs	fp, r0
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
   13668:	2b11      	cmp	r3, #17
	context->user_data = user_data;
   1366a:	f8c5 9000 	str.w	r9, [r5]
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
   1366e:	d141      	bne.n	136f4 <context_sendto.isra.23+0x104>
   13670:	f8b5 306e 	ldrh.w	r3, [r5, #110]	; 0x6e
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   13674:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   13678:	2b01      	cmp	r3, #1
   1367a:	d153      	bne.n	13724 <context_sendto.isra.23+0x134>
		ret = net_context_create_ipv4_new(context, pkt,
   1367c:	1d3b      	adds	r3, r7, #4
   1367e:	2200      	movs	r2, #0
   13680:	4631      	mov	r1, r6
   13682:	4628      	mov	r0, r5
		dst_port = addr4->sin_port;
   13684:	f8b7 8002 	ldrh.w	r8, [r7, #2]
		ret = net_context_create_ipv4_new(context, pkt,
   13688:	f7ff ff91 	bl	135ae <net_context_create_ipv4_new>
	if (ret < 0) {
   1368c:	1e04      	subs	r4, r0, #0
   1368e:	db2d      	blt.n	136ec <context_sendto.isra.23+0xfc>
	ret = bind_default(context);
   13690:	4628      	mov	r0, r5
   13692:	f7ff ff51 	bl	13538 <bind_default>
	if (ret) {
   13696:	4604      	mov	r4, r0
   13698:	bb30      	cbnz	r0, 136e8 <context_sendto.isra.23+0xf8>
	ret = net_udp_create(pkt,
   1369a:	4642      	mov	r2, r8
   1369c:	8be9      	ldrh	r1, [r5, #30]
   1369e:	4630      	mov	r0, r6
   136a0:	f001 fcaa 	bl	14ff8 <net_udp_create>
	if (ret) {
   136a4:	4604      	mov	r4, r0
   136a6:	b9f8      	cbnz	r0, 136e8 <context_sendto.isra.23+0xf8>
	ret = net_pkt_write(pkt, buf, len);
   136a8:	465a      	mov	r2, fp
   136aa:	4651      	mov	r1, sl
   136ac:	4630      	mov	r0, r6
   136ae:	f000 fcef 	bl	14090 <net_pkt_write>
	if (ret) {
   136b2:	4604      	mov	r4, r0
   136b4:	b9c0      	cbnz	r0, 136e8 <context_sendto.isra.23+0xf8>
	net_pkt_cursor_init(pkt);
   136b6:	4630      	mov	r0, r6
   136b8:	f000 fbc1 	bl	13e3e <net_pkt_cursor_init>
   136bc:	f8b5 306e 	ldrh.w	r3, [r5, #110]	; 0x6e
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   136c0:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   136c4:	2b01      	cmp	r3, #1
   136c6:	d104      	bne.n	136d2 <context_sendto.isra.23+0xe2>
		net_ipv4_finalize(pkt, net_context_get_ip_proto(context));
   136c8:	f895 106c 	ldrb.w	r1, [r5, #108]	; 0x6c
   136cc:	4630      	mov	r0, r6
   136ce:	f000 ffde 	bl	1468e <net_ipv4_finalize>
		ret = net_send_data(pkt);
   136d2:	4630      	mov	r0, r6
   136d4:	f000 f970 	bl	139b8 <net_send_data>
	if (ret < 0) {
   136d8:	2800      	cmp	r0, #0
		ret = net_tcp_send_data(context, cb, user_data);
   136da:	4604      	mov	r4, r0
	if (ret < 0) {
   136dc:	db06      	blt.n	136ec <context_sendto.isra.23+0xfc>
	return len;
   136de:	465c      	mov	r4, fp
}
   136e0:	4620      	mov	r0, r4
   136e2:	b003      	add	sp, #12
   136e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (ret < 0) {
   136e8:	2c00      	cmp	r4, #0
   136ea:	dae4      	bge.n	136b6 <context_sendto.isra.23+0xc6>
	net_pkt_unref(pkt);
   136ec:	4630      	mov	r0, r6
   136ee:	f000 fb32 	bl	13d56 <net_pkt_unref>
	return ret;
   136f2:	e7f5      	b.n	136e0 <context_sendto.isra.23+0xf0>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
   136f4:	2b06      	cmp	r3, #6
   136f6:	d118      	bne.n	1372a <context_sendto.isra.23+0x13a>
		ret = net_pkt_write(pkt, buf, len);
   136f8:	465a      	mov	r2, fp
   136fa:	4651      	mov	r1, sl
   136fc:	4630      	mov	r0, r6
   136fe:	f000 fcc7 	bl	14090 <net_pkt_write>
		if (ret < 0) {
   13702:	1e04      	subs	r4, r0, #0
   13704:	dbf2      	blt.n	136ec <context_sendto.isra.23+0xfc>
		net_pkt_cursor_init(pkt);
   13706:	4630      	mov	r0, r6
   13708:	f000 fb99 	bl	13e3e <net_pkt_cursor_init>
		ret = net_tcp_queue_data(context, pkt);
   1370c:	4631      	mov	r1, r6
   1370e:	4628      	mov	r0, r5
   13710:	f001 fb0b 	bl	14d2a <net_tcp_queue_data>
		if (ret < 0) {
   13714:	1e04      	subs	r4, r0, #0
   13716:	dbe9      	blt.n	136ec <context_sendto.isra.23+0xfc>
		ret = net_tcp_send_data(context, cb, user_data);
   13718:	464a      	mov	r2, r9
   1371a:	4641      	mov	r1, r8
   1371c:	4628      	mov	r0, r5
   1371e:	f001 fa02 	bl	14b26 <net_tcp_send_data>
   13722:	e7d9      	b.n	136d8 <context_sendto.isra.23+0xe8>
	int ret = -EINVAL;
   13724:	f06f 0415 	mvn.w	r4, #21
   13728:	e7e0      	b.n	136ec <context_sendto.isra.23+0xfc>
		ret = -EPROTONOSUPPORT;
   1372a:	f06f 047a 	mvn.w	r4, #122	; 0x7a
   1372e:	e7dd      	b.n	136ec <context_sendto.isra.23+0xfc>
		return -EBADF;
   13730:	f06f 0408 	mvn.w	r4, #8
   13734:	e7d4      	b.n	136e0 <context_sendto.isra.23+0xf0>
		return -EINVAL;
   13736:	f06f 0415 	mvn.w	r4, #21
   1373a:	e7d1      	b.n	136e0 <context_sendto.isra.23+0xf0>
		return -EDESTADDRREQ;
   1373c:	f06f 0478 	mvn.w	r4, #120	; 0x78
   13740:	e7ce      	b.n	136e0 <context_sendto.isra.23+0xf0>
		return -ENOMEM;
   13742:	f06f 040b 	mvn.w	r4, #11
   13746:	e7cb      	b.n	136e0 <context_sendto.isra.23+0xf0>

00013748 <net_context_connect>:
{
   13748:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1374c:	4604      	mov	r4, r0
   1374e:	b086      	sub	sp, #24
	k_mutex_lock(&context->lock, K_FOREVER);
   13750:	f100 0708 	add.w	r7, r0, #8
   13754:	4638      	mov	r0, r7
{
   13756:	4699      	mov	r9, r3
   13758:	460e      	mov	r6, r1
   1375a:	4615      	mov	r5, r2
   1375c:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
	k_mutex_lock(&context->lock, K_FOREVER);
   13760:	f7ff fead 	bl	134be <k_mutex_lock.constprop.26>
	if (!net_context_is_used(context)) {
   13764:	f8b4 006e 	ldrh.w	r0, [r4, #110]	; 0x6e
   13768:	07c3      	lsls	r3, r0, #31
   1376a:	d54f      	bpl.n	1380c <net_context_connect+0xc4>
	if (addr->sa_family != net_context_get_family(context)) {
   1376c:	8833      	ldrh	r3, [r6, #0]
   1376e:	f3c0 01c2 	ubfx	r1, r0, #3, #3
   13772:	428b      	cmp	r3, r1
   13774:	d150      	bne.n	13818 <net_context_connect+0xd0>
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
   13776:	f3c0 0241 	ubfx	r2, r0, #1, #2
   1377a:	2a03      	cmp	r2, #3
   1377c:	d049      	beq.n	13812 <net_context_connect+0xca>
	if (net_context_get_family(context) == AF_INET) {
   1377e:	2b01      	cmp	r3, #1
   13780:	d14a      	bne.n	13818 <net_context_connect+0xd0>
		if (addrlen < sizeof(struct sockaddr_in)) {
   13782:	2d07      	cmp	r5, #7
   13784:	d948      	bls.n	13818 <net_context_connect+0xd0>
   13786:	6872      	ldr	r2, [r6, #4]
   13788:	62a2      	str	r2, [r4, #40]	; 0x28
		addr4->sin_port = net_sin(addr)->sin_port;
   1378a:	f8b6 a002 	ldrh.w	sl, [r6, #2]
   1378e:	f8a4 a026 	strh.w	sl, [r4, #38]	; 0x26
		addr4->sin_family = AF_INET;
   13792:	84a3      	strh	r3, [r4, #36]	; 0x24
		if (addr4->sin_addr.s_addr) {
   13794:	b352      	cbz	r2, 137ec <net_context_connect+0xa4>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
   13796:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   1379a:	f8a4 006e 	strh.w	r0, [r4, #110]	; 0x6e
		ret = bind_default(context);
   1379e:	4620      	mov	r0, r4
   137a0:	f7ff feca 	bl	13538 <bind_default>
		if (ret) {
   137a4:	4605      	mov	r5, r0
   137a6:	b9d0      	cbnz	r0, 137de <net_context_connect+0x96>
		if (net_sin_ptr(&context->local)->sin_addr) {
   137a8:	6a22      	ldr	r2, [r4, #32]
		net_sin(&local_addr)->sin_port = lport =
   137aa:	8be1      	ldrh	r1, [r4, #30]
   137ac:	f8ad 1012 	strh.w	r1, [sp, #18]
		net_sin_ptr(&context->local)->sin_family = AF_INET;
   137b0:	2301      	movs	r3, #1
   137b2:	83a3      	strh	r3, [r4, #28]
		net_sin(&local_addr)->sin_family = AF_INET;
   137b4:	f8ad 3010 	strh.w	r3, [sp, #16]
		if (net_sin_ptr(&context->local)->sin_addr) {
   137b8:	b112      	cbz	r2, 137c0 <net_context_connect+0x78>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
   137ba:	6813      	ldr	r3, [r2, #0]
   137bc:	9305      	str	r3, [sp, #20]
			laddr = &local_addr;
   137be:	aa04      	add	r2, sp, #16
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
   137c0:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
   137c4:	f3c3 1381 	ubfx	r3, r3, #6, #2
	switch (net_context_get_type(context)) {
   137c8:	2b01      	cmp	r3, #1
   137ca:	d013      	beq.n	137f4 <net_context_connect+0xac>
   137cc:	2b02      	cmp	r3, #2
   137ce:	d126      	bne.n	1381e <net_context_connect+0xd6>
		if (cb) {
   137d0:	f1b9 0f00 	cmp.w	r9, #0
   137d4:	d003      	beq.n	137de <net_context_connect+0x96>
			cb(context, 0, user_data);
   137d6:	4642      	mov	r2, r8
   137d8:	2100      	movs	r1, #0
   137da:	4620      	mov	r0, r4
   137dc:	47c8      	blx	r9
   137de:	4638      	mov	r0, r7
   137e0:	f7fb fbb4 	bl	ef4c <z_impl_k_mutex_unlock>
}
   137e4:	4628      	mov	r0, r5
   137e6:	b006      	add	sp, #24
   137e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
   137ec:	f420 7080 	bic.w	r0, r0, #256	; 0x100
   137f0:	b280      	uxth	r0, r0
   137f2:	e7d2      	b.n	1379a <net_context_connect+0x52>
		ret = net_tcp_connect(context, addr, laddr, rport, lport,
   137f4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   137f6:	e9cd 9802 	strd	r9, r8, [sp, #8]
   137fa:	e9cd 1300 	strd	r1, r3, [sp]
   137fe:	4620      	mov	r0, r4
   13800:	4653      	mov	r3, sl
   13802:	4631      	mov	r1, r6
   13804:	f7f9 fc60 	bl	d0c8 <net_tcp_connect>
   13808:	4605      	mov	r5, r0
		goto unlock;
   1380a:	e7e8      	b.n	137de <net_context_connect+0x96>
		ret = -EBADF;
   1380c:	f06f 0508 	mvn.w	r5, #8
   13810:	e7e5      	b.n	137de <net_context_connect+0x96>
		ret = -EOPNOTSUPP;
   13812:	f06f 055e 	mvn.w	r5, #94	; 0x5e
   13816:	e7e2      	b.n	137de <net_context_connect+0x96>
		ret = -EINVAL;
   13818:	f06f 0515 	mvn.w	r5, #21
   1381c:	e7df      	b.n	137de <net_context_connect+0x96>
		ret = -ENOTSUP;
   1381e:	f06f 0585 	mvn.w	r5, #133	; 0x85
   13822:	e7dc      	b.n	137de <net_context_connect+0x96>

00013824 <net_context_accept>:
{
   13824:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13826:	461f      	mov	r7, r3
	if (!net_context_is_used(context)) {
   13828:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
   1382c:	07db      	lsls	r3, r3, #31
{
   1382e:	4604      	mov	r4, r0
   13830:	460e      	mov	r6, r1
	if (!net_context_is_used(context)) {
   13832:	d522      	bpl.n	1387a <net_context_accept+0x56>
	k_mutex_lock(&context->lock, K_FOREVER);
   13834:	f100 0508 	add.w	r5, r0, #8
   13838:	4628      	mov	r0, r5
   1383a:	f7ff fe40 	bl	134be <k_mutex_lock.constprop.26>
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
   1383e:	f8b4 006e 	ldrh.w	r0, [r4, #110]	; 0x6e
   13842:	f3c0 0341 	ubfx	r3, r0, #1, #2
   13846:	2b03      	cmp	r3, #3
   13848:	d003      	beq.n	13852 <net_context_accept+0x2e>
   1384a:	f3c0 1081 	ubfx	r0, r0, #6, #2
   1384e:	2801      	cmp	r0, #1
   13850:	d10e      	bne.n	13870 <net_context_accept+0x4c>
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   13852:	f8b4 306c 	ldrh.w	r3, [r4, #108]	; 0x6c
   13856:	2b06      	cmp	r3, #6
   13858:	d10d      	bne.n	13876 <net_context_accept+0x52>
		ret = net_tcp_accept(context, cb, user_data);
   1385a:	4620      	mov	r0, r4
   1385c:	463a      	mov	r2, r7
   1385e:	4631      	mov	r1, r6
   13860:	f7f9 fbdc 	bl	d01c <net_tcp_accept>
   13864:	4604      	mov	r4, r0
   13866:	4628      	mov	r0, r5
   13868:	f7fb fb70 	bl	ef4c <z_impl_k_mutex_unlock>
}
   1386c:	4620      	mov	r0, r4
   1386e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		ret = -EINVAL;
   13870:	f06f 0415 	mvn.w	r4, #21
   13874:	e7f7      	b.n	13866 <net_context_accept+0x42>
	int ret = 0;
   13876:	2400      	movs	r4, #0
   13878:	e7f5      	b.n	13866 <net_context_accept+0x42>
		return -EBADF;
   1387a:	f06f 0408 	mvn.w	r4, #8
   1387e:	e7f5      	b.n	1386c <net_context_accept+0x48>

00013880 <net_context_send>:
{
   13880:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   13884:	4604      	mov	r4, r0
	k_mutex_lock(&context->lock, K_FOREVER);
   13886:	f100 0508 	add.w	r5, r0, #8
   1388a:	4628      	mov	r0, r5
{
   1388c:	4698      	mov	r8, r3
   1388e:	460e      	mov	r6, r1
   13890:	4617      	mov	r7, r2
	k_mutex_lock(&context->lock, K_FOREVER);
   13892:	f7ff fe14 	bl	134be <k_mutex_lock.constprop.26>
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
   13896:	f8b4 006e 	ldrh.w	r0, [r4, #110]	; 0x6e
   1389a:	05c3      	lsls	r3, r0, #23
   1389c:	d51a      	bpl.n	138d4 <net_context_send+0x54>
   1389e:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   138a0:	b1c3      	cbz	r3, 138d4 <net_context_send+0x54>
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   138a2:	f3c0 00c2 	ubfx	r0, r0, #3, #3
   138a6:	2801      	cmp	r0, #1
	ret = context_sendto(context, buf, len, &context->remote,
   138a8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		addrlen = 0;
   138aa:	bf0c      	ite	eq
   138ac:	2208      	moveq	r2, #8
   138ae:	2200      	movne	r2, #0
	ret = context_sendto(context, buf, len, &context->remote,
   138b0:	e9cd 8301 	strd	r8, r3, [sp, #4]
   138b4:	9200      	str	r2, [sp, #0]
   138b6:	f104 0324 	add.w	r3, r4, #36	; 0x24
   138ba:	4620      	mov	r0, r4
   138bc:	463a      	mov	r2, r7
   138be:	4631      	mov	r1, r6
   138c0:	f7ff fe96 	bl	135f0 <context_sendto.isra.23>
   138c4:	4604      	mov	r4, r0
   138c6:	4628      	mov	r0, r5
   138c8:	f7fb fb40 	bl	ef4c <z_impl_k_mutex_unlock>
}
   138cc:	4620      	mov	r0, r4
   138ce:	b004      	add	sp, #16
   138d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = -EDESTADDRREQ;
   138d4:	f06f 0478 	mvn.w	r4, #120	; 0x78
   138d8:	e7f5      	b.n	138c6 <net_context_send+0x46>

000138da <net_context_sendto>:
{
   138da:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	k_mutex_lock(&context->lock, K_FOREVER);
   138de:	f100 0408 	add.w	r4, r0, #8
{
   138e2:	4605      	mov	r5, r0
	k_mutex_lock(&context->lock, K_FOREVER);
   138e4:	4620      	mov	r0, r4
{
   138e6:	4698      	mov	r8, r3
   138e8:	460e      	mov	r6, r1
   138ea:	4617      	mov	r7, r2
	k_mutex_lock(&context->lock, K_FOREVER);
   138ec:	f7ff fde7 	bl	134be <k_mutex_lock.constprop.26>
	ret = context_sendto(context, buf, len, dst_addr, addrlen,
   138f0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   138f2:	9302      	str	r3, [sp, #8]
   138f4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   138f6:	9301      	str	r3, [sp, #4]
   138f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   138fa:	9300      	str	r3, [sp, #0]
   138fc:	463a      	mov	r2, r7
   138fe:	4643      	mov	r3, r8
   13900:	4631      	mov	r1, r6
   13902:	4628      	mov	r0, r5
   13904:	f7ff fe74 	bl	135f0 <context_sendto.isra.23>
   13908:	4605      	mov	r5, r0
   1390a:	4620      	mov	r0, r4
   1390c:	f7fb fb1e 	bl	ef4c <z_impl_k_mutex_unlock>
}
   13910:	4628      	mov	r0, r5
   13912:	b004      	add	sp, #16
   13914:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00013918 <net_context_update_recv_wnd>:

int net_context_update_recv_wnd(struct net_context *context,
				s32_t delta)
{
   13918:	b570      	push	{r4, r5, r6, lr}
	int ret;

	k_mutex_lock(&context->lock, K_FOREVER);
   1391a:	f100 0408 	add.w	r4, r0, #8
{
   1391e:	4605      	mov	r5, r0
   13920:	460e      	mov	r6, r1
	k_mutex_lock(&context->lock, K_FOREVER);
   13922:	4620      	mov	r0, r4
   13924:	f7ff fdcb 	bl	134be <k_mutex_lock.constprop.26>

	ret = net_tcp_update_recv_wnd(context, delta);
   13928:	4631      	mov	r1, r6
   1392a:	4628      	mov	r0, r5
   1392c:	f7f9 fb16 	bl	cf5c <net_tcp_update_recv_wnd>
   13930:	4605      	mov	r5, r0
   13932:	4620      	mov	r0, r4
   13934:	f7fb fb0a 	bl	ef4c <z_impl_k_mutex_unlock>

	k_mutex_unlock(&context->lock);

	return ret;
}
   13938:	4628      	mov	r0, r5
   1393a:	bd70      	pop	{r4, r5, r6, pc}

0001393c <processing_data>:
	if (!pkt->frags) {
   1393c:	6943      	ldr	r3, [r0, #20]
{
   1393e:	b510      	push	{r4, lr}
   13940:	4604      	mov	r4, r0
	if (!pkt->frags) {
   13942:	b923      	cbnz	r3, 1394e <processing_data+0x12>
		net_pkt_unref(pkt);
   13944:	4620      	mov	r0, r4
}
   13946:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		net_pkt_unref(pkt);
   1394a:	f000 ba04 	b.w	13d56 <net_pkt_unref>
	if (!is_loopback && !locally_routed) {
   1394e:	b169      	cbz	r1, 1396c <processing_data+0x30>
	net_pkt_cursor_init(pkt);
   13950:	4620      	mov	r0, r4
   13952:	f000 fa74 	bl	13e3e <net_pkt_cursor_init>
	return pkt->frags->data;
   13956:	6963      	ldr	r3, [r4, #20]
	switch (NET_IPV6_HDR(pkt)->vtc & 0xf0) {
   13958:	689b      	ldr	r3, [r3, #8]
   1395a:	781b      	ldrb	r3, [r3, #0]
   1395c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   13960:	2b40      	cmp	r3, #64	; 0x40
   13962:	d1ef      	bne.n	13944 <processing_data+0x8>
		return net_ipv4_input(pkt);
   13964:	4620      	mov	r0, r4
   13966:	f7f8 f8f9 	bl	bb5c <net_ipv4_input>
   1396a:	e005      	b.n	13978 <processing_data+0x3c>
		ret = net_if_recv_data(net_pkt_iface(pkt), pkt);
   1396c:	4601      	mov	r1, r0
   1396e:	6a40      	ldr	r0, [r0, #36]	; 0x24
   13970:	f000 f907 	bl	13b82 <net_if_recv_data>
		if (ret != NET_CONTINUE) {
   13974:	2801      	cmp	r0, #1
   13976:	d0eb      	beq.n	13950 <processing_data+0x14>
	switch (process_data(pkt, is_loopback)) {
   13978:	2800      	cmp	r0, #0
   1397a:	d1e3      	bne.n	13944 <processing_data+0x8>
}
   1397c:	bd10      	pop	{r4, pc}

0001397e <net_init>:

	return status;
}

static int net_init(struct device *unused)
{
   1397e:	b508      	push	{r3, lr}
	net_hostname_init();

	NET_DBG("Priority %d", CONFIG_NET_INIT_PRIO);

	net_pkt_init();
   13980:	f000 fba4 	bl	140cc <net_pkt_init>

	net_context_init();
   13984:	f7f7 fad0 	bl	af28 <net_context_init>
	net_icmpv4_init();
   13988:	f7f8 f8ce 	bl	bb28 <net_icmpv4_init>
	net_conn_init();
   1398c:	f000 febf 	bl	1470e <net_conn_init>
	net_tcp_init();
   13990:	f001 f8f4 	bl	14b7c <net_tcp_init>

	l3_init();

	net_mgmt_event_init();
   13994:	f7f8 fa76 	bl	be84 <net_mgmt_event_init>
	net_if_init();
   13998:	f7f7 fdb6 	bl	b508 <net_if_init>
	net_tc_rx_init();
   1399c:	f7f7 ff70 	bl	b880 <net_tc_rx_init>
	net_if_post_init();
   139a0:	f7f7 fe08 	bl	b5b4 <net_if_post_init>

	init_rx_queues();

	return services_init();
}
   139a4:	2000      	movs	r0, #0
   139a6:	bd08      	pop	{r3, pc}

000139a8 <process_rx_packet>:
{
   139a8:	4603      	mov	r3, r0
	pkt = CONTAINER_OF(work, struct net_pkt, work);
   139aa:	3804      	subs	r0, #4
	pkt_len = net_pkt_get_len(pkt);
   139ac:	6919      	ldr	r1, [r3, #16]
	while (buf) {
   139ae:	b909      	cbnz	r1, 139b4 <process_rx_packet+0xc>
	processing_data(pkt, false);
   139b0:	f7ff bfc4 	b.w	1393c <processing_data>
		buf = buf->frags;
   139b4:	6809      	ldr	r1, [r1, #0]
   139b6:	e7fa      	b.n	139ae <process_rx_packet+0x6>

000139b8 <net_send_data>:
{
   139b8:	b570      	push	{r4, r5, r6, lr}
	if (!pkt || !pkt->frags) {
   139ba:	4604      	mov	r4, r0
   139bc:	2800      	cmp	r0, #0
   139be:	d065      	beq.n	13a8c <net_send_data+0xd4>
   139c0:	6943      	ldr	r3, [r0, #20]
   139c2:	2b00      	cmp	r3, #0
   139c4:	d062      	beq.n	13a8c <net_send_data+0xd4>
	if (!net_pkt_iface(pkt)) {
   139c6:	6a43      	ldr	r3, [r0, #36]	; 0x24
   139c8:	2b00      	cmp	r3, #0
   139ca:	d062      	beq.n	13a92 <net_send_data+0xda>
	net_pkt_trim_buffer(pkt);
   139cc:	f000 fa1d 	bl	13e0a <net_pkt_trim_buffer>
	net_pkt_cursor_init(pkt);
   139d0:	4620      	mov	r0, r4
   139d2:	f000 fa34 	bl	13e3e <net_pkt_cursor_init>
	return pkt->family;
   139d6:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
	if (net_pkt_family(pkt) == AF_INET) {
   139da:	f3c3 0342 	ubfx	r3, r3, #1, #3
   139de:	2b01      	cmp	r3, #1
   139e0:	d14a      	bne.n	13a78 <net_send_data+0xc0>
	return pkt->frags->data;
   139e2:	6963      	ldr	r3, [r4, #20]
   139e4:	689d      	ldr	r5, [r3, #8]
		if (net_ipv4_addr_cmp(&NET_IPV4_HDR(pkt)->dst,
   139e6:	f7f8 f8b1 	bl	bb4c <net_ipv4_unspecified_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   139ea:	692a      	ldr	r2, [r5, #16]
   139ec:	6803      	ldr	r3, [r0, #0]
   139ee:	429a      	cmp	r2, r3
   139f0:	d102      	bne.n	139f8 <net_send_data+0x40>
			return -EADDRNOTAVAIL;
   139f2:	f06f 007c 	mvn.w	r0, #124	; 0x7c
}
   139f6:	bd70      	pop	{r4, r5, r6, pc}
   139f8:	6963      	ldr	r3, [r4, #20]
   139fa:	689d      	ldr	r5, [r3, #8]
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->dst) ||
   139fc:	7c2b      	ldrb	r3, [r5, #16]
   139fe:	2b7f      	cmp	r3, #127	; 0x7f
   13a00:	d10f      	bne.n	13a22 <net_send_data+0x6a>
   13a02:	6963      	ldr	r3, [r4, #20]
			net_ipaddr_copy(&addr, &NET_IPV4_HDR(pkt)->src);
   13a04:	689b      	ldr	r3, [r3, #8]
   13a06:	68da      	ldr	r2, [r3, #12]
   13a08:	6963      	ldr	r3, [r4, #20]
   13a0a:	689b      	ldr	r3, [r3, #8]
			net_ipaddr_copy(&NET_IPV4_HDR(pkt)->src,
   13a0c:	6919      	ldr	r1, [r3, #16]
   13a0e:	60d9      	str	r1, [r3, #12]
   13a10:	6963      	ldr	r3, [r4, #20]
   13a12:	689b      	ldr	r3, [r3, #8]
			net_ipaddr_copy(&NET_IPV4_HDR(pkt)->dst, &addr);
   13a14:	611a      	str	r2, [r3, #16]
		processing_data(pkt, true);
   13a16:	2101      	movs	r1, #1
   13a18:	4620      	mov	r0, r4
   13a1a:	f7ff ff8f 	bl	1393c <processing_data>
		return 0;
   13a1e:	2000      	movs	r0, #0
   13a20:	e7e9      	b.n	139f6 <net_send_data+0x3e>
		    (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
   13a22:	6a66      	ldr	r6, [r4, #36]	; 0x24
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   13a24:	f7f8 f896 	bl	bb54 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   13a28:	692a      	ldr	r2, [r5, #16]
   13a2a:	6803      	ldr	r3, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   13a2c:	429a      	cmp	r2, r3
   13a2e:	d01e      	beq.n	13a6e <net_send_data+0xb6>
	return net_if_ipv4_is_addr_bcast(iface, addr);
   13a30:	f105 0110 	add.w	r1, r5, #16
   13a34:	4630      	mov	r0, r6
   13a36:	f7f7 fb2f 	bl	b098 <net_if_ipv4_is_addr_bcast>
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->dst) ||
   13a3a:	4601      	mov	r1, r0
   13a3c:	b9b8      	cbnz	r0, 13a6e <net_send_data+0xb6>
   13a3e:	6963      	ldr	r3, [r4, #20]
   13a40:	689e      	ldr	r6, [r3, #8]
		     net_ipv4_is_my_addr(&NET_IPV4_HDR(pkt)->dst))) {
   13a42:	f106 0510 	add.w	r5, r6, #16
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
   13a46:	4628      	mov	r0, r5
   13a48:	f7f7 fba6 	bl	b198 <net_if_ipv4_addr_lookup>
   13a4c:	2800      	cmp	r0, #0
   13a4e:	bf14      	ite	ne
   13a50:	2001      	movne	r0, #1
   13a52:	2000      	moveq	r0, #0
	if (!ret) {
   13a54:	d109      	bne.n	13a6a <net_send_data+0xb2>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   13a56:	f7f8 f87d 	bl	bb54 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   13a5a:	6932      	ldr	r2, [r6, #16]
   13a5c:	6803      	ldr	r3, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   13a5e:	429a      	cmp	r2, r3
   13a60:	d0cf      	beq.n	13a02 <net_send_data+0x4a>
	return net_if_ipv4_is_addr_bcast(iface, addr);
   13a62:	4629      	mov	r1, r5
   13a64:	2000      	movs	r0, #0
   13a66:	f7f7 fb17 	bl	b098 <net_if_ipv4_is_addr_bcast>
				     &NET_IPV4_HDR(pkt)->dst) == false &&
   13a6a:	2800      	cmp	r0, #0
   13a6c:	d1c9      	bne.n	13a02 <net_send_data+0x4a>
   13a6e:	6963      	ldr	r3, [r4, #20]
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->src)) {
   13a70:	689b      	ldr	r3, [r3, #8]
   13a72:	7b1b      	ldrb	r3, [r3, #12]
   13a74:	2b7f      	cmp	r3, #127	; 0x7f
   13a76:	d0bc      	beq.n	139f2 <net_send_data+0x3a>
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
   13a78:	4621      	mov	r1, r4
   13a7a:	6a60      	ldr	r0, [r4, #36]	; 0x24
   13a7c:	f7f7 fc74 	bl	b368 <net_if_send_data>
		return -EIO;
   13a80:	2802      	cmp	r0, #2
   13a82:	bf14      	ite	ne
   13a84:	2000      	movne	r0, #0
   13a86:	f06f 0004 	mvneq.w	r0, #4
   13a8a:	e7b4      	b.n	139f6 <net_send_data+0x3e>
		return -ENODATA;
   13a8c:	f06f 003c 	mvn.w	r0, #60	; 0x3c
   13a90:	e7b1      	b.n	139f6 <net_send_data+0x3e>
		return -EINVAL;
   13a92:	f06f 0015 	mvn.w	r0, #21
   13a96:	e7ae      	b.n	139f6 <net_send_data+0x3e>

00013a98 <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
   13a98:	6800      	ldr	r0, [r0, #0]
   13a9a:	ba00      	rev	r0, r0
   13a9c:	f000 4060 	and.w	r0, r0, #3758096384	; 0xe0000000
}
   13aa0:	f100 5300 	add.w	r3, r0, #536870912	; 0x20000000
   13aa4:	4258      	negs	r0, r3
   13aa6:	4158      	adcs	r0, r3
   13aa8:	4770      	bx	lr

00013aaa <net_context_send_cb>:
	if (!context) {
   13aaa:	b118      	cbz	r0, 13ab4 <net_context_send_cb+0xa>
	if (context->send_cb) {
   13aac:	6b43      	ldr	r3, [r0, #52]	; 0x34
   13aae:	b10b      	cbz	r3, 13ab4 <net_context_send_cb+0xa>
		context->send_cb(context, status, context->user_data);
   13ab0:	6802      	ldr	r2, [r0, #0]
   13ab2:	4718      	bx	r3
}
   13ab4:	4770      	bx	lr

00013ab6 <if_ipv4_get_addr>:
{
   13ab6:	b538      	push	{r3, r4, r5, lr}
   13ab8:	4615      	mov	r5, r2
	if (!iface) {
   13aba:	4604      	mov	r4, r0
   13abc:	b1c0      	cbz	r0, 13af0 <if_ipv4_get_addr+0x3a>
	ipv4 = iface->config.ip.ipv4;
   13abe:	6844      	ldr	r4, [r0, #4]
	if (!ipv4) {
   13ac0:	b1b4      	cbz	r4, 13af0 <if_ipv4_get_addr+0x3a>
		if (!ipv4->unicast[i].is_used ||
   13ac2:	7aa3      	ldrb	r3, [r4, #10]
   13ac4:	f3c3 0340 	ubfx	r3, r3, #1, #1
   13ac8:	b90b      	cbnz	r3, 13ace <if_ipv4_get_addr+0x18>
	return NULL;
   13aca:	2400      	movs	r4, #0
   13acc:	e010      	b.n	13af0 <if_ipv4_get_addr+0x3a>
		if (!ipv4->unicast[i].is_used ||
   13ace:	1c4b      	adds	r3, r1, #1
   13ad0:	d003      	beq.n	13ada <if_ipv4_get_addr+0x24>
		    (addr_state != NET_ADDR_ANY_STATE &&
   13ad2:	f994 3009 	ldrsb.w	r3, [r4, #9]
   13ad6:	428b      	cmp	r3, r1
   13ad8:	d1f7      	bne.n	13aca <if_ipv4_get_addr+0x14>
		     ipv4->unicast[i].addr_state != addr_state) ||
   13ada:	8823      	ldrh	r3, [r4, #0]
   13adc:	2b01      	cmp	r3, #1
   13ade:	d1f4      	bne.n	13aca <if_ipv4_get_addr+0x14>
		if (net_ipv4_is_ll_addr(&ipv4->unicast[i].address.in_addr)) {
   13ae0:	3404      	adds	r4, #4
   13ae2:	4620      	mov	r0, r4
   13ae4:	f7f7 fa62 	bl	afac <net_ipv4_is_ll_addr>
   13ae8:	b120      	cbz	r0, 13af4 <if_ipv4_get_addr+0x3e>
	return NULL;
   13aea:	2d00      	cmp	r5, #0
   13aec:	bf08      	it	eq
   13aee:	2400      	moveq	r4, #0
}
   13af0:	4620      	mov	r0, r4
   13af2:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
   13af4:	2d00      	cmp	r5, #0
   13af6:	bf18      	it	ne
   13af8:	2400      	movne	r4, #0
   13afa:	e7f9      	b.n	13af0 <if_ipv4_get_addr+0x3a>

00013afc <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   13afc:	f3bf 8f5b 	dmb	ish
   13b00:	6800      	ldr	r0, [r0, #0]
   13b02:	f3bf 8f5b 	dmb	ish
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   13b06:	4108      	asrs	r0, r1
}
   13b08:	f000 0001 	and.w	r0, r0, #1
   13b0c:	4770      	bx	lr

00013b0e <need_calc_checksum.part.17>:
	return iface->if_dev->dev;
   13b0e:	6803      	ldr	r3, [r0, #0]
   13b10:	6818      	ldr	r0, [r3, #0]
	if (!eth->get_capabilities) {
   13b12:	6843      	ldr	r3, [r0, #4]
   13b14:	68db      	ldr	r3, [r3, #12]
static bool need_calc_checksum(struct net_if *iface, enum ethernet_hw_caps caps)
   13b16:	b510      	push	{r4, lr}
   13b18:	460c      	mov	r4, r1
   13b1a:	b12b      	cbz	r3, 13b28 <need_calc_checksum.part.17+0x1a>
	return eth->get_capabilities(net_if_get_device(iface));
   13b1c:	4798      	blx	r3
	return !(net_eth_get_hw_capabilities(iface) & caps);
   13b1e:	4204      	tst	r4, r0
}
   13b20:	bf0c      	ite	eq
   13b22:	2001      	moveq	r0, #1
   13b24:	2000      	movne	r0, #0
   13b26:	bd10      	pop	{r4, pc}
		return (enum ethernet_hw_caps)0;
   13b28:	4618      	mov	r0, r3
   13b2a:	e7f8      	b.n	13b1e <need_calc_checksum.part.17+0x10>

00013b2c <net_if_ipv4_addr_mask_cmp>:
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
   13b2c:	6843      	ldr	r3, [r0, #4]
	if (!ipv4) {
   13b2e:	b17b      	cbz	r3, 13b50 <net_if_ipv4_addr_mask_cmp+0x24>
		if (!ipv4->unicast[i].is_used ||
   13b30:	7a98      	ldrb	r0, [r3, #10]
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
   13b32:	69da      	ldr	r2, [r3, #28]
   13b34:	6809      	ldr	r1, [r1, #0]
		if (!ipv4->unicast[i].is_used ||
   13b36:	f3c0 0040 	ubfx	r0, r0, #1, #1
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
   13b3a:	4011      	ands	r1, r2
		if (!ipv4->unicast[i].is_used ||
   13b3c:	b148      	cbz	r0, 13b52 <net_if_ipv4_addr_mask_cmp+0x26>
   13b3e:	8818      	ldrh	r0, [r3, #0]
   13b40:	2801      	cmp	r0, #1
   13b42:	d105      	bne.n	13b50 <net_if_ipv4_addr_mask_cmp+0x24>
		if ((ipv4->unicast[i].address.in_addr.s_addr &
   13b44:	6858      	ldr	r0, [r3, #4]
   13b46:	4010      	ands	r0, r2
   13b48:	1a43      	subs	r3, r0, r1
   13b4a:	4258      	negs	r0, r3
   13b4c:	4158      	adcs	r0, r3
   13b4e:	4770      	bx	lr
		return false;
   13b50:	2000      	movs	r0, #0
}
   13b52:	4770      	bx	lr

00013b54 <ipv4_is_broadcast_address>:
{
   13b54:	b538      	push	{r3, r4, r5, lr}
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
   13b56:	6844      	ldr	r4, [r0, #4]
{
   13b58:	460d      	mov	r5, r1
	if (!ipv4) {
   13b5a:	b154      	cbz	r4, 13b72 <ipv4_is_broadcast_address+0x1e>
	if (!net_if_ipv4_addr_mask_cmp(iface, addr)) {
   13b5c:	f7ff ffe6 	bl	13b2c <net_if_ipv4_addr_mask_cmp>
   13b60:	b130      	cbz	r0, 13b70 <ipv4_is_broadcast_address+0x1c>
	if ((UNALIGNED_GET(&addr->s_addr) & ~ipv4->netmask.s_addr) ==
   13b62:	69e3      	ldr	r3, [r4, #28]
   13b64:	682a      	ldr	r2, [r5, #0]
   13b66:	43db      	mvns	r3, r3
   13b68:	4393      	bics	r3, r2
   13b6a:	bf0c      	ite	eq
   13b6c:	2001      	moveq	r0, #1
   13b6e:	2000      	movne	r0, #0
}
   13b70:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   13b72:	4620      	mov	r0, r4
   13b74:	e7fc      	b.n	13b70 <ipv4_is_broadcast_address+0x1c>

00013b76 <net_if_ipv4_get_ll>:
	return if_ipv4_get_addr(iface, addr_state, true);
   13b76:	2201      	movs	r2, #1
   13b78:	f7ff bf9d 	b.w	13ab6 <if_ipv4_get_addr>

00013b7c <net_if_ipv4_get_global_addr>:
	return if_ipv4_get_addr(iface, addr_state, false);
   13b7c:	2200      	movs	r2, #0
   13b7e:	f7ff bf9a 	b.w	13ab6 <if_ipv4_get_addr>

00013b82 <net_if_recv_data>:
	return iface->if_dev->l2;
   13b82:	6803      	ldr	r3, [r0, #0]
	return net_if_l2(iface)->recv(iface, pkt);
   13b84:	685b      	ldr	r3, [r3, #4]
   13b86:	681b      	ldr	r3, [r3, #0]
   13b88:	4718      	bx	r3

00013b8a <net_buf_frags_len>:
{
   13b8a:	4603      	mov	r3, r0
	size_t bytes = 0;
   13b8c:	2000      	movs	r0, #0
	while (buf) {
   13b8e:	b903      	cbnz	r3, 13b92 <net_buf_frags_len+0x8>
	}

	return bytes;
}
   13b90:	4770      	bx	lr
		bytes += buf->len;
   13b92:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
   13b94:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   13b96:	4410      	add	r0, r2
		buf = buf->frags;
   13b98:	e7f9      	b.n	13b8e <net_buf_frags_len+0x4>

00013b9a <pkt_cursor_jump>:
	cursor->buf = cursor->buf->frags;
   13b9a:	6983      	ldr	r3, [r0, #24]
			cursor->buf = cursor->buf->frags;
   13b9c:	681b      	ldr	r3, [r3, #0]
   13b9e:	6183      	str	r3, [r0, #24]
	while (cursor->buf) {
   13ba0:	6983      	ldr	r3, [r0, #24]
   13ba2:	b90b      	cbnz	r3, 13ba8 <pkt_cursor_jump+0xe>
		cursor->pos = NULL;
   13ba4:	61c3      	str	r3, [r0, #28]
}
   13ba6:	4770      	bx	lr
		size_t len = write ? cursor->buf->size : cursor->buf->len;
   13ba8:	b121      	cbz	r1, 13bb4 <pkt_cursor_jump+0x1a>
   13baa:	89da      	ldrh	r2, [r3, #14]
		if (!len) {
   13bac:	2a00      	cmp	r2, #0
   13bae:	d0f5      	beq.n	13b9c <pkt_cursor_jump+0x2>
		cursor->pos = cursor->buf->data;
   13bb0:	689b      	ldr	r3, [r3, #8]
   13bb2:	e7f7      	b.n	13ba4 <pkt_cursor_jump+0xa>
		size_t len = write ? cursor->buf->size : cursor->buf->len;
   13bb4:	899a      	ldrh	r2, [r3, #12]
   13bb6:	e7f9      	b.n	13bac <pkt_cursor_jump+0x12>

00013bb8 <pkt_cursor_advance>:
	if (!cursor->buf) {
   13bb8:	6983      	ldr	r3, [r0, #24]
{
   13bba:	b410      	push	{r4}
	if (!cursor->buf) {
   13bbc:	b15b      	cbz	r3, 13bd6 <pkt_cursor_advance+0x1e>
	len = write ? cursor->buf->size : cursor->buf->len;
   13bbe:	b141      	cbz	r1, 13bd2 <pkt_cursor_advance+0x1a>
   13bc0:	89dc      	ldrh	r4, [r3, #14]
	if ((cursor->pos - cursor->buf->data) == len) {
   13bc2:	69c2      	ldr	r2, [r0, #28]
   13bc4:	689b      	ldr	r3, [r3, #8]
   13bc6:	1ad2      	subs	r2, r2, r3
   13bc8:	42a2      	cmp	r2, r4
   13bca:	d104      	bne.n	13bd6 <pkt_cursor_advance+0x1e>
}
   13bcc:	bc10      	pop	{r4}
		pkt_cursor_jump(pkt, write);
   13bce:	f7ff bfe4 	b.w	13b9a <pkt_cursor_jump>
	len = write ? cursor->buf->size : cursor->buf->len;
   13bd2:	899c      	ldrh	r4, [r3, #12]
   13bd4:	e7f5      	b.n	13bc2 <pkt_cursor_advance+0xa>
}
   13bd6:	bc10      	pop	{r4}
   13bd8:	4770      	bx	lr

00013bda <pkt_cursor_update>:
	return pkt->overwrite;
   13bda:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
   13bde:	b4f0      	push	{r4, r5, r6, r7}
	if (net_pkt_is_being_overwritten(pkt)) {
   13be0:	f013 0601 	ands.w	r6, r3, #1
   13be4:	6985      	ldr	r5, [r0, #24]
   13be6:	d10f      	bne.n	13c08 <pkt_cursor_update+0x2e>
	len = write ? cursor->buf->size : cursor->buf->len;
   13be8:	b172      	cbz	r2, 13c08 <pkt_cursor_update+0x2e>
   13bea:	89ef      	ldrh	r7, [r5, #14]
	if (length + (cursor->pos - cursor->buf->data) == len &&
   13bec:	69c4      	ldr	r4, [r0, #28]
   13bee:	68ab      	ldr	r3, [r5, #8]
   13bf0:	1ae3      	subs	r3, r4, r3
   13bf2:	440b      	add	r3, r1
   13bf4:	42bb      	cmp	r3, r7
   13bf6:	d10a      	bne.n	13c0e <pkt_cursor_update+0x34>
   13bf8:	b116      	cbz	r6, 13c00 <pkt_cursor_update+0x26>
	    !(net_pkt_is_being_overwritten(pkt) && len < cursor->buf->size)) {
   13bfa:	89eb      	ldrh	r3, [r5, #14]
   13bfc:	42bb      	cmp	r3, r7
   13bfe:	d806      	bhi.n	13c0e <pkt_cursor_update+0x34>
		pkt_cursor_jump(pkt, write);
   13c00:	4611      	mov	r1, r2
}
   13c02:	bcf0      	pop	{r4, r5, r6, r7}
		pkt_cursor_jump(pkt, write);
   13c04:	f7ff bfc9 	b.w	13b9a <pkt_cursor_jump>
	len = write ? cursor->buf->size : cursor->buf->len;
   13c08:	89af      	ldrh	r7, [r5, #12]
   13c0a:	2200      	movs	r2, #0
   13c0c:	e7ee      	b.n	13bec <pkt_cursor_update+0x12>
		cursor->pos += length;
   13c0e:	440c      	add	r4, r1
   13c10:	61c4      	str	r4, [r0, #28]
}
   13c12:	bcf0      	pop	{r4, r5, r6, r7}
   13c14:	4770      	bx	lr

00013c16 <pkt_estimate_headers_length.isra.18.part.19>:
		hdr_len += NET_IPV4H_LEN;
   13c16:	2801      	cmp	r0, #1
   13c18:	bf14      	ite	ne
   13c1a:	2000      	movne	r0, #0
   13c1c:	2014      	moveq	r0, #20
	if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
   13c1e:	2906      	cmp	r1, #6
   13c20:	d101      	bne.n	13c26 <pkt_estimate_headers_length.isra.18.part.19+0x10>
		hdr_len += NET_TCPH_LEN + NET_TCP_MAX_OPT_SIZE;
   13c22:	301c      	adds	r0, #28
   13c24:	4770      	bx	lr
	} else if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
   13c26:	2911      	cmp	r1, #17
   13c28:	d101      	bne.n	13c2e <pkt_estimate_headers_length.isra.18.part.19+0x18>
		hdr_len += NET_UDPH_LEN;
   13c2a:	3008      	adds	r0, #8
   13c2c:	4770      	bx	lr
	} else if (proto == IPPROTO_ICMP || proto == IPPROTO_ICMPV6) {
   13c2e:	2901      	cmp	r1, #1
   13c30:	d001      	beq.n	13c36 <pkt_estimate_headers_length.isra.18.part.19+0x20>
   13c32:	293a      	cmp	r1, #58	; 0x3a
   13c34:	d100      	bne.n	13c38 <pkt_estimate_headers_length.isra.18.part.19+0x22>
		hdr_len += NET_ICMPH_LEN;
   13c36:	3004      	adds	r0, #4
}
   13c38:	4770      	bx	lr

00013c3a <net_pkt_cursor_operate>:
{
   13c3a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13c3e:	f89d 8020 	ldrb.w	r8, [sp, #32]
   13c42:	4606      	mov	r6, r0
   13c44:	460f      	mov	r7, r1
   13c46:	4615      	mov	r5, r2
   13c48:	4699      	mov	r9, r3
	while (c_op->buf && length) {
   13c4a:	69b3      	ldr	r3, [r6, #24]
   13c4c:	2b00      	cmp	r3, #0
   13c4e:	d051      	beq.n	13cf4 <net_pkt_cursor_operate+0xba>
   13c50:	b90d      	cbnz	r5, 13c56 <net_pkt_cursor_operate+0x1c>
	return 0;
   13c52:	4628      	mov	r0, r5
   13c54:	e00d      	b.n	13c72 <net_pkt_cursor_operate+0x38>
   13c56:	f896 3041 	ldrb.w	r3, [r6, #65]	; 0x41
		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
   13c5a:	f013 0f01 	tst.w	r3, #1
   13c5e:	bf0c      	ite	eq
   13c60:	4641      	moveq	r1, r8
   13c62:	2100      	movne	r1, #0
   13c64:	4630      	mov	r0, r6
   13c66:	f7ff ffa7 	bl	13bb8 <pkt_cursor_advance>
		if (c_op->buf == NULL) {
   13c6a:	69b3      	ldr	r3, [r6, #24]
   13c6c:	b91b      	cbnz	r3, 13c76 <net_pkt_cursor_operate+0x3c>
		return -ENOBUFS;
   13c6e:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   13c72:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (write && !net_pkt_is_being_overwritten(pkt)) {
   13c76:	69f0      	ldr	r0, [r6, #28]
   13c78:	689c      	ldr	r4, [r3, #8]
   13c7a:	1b04      	subs	r4, r0, r4
   13c7c:	f1b8 0f00 	cmp.w	r8, #0
   13c80:	d02d      	beq.n	13cde <net_pkt_cursor_operate+0xa4>
   13c82:	f896 2041 	ldrb.w	r2, [r6, #65]	; 0x41
   13c86:	07d2      	lsls	r2, r2, #31
   13c88:	d429      	bmi.n	13cde <net_pkt_cursor_operate+0xa4>
			d_len = c_op->buf->size - (c_op->pos - c_op->buf->data);
   13c8a:	89db      	ldrh	r3, [r3, #14]
			d_len = c_op->buf->len - (c_op->pos - c_op->buf->data);
   13c8c:	1b1c      	subs	r4, r3, r4
		if (!d_len) {
   13c8e:	2c00      	cmp	r4, #0
   13c90:	d0ed      	beq.n	13c6e <net_pkt_cursor_operate+0x34>
		if (length < d_len) {
   13c92:	42ac      	cmp	r4, r5
   13c94:	bf28      	it	cs
   13c96:	462c      	movcs	r4, r5
		if (copy) {
   13c98:	f1b9 0f00 	cmp.w	r9, #0
   13c9c:	d023      	beq.n	13ce6 <net_pkt_cursor_operate+0xac>
			memcpy(write ? c_op->pos : data,
   13c9e:	f1b8 0f00 	cmp.w	r8, #0
   13ca2:	d11e      	bne.n	13ce2 <net_pkt_cursor_operate+0xa8>
   13ca4:	4601      	mov	r1, r0
   13ca6:	4638      	mov	r0, r7
   13ca8:	4622      	mov	r2, r4
   13caa:	f7ee fa63 	bl	2174 <memcpy>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
   13cae:	f1b8 0f00 	cmp.w	r8, #0
   13cb2:	d008      	beq.n	13cc6 <net_pkt_cursor_operate+0x8c>
   13cb4:	f896 3041 	ldrb.w	r3, [r6, #65]	; 0x41
   13cb8:	07db      	lsls	r3, r3, #31
   13cba:	d404      	bmi.n	13cc6 <net_pkt_cursor_operate+0x8c>
			net_buf_add(c_op->buf, len);
   13cbc:	69b0      	ldr	r0, [r6, #24]
   13cbe:	4621      	mov	r1, r4
   13cc0:	3008      	adds	r0, #8
   13cc2:	f7ff f9f1 	bl	130a8 <net_buf_simple_add>
		pkt_cursor_update(pkt, len, write);
   13cc6:	4642      	mov	r2, r8
   13cc8:	4621      	mov	r1, r4
   13cca:	4630      	mov	r0, r6
   13ccc:	f7ff ff85 	bl	13bda <pkt_cursor_update>
		if (copy && data) {
   13cd0:	f1b9 0f00 	cmp.w	r9, #0
   13cd4:	d001      	beq.n	13cda <net_pkt_cursor_operate+0xa0>
   13cd6:	b107      	cbz	r7, 13cda <net_pkt_cursor_operate+0xa0>
			data = (u8_t *) data + len;
   13cd8:	4427      	add	r7, r4
		length -= len;
   13cda:	1b2d      	subs	r5, r5, r4
   13cdc:	e7b5      	b.n	13c4a <net_pkt_cursor_operate+0x10>
			d_len = c_op->buf->len - (c_op->pos - c_op->buf->data);
   13cde:	899b      	ldrh	r3, [r3, #12]
   13ce0:	e7d4      	b.n	13c8c <net_pkt_cursor_operate+0x52>
   13ce2:	4639      	mov	r1, r7
   13ce4:	e7e0      	b.n	13ca8 <net_pkt_cursor_operate+0x6e>
		} else if (data) {
   13ce6:	2f00      	cmp	r7, #0
   13ce8:	d0e1      	beq.n	13cae <net_pkt_cursor_operate+0x74>
__ssp_bos_icheck3(memset, void *, int)
   13cea:	4622      	mov	r2, r4
   13cec:	6839      	ldr	r1, [r7, #0]
   13cee:	f7ee fa7c 	bl	21ea <memset>
   13cf2:	e7dc      	b.n	13cae <net_pkt_cursor_operate+0x74>
	if (length) {
   13cf4:	2d00      	cmp	r5, #0
   13cf6:	d0ac      	beq.n	13c52 <net_pkt_cursor_operate+0x18>
   13cf8:	e7b9      	b.n	13c6e <net_pkt_cursor_operate+0x34>

00013cfa <net_pkt_get_reserve_data>:
{
   13cfa:	b538      	push	{r3, r4, r5, lr}
   13cfc:	4604      	mov	r4, r0
   13cfe:	460d      	mov	r5, r1
	if (k_is_in_isr()) {
   13d00:	f7fb fcea 	bl	f6d8 <k_is_in_isr>
   13d04:	b128      	cbz	r0, 13d12 <net_pkt_get_reserve_data+0x18>
		frag = net_buf_alloc(pool, K_NO_WAIT);
   13d06:	2100      	movs	r1, #0
		frag = net_buf_alloc(pool, timeout);
   13d08:	4620      	mov	r0, r4
}
   13d0a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		frag = net_buf_alloc(pool, timeout);
   13d0e:	f7ff b9b5 	b.w	1307c <net_buf_alloc_fixed>
   13d12:	4629      	mov	r1, r5
   13d14:	e7f8      	b.n	13d08 <net_pkt_get_reserve_data+0xe>

00013d16 <net_pkt_ref>:
{
   13d16:	b510      	push	{r4, lr}
		ref = pkt ? atomic_get(&pkt->atomic_ref) : 0;
   13d18:	f100 0328 	add.w	r3, r0, #40	; 0x28
   13d1c:	b1a8      	cbz	r0, 13d4a <net_pkt_ref+0x34>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   13d1e:	f3bf 8f5b 	dmb	ish
   13d22:	681a      	ldr	r2, [r3, #0]
   13d24:	f3bf 8f5b 	dmb	ish
		if (!ref) {
   13d28:	b17a      	cbz	r2, 13d4a <net_pkt_ref+0x34>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   13d2a:	f3bf 8f5b 	dmb	ish
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref + 1));
   13d2e:	1c51      	adds	r1, r2, #1
   13d30:	e853 4f00 	ldrex	r4, [r3]
   13d34:	4294      	cmp	r4, r2
   13d36:	d104      	bne.n	13d42 <net_pkt_ref+0x2c>
   13d38:	e843 1c00 	strex	ip, r1, [r3]
   13d3c:	f1bc 0f00 	cmp.w	ip, #0
   13d40:	d1f6      	bne.n	13d30 <net_pkt_ref+0x1a>
   13d42:	f3bf 8f5b 	dmb	ish
   13d46:	d1e9      	bne.n	13d1c <net_pkt_ref+0x6>
}
   13d48:	bd10      	pop	{r4, pc}
			return NULL;
   13d4a:	2000      	movs	r0, #0
   13d4c:	e7fc      	b.n	13d48 <net_pkt_ref+0x32>

00013d4e <net_pkt_frag_unref>:
	if (!frag) {
   13d4e:	b108      	cbz	r0, 13d54 <net_pkt_frag_unref+0x6>
	net_buf_unref(frag);
   13d50:	f7f6 bb4e 	b.w	a3f0 <net_buf_unref>
}
   13d54:	4770      	bx	lr

00013d56 <net_pkt_unref>:
{
   13d56:	b507      	push	{r0, r1, r2, lr}
   13d58:	9001      	str	r0, [sp, #4]
	if (!pkt) {
   13d5a:	b318      	cbz	r0, 13da4 <net_pkt_unref+0x4e>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   13d5c:	9b01      	ldr	r3, [sp, #4]
   13d5e:	f3bf 8f5b 	dmb	ish
   13d62:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13d64:	f3bf 8f5b 	dmb	ish
		if (!ref) {
   13d68:	b1e3      	cbz	r3, 13da4 <net_pkt_unref+0x4e>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   13d6a:	9a01      	ldr	r2, [sp, #4]
   13d6c:	f3bf 8f5b 	dmb	ish
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref - 1));
   13d70:	1e59      	subs	r1, r3, #1
   13d72:	3228      	adds	r2, #40	; 0x28
   13d74:	e852 0f00 	ldrex	r0, [r2]
   13d78:	4298      	cmp	r0, r3
   13d7a:	d104      	bne.n	13d86 <net_pkt_unref+0x30>
   13d7c:	e842 1c00 	strex	ip, r1, [r2]
   13d80:	f1bc 0f00 	cmp.w	ip, #0
   13d84:	d1f6      	bne.n	13d74 <net_pkt_unref+0x1e>
   13d86:	f3bf 8f5b 	dmb	ish
   13d8a:	d1e7      	bne.n	13d5c <net_pkt_unref+0x6>
	if (ref > 1) {
   13d8c:	2b01      	cmp	r3, #1
   13d8e:	dc09      	bgt.n	13da4 <net_pkt_unref+0x4e>
	if (pkt->frags) {
   13d90:	9b01      	ldr	r3, [sp, #4]
   13d92:	6958      	ldr	r0, [r3, #20]
   13d94:	b108      	cbz	r0, 13d9a <net_pkt_unref+0x44>
		net_pkt_frag_unref(pkt->frags);
   13d96:	f7ff ffda 	bl	13d4e <net_pkt_frag_unref>
	k_mem_slab_free(pkt->slab, (void **)&pkt);
   13d9a:	9b01      	ldr	r3, [sp, #4]
   13d9c:	a901      	add	r1, sp, #4
   13d9e:	6918      	ldr	r0, [r3, #16]
   13da0:	f7fa ff82 	bl	eca8 <k_mem_slab_free>
}
   13da4:	b003      	add	sp, #12
   13da6:	f85d fb04 	ldr.w	pc, [sp], #4

00013daa <net_pkt_frag_insert>:
{
   13daa:	b538      	push	{r3, r4, r5, lr}
   13dac:	4604      	mov	r4, r0
	net_buf_frag_last(frag)->frags = pkt->frags;
   13dae:	4608      	mov	r0, r1
{
   13db0:	460d      	mov	r5, r1
	net_buf_frag_last(frag)->frags = pkt->frags;
   13db2:	f7ff f969 	bl	13088 <net_buf_frag_last>
   13db6:	6963      	ldr	r3, [r4, #20]
   13db8:	6003      	str	r3, [r0, #0]
	pkt->frags = frag;
   13dba:	6165      	str	r5, [r4, #20]
}
   13dbc:	bd38      	pop	{r3, r4, r5, pc}

00013dbe <net_pkt_available_buffer>:
{
   13dbe:	b508      	push	{r3, lr}
	if (!pkt) {
   13dc0:	b130      	cbz	r0, 13dd0 <net_pkt_available_buffer+0x12>
	return pkt_get_size(pkt) - net_pkt_get_len(pkt);
   13dc2:	6940      	ldr	r0, [r0, #20]
	size_t size = 0;
   13dc4:	2100      	movs	r1, #0
	struct net_buf *buf = pkt->buffer;
   13dc6:	4603      	mov	r3, r0
	while (buf) {
   13dc8:	b91b      	cbnz	r3, 13dd2 <net_pkt_available_buffer+0x14>
	return net_buf_frags_len(pkt->frags);
   13dca:	f7ff fede 	bl	13b8a <net_buf_frags_len>
	return pkt_get_size(pkt) - net_pkt_get_len(pkt);
   13dce:	1a08      	subs	r0, r1, r0
}
   13dd0:	bd08      	pop	{r3, pc}
		size += buf->size;
   13dd2:	89da      	ldrh	r2, [r3, #14]
		buf = buf->frags;
   13dd4:	681b      	ldr	r3, [r3, #0]
		size += buf->size;
   13dd6:	4411      	add	r1, r2
		buf = buf->frags;
   13dd8:	e7f6      	b.n	13dc8 <net_pkt_available_buffer+0xa>

00013dda <net_pkt_available_payload_buffer>:
{
   13dda:	b538      	push	{r3, r4, r5, lr}
	if (!pkt) {
   13ddc:	4605      	mov	r5, r0
   13dde:	b198      	cbz	r0, 13e08 <net_pkt_available_payload_buffer+0x2e>
	return pkt->family;
   13de0:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
	hdr_len = pkt_estimate_headers_length(pkt, net_pkt_family(pkt), proto);
   13de4:	f3c3 0042 	ubfx	r0, r3, #1, #3
	if (family == AF_UNSPEC) {
   13de8:	b108      	cbz	r0, 13dee <net_pkt_available_payload_buffer+0x14>
   13dea:	f7ff ff14 	bl	13c16 <pkt_estimate_headers_length.isra.18.part.19>
		return  0;
   13dee:	4604      	mov	r4, r0
	return net_buf_frags_len(pkt->frags);
   13df0:	6968      	ldr	r0, [r5, #20]
   13df2:	f7ff feca 	bl	13b8a <net_buf_frags_len>
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
   13df6:	42a0      	cmp	r0, r4
   13df8:	bf38      	it	cc
   13dfa:	1a24      	subcc	r4, r4, r0
	len = net_pkt_available_buffer(pkt) - hdr_len;
   13dfc:	4628      	mov	r0, r5
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
   13dfe:	bf28      	it	cs
   13e00:	2400      	movcs	r4, #0
	len = net_pkt_available_buffer(pkt) - hdr_len;
   13e02:	f7ff ffdc 	bl	13dbe <net_pkt_available_buffer>
   13e06:	1b00      	subs	r0, r0, r4
}
   13e08:	bd38      	pop	{r3, r4, r5, pc}

00013e0a <net_pkt_trim_buffer>:
{
   13e0a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13e0c:	4605      	mov	r5, r0
	buf = pkt->buffer;
   13e0e:	6940      	ldr	r0, [r0, #20]
			buf->frags = NULL;
   13e10:	2700      	movs	r7, #0
	prev = buf;
   13e12:	4604      	mov	r4, r0
	while (buf) {
   13e14:	b900      	cbnz	r0, 13e18 <net_pkt_trim_buffer+0xe>
}
   13e16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (!buf->len) {
   13e18:	8983      	ldrh	r3, [r0, #12]
		struct net_buf *next = buf->frags;
   13e1a:	6806      	ldr	r6, [r0, #0]
		if (!buf->len) {
   13e1c:	b93b      	cbnz	r3, 13e2e <net_pkt_trim_buffer+0x24>
			if (buf == pkt->buffer) {
   13e1e:	696b      	ldr	r3, [r5, #20]
   13e20:	4283      	cmp	r3, r0
   13e22:	d107      	bne.n	13e34 <net_pkt_trim_buffer+0x2a>
				pkt->buffer = next;
   13e24:	616e      	str	r6, [r5, #20]
			buf->frags = NULL;
   13e26:	6007      	str	r7, [r0, #0]
			net_buf_unref(buf);
   13e28:	f7f6 fae2 	bl	a3f0 <net_buf_unref>
   13e2c:	4620      	mov	r0, r4
   13e2e:	4604      	mov	r4, r0
   13e30:	4630      	mov	r0, r6
   13e32:	e7ef      	b.n	13e14 <net_pkt_trim_buffer+0xa>
			} else if (buf == prev->frags) {
   13e34:	6823      	ldr	r3, [r4, #0]
   13e36:	4283      	cmp	r3, r0
				prev->frags = next;
   13e38:	bf08      	it	eq
   13e3a:	6026      	streq	r6, [r4, #0]
   13e3c:	e7f3      	b.n	13e26 <net_pkt_trim_buffer+0x1c>

00013e3e <net_pkt_cursor_init>:
	pkt->cursor.buf = pkt->buffer;
   13e3e:	6943      	ldr	r3, [r0, #20]
   13e40:	6183      	str	r3, [r0, #24]
	if (pkt->cursor.buf) {
   13e42:	b103      	cbz	r3, 13e46 <net_pkt_cursor_init+0x8>
		pkt->cursor.pos = pkt->cursor.buf->data;
   13e44:	689b      	ldr	r3, [r3, #8]
   13e46:	61c3      	str	r3, [r0, #28]
}
   13e48:	4770      	bx	lr

00013e4a <pkt_alloc>:
{
   13e4a:	b537      	push	{r0, r1, r2, r4, r5, lr}
   13e4c:	460d      	mov	r5, r1
   13e4e:	4604      	mov	r4, r0
	if (k_is_in_isr()) {
   13e50:	f7fb fc42 	bl	f6d8 <k_is_in_isr>
   13e54:	2800      	cmp	r0, #0
	ret = k_mem_slab_alloc(slab, (void **)&pkt, timeout);
   13e56:	a901      	add	r1, sp, #4
   13e58:	bf0c      	ite	eq
   13e5a:	462a      	moveq	r2, r5
   13e5c:	2200      	movne	r2, #0
   13e5e:	4620      	mov	r0, r4
   13e60:	f7fa fef6 	bl	ec50 <k_mem_slab_alloc>
	if (ret) {
   13e64:	4601      	mov	r1, r0
   13e66:	b960      	cbnz	r0, 13e82 <pkt_alloc+0x38>
   13e68:	2248      	movs	r2, #72	; 0x48
   13e6a:	9801      	ldr	r0, [sp, #4]
   13e6c:	f7ee f9bd 	bl	21ea <memset>
	pkt->atomic_ref = ATOMIC_INIT(1);
   13e70:	9801      	ldr	r0, [sp, #4]
   13e72:	2301      	movs	r3, #1
   13e74:	6283      	str	r3, [r0, #40]	; 0x28
	pkt->slab = slab;
   13e76:	6104      	str	r4, [r0, #16]
	net_pkt_cursor_init(pkt);
   13e78:	f7ff ffe1 	bl	13e3e <net_pkt_cursor_init>
	return pkt;
   13e7c:	9801      	ldr	r0, [sp, #4]
}
   13e7e:	b003      	add	sp, #12
   13e80:	bd30      	pop	{r4, r5, pc}
		return NULL;
   13e82:	2000      	movs	r0, #0
   13e84:	e7fb      	b.n	13e7e <pkt_alloc+0x34>

00013e86 <pkt_alloc_on_iface>:
{
   13e86:	b510      	push	{r4, lr}
   13e88:	460c      	mov	r4, r1
	pkt = pkt_alloc(slab, timeout);
   13e8a:	4611      	mov	r1, r2
   13e8c:	f7ff ffdd 	bl	13e4a <pkt_alloc>
	if (pkt) {
   13e90:	b148      	cbz	r0, 13ea6 <pkt_alloc_on_iface+0x20>
	pkt->iface = iface;
   13e92:	6244      	str	r4, [r0, #36]	; 0x24
	if (iface) {
   13e94:	b13c      	cbz	r4, 13ea6 <pkt_alloc_on_iface+0x20>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
   13e96:	6823      	ldr	r3, [r4, #0]
   13e98:	7d5b      	ldrb	r3, [r3, #21]
   13e9a:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
   13e9e:	6823      	ldr	r3, [r4, #0]
   13ea0:	7d5b      	ldrb	r3, [r3, #21]
   13ea2:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
}
   13ea6:	bd10      	pop	{r4, pc}

00013ea8 <net_pkt_append_buffer>:
	if (!pkt->buffer) {
   13ea8:	6943      	ldr	r3, [r0, #20]
{
   13eaa:	b510      	push	{r4, lr}
   13eac:	4602      	mov	r2, r0
   13eae:	460c      	mov	r4, r1
	if (!pkt->buffer) {
   13eb0:	b923      	cbnz	r3, 13ebc <net_pkt_append_buffer+0x14>
		pkt->buffer = buffer;
   13eb2:	6151      	str	r1, [r2, #20]
}
   13eb4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		net_pkt_cursor_init(pkt);
   13eb8:	f7ff bfc1 	b.w	13e3e <net_pkt_cursor_init>
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
   13ebc:	4618      	mov	r0, r3
   13ebe:	f7ff f8e3 	bl	13088 <net_buf_frag_last>
   13ec2:	4621      	mov	r1, r4
}
   13ec4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
   13ec8:	f7ff b8e3 	b.w	13092 <net_buf_frag_insert>

00013ecc <pkt_alloc_with_buffer>:
{
   13ecc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   13ed0:	9d09      	ldr	r5, [sp, #36]	; 0x24
   13ed2:	4604      	mov	r4, r0
   13ed4:	4689      	mov	r9, r1
   13ed6:	4617      	mov	r7, r2
   13ed8:	4698      	mov	r8, r3
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
   13eda:	f002 f85d 	bl	15f98 <z_impl_k_uptime_get>
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
   13ede:	462a      	mov	r2, r5
   13ee0:	4606      	mov	r6, r0
   13ee2:	4649      	mov	r1, r9
   13ee4:	4620      	mov	r0, r4
   13ee6:	f7ff ffce 	bl	13e86 <pkt_alloc_on_iface>
	if (!pkt) {
   13eea:	4604      	mov	r4, r0
   13eec:	b1d8      	cbz	r0, 13f26 <pkt_alloc_with_buffer+0x5a>
	pkt->family = family;
   13eee:	f890 2043 	ldrb.w	r2, [r0, #67]	; 0x43
	if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
   13ef2:	1c6b      	adds	r3, r5, #1
   13ef4:	f368 0243 	bfi	r2, r8, #1, #3
   13ef8:	2b01      	cmp	r3, #1
   13efa:	f880 2043 	strb.w	r2, [r0, #67]	; 0x43
   13efe:	d906      	bls.n	13f0e <pkt_alloc_with_buffer+0x42>
   13f00:	f002 f84a 	bl	15f98 <z_impl_k_uptime_get>
		u32_t diff = k_uptime_get_32() - alloc_start;
   13f04:	1b80      	subs	r0, r0, r6
		timeout -= MIN(timeout, diff);
   13f06:	42a8      	cmp	r0, r5
   13f08:	bf94      	ite	ls
   13f0a:	1a2d      	subls	r5, r5, r0
   13f0c:	1b6d      	subhi	r5, r5, r5
	ret = net_pkt_alloc_buffer(pkt, size, proto, timeout);
   13f0e:	462b      	mov	r3, r5
   13f10:	f89d 2020 	ldrb.w	r2, [sp, #32]
   13f14:	4639      	mov	r1, r7
   13f16:	4620      	mov	r0, r4
   13f18:	f7f7 fb74 	bl	b604 <net_pkt_alloc_buffer>
	if (ret) {
   13f1c:	b118      	cbz	r0, 13f26 <pkt_alloc_with_buffer+0x5a>
		net_pkt_unref(pkt);
   13f1e:	4620      	mov	r0, r4
   13f20:	f7ff ff19 	bl	13d56 <net_pkt_unref>
		return NULL;
   13f24:	2400      	movs	r4, #0
}
   13f26:	4620      	mov	r0, r4
   13f28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00013f2c <net_pkt_skip>:
{
   13f2c:	b507      	push	{r0, r1, r2, lr}
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
   13f2e:	2301      	movs	r3, #1
   13f30:	9300      	str	r3, [sp, #0]
   13f32:	2300      	movs	r3, #0
   13f34:	460a      	mov	r2, r1
   13f36:	4619      	mov	r1, r3
   13f38:	f7ff fe7f 	bl	13c3a <net_pkt_cursor_operate>
}
   13f3c:	b003      	add	sp, #12
   13f3e:	f85d fb04 	ldr.w	pc, [sp], #4

00013f42 <net_pkt_memset>:
{
   13f42:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
   13f44:	2301      	movs	r3, #1
{
   13f46:	9103      	str	r1, [sp, #12]
	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
   13f48:	9300      	str	r3, [sp, #0]
   13f4a:	a903      	add	r1, sp, #12
   13f4c:	2300      	movs	r3, #0
   13f4e:	f7ff fe74 	bl	13c3a <net_pkt_cursor_operate>
}
   13f52:	b005      	add	sp, #20
   13f54:	f85d fb04 	ldr.w	pc, [sp], #4

00013f58 <net_pkt_read>:
{
   13f58:	b507      	push	{r0, r1, r2, lr}
	return net_pkt_cursor_operate(pkt, data, length, true, false);
   13f5a:	2300      	movs	r3, #0
   13f5c:	9300      	str	r3, [sp, #0]
   13f5e:	2301      	movs	r3, #1
   13f60:	f7ff fe6b 	bl	13c3a <net_pkt_cursor_operate>
}
   13f64:	b003      	add	sp, #12
   13f66:	f85d fb04 	ldr.w	pc, [sp], #4

00013f6a <net_pkt_read_be16>:
{
   13f6a:	b513      	push	{r0, r1, r4, lr}
	ret = net_pkt_read(pkt, d16, sizeof(u16_t));
   13f6c:	2202      	movs	r2, #2
{
   13f6e:	460c      	mov	r4, r1
	ret = net_pkt_read(pkt, d16, sizeof(u16_t));
   13f70:	a901      	add	r1, sp, #4
   13f72:	f7ff fff1 	bl	13f58 <net_pkt_read>
	*data = d16[0] << 8 | d16[1];
   13f76:	f89d 2004 	ldrb.w	r2, [sp, #4]
   13f7a:	f89d 3005 	ldrb.w	r3, [sp, #5]
   13f7e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   13f82:	8023      	strh	r3, [r4, #0]
}
   13f84:	b002      	add	sp, #8
   13f86:	bd10      	pop	{r4, pc}

00013f88 <net_pkt_copy>:
{
   13f88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13f8a:	4606      	mov	r6, r0
   13f8c:	460f      	mov	r7, r1
   13f8e:	4614      	mov	r4, r2
	while (c_dst->buf && c_src->buf && length) {
   13f90:	69b3      	ldr	r3, [r6, #24]
   13f92:	2b00      	cmp	r3, #0
   13f94:	d041      	beq.n	1401a <net_pkt_copy+0x92>
   13f96:	69bb      	ldr	r3, [r7, #24]
   13f98:	2b00      	cmp	r3, #0
   13f9a:	d03e      	beq.n	1401a <net_pkt_copy+0x92>
   13f9c:	b90c      	cbnz	r4, 13fa2 <net_pkt_copy+0x1a>
	return 0;
   13f9e:	4620      	mov	r0, r4
   13fa0:	e021      	b.n	13fe6 <net_pkt_copy+0x5e>
		pkt_cursor_advance(pkt_dst, true);
   13fa2:	2101      	movs	r1, #1
   13fa4:	4630      	mov	r0, r6
   13fa6:	f7ff fe07 	bl	13bb8 <pkt_cursor_advance>
		pkt_cursor_advance(pkt_src, false);
   13faa:	2100      	movs	r1, #0
   13fac:	4638      	mov	r0, r7
   13fae:	f7ff fe03 	bl	13bb8 <pkt_cursor_advance>
		if (!c_dst->buf || !c_src->buf) {
   13fb2:	69b2      	ldr	r2, [r6, #24]
   13fb4:	b1aa      	cbz	r2, 13fe2 <net_pkt_copy+0x5a>
   13fb6:	69bb      	ldr	r3, [r7, #24]
   13fb8:	b19b      	cbz	r3, 13fe2 <net_pkt_copy+0x5a>
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
   13fba:	899d      	ldrh	r5, [r3, #12]
   13fbc:	69f9      	ldr	r1, [r7, #28]
   13fbe:	689b      	ldr	r3, [r3, #8]
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
   13fc0:	69f0      	ldr	r0, [r6, #28]
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
   13fc2:	1acb      	subs	r3, r1, r3
   13fc4:	1aed      	subs	r5, r5, r3
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
   13fc6:	89d3      	ldrh	r3, [r2, #14]
   13fc8:	6892      	ldr	r2, [r2, #8]
		if (length < s_len && length < d_len) {
   13fca:	42ac      	cmp	r4, r5
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
   13fcc:	eba0 0202 	sub.w	r2, r0, r2
   13fd0:	eba3 0302 	sub.w	r3, r3, r2
		if (length < s_len && length < d_len) {
   13fd4:	d201      	bcs.n	13fda <net_pkt_copy+0x52>
   13fd6:	429c      	cmp	r4, r3
   13fd8:	d306      	bcc.n	13fe8 <net_pkt_copy+0x60>
			if (d_len < s_len) {
   13fda:	429d      	cmp	r5, r3
   13fdc:	bf28      	it	cs
   13fde:	461d      	movcs	r5, r3
		if (!len) {
   13fe0:	b91d      	cbnz	r5, 13fea <net_pkt_copy+0x62>
		return -ENOBUFS;
   13fe2:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   13fe6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13fe8:	4625      	mov	r5, r4
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   13fea:	462a      	mov	r2, r5
   13fec:	f7ee f8c2 	bl	2174 <memcpy>
	return pkt->overwrite;
   13ff0:	f896 3041 	ldrb.w	r3, [r6, #65]	; 0x41
		if (!net_pkt_is_being_overwritten(pkt_dst)) {
   13ff4:	07db      	lsls	r3, r3, #31
   13ff6:	d404      	bmi.n	14002 <net_pkt_copy+0x7a>
			net_buf_add(c_dst->buf, len);
   13ff8:	69b0      	ldr	r0, [r6, #24]
   13ffa:	4629      	mov	r1, r5
   13ffc:	3008      	adds	r0, #8
   13ffe:	f7ff f853 	bl	130a8 <net_buf_simple_add>
		pkt_cursor_update(pkt_dst, len, true);
   14002:	2201      	movs	r2, #1
   14004:	4629      	mov	r1, r5
   14006:	4630      	mov	r0, r6
   14008:	f7ff fde7 	bl	13bda <pkt_cursor_update>
		pkt_cursor_update(pkt_src, len, false);
   1400c:	2200      	movs	r2, #0
   1400e:	4629      	mov	r1, r5
   14010:	4638      	mov	r0, r7
   14012:	f7ff fde2 	bl	13bda <pkt_cursor_update>
		length -= len;
   14016:	1b64      	subs	r4, r4, r5
   14018:	e7ba      	b.n	13f90 <net_pkt_copy+0x8>
	if (length) {
   1401a:	2c00      	cmp	r4, #0
   1401c:	d0bf      	beq.n	13f9e <net_pkt_copy+0x16>
   1401e:	e7e0      	b.n	13fe2 <net_pkt_copy+0x5a>

00014020 <net_pkt_remaining_data>:
	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
   14020:	b170      	cbz	r0, 14040 <net_pkt_remaining_data+0x20>
   14022:	6983      	ldr	r3, [r0, #24]
   14024:	b15b      	cbz	r3, 1403e <net_pkt_remaining_data+0x1e>
   14026:	69c0      	ldr	r0, [r0, #28]
   14028:	b150      	cbz	r0, 14040 <net_pkt_remaining_data+0x20>
	data_length = buf->len - (pkt->cursor.pos - buf->data);
   1402a:	6899      	ldr	r1, [r3, #8]
   1402c:	899a      	ldrh	r2, [r3, #12]
   1402e:	1a40      	subs	r0, r0, r1
   14030:	1a10      	subs	r0, r2, r0
		buf = buf->frags;
   14032:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   14034:	b903      	cbnz	r3, 14038 <net_pkt_remaining_data+0x18>
   14036:	4770      	bx	lr
		data_length += buf->len;
   14038:	899a      	ldrh	r2, [r3, #12]
   1403a:	4410      	add	r0, r2
   1403c:	e7f9      	b.n	14032 <net_pkt_remaining_data+0x12>
		return 0;
   1403e:	4618      	mov	r0, r3
}
   14040:	4770      	bx	lr

00014042 <net_pkt_update_length>:
	for (buf = pkt->buffer; buf; buf = buf->frags) {
   14042:	6943      	ldr	r3, [r0, #20]
   14044:	b92b      	cbnz	r3, 14052 <net_pkt_update_length+0x10>
	return !length ? 0 : -EINVAL;
   14046:	2900      	cmp	r1, #0
}
   14048:	bf14      	ite	ne
   1404a:	f06f 0015 	mvnne.w	r0, #21
   1404e:	2000      	moveq	r0, #0
   14050:	4770      	bx	lr
		if (buf->len < length) {
   14052:	899a      	ldrh	r2, [r3, #12]
   14054:	428a      	cmp	r2, r1
			buf->len = length;
   14056:	bf2a      	itet	cs
   14058:	8199      	strhcs	r1, [r3, #12]
			length -= buf->len;
   1405a:	1a89      	subcc	r1, r1, r2
			length = 0;
   1405c:	2100      	movcs	r1, #0
	for (buf = pkt->buffer; buf; buf = buf->frags) {
   1405e:	681b      	ldr	r3, [r3, #0]
   14060:	e7f0      	b.n	14044 <net_pkt_update_length+0x2>

00014062 <net_pkt_is_contiguous>:
	if (pkt->cursor.buf && pkt->cursor.pos) {
   14062:	6982      	ldr	r2, [r0, #24]
{
   14064:	b510      	push	{r4, lr}
	if (pkt->cursor.buf && pkt->cursor.pos) {
   14066:	b17a      	cbz	r2, 14088 <net_pkt_is_contiguous+0x26>
   14068:	69c3      	ldr	r3, [r0, #28]
   1406a:	b17b      	cbz	r3, 1408c <net_pkt_is_contiguous+0x2a>
   1406c:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
			pkt->cursor.buf->len : pkt->cursor.buf->size;
   14070:	07c0      	lsls	r0, r0, #31
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
   14072:	6890      	ldr	r0, [r2, #8]
			pkt->cursor.buf->len : pkt->cursor.buf->size;
   14074:	bf4c      	ite	mi
   14076:	8994      	ldrhmi	r4, [r2, #12]
   14078:	89d4      	ldrhpl	r4, [r2, #14]
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
   1407a:	1a1b      	subs	r3, r3, r0
   1407c:	1ae3      	subs	r3, r4, r3
		if (len >= size) {
   1407e:	428b      	cmp	r3, r1
   14080:	bf34      	ite	cc
   14082:	2000      	movcc	r0, #0
   14084:	2001      	movcs	r0, #1
}
   14086:	bd10      	pop	{r4, pc}
	return false;
   14088:	4610      	mov	r0, r2
   1408a:	e7fc      	b.n	14086 <net_pkt_is_contiguous+0x24>
   1408c:	4618      	mov	r0, r3
   1408e:	e7fa      	b.n	14086 <net_pkt_is_contiguous+0x24>

00014090 <net_pkt_write>:
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
   14090:	69c3      	ldr	r3, [r0, #28]
   14092:	4299      	cmp	r1, r3
{
   14094:	b573      	push	{r0, r1, r4, r5, r6, lr}
   14096:	4604      	mov	r4, r0
   14098:	460e      	mov	r6, r1
   1409a:	4615      	mov	r5, r2
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
   1409c:	d109      	bne.n	140b2 <net_pkt_write+0x22>
   1409e:	4611      	mov	r1, r2
   140a0:	f7ff ffdf 	bl	14062 <net_pkt_is_contiguous>
   140a4:	b128      	cbz	r0, 140b2 <net_pkt_write+0x22>
		return net_pkt_skip(pkt, length);
   140a6:	4620      	mov	r0, r4
}
   140a8:	b002      	add	sp, #8
   140aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return net_pkt_skip(pkt, length);
   140ae:	f7ff bf3d 	b.w	13f2c <net_pkt_skip>
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
   140b2:	2301      	movs	r3, #1
   140b4:	9300      	str	r3, [sp, #0]
   140b6:	462a      	mov	r2, r5
   140b8:	4631      	mov	r1, r6
   140ba:	4620      	mov	r0, r4
   140bc:	f7ff fdbd 	bl	13c3a <net_pkt_cursor_operate>
}
   140c0:	b002      	add	sp, #8
   140c2:	bd70      	pop	{r4, r5, r6, pc}

000140c4 <net_pkt_set_data>:
{
	if (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {
		return net_pkt_skip(pkt, access->size);
	}

	return net_pkt_write(pkt, access->data, access->size);
   140c4:	e9d1 1200 	ldrd	r1, r2, [r1]
   140c8:	f7ff bfe2 	b.w	14090 <net_pkt_write>

000140cc <net_pkt_init>:
		(size_t)(k_mem_slab_num_free_get(&tx_pkts) *
			 sizeof(struct net_pkt)),
		get_frees(&rx_bufs), get_size(&rx_bufs),
		get_frees(&tx_bufs), get_size(&tx_bufs));
#endif
}
   140cc:	4770      	bx	lr

000140ce <k_work_submit_to_queue>:
{
   140ce:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   140d0:	f101 0308 	add.w	r3, r1, #8
   140d4:	f3bf 8f5b 	dmb	ish
   140d8:	e853 2f00 	ldrex	r2, [r3]
   140dc:	f042 0c01 	orr.w	ip, r2, #1
   140e0:	e843 ce00 	strex	lr, ip, [r3]
   140e4:	f1be 0f00 	cmp.w	lr, #0
   140e8:	d1f6      	bne.n	140d8 <k_work_submit_to_queue+0xa>
   140ea:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   140ee:	07d3      	lsls	r3, r2, #31
   140f0:	d403      	bmi.n	140fa <k_work_submit_to_queue+0x2c>
}
   140f2:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   140f6:	f001 bcfa 	b.w	15aee <k_queue_append>
}
   140fa:	f85d fb04 	ldr.w	pc, [sp], #4

000140fe <net_rx_priority2tc>:
   140fe:	f7f7 bb9d 	b.w	b83c <net_tx_priority2tc>

00014102 <calc_chksum>:

	return 0;
}

static u16_t calc_chksum(u16_t sum, const u8_t *data, size_t len)
{
   14102:	b510      	push	{r4, lr}
	const u8_t *end;
	u16_t tmp;

	end = data + len - 1;
   14104:	3a01      	subs	r2, #1
   14106:	440a      	add	r2, r1

	while (data < end) {
   14108:	4291      	cmp	r1, r2
   1410a:	d309      	bcc.n	14120 <calc_chksum+0x1e>
		}

		data += 2;
	}

	if (data == end) {
   1410c:	d107      	bne.n	1411e <calc_chksum+0x1c>
		tmp = data[0] << 8;
   1410e:	780b      	ldrb	r3, [r1, #0]
   14110:	021b      	lsls	r3, r3, #8
		sum += tmp;
   14112:	4418      	add	r0, r3
   14114:	b280      	uxth	r0, r0
		if (sum < tmp) {
   14116:	4283      	cmp	r3, r0
			sum++;
   14118:	bf84      	itt	hi
   1411a:	3001      	addhi	r0, #1
   1411c:	b280      	uxthhi	r0, r0
		}
	}

	return sum;
}
   1411e:	bd10      	pop	{r4, pc}
		tmp = (data[0] << 8) + data[1];
   14120:	780c      	ldrb	r4, [r1, #0]
   14122:	784b      	ldrb	r3, [r1, #1]
   14124:	eb03 2304 	add.w	r3, r3, r4, lsl #8
   14128:	b29b      	uxth	r3, r3
		sum += tmp;
   1412a:	4418      	add	r0, r3
   1412c:	b280      	uxth	r0, r0
		if (sum < tmp) {
   1412e:	4283      	cmp	r3, r0
			sum++;
   14130:	bf84      	itt	hi
   14132:	3001      	addhi	r0, #1
   14134:	b280      	uxthhi	r0, r0
		data += 2;
   14136:	3102      	adds	r1, #2
   14138:	e7e6      	b.n	14108 <calc_chksum+0x6>

0001413a <net_byte_to_hex>:
{
   1413a:	b570      	push	{r4, r5, r6, lr}
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
   1413c:	090e      	lsrs	r6, r1, #4
		if (i == 0 && !pad && !val) {
   1413e:	b1b3      	cbz	r3, 1416e <net_byte_to_hex+0x34>
		if (val < 10) {
   14140:	2e09      	cmp	r6, #9
			*ptr++ = (char) (val - 10 + base);
   14142:	b274      	sxtb	r4, r6
   14144:	bf86      	itte	hi
   14146:	f1a2 030a 	subhi.w	r3, r2, #10
   1414a:	18e4      	addhi	r4, r4, r3
			*ptr++ = (char) (val + '0');
   1414c:	3430      	addls	r4, #48	; 0x30
   1414e:	1c45      	adds	r5, r0, #1
   14150:	7004      	strb	r4, [r0, #0]
   14152:	f001 010f 	and.w	r1, r1, #15
		if (val < 10) {
   14156:	2909      	cmp	r1, #9
			*ptr++ = (char) (val - 10 + base);
   14158:	b24b      	sxtb	r3, r1
   1415a:	bf83      	ittte	hi
   1415c:	3a0a      	subhi	r2, #10
   1415e:	189b      	addhi	r3, r3, r2
   14160:	b2db      	uxtbhi	r3, r3
			*ptr++ = (char) (val + '0');
   14162:	3330      	addls	r3, #48	; 0x30
   14164:	702b      	strb	r3, [r5, #0]
	*ptr = '\0';
   14166:	2300      	movs	r3, #0
   14168:	706b      	strb	r3, [r5, #1]
   1416a:	1c68      	adds	r0, r5, #1
}
   1416c:	bd70      	pop	{r4, r5, r6, pc}
		if (i == 0 && !pad && !val) {
   1416e:	2e00      	cmp	r6, #0
   14170:	d1e6      	bne.n	14140 <net_byte_to_hex+0x6>
   14172:	4605      	mov	r5, r0
   14174:	e7ed      	b.n	14152 <net_byte_to_hex+0x18>

00014176 <net_addr_pton>:
	if (family == AF_INET) {
   14176:	2801      	cmp	r0, #1
{
   14178:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1417c:	460c      	mov	r4, r1
   1417e:	4616      	mov	r6, r2
	if (family == AF_INET) {
   14180:	d126      	bne.n	141d0 <net_addr_pton+0x5a>
		len = strlen(src);
   14182:	4608      	mov	r0, r1
   14184:	f7ee f850 	bl	2228 <strlen>
		for (i = 0; i < len; i++) {
   14188:	4623      	mov	r3, r4
   1418a:	4420      	add	r0, r4
   1418c:	4283      	cmp	r3, r0
   1418e:	d112      	bne.n	141b6 <net_addr_pton+0x40>
__ssp_bos_icheck3(memset, void *, int)
   14190:	4635      	mov	r5, r6
   14192:	2300      	movs	r3, #0
   14194:	f845 3901 	str.w	r3, [r5], #-1
   14198:	3603      	adds	r6, #3
			addr->s4_addr[i] = strtol(src, &endptr, 10);
   1419a:	4620      	mov	r0, r4
   1419c:	220a      	movs	r2, #10
   1419e:	a901      	add	r1, sp, #4
   141a0:	f7ec ff3a 	bl	1018 <strtol>
   141a4:	f805 0f01 	strb.w	r0, [r5, #1]!
			src = ++endptr;
   141a8:	9c01      	ldr	r4, [sp, #4]
		for (i = 0; i < sizeof(struct in_addr); i++) {
   141aa:	42ae      	cmp	r6, r5
			src = ++endptr;
   141ac:	f104 0401 	add.w	r4, r4, #1
		for (i = 0; i < sizeof(struct in_addr); i++) {
   141b0:	d1f3      	bne.n	1419a <net_addr_pton+0x24>
	return 0;
   141b2:	2000      	movs	r0, #0
   141b4:	e009      	b.n	141ca <net_addr_pton+0x54>
			if (!(src[i] >= '0' && src[i] <= '9') &&
   141b6:	f813 2b01 	ldrb.w	r2, [r3], #1
   141ba:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   141be:	2909      	cmp	r1, #9
   141c0:	d9e4      	bls.n	1418c <net_addr_pton+0x16>
   141c2:	2a2e      	cmp	r2, #46	; 0x2e
   141c4:	d0e2      	beq.n	1418c <net_addr_pton+0x16>
				return -EINVAL;
   141c6:	f06f 0015 	mvn.w	r0, #21
}
   141ca:	b003      	add	sp, #12
   141cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (family == AF_INET6) {
   141d0:	2802      	cmp	r0, #2
   141d2:	d1f8      	bne.n	141c6 <net_addr_pton+0x50>
		int expected_groups = strchr(src, '.') ? 6 : 8;
   141d4:	212e      	movs	r1, #46	; 0x2e
   141d6:	4620      	mov	r0, r4
   141d8:	f7ee f80f 	bl	21fa <strchr>
		if (*src == ':') {
   141dc:	7823      	ldrb	r3, [r4, #0]
		int expected_groups = strchr(src, '.') ? 6 : 8;
   141de:	2800      	cmp	r0, #0
   141e0:	bf14      	ite	ne
   141e2:	2706      	movne	r7, #6
   141e4:	2708      	moveq	r7, #8
		if (*src == ':') {
   141e6:	2b3a      	cmp	r3, #58	; 0x3a
			src++;
   141e8:	bf08      	it	eq
   141ea:	3401      	addeq	r4, #1
		len = strlen(src);
   141ec:	4620      	mov	r0, r4
   141ee:	f7ee f81b 	bl	2228 <strlen>
		for (i = 0; i < len; i++) {
   141f2:	2300      	movs	r3, #0
   141f4:	4283      	cmp	r3, r0
   141f6:	db21      	blt.n	1423c <net_addr_pton+0xc6>
		for (i = 0; i < expected_groups; i++) {
   141f8:	2500      	movs	r5, #0
				UNALIGNED_PUT(htons(strtol(src, NULL, 16)),
   141fa:	46a9      	mov	r9, r5
			if (!src || *src == '\0') {
   141fc:	2c00      	cmp	r4, #0
   141fe:	d0e2      	beq.n	141c6 <net_addr_pton+0x50>
   14200:	7823      	ldrb	r3, [r4, #0]
   14202:	2b00      	cmp	r3, #0
   14204:	d0df      	beq.n	141c6 <net_addr_pton+0x50>
			if (*src != ':') {
   14206:	2b3a      	cmp	r3, #58	; 0x3a
   14208:	d02d      	beq.n	14266 <net_addr_pton+0xf0>
				UNALIGNED_PUT(htons(strtol(src, NULL, 16)),
   1420a:	2210      	movs	r2, #16
   1420c:	2100      	movs	r1, #0
   1420e:	4620      	mov	r0, r4
   14210:	f7ec ff02 	bl	1018 <strtol>
   14214:	2210      	movs	r2, #16
   14216:	4680      	mov	r8, r0
   14218:	2100      	movs	r1, #0
   1421a:	4620      	mov	r0, r4
   1421c:	f7ec fefc 	bl	1018 <strtol>
   14220:	f3c8 2807 	ubfx	r8, r8, #8, #8
   14224:	ea48 2800 	orr.w	r8, r8, r0, lsl #8
   14228:	f826 8015 	strh.w	r8, [r6, r5, lsl #1]
				src = strchr(src, ':');
   1422c:	213a      	movs	r1, #58	; 0x3a
   1422e:	4620      	mov	r0, r4
   14230:	f7ed ffe3 	bl	21fa <strchr>
				if (src) {
   14234:	4604      	mov	r4, r0
   14236:	b178      	cbz	r0, 14258 <net_addr_pton+0xe2>
			src++;
   14238:	3401      	adds	r4, #1
   1423a:	e010      	b.n	1425e <net_addr_pton+0xe8>
			if (!(src[i] >= '0' && src[i] <= '9') &&
   1423c:	5ce2      	ldrb	r2, [r4, r3]
   1423e:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   14242:	290a      	cmp	r1, #10
   14244:	d906      	bls.n	14254 <net_addr_pton+0xde>
   14246:	f022 0120 	bic.w	r1, r2, #32
   1424a:	3941      	subs	r1, #65	; 0x41
   1424c:	2905      	cmp	r1, #5
   1424e:	d901      	bls.n	14254 <net_addr_pton+0xde>
			    !(src[i] >= 'a' && src[i] <= 'f') &&
   14250:	2a2e      	cmp	r2, #46	; 0x2e
   14252:	d1b8      	bne.n	141c6 <net_addr_pton+0x50>
		for (i = 0; i < len; i++) {
   14254:	3301      	adds	r3, #1
   14256:	e7cd      	b.n	141f4 <net_addr_pton+0x7e>
					if (i < expected_groups - 1) {
   14258:	1e7b      	subs	r3, r7, #1
   1425a:	42ab      	cmp	r3, r5
   1425c:	dcb3      	bgt.n	141c6 <net_addr_pton+0x50>
		for (i = 0; i < expected_groups; i++) {
   1425e:	3501      	adds	r5, #1
   14260:	42af      	cmp	r7, r5
   14262:	dccb      	bgt.n	141fc <net_addr_pton+0x86>
   14264:	e013      	b.n	1428e <net_addr_pton+0x118>
				UNALIGNED_PUT(0, &addr->s6_addr16[i]);
   14266:	eb06 0345 	add.w	r3, r6, r5, lsl #1
   1426a:	f806 9015 	strb.w	r9, [r6, r5, lsl #1]
   1426e:	f883 9001 	strb.w	r9, [r3, #1]
			for (; i < expected_groups; i++) {
   14272:	3501      	adds	r5, #1
   14274:	42af      	cmp	r7, r5
   14276:	dcf6      	bgt.n	14266 <net_addr_pton+0xf0>
			tmp = strrchr(src, ':');
   14278:	213a      	movs	r1, #58	; 0x3a
   1427a:	4620      	mov	r0, r4
   1427c:	f7ed ffef 	bl	225e <strrchr>
			if (src == tmp && (expected_groups == 6 || !src[1])) {
   14280:	42a0      	cmp	r0, r4
   14282:	d11f      	bne.n	142c4 <net_addr_pton+0x14e>
   14284:	2f06      	cmp	r7, #6
   14286:	d001      	beq.n	1428c <net_addr_pton+0x116>
   14288:	7863      	ldrb	r3, [r4, #1]
   1428a:	bb63      	cbnz	r3, 142e6 <net_addr_pton+0x170>
				src++;
   1428c:	3401      	adds	r4, #1
		if (expected_groups == 6) {
   1428e:	2f06      	cmp	r7, #6
   14290:	d18f      	bne.n	141b2 <net_addr_pton+0x3c>
   14292:	360c      	adds	r6, #12
			for (i = 0; i < 4; i++) {
   14294:	2500      	movs	r5, #0
				if (!src || !*src) {
   14296:	2c00      	cmp	r4, #0
   14298:	d095      	beq.n	141c6 <net_addr_pton+0x50>
   1429a:	7823      	ldrb	r3, [r4, #0]
   1429c:	2b00      	cmp	r3, #0
   1429e:	d092      	beq.n	141c6 <net_addr_pton+0x50>
				addr->s6_addr[12 + i] = strtol(src, NULL, 10);
   142a0:	220a      	movs	r2, #10
   142a2:	2100      	movs	r1, #0
   142a4:	4620      	mov	r0, r4
   142a6:	f7ec feb7 	bl	1018 <strtol>
				src = strchr(src, '.');
   142aa:	212e      	movs	r1, #46	; 0x2e
				addr->s6_addr[12 + i] = strtol(src, NULL, 10);
   142ac:	f806 0b01 	strb.w	r0, [r6], #1
				src = strchr(src, '.');
   142b0:	4620      	mov	r0, r4
   142b2:	f7ed ffa2 	bl	21fa <strchr>
				if (src) {
   142b6:	4604      	mov	r4, r0
   142b8:	b1b8      	cbz	r0, 142ea <net_addr_pton+0x174>
					src++;
   142ba:	3401      	adds	r4, #1
			for (i = 0; i < 4; i++) {
   142bc:	3501      	adds	r5, #1
   142be:	2d04      	cmp	r5, #4
   142c0:	d1e9      	bne.n	14296 <net_addr_pton+0x120>
   142c2:	e776      	b.n	141b2 <net_addr_pton+0x3c>
			if (expected_groups == 6) {
   142c4:	2f06      	cmp	r7, #6
   142c6:	d100      	bne.n	142ca <net_addr_pton+0x154>
				tmp--;
   142c8:	3801      	subs	r0, #1
			i = expected_groups - 1;
   142ca:	1e7d      	subs	r5, r7, #1
   142cc:	3001      	adds	r0, #1
				if (*tmp == ':') {
   142ce:	f810 3d01 	ldrb.w	r3, [r0, #-1]!
   142d2:	2b3a      	cmp	r3, #58	; 0x3a
					i--;
   142d4:	bf08      	it	eq
   142d6:	f105 35ff 	addeq.w	r5, r5, #4294967295	; 0xffffffff
				if (i < 0) {
   142da:	2d00      	cmp	r5, #0
   142dc:	f6ff af73 	blt.w	141c6 <net_addr_pton+0x50>
			} while (tmp-- != src);
   142e0:	42a0      	cmp	r0, r4
   142e2:	d1f4      	bne.n	142ce <net_addr_pton+0x158>
   142e4:	e7a8      	b.n	14238 <net_addr_pton+0xc2>
   142e6:	4620      	mov	r0, r4
   142e8:	e7ef      	b.n	142ca <net_addr_pton+0x154>
					if (i < 3) {
   142ea:	2d03      	cmp	r5, #3
   142ec:	f47f af6b 	bne.w	141c6 <net_addr_pton+0x50>
   142f0:	e7e4      	b.n	142bc <net_addr_pton+0x146>

000142f2 <net_calc_chksum>:
	return pkt->family;
   142f2:	f890 3043 	ldrb.w	r3, [r0, #67]	; 0x43
	size_t len = 0U;
	u16_t sum = 0U;
	struct net_pkt_cursor backup;
	bool ow;

	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   142f6:	f3c3 0342 	ubfx	r3, r3, #1, #3
   142fa:	2b01      	cmp	r3, #1
{
   142fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14300:	4605      	mov	r5, r0
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   14302:	d176      	bne.n	143f2 <net_calc_chksum+0x100>
	    net_pkt_family(pkt) == AF_INET) {
		if (proto != IPPROTO_ICMP) {
   14304:	2901      	cmp	r1, #1
   14306:	d04b      	beq.n	143a0 <net_calc_chksum+0xae>
			len = 2 * sizeof(struct in_addr);
			sum = net_pkt_get_len(pkt) -
   14308:	6943      	ldr	r3, [r0, #20]
	size_t bytes = 0;
   1430a:	2200      	movs	r2, #0
	while (buf) {
   1430c:	2b00      	cmp	r3, #0
   1430e:	d143      	bne.n	14398 <net_calc_chksum+0xa6>
				net_pkt_ip_hdr_len(pkt) + proto;
   14310:	f895 4040 	ldrb.w	r4, [r5, #64]	; 0x40
			sum = net_pkt_get_len(pkt) -
   14314:	1b0c      	subs	r4, r1, r4
   14316:	4414      	add	r4, r2
   14318:	b2a4      	uxth	r4, r4
			len = 2 * sizeof(struct in_addr);
   1431a:	f04f 0908 	mov.w	r9, #8
		NET_DBG("Unknown protocol family %d", net_pkt_family(pkt));
		return 0;
	}

	net_pkt_cursor_backup(pkt, &backup);
	net_pkt_cursor_init(pkt);
   1431e:	4628      	mov	r0, r5
	backup->pos = pkt->cursor.pos;
   14320:	e9d5 8706 	ldrd	r8, r7, [r5, #24]
   14324:	f7ff fd8b 	bl	13e3e <net_pkt_cursor_init>
	return pkt->overwrite;
   14328:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41

	ow = net_pkt_is_being_overwritten(pkt);
	net_pkt_set_overwrite(pkt, true);

	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);
   1432c:	f895 1040 	ldrb.w	r1, [r5, #64]	; 0x40
   14330:	f003 0601 	and.w	r6, r3, #1
	pkt->overwrite = overwrite;
   14334:	f043 0301 	orr.w	r3, r3, #1
   14338:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
   1433c:	eba1 0109 	sub.w	r1, r1, r9
   14340:	4628      	mov	r0, r5
   14342:	f7ff fdf3 	bl	13f2c <net_pkt_skip>

	sum = calc_chksum(sum, pkt->cursor.pos, len);
   14346:	464a      	mov	r2, r9
   14348:	69e9      	ldr	r1, [r5, #28]
   1434a:	4620      	mov	r0, r4
   1434c:	f7ff fed9 	bl	14102 <calc_chksum>

	net_pkt_skip(pkt, len + net_pkt_ipv6_ext_len(pkt));
   14350:	4649      	mov	r1, r9
	sum = calc_chksum(sum, pkt->cursor.pos, len);
   14352:	4604      	mov	r4, r0
	net_pkt_skip(pkt, len + net_pkt_ipv6_ext_len(pkt));
   14354:	4628      	mov	r0, r5
   14356:	f7ff fde9 	bl	13f2c <net_pkt_skip>
	if (!cur->buf || !cur->pos) {
   1435a:	69aa      	ldr	r2, [r5, #24]
   1435c:	b162      	cbz	r2, 14378 <net_calc_chksum+0x86>
   1435e:	69eb      	ldr	r3, [r5, #28]
   14360:	b153      	cbz	r3, 14378 <net_calc_chksum+0x86>
	len = cur->buf->len - (cur->pos - cur->buf->data);
   14362:	f8b2 900c 	ldrh.w	r9, [r2, #12]
   14366:	6892      	ldr	r2, [r2, #8]
   14368:	1a9b      	subs	r3, r3, r2
   1436a:	eba9 0903 	sub.w	r9, r9, r3
	while (cur->buf) {
   1436e:	f8d5 a018 	ldr.w	sl, [r5, #24]
   14372:	f1ba 0f00 	cmp.w	sl, #0
   14376:	d116      	bne.n	143a6 <net_calc_chksum+0xb4>

	sum = pkt_calc_chksum(pkt, sum);

	sum = (sum == 0U) ? 0xffff : htons(sum);
   14378:	2c00      	cmp	r4, #0
   1437a:	d037      	beq.n	143ec <net_calc_chksum+0xfa>
   1437c:	ba60      	rev16	r0, r4
   1437e:	b280      	uxth	r0, r0
   14380:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
	pkt->cursor.pos = backup->pos;
   14384:	e9c5 8706 	strd	r8, r7, [r5, #24]
	pkt->overwrite = overwrite;
   14388:	f366 0300 	bfi	r3, r6, #0, #1

	net_pkt_cursor_restore(pkt, &backup);

	net_pkt_set_overwrite(pkt, ow);

	return ~sum;
   1438c:	43c0      	mvns	r0, r0
   1438e:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
   14392:	b280      	uxth	r0, r0
}
   14394:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		bytes += buf->len;
   14398:	8998      	ldrh	r0, [r3, #12]
		buf = buf->frags;
   1439a:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   1439c:	4402      	add	r2, r0
		buf = buf->frags;
   1439e:	e7b5      	b.n	1430c <net_calc_chksum+0x1a>
	u16_t sum = 0U;
   143a0:	2400      	movs	r4, #0
	size_t len = 0U;
   143a2:	46a1      	mov	r9, r4
   143a4:	e7bb      	b.n	1431e <net_calc_chksum+0x2c>
		sum = calc_chksum(sum, cur->pos, len);
   143a6:	4620      	mov	r0, r4
   143a8:	464a      	mov	r2, r9
   143aa:	69e9      	ldr	r1, [r5, #28]
   143ac:	f7ff fea9 	bl	14102 <calc_chksum>
		cur->buf = cur->buf->frags;
   143b0:	f8da 3000 	ldr.w	r3, [sl]
   143b4:	61ab      	str	r3, [r5, #24]
		sum = calc_chksum(sum, cur->pos, len);
   143b6:	4604      	mov	r4, r0
		if (!cur->buf || !cur->buf->len) {
   143b8:	2b00      	cmp	r3, #0
   143ba:	d0dd      	beq.n	14378 <net_calc_chksum+0x86>
   143bc:	899a      	ldrh	r2, [r3, #12]
   143be:	2a00      	cmp	r2, #0
   143c0:	d0da      	beq.n	14378 <net_calc_chksum+0x86>
		cur->pos = cur->buf->data;
   143c2:	689b      	ldr	r3, [r3, #8]
   143c4:	61eb      	str	r3, [r5, #28]
		if (len % 2) {
   143c6:	f019 0f01 	tst.w	r9, #1
   143ca:	d00d      	beq.n	143e8 <net_calc_chksum+0xf6>
			sum += *cur->pos;
   143cc:	7819      	ldrb	r1, [r3, #0]
   143ce:	440c      	add	r4, r1
   143d0:	b2a4      	uxth	r4, r4
			if (sum < *cur->pos) {
   143d2:	42a1      	cmp	r1, r4
				sum++;
   143d4:	bf88      	it	hi
   143d6:	3401      	addhi	r4, #1
			cur->pos++;
   143d8:	f103 0301 	add.w	r3, r3, #1
				sum++;
   143dc:	bf88      	it	hi
   143de:	b2a4      	uxthhi	r4, r4
			cur->pos++;
   143e0:	61eb      	str	r3, [r5, #28]
			len = cur->buf->len - 1;
   143e2:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
   143e6:	e7c2      	b.n	1436e <net_calc_chksum+0x7c>
			len = cur->buf->len;
   143e8:	4691      	mov	r9, r2
   143ea:	e7c0      	b.n	1436e <net_calc_chksum+0x7c>
	sum = (sum == 0U) ? 0xffff : htons(sum);
   143ec:	f64f 70ff 	movw	r0, #65535	; 0xffff
   143f0:	e7c6      	b.n	14380 <net_calc_chksum+0x8e>
		return 0;
   143f2:	2000      	movs	r0, #0
   143f4:	e7ce      	b.n	14394 <net_calc_chksum+0xa2>

000143f6 <net_calc_chksum_ipv4>:

#if defined(CONFIG_NET_IPV4)
u16_t net_calc_chksum_ipv4(struct net_pkt *pkt)
{
   143f6:	b508      	push	{r3, lr}
	u16_t sum;

	sum = calc_chksum(0, pkt->buffer->data, net_pkt_ip_hdr_len(pkt));
   143f8:	6943      	ldr	r3, [r0, #20]
   143fa:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
   143fe:	6899      	ldr	r1, [r3, #8]
   14400:	2000      	movs	r0, #0
   14402:	f7ff fe7e 	bl	14102 <calc_chksum>

	sum = (sum == 0U) ? 0xffff : htons(sum);
   14406:	b120      	cbz	r0, 14412 <net_calc_chksum_ipv4+0x1c>
   14408:	ba40      	rev16	r0, r0
   1440a:	b280      	uxth	r0, r0

	return ~sum;
   1440c:	43c0      	mvns	r0, r0
}
   1440e:	b280      	uxth	r0, r0
   14410:	bd08      	pop	{r3, pc}
	sum = (sum == 0U) ? 0xffff : htons(sum);
   14412:	f64f 70ff 	movw	r0, #65535	; 0xffff
   14416:	e7f9      	b.n	1440c <net_calc_chksum_ipv4+0x16>

00014418 <icmpv4_create>:
{
   14418:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   1441a:	2304      	movs	r3, #4
{
   1441c:	460f      	mov	r7, r1
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   1441e:	2400      	movs	r4, #0
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   14420:	4669      	mov	r1, sp
{
   14422:	4605      	mov	r5, r0
   14424:	4616      	mov	r6, r2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   14426:	e9cd 4300 	strd	r4, r3, [sp]
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   1442a:	f7f7 f9b9 	bl	b7a0 <net_pkt_get_data>
	if (!icmp_hdr) {
   1442e:	b148      	cbz	r0, 14444 <icmpv4_create+0x2c>
	icmp_hdr->type   = icmp_type;
   14430:	7007      	strb	r7, [r0, #0]
	icmp_hdr->code   = icmp_code;
   14432:	7046      	strb	r6, [r0, #1]
	icmp_hdr->chksum = 0U;
   14434:	7084      	strb	r4, [r0, #2]
   14436:	70c4      	strb	r4, [r0, #3]
	return net_pkt_set_data(pkt, &icmpv4_access);
   14438:	4669      	mov	r1, sp
   1443a:	4628      	mov	r0, r5
   1443c:	f7ff fe42 	bl	140c4 <net_pkt_set_data>
}
   14440:	b003      	add	sp, #12
   14442:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -ENOBUFS;
   14444:	f06f 0068 	mvn.w	r0, #104	; 0x68
   14448:	e7fa      	b.n	14440 <icmpv4_create+0x28>

0001444a <icmpv4_handle_echo_request>:
	return UNALIGNED_GET(&addr->s_addr) == 0;
   1444a:	68cb      	ldr	r3, [r1, #12]
{
   1444c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1444e:	4606      	mov	r6, r0
   14450:	460f      	mov	r7, r1
	if (net_ipv4_is_addr_unspecified(&ip_hdr->src)) {
   14452:	b90b      	cbnz	r3, 14458 <icmpv4_handle_echo_request+0xe>
	return NET_DROP;
   14454:	2002      	movs	r0, #2
   14456:	e048      	b.n	144ea <icmpv4_handle_echo_request+0xa0>
	payload_len = net_pkt_get_len(pkt) -
   14458:	6943      	ldr	r3, [r0, #20]
	size_t bytes = 0;
   1445a:	2200      	movs	r2, #0
	while (buf) {
   1445c:	2b00      	cmp	r3, #0
   1445e:	d146      	bne.n	144ee <icmpv4_handle_echo_request+0xa4>
		net_pkt_ip_hdr_len(pkt) - NET_ICMPH_LEN;
   14460:	f896 4040 	ldrb.w	r4, [r6, #64]	; 0x40
   14464:	f5c4 447f 	rsb	r4, r4, #65280	; 0xff00
   14468:	34fc      	adds	r4, #252	; 0xfc
   1446a:	4414      	add	r4, r2
	payload_len = net_pkt_get_len(pkt) -
   1446c:	b224      	sxth	r4, r4
	if (payload_len < NET_ICMPV4_UNUSED_LEN) {
   1446e:	2c03      	cmp	r4, #3
   14470:	ddf0      	ble.n	14454 <icmpv4_handle_echo_request+0xa>
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt), payload_len,
   14472:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   14476:	9300      	str	r3, [sp, #0]
   14478:	2301      	movs	r3, #1
   1447a:	461a      	mov	r2, r3
   1447c:	4621      	mov	r1, r4
   1447e:	6a70      	ldr	r0, [r6, #36]	; 0x24
   14480:	f7f7 f980 	bl	b784 <net_pkt_alloc_with_buffer>
	if (!reply) {
   14484:	4605      	mov	r5, r0
   14486:	2800      	cmp	r0, #0
   14488:	d0e4      	beq.n	14454 <icmpv4_handle_echo_request+0xa>
	if (net_ipv4_is_addr_mcast(&ip_hdr->dst)) {
   1448a:	693b      	ldr	r3, [r7, #16]
   1448c:	ba1b      	rev	r3, r3
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
   1448e:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   14492:	f1b3 4f60 	cmp.w	r3, #3758096384	; 0xe0000000
   14496:	f107 0110 	add.w	r1, r7, #16
   1449a:	d103      	bne.n	144a4 <icmpv4_handle_echo_request+0x5a>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
   1449c:	6a70      	ldr	r0, [r6, #36]	; 0x24
   1449e:	f7f6 fe2d 	bl	b0fc <net_if_ipv4_select_src_addr>
   144a2:	4601      	mov	r1, r0
	if (net_ipv4_create(reply, src, &ip_hdr->src) ||
   144a4:	f107 020c 	add.w	r2, r7, #12
   144a8:	4628      	mov	r0, r5
   144aa:	f000 f8bd 	bl	14628 <net_ipv4_create>
   144ae:	4602      	mov	r2, r0
   144b0:	bb08      	cbnz	r0, 144f6 <icmpv4_handle_echo_request+0xac>
	    icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
   144b2:	4601      	mov	r1, r0
   144b4:	4628      	mov	r0, r5
   144b6:	f7ff ffaf 	bl	14418 <icmpv4_create>
	if (net_ipv4_create(reply, src, &ip_hdr->src) ||
   144ba:	b9e0      	cbnz	r0, 144f6 <icmpv4_handle_echo_request+0xac>
	    net_pkt_copy(reply, pkt, payload_len)) {
   144bc:	4622      	mov	r2, r4
   144be:	4631      	mov	r1, r6
   144c0:	4628      	mov	r0, r5
   144c2:	f7ff fd61 	bl	13f88 <net_pkt_copy>
	    icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
   144c6:	4604      	mov	r4, r0
   144c8:	b9a8      	cbnz	r0, 144f6 <icmpv4_handle_echo_request+0xac>
	net_pkt_cursor_init(reply);
   144ca:	4628      	mov	r0, r5
   144cc:	f7ff fcb7 	bl	13e3e <net_pkt_cursor_init>
	net_ipv4_finalize(reply, IPPROTO_ICMP);
   144d0:	2101      	movs	r1, #1
   144d2:	4628      	mov	r0, r5
   144d4:	f000 f8db 	bl	1468e <net_ipv4_finalize>
	if (net_send_data(reply) < 0) {
   144d8:	4628      	mov	r0, r5
   144da:	f7ff fa6d 	bl	139b8 <net_send_data>
   144de:	2800      	cmp	r0, #0
   144e0:	db09      	blt.n	144f6 <icmpv4_handle_echo_request+0xac>
	net_pkt_unref(pkt);
   144e2:	4630      	mov	r0, r6
   144e4:	f7ff fc37 	bl	13d56 <net_pkt_unref>
	return NET_OK;
   144e8:	4620      	mov	r0, r4
}
   144ea:	b003      	add	sp, #12
   144ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bytes += buf->len;
   144ee:	8999      	ldrh	r1, [r3, #12]
		buf = buf->frags;
   144f0:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   144f2:	440a      	add	r2, r1
		buf = buf->frags;
   144f4:	e7b2      	b.n	1445c <icmpv4_handle_echo_request+0x12>
		net_pkt_unref(reply);
   144f6:	4628      	mov	r0, r5
   144f8:	f7ff fc2d 	bl	13d56 <net_pkt_unref>
   144fc:	e7aa      	b.n	14454 <icmpv4_handle_echo_request+0xa>

000144fe <net_icmpv4_finalize>:
{
   144fe:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   14500:	2304      	movs	r3, #4
   14502:	2200      	movs	r2, #0
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   14504:	4669      	mov	r1, sp
{
   14506:	4604      	mov	r4, r0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   14508:	e9cd 2300 	strd	r2, r3, [sp]
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   1450c:	f7f7 f948 	bl	b7a0 <net_pkt_get_data>
	if (!icmp_hdr) {
   14510:	4605      	mov	r5, r0
   14512:	b150      	cbz	r0, 1452a <net_icmpv4_finalize+0x2c>
	return net_calc_chksum(pkt, IPPROTO_ICMP);
   14514:	2101      	movs	r1, #1
   14516:	4620      	mov	r0, r4
   14518:	f7ff feeb 	bl	142f2 <net_calc_chksum>
	return net_pkt_set_data(pkt, &icmpv4_access);
   1451c:	4669      	mov	r1, sp
	icmp_hdr->chksum = net_calc_chksum_icmpv4(pkt);
   1451e:	8068      	strh	r0, [r5, #2]
	return net_pkt_set_data(pkt, &icmpv4_access);
   14520:	4620      	mov	r0, r4
   14522:	f7ff fdcf 	bl	140c4 <net_pkt_set_data>
}
   14526:	b003      	add	sp, #12
   14528:	bd30      	pop	{r4, r5, pc}
		return -ENOBUFS;
   1452a:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1452e:	e7fa      	b.n	14526 <net_icmpv4_finalize+0x28>

00014530 <net_icmpv4_send_error>:
{
   14530:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   14534:	2314      	movs	r3, #20
{
   14536:	b087      	sub	sp, #28
   14538:	4606      	mov	r6, r0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   1453a:	2400      	movs	r4, #0
{
   1453c:	4688      	mov	r8, r1
   1453e:	4691      	mov	r9, r2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   14540:	e9cd 4302 	strd	r4, r3, [sp, #8]
	net_pkt_cursor_init(orig);
   14544:	f7ff fc7b 	bl	13e3e <net_pkt_cursor_init>
	ip_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(orig, &ipv4_access);
   14548:	a902      	add	r1, sp, #8
   1454a:	4630      	mov	r0, r6
   1454c:	f7f7 f928 	bl	b7a0 <net_pkt_get_data>
	if (!ip_hdr) {
   14550:	4605      	mov	r5, r0
   14552:	b378      	cbz	r0, 145b4 <net_icmpv4_send_error+0x84>
	if (ip_hdr->proto == IPPROTO_ICMP) {
   14554:	7a43      	ldrb	r3, [r0, #9]
   14556:	2b01      	cmp	r3, #1
   14558:	d110      	bne.n	1457c <net_icmpv4_send_error+0x4c>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   1455a:	2304      	movs	r3, #4
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
   1455c:	a904      	add	r1, sp, #16
   1455e:	4630      	mov	r0, r6
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   14560:	9404      	str	r4, [sp, #16]
   14562:	9305      	str	r3, [sp, #20]
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
   14564:	f7f7 f91c 	bl	b7a0 <net_pkt_get_data>
		if (!icmp_hdr || icmp_hdr->code < 8) {
   14568:	b110      	cbz	r0, 14570 <net_icmpv4_send_error+0x40>
   1456a:	7843      	ldrb	r3, [r0, #1]
   1456c:	2b07      	cmp	r3, #7
   1456e:	d805      	bhi.n	1457c <net_icmpv4_send_error+0x4c>
			err = -EINVAL;
   14570:	f06f 0515 	mvn.w	r5, #21
}
   14574:	4628      	mov	r0, r5
   14576:	b007      	add	sp, #28
   14578:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (ip_hdr->proto == IPPROTO_UDP) {
   1457c:	7a6b      	ldrb	r3, [r5, #9]
   1457e:	2b11      	cmp	r3, #17
   14580:	d01b      	beq.n	145ba <net_icmpv4_send_error+0x8a>
		copy_len = 0;
   14582:	2b06      	cmp	r3, #6
   14584:	bf0c      	ite	eq
   14586:	2728      	moveq	r7, #40	; 0x28
   14588:	2700      	movne	r7, #0
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
   1458a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1458e:	9300      	str	r3, [sp, #0]
   14590:	2301      	movs	r3, #1
   14592:	461a      	mov	r2, r3
   14594:	1d39      	adds	r1, r7, #4
   14596:	6a70      	ldr	r0, [r6, #36]	; 0x24
   14598:	f7f7 f8f4 	bl	b784 <net_pkt_alloc_with_buffer>
	if (!pkt) {
   1459c:	4604      	mov	r4, r0
   1459e:	b3b8      	cbz	r0, 14610 <net_icmpv4_send_error+0xe0>
	if (net_ipv4_create(pkt, &ip_hdr->dst, &ip_hdr->src) ||
   145a0:	f105 020c 	add.w	r2, r5, #12
   145a4:	f105 0110 	add.w	r1, r5, #16
   145a8:	f000 f83e 	bl	14628 <net_ipv4_create>
   145ac:	b138      	cbz	r0, 145be <net_icmpv4_send_error+0x8e>
	net_pkt_unref(pkt);
   145ae:	4620      	mov	r0, r4
   145b0:	f7ff fbd1 	bl	13d56 <net_pkt_unref>
	int err = -EIO;
   145b4:	f06f 0504 	mvn.w	r5, #4
   145b8:	e7dc      	b.n	14574 <net_icmpv4_send_error+0x44>
		copy_len = sizeof(struct net_ipv4_hdr) +
   145ba:	271c      	movs	r7, #28
   145bc:	e7e5      	b.n	1458a <net_icmpv4_send_error+0x5a>
	    icmpv4_create(pkt, type, code) ||
   145be:	4641      	mov	r1, r8
   145c0:	464a      	mov	r2, r9
   145c2:	4620      	mov	r0, r4
   145c4:	f7ff ff28 	bl	14418 <icmpv4_create>
	if (net_ipv4_create(pkt, &ip_hdr->dst, &ip_hdr->src) ||
   145c8:	4601      	mov	r1, r0
   145ca:	2800      	cmp	r0, #0
   145cc:	d1ef      	bne.n	145ae <net_icmpv4_send_error+0x7e>
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
   145ce:	2204      	movs	r2, #4
   145d0:	4620      	mov	r0, r4
   145d2:	f7ff fcb6 	bl	13f42 <net_pkt_memset>
	    icmpv4_create(pkt, type, code) ||
   145d6:	2800      	cmp	r0, #0
   145d8:	d1e9      	bne.n	145ae <net_icmpv4_send_error+0x7e>
	    net_pkt_copy(pkt, orig, copy_len)) {
   145da:	463a      	mov	r2, r7
   145dc:	4631      	mov	r1, r6
   145de:	4620      	mov	r0, r4
   145e0:	f7ff fcd2 	bl	13f88 <net_pkt_copy>
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
   145e4:	4605      	mov	r5, r0
   145e6:	2800      	cmp	r0, #0
   145e8:	d1e1      	bne.n	145ae <net_icmpv4_send_error+0x7e>
	net_pkt_cursor_init(pkt);
   145ea:	4620      	mov	r0, r4
   145ec:	f7ff fc27 	bl	13e3e <net_pkt_cursor_init>
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
   145f0:	2101      	movs	r1, #1
   145f2:	4620      	mov	r0, r4
   145f4:	f000 f84b 	bl	1468e <net_ipv4_finalize>
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
   145f8:	6af3      	ldr	r3, [r6, #44]	; 0x2c
   145fa:	6363      	str	r3, [r4, #52]	; 0x34
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
   145fc:	f896 3030 	ldrb.w	r3, [r6, #48]	; 0x30
   14600:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
	if (net_send_data(pkt) >= 0) {
   14604:	4620      	mov	r0, r4
   14606:	f7ff f9d7 	bl	139b8 <net_send_data>
   1460a:	2800      	cmp	r0, #0
   1460c:	dab2      	bge.n	14574 <net_icmpv4_send_error+0x44>
   1460e:	e7ce      	b.n	145ae <net_icmpv4_send_error+0x7e>
		err =  -ENOMEM;
   14610:	f06f 050b 	mvn.w	r5, #11
   14614:	e7ae      	b.n	14574 <net_icmpv4_send_error+0x44>

00014616 <net_ipv4_is_addr_mcast>:
   14616:	6800      	ldr	r0, [r0, #0]
   14618:	ba00      	rev	r0, r0
   1461a:	f000 4060 	and.w	r0, r0, #3758096384	; 0xe0000000
}
   1461e:	f100 5300 	add.w	r3, r0, #536870912	; 0x20000000
   14622:	4258      	negs	r0, r3
   14624:	4158      	adcs	r0, r3
   14626:	4770      	bx	lr

00014628 <net_ipv4_create>:
{
   14628:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   1462a:	2314      	movs	r3, #20
{
   1462c:	460e      	mov	r6, r1
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   1462e:	2400      	movs	r4, #0
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   14630:	4669      	mov	r1, sp
{
   14632:	4605      	mov	r5, r0
   14634:	4617      	mov	r7, r2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   14636:	e9cd 4300 	strd	r4, r3, [sp]
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   1463a:	f7f7 f8b1 	bl	b7a0 <net_pkt_get_data>
	if (!ipv4_hdr) {
   1463e:	b318      	cbz	r0, 14688 <net_ipv4_create+0x60>
	ipv4_hdr->vhl       = 0x45;
   14640:	2345      	movs	r3, #69	; 0x45
   14642:	7003      	strb	r3, [r0, #0]
	ipv4_hdr->tos       = 0x00;
   14644:	7044      	strb	r4, [r0, #1]
	ipv4_hdr->id[0]     = 0U;
   14646:	7104      	strb	r4, [r0, #4]
	ipv4_hdr->id[1]     = 0U;
   14648:	7144      	strb	r4, [r0, #5]
	ipv4_hdr->offset[0] = 0U;
   1464a:	7184      	strb	r4, [r0, #6]
	ipv4_hdr->offset[1] = 0U;
   1464c:	71c4      	strb	r4, [r0, #7]
	ipv4_hdr->ttl       = net_pkt_ipv4_ttl(pkt);
   1464e:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
	ipv4_hdr->len       = 0U;
   14652:	7084      	strb	r4, [r0, #2]
   14654:	70c4      	strb	r4, [r0, #3]
	ipv4_hdr->ttl       = net_pkt_ipv4_ttl(pkt);
   14656:	7203      	strb	r3, [r0, #8]
	if (ipv4_hdr->ttl == 0U) {
   14658:	b92b      	cbnz	r3, 14666 <net_ipv4_create+0x3e>
		ipv4_hdr->ttl = net_if_ipv4_get_ttl(net_pkt_iface(pkt));
   1465a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   1465c:	6851      	ldr	r1, [r2, #4]
	if (!iface->config.ip.ipv4) {
   1465e:	b109      	cbz	r1, 14664 <net_ipv4_create+0x3c>
	return iface->config.ip.ipv4->ttl;
   14660:	f891 3020 	ldrb.w	r3, [r1, #32]
   14664:	7203      	strb	r3, [r0, #8]
	ipv4_hdr->proto     = 0U;
   14666:	2300      	movs	r3, #0
   14668:	7243      	strb	r3, [r0, #9]
	ipv4_hdr->chksum    = 0U;
   1466a:	7283      	strb	r3, [r0, #10]
   1466c:	72c3      	strb	r3, [r0, #11]
	net_ipaddr_copy(&ipv4_hdr->dst, dst);
   1466e:	683b      	ldr	r3, [r7, #0]
   14670:	6103      	str	r3, [r0, #16]
	net_ipaddr_copy(&ipv4_hdr->src, src);
   14672:	6833      	ldr	r3, [r6, #0]
   14674:	60c3      	str	r3, [r0, #12]
	pkt->ip_hdr_len = len;
   14676:	2314      	movs	r3, #20
   14678:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
	return net_pkt_set_data(pkt, &ipv4_access);
   1467c:	4669      	mov	r1, sp
   1467e:	4628      	mov	r0, r5
   14680:	f7ff fd20 	bl	140c4 <net_pkt_set_data>
}
   14684:	b003      	add	sp, #12
   14686:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -ENOBUFS;
   14688:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1468c:	e7fa      	b.n	14684 <net_ipv4_create+0x5c>

0001468e <net_ipv4_finalize>:
{
   1468e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   14690:	2314      	movs	r3, #20
   14692:	2500      	movs	r5, #0
   14694:	e9cd 5300 	strd	r5, r3, [sp]
	pkt->overwrite = overwrite;
   14698:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   1469c:	f043 0301 	orr.w	r3, r3, #1
{
   146a0:	460e      	mov	r6, r1
   146a2:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   146a6:	4669      	mov	r1, sp
{
   146a8:	4604      	mov	r4, r0
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   146aa:	f7f7 f879 	bl	b7a0 <net_pkt_get_data>
	if (!ipv4_hdr) {
   146ae:	4607      	mov	r7, r0
   146b0:	b340      	cbz	r0, 14704 <net_ipv4_finalize+0x76>
	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
   146b2:	6962      	ldr	r2, [r4, #20]
	size_t bytes = 0;
   146b4:	462b      	mov	r3, r5
	while (buf) {
   146b6:	b9aa      	cbnz	r2, 146e4 <net_ipv4_finalize+0x56>
   146b8:	ba5b      	rev16	r3, r3
	ipv4_hdr->proto = next_header_proto;
   146ba:	727e      	strb	r6, [r7, #9]
	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
   146bc:	807b      	strh	r3, [r7, #2]
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
   146be:	6a60      	ldr	r0, [r4, #36]	; 0x24
   146c0:	f7f6 fe98 	bl	b3f4 <net_if_need_calc_tx_checksum>
   146c4:	b118      	cbz	r0, 146ce <net_ipv4_finalize+0x40>
		ipv4_hdr->chksum = net_calc_chksum_ipv4(pkt);
   146c6:	4620      	mov	r0, r4
   146c8:	f7ff fe95 	bl	143f6 <net_calc_chksum_ipv4>
   146cc:	8178      	strh	r0, [r7, #10]
	net_pkt_set_data(pkt, &ipv4_access);
   146ce:	4669      	mov	r1, sp
   146d0:	4620      	mov	r0, r4
   146d2:	f7ff fcf7 	bl	140c4 <net_pkt_set_data>
	if (IS_ENABLED(CONFIG_NET_UDP) &&
   146d6:	2e11      	cmp	r6, #17
   146d8:	d108      	bne.n	146ec <net_ipv4_finalize+0x5e>
		return net_udp_finalize(pkt);
   146da:	4620      	mov	r0, r4
   146dc:	f000 fca9 	bl	15032 <net_udp_finalize>
}
   146e0:	b003      	add	sp, #12
   146e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bytes += buf->len;
   146e4:	8991      	ldrh	r1, [r2, #12]
		buf = buf->frags;
   146e6:	6812      	ldr	r2, [r2, #0]
		bytes += buf->len;
   146e8:	440b      	add	r3, r1
		buf = buf->frags;
   146ea:	e7e4      	b.n	146b6 <net_ipv4_finalize+0x28>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
   146ec:	2e06      	cmp	r6, #6
   146ee:	d103      	bne.n	146f8 <net_ipv4_finalize+0x6a>
		return net_tcp_finalize(pkt);
   146f0:	4620      	mov	r0, r4
   146f2:	f000 fbd1 	bl	14e98 <net_tcp_finalize>
   146f6:	e7f3      	b.n	146e0 <net_ipv4_finalize+0x52>
	} else if (next_header_proto == IPPROTO_ICMP) {
   146f8:	2e01      	cmp	r6, #1
   146fa:	d106      	bne.n	1470a <net_ipv4_finalize+0x7c>
		return net_icmpv4_finalize(pkt);
   146fc:	4620      	mov	r0, r4
   146fe:	f7ff fefe 	bl	144fe <net_icmpv4_finalize>
   14702:	e7ed      	b.n	146e0 <net_ipv4_finalize+0x52>
		return -ENOBUFS;
   14704:	f06f 0068 	mvn.w	r0, #104	; 0x68
   14708:	e7ea      	b.n	146e0 <net_ipv4_finalize+0x52>
	return 0;
   1470a:	2000      	movs	r0, #0
   1470c:	e7e8      	b.n	146e0 <net_ipv4_finalize+0x52>

0001470e <net_conn_init>:
		for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
			conn_cache[i].idx = -1;
		}
	} while (0);
#endif /* CONFIG_NET_CONN_CACHE */
}
   1470e:	4770      	bx	lr

00014710 <sys_get_be32>:
 *
 *  @return 16-bit integer in host endianness.
 */
static inline u16_t sys_get_be16(const u8_t src[2])
{
	return ((u16_t)src[0] << 8) | src[1];
   14710:	7803      	ldrb	r3, [r0, #0]
   14712:	7842      	ldrb	r2, [r0, #1]
   14714:	7881      	ldrb	r1, [r0, #2]
 *
 *  @return 32-bit integer in host endianness.
 */
static inline u32_t sys_get_be32(const u8_t src[4])
{
	return ((u32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
   14716:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
	return ((u16_t)src[0] << 8) | src[1];
   1471a:	78c3      	ldrb	r3, [r0, #3]
	return ((u32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
   1471c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
}
   14720:	ea43 4002 	orr.w	r0, r3, r2, lsl #16
   14724:	4770      	bx	lr

00014726 <handle_fin_timeout>:
	net_context_unref(tcp->context);
   14726:	f850 0c28 	ldr.w	r0, [r0, #-40]
   1472a:	f7fe beda 	b.w	134e2 <net_context_unref>

0001472e <net_tcp_queue_pkt.isra.27>:
static int net_tcp_queue_pkt(struct net_context *context, struct net_pkt *pkt)
   1472e:	b538      	push	{r3, r4, r5, lr}
	parent->next = child;
   14730:	2200      	movs	r2, #0
   14732:	4605      	mov	r5, r0
	sys_slist_append(&context->tcp->sent_list, &pkt->sent_list);
   14734:	6800      	ldr	r0, [r0, #0]
   14736:	63ca      	str	r2, [r1, #60]	; 0x3c
Z_GENLIST_APPEND(slist, snode)
   14738:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
static int net_tcp_queue_pkt(struct net_context *context, struct net_pkt *pkt)
   1473c:	460c      	mov	r4, r1
	sys_slist_append(&context->tcp->sent_list, &pkt->sent_list);
   1473e:	f101 033c 	add.w	r3, r1, #60	; 0x3c
   14742:	b9e2      	cbnz	r2, 1477e <net_tcp_queue_pkt.isra.27+0x50>
	list->head = node;
   14744:	e9c0 3322 	strd	r3, r3, [r0, #136]	; 0x88
	return __ticks_to_ms(z_timeout_remaining(&work->timeout));
   14748:	3054      	adds	r0, #84	; 0x54
   1474a:	f7fb f9b3 	bl	fab4 <z_timeout_remaining>
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
   1474e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   14752:	2264      	movs	r2, #100	; 0x64
   14754:	2300      	movs	r3, #0
   14756:	fb80 0101 	smull	r0, r1, r0, r1
   1475a:	f7eb fff5 	bl	748 <__aeabi_uldivmod>
	if (k_delayed_work_remaining_get(&context->tcp->retry_timer) == 0) {
   1475e:	b948      	cbnz	r0, 14774 <net_tcp_queue_pkt.isra.27+0x46>
		k_delayed_work_submit(&context->tcp->retry_timer,
   14760:	6828      	ldr	r0, [r5, #0]
	return ((u32_t)1 << tcp->retry_timeout_shift) *
   14762:	f890 30bc 	ldrb.w	r3, [r0, #188]	; 0xbc
		k_delayed_work_submit(&context->tcp->retry_timer,
   14766:	21c8      	movs	r1, #200	; 0xc8
	return ((u32_t)1 << tcp->retry_timeout_shift) *
   14768:	f003 031f 	and.w	r3, r3, #31
		k_delayed_work_submit(&context->tcp->retry_timer,
   1476c:	4099      	lsls	r1, r3
   1476e:	3048      	adds	r0, #72	; 0x48
   14770:	f7f7 fda8 	bl	c2c4 <k_delayed_work_submit>
	do_ref_if_needed(context->tcp, pkt);
   14774:	4620      	mov	r0, r4
   14776:	f7ff face 	bl	13d16 <net_pkt_ref>
}
   1477a:	2000      	movs	r0, #0
   1477c:	bd38      	pop	{r3, r4, r5, pc}
	parent->next = child;
   1477e:	6013      	str	r3, [r2, #0]
	list->tail = node;
   14780:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
   14784:	e7e0      	b.n	14748 <net_tcp_queue_pkt.isra.27+0x1a>

00014786 <prepare_segment.isra.26>:
static int prepare_segment(struct net_tcp *tcp,
   14786:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1478a:	b08d      	sub	sp, #52	; 0x34
   1478c:	4605      	mov	r5, r0
   1478e:	9303      	str	r3, [sp, #12]
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   14790:	ab07      	add	r3, sp, #28
   14792:	9305      	str	r3, [sp, #20]
   14794:	2314      	movs	r3, #20
static int prepare_segment(struct net_tcp *tcp,
   14796:	460e      	mov	r6, r1
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   14798:	9306      	str	r3, [sp, #24]
	if (pkt) {
   1479a:	4614      	mov	r4, r2
   1479c:	2a00      	cmp	r2, #0
   1479e:	f000 8089 	beq.w	148b4 <prepare_segment.isra.26+0x12e>
		pkt->buffer = NULL;
   147a2:	2300      	movs	r3, #0
		tail = pkt->buffer;
   147a4:	f8d2 8014 	ldr.w	r8, [r2, #20]
		pkt->buffer = NULL;
   147a8:	6153      	str	r3, [r2, #20]
		status = net_pkt_alloc_buffer(pkt, segment->optlen,
   147aa:	7ac9      	ldrb	r1, [r1, #11]
   147ac:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   147b0:	2206      	movs	r2, #6
   147b2:	4620      	mov	r0, r4
   147b4:	f7f6 ff26 	bl	b604 <net_pkt_alloc_buffer>
		if (status) {
   147b8:	4607      	mov	r7, r0
   147ba:	2800      	cmp	r0, #0
   147bc:	f040 809c 	bne.w	148f8 <prepare_segment.isra.26+0x172>
		pkt_allocated = false;
   147c0:	4681      	mov	r9, r0
	return pkt->family;
   147c2:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   147c6:	f3c3 0342 	ubfx	r3, r3, #1, #3
   147ca:	2b01      	cmp	r3, #1
   147cc:	f040 80a9 	bne.w	14922 <prepare_segment.isra.26+0x19c>
				net_sin_ptr(segment->src_addr)->sin_addr,
   147d0:	e9d6 2304 	ldrd	r2, r3, [r6, #16]
		status = net_context_create_ipv4_new(context, pkt,
   147d4:	4621      	mov	r1, r4
   147d6:	3304      	adds	r3, #4
   147d8:	6852      	ldr	r2, [r2, #4]
   147da:	4628      	mov	r0, r5
   147dc:	f7fe fee7 	bl	135ae <net_context_create_ipv4_new>
		if (status < 0) {
   147e0:	1e07      	subs	r7, r0, #0
   147e2:	f2c0 8086 	blt.w	148f2 <prepare_segment.isra.26+0x16c>
		dst_port = net_sin(segment->dst_addr)->sin_port;
   147e6:	6973      	ldr	r3, [r6, #20]
		src_port = ((struct sockaddr_in_ptr *)&context->local)->
   147e8:	f8b5 b01e 	ldrh.w	fp, [r5, #30]
		dst_port = net_sin(segment->dst_addr)->sin_port;
   147ec:	885b      	ldrh	r3, [r3, #2]
   147ee:	9302      	str	r3, [sp, #8]
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
   147f0:	a905      	add	r1, sp, #20
   147f2:	4620      	mov	r0, r4
   147f4:	f7f6 ffd4 	bl	b7a0 <net_pkt_get_data>
	if (!tcp_hdr) {
   147f8:	4605      	mov	r5, r0
   147fa:	2800      	cmp	r0, #0
   147fc:	f000 8094 	beq.w	14928 <prepare_segment.isra.26+0x1a2>
	if (segment->options && segment->optlen) {
   14800:	68f3      	ldr	r3, [r6, #12]
   14802:	2b00      	cmp	r3, #0
   14804:	d06c      	beq.n	148e0 <prepare_segment.isra.26+0x15a>
   14806:	f896 a00b 	ldrb.w	sl, [r6, #11]
   1480a:	f1ba 0f00 	cmp.w	sl, #0
   1480e:	d007      	beq.n	14820 <prepare_segment.isra.26+0x9a>
		if ((segment->optlen & 0x3u) != 0u) {
   14810:	f01a 0f03 	tst.w	sl, #3
   14814:	d004      	beq.n	14820 <prepare_segment.isra.26+0x9a>
			optlen = (segment->optlen & 0xfffCu) + 4u;
   14816:	f02a 0303 	bic.w	r3, sl, #3
   1481a:	3304      	adds	r3, #4
   1481c:	fa5f fa83 	uxtb.w	sl, r3
   14820:	2210      	movs	r2, #16
   14822:	2100      	movs	r1, #0
   14824:	1d28      	adds	r0, r5, #4
   14826:	f7ed fce0 	bl	21ea <memset>
	sys_put_be32(segment->seq, tcp_hdr->seq);
   1482a:	6832      	ldr	r2, [r6, #0]
	dst[1] = val;
   1482c:	71ea      	strb	r2, [r5, #7]
	sys_put_be16(val >> 16, dst);
   1482e:	0c11      	lsrs	r1, r2, #16
	dst[1] = val;
   14830:	7169      	strb	r1, [r5, #5]
	dst[0] = val >> 8;
   14832:	0a08      	lsrs	r0, r1, #8
   14834:	f3c2 2107 	ubfx	r1, r2, #8, #8
   14838:	7128      	strb	r0, [r5, #4]
   1483a:	71a9      	strb	r1, [r5, #6]
	sys_put_be32(segment->ack, tcp_hdr->ack);
   1483c:	6872      	ldr	r2, [r6, #4]
	dst[1] = val;
   1483e:	72ea      	strb	r2, [r5, #11]
	sys_put_be16(val >> 16, dst);
   14840:	0c11      	lsrs	r1, r2, #16
	dst[0] = val >> 8;
   14842:	0a08      	lsrs	r0, r1, #8
	dst[1] = val;
   14844:	7269      	strb	r1, [r5, #9]
	dst[0] = val >> 8;
   14846:	f3c2 2107 	ubfx	r1, r2, #8, #8
	tcp_hdr->offset   = (NET_TCPH_LEN + optlen) << 2;
   1484a:	f10a 0214 	add.w	r2, sl, #20
   1484e:	0092      	lsls	r2, r2, #2
	tcp_hdr->dst_port = dst_port;
   14850:	9b02      	ldr	r3, [sp, #8]
   14852:	7228      	strb	r0, [r5, #8]
   14854:	72a9      	strb	r1, [r5, #10]
	tcp_hdr->offset   = (NET_TCPH_LEN + optlen) << 2;
   14856:	732a      	strb	r2, [r5, #12]
	tcp_hdr->src_port = src_port;
   14858:	f8a5 b000 	strh.w	fp, [r5]
	tcp_hdr->dst_port = dst_port;
   1485c:	806b      	strh	r3, [r5, #2]
	tcp_hdr->flags    = segment->flags;
   1485e:	7ab2      	ldrb	r2, [r6, #10]
   14860:	736a      	strb	r2, [r5, #13]
	sys_put_be16(segment->wnd, tcp_hdr->wnd);
   14862:	8932      	ldrh	r2, [r6, #8]
	dst[1] = val;
   14864:	73ea      	strb	r2, [r5, #15]
	dst[0] = val >> 8;
   14866:	0a11      	lsrs	r1, r2, #8
	tcp_hdr->chksum   = 0U;
   14868:	2200      	movs	r2, #0
   1486a:	73a9      	strb	r1, [r5, #14]
   1486c:	742a      	strb	r2, [r5, #16]
   1486e:	746a      	strb	r2, [r5, #17]
	tcp_hdr->urg[0]   = 0U;
   14870:	74aa      	strb	r2, [r5, #18]
	tcp_hdr->urg[1]   = 0U;
   14872:	74ea      	strb	r2, [r5, #19]
	net_pkt_set_data(pkt, &tcp_access);
   14874:	a905      	add	r1, sp, #20
   14876:	4620      	mov	r0, r4
   14878:	f7ff fc24 	bl	140c4 <net_pkt_set_data>
	if (optlen && net_pkt_write(pkt, segment->options, segment->optlen)) {
   1487c:	f1ba 0f00 	cmp.w	sl, #0
   14880:	d130      	bne.n	148e4 <prepare_segment.isra.26+0x15e>
	if (tail) {
   14882:	f1b8 0f00 	cmp.w	r8, #0
   14886:	d13d      	bne.n	14904 <prepare_segment.isra.26+0x17e>
	net_pkt_cursor_init(pkt);
   14888:	4620      	mov	r0, r4
   1488a:	f7ff fad8 	bl	13e3e <net_pkt_cursor_init>
   1488e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   14892:	f3c3 0342 	ubfx	r3, r3, #1, #3
   14896:	2b01      	cmp	r3, #1
   14898:	d139      	bne.n	1490e <prepare_segment.isra.26+0x188>
		return net_ipv4_finalize(pkt, IPPROTO_TCP);
   1489a:	2106      	movs	r1, #6
   1489c:	4620      	mov	r0, r4
   1489e:	f7ff fef6 	bl	1468e <net_ipv4_finalize>
	if (status < 0) {
   148a2:	1e07      	subs	r7, r0, #0
   148a4:	da36      	bge.n	14914 <prepare_segment.isra.26+0x18e>
		if (pkt_allocated) {
   148a6:	f1b9 0f00 	cmp.w	r9, #0
   148aa:	d036      	beq.n	1491a <prepare_segment.isra.26+0x194>
		net_pkt_unref(pkt);
   148ac:	4620      	mov	r0, r4
   148ae:	f7ff fa52 	bl	13d56 <net_pkt_unref>
   148b2:	e032      	b.n	1491a <prepare_segment.isra.26+0x194>
	return net_if_get_by_index(context->iface);
   148b4:	f990 0070 	ldrsb.w	r0, [r0, #112]	; 0x70
   148b8:	f7f6 fdb4 	bl	b424 <net_if_get_by_index>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
   148bc:	f8b5 206e 	ldrh.w	r2, [r5, #110]	; 0x6e
		pkt = net_pkt_alloc_with_buffer(net_context_get_iface(context),
   148c0:	7af1      	ldrb	r1, [r6, #11]
   148c2:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   148c6:	9300      	str	r3, [sp, #0]
   148c8:	f3c2 02c2 	ubfx	r2, r2, #3, #3
   148cc:	2306      	movs	r3, #6
   148ce:	f7f6 ff59 	bl	b784 <net_pkt_alloc_with_buffer>
		if (!pkt) {
   148d2:	b360      	cbz	r0, 1492e <prepare_segment.isra.26+0x1a8>
	struct net_buf *tail = NULL;
   148d4:	46a0      	mov	r8, r4
	pkt->context = ctx;
   148d6:	6205      	str	r5, [r0, #32]
   148d8:	4604      	mov	r4, r0
		pkt_allocated = true;
   148da:	f04f 0901 	mov.w	r9, #1
   148de:	e770      	b.n	147c2 <prepare_segment.isra.26+0x3c>
	u8_t optlen = 0U;
   148e0:	469a      	mov	sl, r3
   148e2:	e79d      	b.n	14820 <prepare_segment.isra.26+0x9a>
	if (optlen && net_pkt_write(pkt, segment->options, segment->optlen)) {
   148e4:	7af2      	ldrb	r2, [r6, #11]
   148e6:	68f1      	ldr	r1, [r6, #12]
   148e8:	4620      	mov	r0, r4
   148ea:	f7ff fbd1 	bl	14090 <net_pkt_write>
   148ee:	2800      	cmp	r0, #0
   148f0:	d0c7      	beq.n	14882 <prepare_segment.isra.26+0xfc>
	if (pkt_allocated) {
   148f2:	f1b9 0f00 	cmp.w	r9, #0
   148f6:	d1d9      	bne.n	148ac <prepare_segment.isra.26+0x126>
		net_buf_unref(pkt->buffer);
   148f8:	6960      	ldr	r0, [r4, #20]
   148fa:	f7f5 fd79 	bl	a3f0 <net_buf_unref>
		pkt->buffer = tail;
   148fe:	f8c4 8014 	str.w	r8, [r4, #20]
   14902:	e00a      	b.n	1491a <prepare_segment.isra.26+0x194>
		net_pkt_append_buffer(pkt, tail);
   14904:	4641      	mov	r1, r8
   14906:	4620      	mov	r0, r4
   14908:	f7ff face 	bl	13ea8 <net_pkt_append_buffer>
   1490c:	e7bc      	b.n	14888 <prepare_segment.isra.26+0x102>
	return -EINVAL;
   1490e:	f06f 0715 	mvn.w	r7, #21
   14912:	e7c8      	b.n	148a6 <prepare_segment.isra.26+0x120>
	*out_pkt = pkt;
   14914:	9b03      	ldr	r3, [sp, #12]
	return 0;
   14916:	2700      	movs	r7, #0
	*out_pkt = pkt;
   14918:	601c      	str	r4, [r3, #0]
}
   1491a:	4638      	mov	r0, r7
   1491c:	b00d      	add	sp, #52	; 0x34
   1491e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		status = -EINVAL;
   14922:	f06f 0715 	mvn.w	r7, #21
   14926:	e7e4      	b.n	148f2 <prepare_segment.isra.26+0x16c>
		status = -ENOBUFS;
   14928:	f06f 0768 	mvn.w	r7, #104	; 0x68
   1492c:	e7e1      	b.n	148f2 <prepare_segment.isra.26+0x16c>
			return -ENOMEM;
   1492e:	f06f 070b 	mvn.w	r7, #11
   14932:	e7f2      	b.n	1491a <prepare_segment.isra.26+0x194>

00014934 <net_tcp_get_recv_mss>:
	sa_family_t family = net_context_get_family(tcp->context);
   14934:	6802      	ldr	r2, [r0, #0]
{
   14936:	b508      	push	{r3, lr}
   14938:	f8b2 306e 	ldrh.w	r3, [r2, #110]	; 0x6e
	if (family == AF_INET) {
   1493c:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   14940:	2b01      	cmp	r3, #1
   14942:	d001      	beq.n	14948 <net_tcp_get_recv_mss+0x14>
	return 0;
   14944:	2000      	movs	r0, #0
}
   14946:	bd08      	pop	{r3, pc}
	return net_if_get_by_index(context->iface);
   14948:	f992 0070 	ldrsb.w	r0, [r2, #112]	; 0x70
   1494c:	f7f6 fd6a 	bl	b424 <net_if_get_by_index>
		if (iface && net_if_get_mtu(iface) >= NET_IPV4TCPH_LEN) {
   14950:	2800      	cmp	r0, #0
   14952:	d0f7      	beq.n	14944 <net_tcp_get_recv_mss+0x10>
	return iface->if_dev->mtu;
   14954:	6803      	ldr	r3, [r0, #0]
   14956:	8b18      	ldrh	r0, [r3, #24]
   14958:	2827      	cmp	r0, #39	; 0x27
   1495a:	d9f3      	bls.n	14944 <net_tcp_get_recv_mss+0x10>
			return net_if_get_mtu(iface) - NET_IPV4TCPH_LEN;
   1495c:	3828      	subs	r0, #40	; 0x28
   1495e:	b280      	uxth	r0, r0
   14960:	e7f1      	b.n	14946 <net_tcp_get_recv_mss+0x12>

00014962 <net_tcp_set_syn_opt>:
	*optionlen = 0U;
   14962:	2300      	movs	r3, #0
{
   14964:	b570      	push	{r4, r5, r6, lr}
	*optionlen = 0U;
   14966:	7013      	strb	r3, [r2, #0]
{
   14968:	4614      	mov	r4, r2
	if (!(tcp->flags & NET_TCP_RECV_MSS_SET)) {
   1496a:	f8b0 20bc 	ldrh.w	r2, [r0, #188]	; 0xbc
   1496e:	0552      	lsls	r2, r2, #21
{
   14970:	4605      	mov	r5, r0
   14972:	460e      	mov	r6, r1
	if (!(tcp->flags & NET_TCP_RECV_MSS_SET)) {
   14974:	d418      	bmi.n	149a8 <net_tcp_set_syn_opt+0x46>
		recv_mss = net_tcp_get_recv_mss(tcp);
   14976:	f7ff ffdd 	bl	14934 <net_tcp_get_recv_mss>
		tcp->flags |= NET_TCP_RECV_MSS_SET;
   1497a:	f8b5 30bc 	ldrh.w	r3, [r5, #188]	; 0xbc
   1497e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   14982:	f8a5 30bc 	strh.w	r3, [r5, #188]	; 0xbc
	recv_mss |= (NET_TCP_MSS_OPT << 24) | (NET_TCP_MSS_SIZE << 16);
   14986:	f040 7301 	orr.w	r3, r0, #33816576	; 0x2040000
	UNALIGNED_PUT(htonl(recv_mss),
   1498a:	0218      	lsls	r0, r3, #8
   1498c:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
   14990:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
   14994:	7822      	ldrb	r2, [r4, #0]
   14996:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
   1499a:	f040 0002 	orr.w	r0, r0, #2
   1499e:	50b0      	str	r0, [r6, r2]
	*optionlen += NET_TCP_MSS_SIZE;
   149a0:	7823      	ldrb	r3, [r4, #0]
   149a2:	3304      	adds	r3, #4
   149a4:	7023      	strb	r3, [r4, #0]
}
   149a6:	bd70      	pop	{r4, r5, r6, pc}
		recv_mss = 0U;
   149a8:	4618      	mov	r0, r3
   149aa:	e7ec      	b.n	14986 <net_tcp_set_syn_opt+0x24>

000149ac <net_tcp_prepare_reset>:
{
   149ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   149ae:	4605      	mov	r5, r0
   149b0:	b089      	sub	sp, #36	; 0x24
   149b2:	460c      	mov	r4, r1
   149b4:	4616      	mov	r6, r2
	struct tcp_segment segment = { 0 };
   149b6:	2100      	movs	r1, #0
   149b8:	2218      	movs	r2, #24
   149ba:	a802      	add	r0, sp, #8
{
   149bc:	461f      	mov	r7, r3
	struct tcp_segment segment = { 0 };
   149be:	f7ed fc14 	bl	21ea <memset>
	if ((net_context_get_state(tcp->context) != NET_CONTEXT_UNCONNECTED) &&
   149c2:	6828      	ldr	r0, [r5, #0]
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
   149c4:	f8b0 206e 	ldrh.w	r2, [r0, #110]	; 0x6e
   149c8:	f3c2 0241 	ubfx	r2, r2, #1, #2
   149cc:	b36a      	cbz	r2, 14a2a <net_tcp_prepare_reset+0x7e>
	return (enum net_tcp_state)tcp->state;
   149ce:	f8d5 20bc 	ldr.w	r2, [r5, #188]	; 0xbc
   149d2:	f3c2 3243 	ubfx	r2, r2, #13, #4
   149d6:	2a02      	cmp	r2, #2
   149d8:	d027      	beq.n	14a2a <net_tcp_prepare_reset+0x7e>
	    (net_tcp_get_state(tcp) != NET_TCP_SYN_SENT) &&
   149da:	2a09      	cmp	r2, #9
   149dc:	d025      	beq.n	14a2a <net_tcp_prepare_reset+0x7e>
		segment.ack = tcp->send_ack;
   149de:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
   149e2:	9303      	str	r3, [sp, #12]
		segment.flags = NET_TCP_RST | NET_TCP_ACK;
   149e4:	2314      	movs	r3, #20
   149e6:	f88d 3012 	strb.w	r3, [sp, #18]
		segment.seq = tcp->send_seq;
   149ea:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   149ee:	9302      	str	r3, [sp, #8]
		if (!local) {
   149f0:	b954      	cbnz	r4, 14a08 <net_tcp_prepare_reset+0x5c>
			segment.src_addr = &tcp->context->local;
   149f2:	f100 031c 	add.w	r3, r0, #28
   149f6:	9306      	str	r3, [sp, #24]
		status = prepare_segment(tcp, &segment, NULL, pkt);
   149f8:	463b      	mov	r3, r7
   149fa:	2200      	movs	r2, #0
   149fc:	a902      	add	r1, sp, #8
		segment.dst_addr = remote;
   149fe:	9607      	str	r6, [sp, #28]
		status = prepare_segment(tcp, &segment, NULL, pkt);
   14a00:	f7ff fec1 	bl	14786 <prepare_segment.isra.26>
}
   14a04:	b009      	add	sp, #36	; 0x24
   14a06:	bdf0      	pop	{r4, r5, r6, r7, pc}
	(void)memset(addr, 0, sizeof(struct sockaddr_ptr));
   14a08:	2300      	movs	r3, #0
   14a0a:	e9cd 3300 	strd	r3, r3, [sp]
	if (local->sa_family == AF_INET) {
   14a0e:	8823      	ldrh	r3, [r4, #0]
   14a10:	2b01      	cmp	r3, #1
   14a12:	d107      	bne.n	14a24 <net_tcp_prepare_reset+0x78>
		net_sin_ptr(addr)->sin_family = AF_INET;
   14a14:	f8ad 3000 	strh.w	r3, [sp]
		net_sin_ptr(addr)->sin_addr = &net_sin(local)->sin_addr;
   14a18:	3404      	adds	r4, #4
		net_sin_ptr(addr)->sin_port = net_sin(local)->sin_port;
   14a1a:	f834 3c02 	ldrh.w	r3, [r4, #-2]
   14a1e:	f8ad 3002 	strh.w	r3, [sp, #2]
		net_sin_ptr(addr)->sin_addr = &net_sin(local)->sin_addr;
   14a22:	9401      	str	r4, [sp, #4]
			segment.src_addr = &src_addr_ptr;
   14a24:	f8cd d018 	str.w	sp, [sp, #24]
   14a28:	e7e6      	b.n	149f8 <net_tcp_prepare_reset+0x4c>
	int status = 0;
   14a2a:	2000      	movs	r0, #0
	return status;
   14a2c:	e7ea      	b.n	14a04 <net_tcp_prepare_reset+0x58>

00014a2e <send_reset.isra.33>:
static int send_reset(struct net_context *context,
   14a2e:	b513      	push	{r0, r1, r4, lr}
	struct net_pkt *pkt = NULL;
   14a30:	2300      	movs	r3, #0
   14a32:	9301      	str	r3, [sp, #4]
	ret = net_tcp_prepare_reset(context->tcp, local, remote, &pkt);
   14a34:	ab01      	add	r3, sp, #4
   14a36:	f7ff ffb9 	bl	149ac <net_tcp_prepare_reset>
	if (ret || !pkt) {
   14a3a:	4604      	mov	r4, r0
   14a3c:	b940      	cbnz	r0, 14a50 <send_reset.isra.33+0x22>
   14a3e:	9801      	ldr	r0, [sp, #4]
   14a40:	b130      	cbz	r0, 14a50 <send_reset.isra.33+0x22>
	ret = net_send_data(pkt);
   14a42:	f7fe ffb9 	bl	139b8 <net_send_data>
	if (ret < 0) {
   14a46:	1e04      	subs	r4, r0, #0
   14a48:	da02      	bge.n	14a50 <send_reset.isra.33+0x22>
		net_pkt_unref(pkt);
   14a4a:	9801      	ldr	r0, [sp, #4]
   14a4c:	f7ff f983 	bl	13d56 <net_pkt_unref>
}
   14a50:	4620      	mov	r0, r4
   14a52:	b002      	add	sp, #8
   14a54:	bd10      	pop	{r4, pc}

00014a56 <backlog_ack_timeout>:
{
   14a56:	b510      	push	{r4, lr}
	send_reset(backlog->tcp->context, NULL, &backlog->remote);
   14a58:	f850 3c0c 	ldr.w	r3, [r0, #-12]
   14a5c:	681b      	ldr	r3, [r3, #0]
   14a5e:	f1a0 040c 	sub.w	r4, r0, #12
   14a62:	f100 0220 	add.w	r2, r0, #32
   14a66:	2100      	movs	r1, #0
   14a68:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
   14a6a:	f7ff ffe0 	bl	14a2e <send_reset.isra.33>
   14a6e:	4620      	mov	r0, r4
   14a70:	2238      	movs	r2, #56	; 0x38
   14a72:	2100      	movs	r1, #0
}
   14a74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   14a78:	f7ed bbb7 	b.w	21ea <memset>

00014a7c <tcp_retry_expired>:
	if (!sys_slist_is_empty(&tcp->sent_list)) {
   14a7c:	6c03      	ldr	r3, [r0, #64]	; 0x40
{
   14a7e:	b573      	push	{r0, r1, r4, r5, r6, lr}
   14a80:	4604      	mov	r4, r0
	if (!sys_slist_is_empty(&tcp->sent_list)) {
   14a82:	2b00      	cmp	r3, #0
   14a84:	d044      	beq.n	14b10 <tcp_retry_expired+0x94>
		tcp->retry_timeout_shift++;
   14a86:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74
   14a8a:	1c53      	adds	r3, r2, #1
   14a8c:	f003 031f 	and.w	r3, r3, #31
   14a90:	f363 0204 	bfi	r2, r3, #0, #5
		if (tcp->retry_timeout_shift > CONFIG_NET_TCP_RETRY_COUNT) {
   14a94:	2b09      	cmp	r3, #9
		tcp->retry_timeout_shift++;
   14a96:	f880 2074 	strb.w	r2, [r0, #116]	; 0x74
		if (tcp->retry_timeout_shift > CONFIG_NET_TCP_RETRY_COUNT) {
   14a9a:	d914      	bls.n	14ac6 <tcp_retry_expired+0x4a>
	struct net_context *ctx = tcp->context;
   14a9c:	f850 5c48 	ldr.w	r5, [r0, #-72]
	if (ctx->recv_cb) {
   14aa0:	6b2e      	ldr	r6, [r5, #48]	; 0x30
   14aa2:	b156      	cbz	r6, 14aba <tcp_retry_expired+0x3e>
		ctx->recv_cb(ctx, NULL, NULL, NULL, -ECONNRESET,
   14aa4:	f850 3c44 	ldr.w	r3, [r0, #-68]
   14aa8:	9301      	str	r3, [sp, #4]
   14aaa:	f06f 0367 	mvn.w	r3, #103	; 0x67
   14aae:	9300      	str	r3, [sp, #0]
   14ab0:	2300      	movs	r3, #0
   14ab2:	461a      	mov	r2, r3
   14ab4:	4619      	mov	r1, r3
   14ab6:	4628      	mov	r0, r5
   14ab8:	47b0      	blx	r6
	net_context_unref(ctx);
   14aba:	4628      	mov	r0, r5
}
   14abc:	b002      	add	sp, #8
   14abe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			net_context_unref(tcp->context);
   14ac2:	f7fe bd0e 	b.w	134e2 <net_context_unref>
		k_delayed_work_submit(&tcp->retry_timer, retry_timeout(tcp));
   14ac6:	21c8      	movs	r1, #200	; 0xc8
   14ac8:	4099      	lsls	r1, r3
   14aca:	f7f7 fbfb 	bl	c2c4 <k_delayed_work_submit>
		pkt = CONTAINER_OF(sys_slist_peek_head(&tcp->sent_list),
   14ace:	6c23      	ldr	r3, [r4, #64]	; 0x40
   14ad0:	f1a3 043c 	sub.w	r4, r3, #60	; 0x3c
	return pkt->sent_or_eof;
   14ad4:	795b      	ldrb	r3, [r3, #5]
		if (net_pkt_sent(pkt)) {
   14ad6:	079b      	lsls	r3, r3, #30
   14ad8:	d509      	bpl.n	14aee <tcp_retry_expired+0x72>
			do_ref_if_needed(tcp, pkt);
   14ada:	4620      	mov	r0, r4
   14adc:	f7ff f91b 	bl	13d16 <net_pkt_ref>
	pkt->sent_or_eof = sent;
   14ae0:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
   14ae4:	f36f 0341 	bfc	r3, #1, #1
   14ae8:	4604      	mov	r4, r0
   14aea:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
	pkt->pkt_queued = send;
   14aee:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   14af2:	f043 0301 	orr.w	r3, r3, #1
   14af6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
		if (net_tcp_send_pkt(pkt) < 0 && !is_6lo_technology(pkt)) {
   14afa:	4620      	mov	r0, r4
   14afc:	f7f7 fc70 	bl	c3e0 <net_tcp_send_pkt>
   14b00:	2800      	cmp	r0, #0
   14b02:	da0e      	bge.n	14b22 <tcp_retry_expired+0xa6>
			net_pkt_unref(pkt);
   14b04:	4620      	mov	r0, r4
}
   14b06:	b002      	add	sp, #8
   14b08:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			net_pkt_unref(pkt);
   14b0c:	f7ff b923 	b.w	13d56 <net_pkt_unref>
		if (tcp->fin_sent && tcp->fin_rcvd) {
   14b10:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
   14b14:	f003 0306 	and.w	r3, r3, #6
   14b18:	2b06      	cmp	r3, #6
   14b1a:	d102      	bne.n	14b22 <tcp_retry_expired+0xa6>
			net_context_unref(tcp->context);
   14b1c:	f850 0c48 	ldr.w	r0, [r0, #-72]
   14b20:	e7cc      	b.n	14abc <tcp_retry_expired+0x40>
}
   14b22:	b002      	add	sp, #8
   14b24:	bd70      	pop	{r4, r5, r6, pc}

00014b26 <net_tcp_send_data>:
{
   14b26:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(&context->tcp->sent_list, pkt, sent_list) {
   14b28:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
   14b2a:	f8d3 4088 	ldr.w	r4, [r3, #136]	; 0x88
{
   14b2e:	4606      	mov	r6, r0
   14b30:	460d      	mov	r5, r1
   14b32:	4617      	mov	r7, r2
	SYS_SLIST_FOR_EACH_CONTAINER(&context->tcp->sent_list, pkt, sent_list) {
   14b34:	b914      	cbnz	r4, 14b3c <net_tcp_send_data+0x16>
	if (cb) {
   14b36:	b9e5      	cbnz	r5, 14b72 <net_tcp_send_data+0x4c>
}
   14b38:	2000      	movs	r0, #0
   14b3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	SYS_SLIST_FOR_EACH_CONTAINER(&context->tcp->sent_list, pkt, sent_list) {
   14b3c:	3c3c      	subs	r4, #60	; 0x3c
   14b3e:	2c00      	cmp	r4, #0
   14b40:	d0f9      	beq.n	14b36 <net_tcp_send_data+0x10>
	return pkt->pkt_queued;
   14b42:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
		if (net_pkt_queued(pkt)) {
   14b46:	07da      	lsls	r2, r3, #31
   14b48:	d411      	bmi.n	14b6e <net_tcp_send_data+0x48>
	return pkt->sent_or_eof;
   14b4a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
		if (!net_pkt_sent(pkt)) {
   14b4e:	079b      	lsls	r3, r3, #30
   14b50:	d40d      	bmi.n	14b6e <net_tcp_send_data+0x48>
			ret = net_tcp_send_pkt(pkt);
   14b52:	4620      	mov	r0, r4
   14b54:	f7f7 fc44 	bl	c3e0 <net_tcp_send_pkt>
			if (ret < 0 && !is_6lo_technology(pkt)) {
   14b58:	2800      	cmp	r0, #0
   14b5a:	da02      	bge.n	14b62 <net_tcp_send_data+0x3c>
				net_pkt_unref(pkt);
   14b5c:	4620      	mov	r0, r4
   14b5e:	f7ff f8fa 	bl	13d56 <net_pkt_unref>
	pkt->pkt_queued = send;
   14b62:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   14b66:	f043 0301 	orr.w	r3, r3, #1
   14b6a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   14b6e:	6be4      	ldr	r4, [r4, #60]	; 0x3c
	return node->next;
   14b70:	e7e0      	b.n	14b34 <net_tcp_send_data+0xe>
		cb(context, 0, user_data);
   14b72:	463a      	mov	r2, r7
   14b74:	2100      	movs	r1, #0
   14b76:	4630      	mov	r0, r6
   14b78:	47a8      	blx	r5
   14b7a:	e7dd      	b.n	14b38 <net_tcp_send_data+0x12>

00014b7c <net_tcp_init>:
}
   14b7c:	4770      	bx	lr

00014b7e <net_tcp_change_state>:
   14b7e:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
{
   14b82:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (net_tcp_get_state(tcp) == new_state) {
   14b84:	f3c3 3243 	ubfx	r2, r3, #13, #4
   14b88:	428a      	cmp	r2, r1
{
   14b8a:	4604      	mov	r4, r0
	if (net_tcp_get_state(tcp) == new_state) {
   14b8c:	d01a      	beq.n	14bc4 <net_tcp_change_state+0x46>
	tcp->state = new_state;
   14b8e:	f001 050f 	and.w	r5, r1, #15
   14b92:	f365 3350 	bfi	r3, r5, #13, #4
   14b96:	f8c0 30bc 	str.w	r3, [r0, #188]	; 0xbc
	if (net_tcp_get_state(tcp) != NET_TCP_CLOSED) {
   14b9a:	b99d      	cbnz	r5, 14bc4 <net_tcp_change_state+0x46>
	if (!tcp->context) {
   14b9c:	6803      	ldr	r3, [r0, #0]
   14b9e:	b18b      	cbz	r3, 14bc4 <net_tcp_change_state+0x46>
	if (tcp->context->conn_handler) {
   14ba0:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
   14ba2:	b118      	cbz	r0, 14bac <net_tcp_change_state+0x2e>
	return net_conn_unregister(handle);
   14ba4:	f7f7 f9aa 	bl	befc <net_conn_unregister>
		tcp->context->conn_handler = NULL;
   14ba8:	6823      	ldr	r3, [r4, #0]
   14baa:	62dd      	str	r5, [r3, #44]	; 0x2c
	if (tcp->accept_cb) {
   14bac:	f8d4 509c 	ldr.w	r5, [r4, #156]	; 0x9c
   14bb0:	b145      	cbz	r5, 14bc4 <net_tcp_change_state+0x46>
		tcp->accept_cb(tcp->context,
   14bb2:	6820      	ldr	r0, [r4, #0]
   14bb4:	4601      	mov	r1, r0
   14bb6:	2208      	movs	r2, #8
   14bb8:	f851 3b24 	ldr.w	r3, [r1], #36
   14bbc:	9300      	str	r3, [sp, #0]
   14bbe:	f06f 037d 	mvn.w	r3, #125	; 0x7d
   14bc2:	47a8      	blx	r5
}
   14bc4:	b003      	add	sp, #12
   14bc6:	bd30      	pop	{r4, r5, pc}

00014bc8 <net_tcp_prepare_segment>:
{
   14bc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   14bcc:	b087      	sub	sp, #28
   14bce:	4604      	mov	r4, r0
   14bd0:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   14bd2:	460d      	mov	r5, r1
   14bd4:	4691      	mov	r9, r2
	struct tcp_segment segment = { 0 };
   14bd6:	2100      	movs	r1, #0
   14bd8:	2218      	movs	r2, #24
   14bda:	4668      	mov	r0, sp
{
   14bdc:	4698      	mov	r8, r3
	struct tcp_segment segment = { 0 };
   14bde:	f7ed fb04 	bl	21ea <memset>
	if (!local) {
   14be2:	b90e      	cbnz	r6, 14be8 <net_tcp_prepare_segment+0x20>
		local = &tcp->context->local;
   14be4:	6826      	ldr	r6, [r4, #0]
   14be6:	361c      	adds	r6, #28
	if (flags & NET_TCP_ACK) {
   14be8:	06e9      	lsls	r1, r5, #27
	seq = tcp->send_seq;
   14bea:	f8d4 7090 	ldr.w	r7, [r4, #144]	; 0x90
	if (flags & NET_TCP_ACK) {
   14bee:	d50f      	bpl.n	14c10 <net_tcp_prepare_segment+0x48>
	return (enum net_tcp_state)tcp->state;
   14bf0:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
   14bf4:	f3c3 3343 	ubfx	r3, r3, #13, #4
		if (net_tcp_get_state(tcp) == NET_TCP_FIN_WAIT_1) {
   14bf8:	2b07      	cmp	r3, #7
   14bfa:	d13d      	bne.n	14c78 <net_tcp_prepare_segment+0xb0>
			if (flags & NET_TCP_FIN) {
   14bfc:	07ea      	lsls	r2, r5, #31
   14bfe:	d503      	bpl.n	14c08 <net_tcp_prepare_segment+0x40>
				flags &= ~NET_TCP_FIN;
   14c00:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
			net_tcp_change_state(tcp, NET_TCP_TIME_WAIT);
   14c04:	2109      	movs	r1, #9
   14c06:	e000      	b.n	14c0a <net_tcp_prepare_segment+0x42>
				net_tcp_change_state(tcp, NET_TCP_CLOSING);
   14c08:	210a      	movs	r1, #10
			net_tcp_change_state(tcp, NET_TCP_LAST_ACK);
   14c0a:	4620      	mov	r0, r4
   14c0c:	f7ff ffb7 	bl	14b7e <net_tcp_change_state>
	if (flags & NET_TCP_FIN) {
   14c10:	07eb      	lsls	r3, r5, #31
   14c12:	d510      	bpl.n	14c36 <net_tcp_prepare_segment+0x6e>
   14c14:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
   14c18:	f3c3 3343 	ubfx	r3, r3, #13, #4
		if (net_tcp_get_state(tcp) == NET_TCP_ESTABLISHED ||
   14c1c:	330d      	adds	r3, #13
   14c1e:	f003 030f 	and.w	r3, r3, #15
   14c22:	2b01      	cmp	r3, #1
		flags |= NET_TCP_ACK;
   14c24:	f045 0510 	orr.w	r5, r5, #16
		seq++;
   14c28:	f107 0701 	add.w	r7, r7, #1
		if (net_tcp_get_state(tcp) == NET_TCP_ESTABLISHED ||
   14c2c:	d803      	bhi.n	14c36 <net_tcp_prepare_segment+0x6e>
			net_tcp_change_state(tcp, NET_TCP_FIN_WAIT_1);
   14c2e:	2107      	movs	r1, #7
   14c30:	4620      	mov	r0, r4
   14c32:	f7ff ffa4 	bl	14b7e <net_tcp_change_state>
	return tcp->recv_wnd;
   14c36:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
	segment.dst_addr = remote;
   14c3a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   14c3c:	9205      	str	r2, [sp, #20]
	segment.wnd = wnd;
   14c3e:	f8ad 3008 	strh.w	r3, [sp, #8]
	segment.seq = tcp->send_seq;
   14c42:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
	status = prepare_segment(tcp, &segment, *send_pkt, send_pkt);
   14c46:	9b10      	ldr	r3, [sp, #64]	; 0x40
	segment.seq = tcp->send_seq;
   14c48:	9200      	str	r2, [sp, #0]
	segment.ack = tcp->send_ack;
   14c4a:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
   14c4e:	9201      	str	r2, [sp, #4]
	status = prepare_segment(tcp, &segment, *send_pkt, send_pkt);
   14c50:	4669      	mov	r1, sp
   14c52:	681a      	ldr	r2, [r3, #0]
   14c54:	6820      	ldr	r0, [r4, #0]
	segment.src_addr = (struct sockaddr_ptr *)local;
   14c56:	9604      	str	r6, [sp, #16]
	segment.flags = flags;
   14c58:	f88d 500a 	strb.w	r5, [sp, #10]
	segment.options = options;
   14c5c:	f8cd 900c 	str.w	r9, [sp, #12]
	segment.optlen = optlen;
   14c60:	f88d 800b 	strb.w	r8, [sp, #11]
	status = prepare_segment(tcp, &segment, *send_pkt, send_pkt);
   14c64:	f7ff fd8f 	bl	14786 <prepare_segment.isra.26>
	if (status < 0) {
   14c68:	2800      	cmp	r0, #0
	return 0;
   14c6a:	bfa4      	itt	ge
   14c6c:	2000      	movge	r0, #0
	tcp->send_seq = seq;
   14c6e:	f8c4 7090 	strge.w	r7, [r4, #144]	; 0x90
}
   14c72:	b007      	add	sp, #28
   14c74:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		} else if (net_tcp_get_state(tcp) == NET_TCP_FIN_WAIT_2) {
   14c78:	2b08      	cmp	r3, #8
   14c7a:	d0c3      	beq.n	14c04 <net_tcp_prepare_segment+0x3c>
		} else if (net_tcp_get_state(tcp) == NET_TCP_CLOSE_WAIT) {
   14c7c:	2b05      	cmp	r3, #5
   14c7e:	d1c7      	bne.n	14c10 <net_tcp_prepare_segment+0x48>
			tcp->flags |= NET_TCP_IS_SHUTDOWN;
   14c80:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
   14c84:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   14c88:	f8a4 30bc 	strh.w	r3, [r4, #188]	; 0xbc
			flags |= NET_TCP_FIN;
   14c8c:	f045 0501 	orr.w	r5, r5, #1
			net_tcp_change_state(tcp, NET_TCP_LAST_ACK);
   14c90:	2106      	movs	r1, #6
   14c92:	e7ba      	b.n	14c0a <net_tcp_prepare_segment+0x42>

00014c94 <net_tcp_prepare_ack>:
{
   14c94:	b570      	push	{r4, r5, r6, lr}
   14c96:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
   14c9a:	f3c3 3343 	ubfx	r3, r3, #13, #4
	switch (net_tcp_get_state(tcp)) {
   14c9e:	2b03      	cmp	r3, #3
{
   14ca0:	b088      	sub	sp, #32
   14ca2:	4604      	mov	r4, r0
   14ca4:	460d      	mov	r5, r1
   14ca6:	4616      	mov	r6, r2
	switch (net_tcp_get_state(tcp)) {
   14ca8:	d00c      	beq.n	14cc4 <net_tcp_prepare_ack+0x30>
   14caa:	d304      	bcc.n	14cb6 <net_tcp_prepare_ack+0x22>
   14cac:	330a      	adds	r3, #10
   14cae:	f003 030f 	and.w	r3, r3, #15
   14cb2:	2b01      	cmp	r3, #1
   14cb4:	d915      	bls.n	14ce2 <net_tcp_prepare_ack+0x4e>
		return net_tcp_prepare_segment(tcp, NET_TCP_ACK, 0, 0, NULL,
   14cb6:	2300      	movs	r3, #0
   14cb8:	e9cd 5601 	strd	r5, r6, [sp, #4]
   14cbc:	9300      	str	r3, [sp, #0]
   14cbe:	461a      	mov	r2, r3
   14cc0:	2110      	movs	r1, #16
   14cc2:	e00c      	b.n	14cde <net_tcp_prepare_ack+0x4a>
		net_tcp_set_syn_opt(tcp, options, &optionlen);
   14cc4:	f10d 0217 	add.w	r2, sp, #23
   14cc8:	a906      	add	r1, sp, #24
   14cca:	f7ff fe4a 	bl	14962 <net_tcp_set_syn_opt>
		return net_tcp_prepare_segment(tcp, NET_TCP_SYN | NET_TCP_ACK,
   14cce:	2300      	movs	r3, #0
   14cd0:	e9cd 5601 	strd	r5, r6, [sp, #4]
   14cd4:	9300      	str	r3, [sp, #0]
   14cd6:	f89d 3017 	ldrb.w	r3, [sp, #23]
   14cda:	aa06      	add	r2, sp, #24
   14cdc:	2112      	movs	r1, #18
		return net_tcp_prepare_segment(tcp, NET_TCP_ACK, 0, 0, NULL,
   14cde:	4620      	mov	r0, r4
   14ce0:	e005      	b.n	14cee <net_tcp_prepare_ack+0x5a>
		return net_tcp_prepare_segment(tcp, NET_TCP_FIN | NET_TCP_ACK,
   14ce2:	2300      	movs	r3, #0
   14ce4:	e9cd 1201 	strd	r1, r2, [sp, #4]
   14ce8:	9300      	str	r3, [sp, #0]
   14cea:	461a      	mov	r2, r3
   14cec:	2111      	movs	r1, #17
		return net_tcp_prepare_segment(tcp, NET_TCP_ACK, 0, 0, NULL,
   14cee:	f7ff ff6b 	bl	14bc8 <net_tcp_prepare_segment>
}
   14cf2:	b008      	add	sp, #32
   14cf4:	bd70      	pop	{r4, r5, r6, pc}

00014cf6 <send_ack.isra.37>:
static int send_ack(struct net_context *context,
   14cf6:	b513      	push	{r0, r1, r4, lr}
	struct net_pkt *pkt = NULL;
   14cf8:	2300      	movs	r3, #0
   14cfa:	9301      	str	r3, [sp, #4]
	if (!force && context->tcp->send_ack == context->tcp->sent_ack) {
   14cfc:	b91a      	cbnz	r2, 14d06 <send_ack.isra.37+0x10>
   14cfe:	e9d0 4325 	ldrd	r4, r3, [r0, #148]	; 0x94
   14d02:	429c      	cmp	r4, r3
   14d04:	d00f      	beq.n	14d26 <send_ack.isra.37+0x30>
	ret = net_tcp_prepare_ack(context->tcp, remote, &pkt);
   14d06:	aa01      	add	r2, sp, #4
   14d08:	f7ff ffc4 	bl	14c94 <net_tcp_prepare_ack>
	if (ret) {
   14d0c:	4604      	mov	r4, r0
   14d0e:	b938      	cbnz	r0, 14d20 <send_ack.isra.37+0x2a>
	ret = net_tcp_send_pkt(pkt);
   14d10:	9801      	ldr	r0, [sp, #4]
   14d12:	f7f7 fb65 	bl	c3e0 <net_tcp_send_pkt>
	if (ret < 0) {
   14d16:	1e04      	subs	r4, r0, #0
   14d18:	da02      	bge.n	14d20 <send_ack.isra.37+0x2a>
		net_pkt_unref(pkt);
   14d1a:	9801      	ldr	r0, [sp, #4]
   14d1c:	f7ff f81b 	bl	13d56 <net_pkt_unref>
}
   14d20:	4620      	mov	r0, r4
   14d22:	b002      	add	sp, #8
   14d24:	bd10      	pop	{r4, pc}
		return 0;
   14d26:	4614      	mov	r4, r2
   14d28:	e7fa      	b.n	14d20 <send_ack.isra.37+0x2a>

00014d2a <net_tcp_queue_data>:
{
   14d2a:	b570      	push	{r4, r5, r6, lr}
   14d2c:	b086      	sub	sp, #24
	struct net_conn *conn = (struct net_conn *)context->conn_handler;
   14d2e:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
	size_t data_len = net_pkt_get_len(pkt);
   14d30:	694b      	ldr	r3, [r1, #20]
{
   14d32:	9105      	str	r1, [sp, #20]
   14d34:	4604      	mov	r4, r0
	size_t bytes = 0;
   14d36:	2500      	movs	r5, #0
	while (buf) {
   14d38:	bb03      	cbnz	r3, 14d7c <net_tcp_queue_data+0x52>
   14d3a:	f8b4 206e 	ldrh.w	r2, [r4, #110]	; 0x6e
	if (net_context_get_state(context) != NET_CONTEXT_CONNECTED) {
   14d3e:	f3c2 0241 	ubfx	r2, r2, #1, #2
   14d42:	2a02      	cmp	r2, #2
   14d44:	d11e      	bne.n	14d84 <net_tcp_queue_data+0x5a>
	if (context->tcp->flags & NET_TCP_IS_SHUTDOWN) {
   14d46:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   14d48:	f8b0 20bc 	ldrh.w	r2, [r0, #188]	; 0xbc
   14d4c:	05d2      	lsls	r2, r2, #23
   14d4e:	d41c      	bmi.n	14d8a <net_tcp_queue_data+0x60>
	ret = net_tcp_prepare_segment(context->tcp, NET_TCP_PSH | NET_TCP_ACK,
   14d50:	aa05      	add	r2, sp, #20
   14d52:	e9cd 6201 	strd	r6, r2, [sp, #4]
   14d56:	9300      	str	r3, [sp, #0]
   14d58:	461a      	mov	r2, r3
   14d5a:	2118      	movs	r1, #24
   14d5c:	f7ff ff34 	bl	14bc8 <net_tcp_prepare_segment>
	if (ret) {
   14d60:	b950      	cbnz	r0, 14d78 <net_tcp_queue_data+0x4e>
	context->tcp->send_seq += data_len;
   14d62:	4620      	mov	r0, r4
	return net_tcp_queue_pkt(context, pkt);
   14d64:	9905      	ldr	r1, [sp, #20]
	context->tcp->send_seq += data_len;
   14d66:	f850 2f3c 	ldr.w	r2, [r0, #60]!
   14d6a:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
   14d6e:	442b      	add	r3, r5
   14d70:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
	return net_tcp_queue_pkt(context, pkt);
   14d74:	f7ff fcdb 	bl	1472e <net_tcp_queue_pkt.isra.27>
}
   14d78:	b006      	add	sp, #24
   14d7a:	bd70      	pop	{r4, r5, r6, pc}
		bytes += buf->len;
   14d7c:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
   14d7e:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   14d80:	4415      	add	r5, r2
		buf = buf->frags;
   14d82:	e7d9      	b.n	14d38 <net_tcp_queue_data+0xe>
		return -ENOTCONN;
   14d84:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   14d88:	e7f6      	b.n	14d78 <net_tcp_queue_data+0x4e>
		return -ESHUTDOWN;
   14d8a:	f06f 006d 	mvn.w	r0, #109	; 0x6d
   14d8e:	e7f3      	b.n	14d78 <net_tcp_queue_data+0x4e>

00014d90 <send_syn_segment.isra.38>:
static inline int send_syn_segment(struct net_context *context,
   14d90:	b5f0      	push	{r4, r5, r6, r7, lr}
   14d92:	461c      	mov	r4, r3
   14d94:	b089      	sub	sp, #36	; 0x24
	struct net_pkt *pkt = NULL;
   14d96:	2300      	movs	r3, #0
	if (flags == NET_TCP_SYN) {
   14d98:	2c02      	cmp	r4, #2
static inline int send_syn_segment(struct net_context *context,
   14d9a:	4605      	mov	r5, r0
   14d9c:	460e      	mov	r6, r1
   14d9e:	4617      	mov	r7, r2
	struct net_pkt *pkt = NULL;
   14da0:	9305      	str	r3, [sp, #20]
	u8_t optionlen = 0U;
   14da2:	f88d 3013 	strb.w	r3, [sp, #19]
	if (flags == NET_TCP_SYN) {
   14da6:	d105      	bne.n	14db4 <send_syn_segment.isra.38+0x24>
		net_tcp_set_syn_opt(context->tcp, options, &optionlen);
   14da8:	f10d 0213 	add.w	r2, sp, #19
   14dac:	a906      	add	r1, sp, #24
   14dae:	6800      	ldr	r0, [r0, #0]
   14db0:	f7ff fdd7 	bl	14962 <net_tcp_set_syn_opt>
	ret = net_tcp_prepare_segment(context->tcp, flags, options, optionlen,
   14db4:	ab05      	add	r3, sp, #20
   14db6:	e9cd 7301 	strd	r7, r3, [sp, #4]
   14dba:	b2e1      	uxtb	r1, r4
   14dbc:	9600      	str	r6, [sp, #0]
   14dbe:	f89d 3013 	ldrb.w	r3, [sp, #19]
   14dc2:	6828      	ldr	r0, [r5, #0]
   14dc4:	aa06      	add	r2, sp, #24
   14dc6:	f7ff feff 	bl	14bc8 <net_tcp_prepare_segment>
	if (ret) {
   14dca:	4604      	mov	r4, r0
   14dcc:	b938      	cbnz	r0, 14dde <send_syn_segment.isra.38+0x4e>
	ret = net_send_data(pkt);
   14dce:	9805      	ldr	r0, [sp, #20]
   14dd0:	f7fe fdf2 	bl	139b8 <net_send_data>
	if (ret < 0) {
   14dd4:	1e04      	subs	r4, r0, #0
   14dd6:	da05      	bge.n	14de4 <send_syn_segment.isra.38+0x54>
		net_pkt_unref(pkt);
   14dd8:	9805      	ldr	r0, [sp, #20]
   14dda:	f7fe ffbc 	bl	13d56 <net_pkt_unref>
}
   14dde:	4620      	mov	r0, r4
   14de0:	b009      	add	sp, #36	; 0x24
   14de2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	context->tcp->send_seq++;
   14de4:	682a      	ldr	r2, [r5, #0]
   14de6:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
   14dea:	3301      	adds	r3, #1
   14dec:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
	return ret;
   14df0:	e7f5      	b.n	14dde <send_syn_segment.isra.38+0x4e>

00014df2 <handle_timewait_timeout>:
   14df2:	6d43      	ldr	r3, [r0, #84]	; 0x54
	if (net_tcp_get_state(tcp) == NET_TCP_TIME_WAIT) {
   14df4:	f3c3 3343 	ubfx	r3, r3, #13, #4
   14df8:	2b09      	cmp	r3, #9
{
   14dfa:	b537      	push	{r0, r1, r2, r4, r5, lr}
   14dfc:	4604      	mov	r4, r0
	if (net_tcp_get_state(tcp) == NET_TCP_TIME_WAIT) {
   14dfe:	d116      	bne.n	14e2e <handle_timewait_timeout+0x3c>
		net_tcp_change_state(tcp, NET_TCP_CLOSED);
   14e00:	3868      	subs	r0, #104	; 0x68
   14e02:	2100      	movs	r1, #0
   14e04:	f7ff febb 	bl	14b7e <net_tcp_change_state>
		if (tcp->context->recv_cb) {
   14e08:	f854 0c68 	ldr.w	r0, [r4, #-104]
   14e0c:	6b05      	ldr	r5, [r0, #48]	; 0x30
   14e0e:	b13d      	cbz	r5, 14e20 <handle_timewait_timeout+0x2e>
			tcp->context->recv_cb(tcp->context, NULL, NULL, NULL,
   14e10:	f854 3c64 	ldr.w	r3, [r4, #-100]
   14e14:	9301      	str	r3, [sp, #4]
   14e16:	2300      	movs	r3, #0
   14e18:	9300      	str	r3, [sp, #0]
   14e1a:	461a      	mov	r2, r3
   14e1c:	4619      	mov	r1, r3
   14e1e:	47a8      	blx	r5
		net_context_unref(tcp->context);
   14e20:	f854 0c68 	ldr.w	r0, [r4, #-104]
}
   14e24:	b003      	add	sp, #12
   14e26:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		net_context_unref(tcp->context);
   14e2a:	f7fe bb5a 	b.w	134e2 <net_context_unref>
}
   14e2e:	b003      	add	sp, #12
   14e30:	bd30      	pop	{r4, r5, pc}

00014e32 <handle_ack_timeout>:
   14e32:	f8d0 30b4 	ldr.w	r3, [r0, #180]	; 0xb4
	if (net_tcp_get_state(tcp) == NET_TCP_LAST_ACK) {
   14e36:	f3c3 3343 	ubfx	r3, r3, #13, #4
   14e3a:	2b06      	cmp	r3, #6
{
   14e3c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   14e3e:	4604      	mov	r4, r0
	if (net_tcp_get_state(tcp) == NET_TCP_LAST_ACK) {
   14e40:	d116      	bne.n	14e70 <handle_ack_timeout+0x3e>
		net_tcp_change_state(tcp, NET_TCP_CLOSED);
   14e42:	3808      	subs	r0, #8
   14e44:	2100      	movs	r1, #0
   14e46:	f7ff fe9a 	bl	14b7e <net_tcp_change_state>
		if (tcp->context->recv_cb) {
   14e4a:	f854 0c08 	ldr.w	r0, [r4, #-8]
   14e4e:	6b05      	ldr	r5, [r0, #48]	; 0x30
   14e50:	b13d      	cbz	r5, 14e62 <handle_ack_timeout+0x30>
			tcp->context->recv_cb(tcp->context, NULL, NULL, NULL,
   14e52:	f854 3c04 	ldr.w	r3, [r4, #-4]
   14e56:	9301      	str	r3, [sp, #4]
   14e58:	2300      	movs	r3, #0
   14e5a:	9300      	str	r3, [sp, #0]
   14e5c:	461a      	mov	r2, r3
   14e5e:	4619      	mov	r1, r3
   14e60:	47a8      	blx	r5
		net_context_unref(tcp->context);
   14e62:	f854 0c08 	ldr.w	r0, [r4, #-8]
}
   14e66:	b003      	add	sp, #12
   14e68:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		net_context_unref(tcp->context);
   14e6c:	f7fe bb39 	b.w	134e2 <net_context_unref>
}
   14e70:	b003      	add	sp, #12
   14e72:	bd30      	pop	{r4, r5, pc}

00014e74 <net_tcp_validate_seq>:
{
   14e74:	b510      	push	{r4, lr}
   14e76:	4604      	mov	r4, r0
	return (net_tcp_seq_cmp(sys_get_be32(tcp_hdr->seq),
   14e78:	1d08      	adds	r0, r1, #4
   14e7a:	f7ff fc49 	bl	14710 <sys_get_be32>
   14e7e:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
	return (s32_t)(seq1 - seq2);
   14e82:	1a83      	subs	r3, r0, r2
				tcp->send_ack) >= 0) &&
   14e84:	2b00      	cmp	r3, #0
	return tcp->recv_wnd;
   14e86:	bfa1      	itttt	ge
   14e88:	f8b4 30b8 	ldrhge.w	r3, [r4, #184]	; 0xb8
   14e8c:	189b      	addge	r3, r3, r2
   14e8e:	1ac0      	subge	r0, r0, r3
				tcp->send_ack) >= 0) &&
   14e90:	0fc0      	lsrge	r0, r0, #31
   14e92:	bfb8      	it	lt
   14e94:	2000      	movlt	r0, #0
}
   14e96:	bd10      	pop	{r4, pc}

00014e98 <net_tcp_finalize>:
{
   14e98:	b530      	push	{r4, r5, lr}
   14e9a:	b089      	sub	sp, #36	; 0x24
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   14e9c:	ab03      	add	r3, sp, #12
   14e9e:	9301      	str	r3, [sp, #4]
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
   14ea0:	a901      	add	r1, sp, #4
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   14ea2:	2314      	movs	r3, #20
{
   14ea4:	4605      	mov	r5, r0
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   14ea6:	9302      	str	r3, [sp, #8]
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
   14ea8:	f7f6 fc7a 	bl	b7a0 <net_pkt_get_data>
	if (!tcp_hdr) {
   14eac:	4604      	mov	r4, r0
   14eae:	b188      	cbz	r0, 14ed4 <net_tcp_finalize+0x3c>
	tcp_hdr->chksum = 0U;
   14eb0:	2300      	movs	r3, #0
   14eb2:	7403      	strb	r3, [r0, #16]
   14eb4:	7443      	strb	r3, [r0, #17]
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
   14eb6:	6a68      	ldr	r0, [r5, #36]	; 0x24
   14eb8:	f7f6 fa9c 	bl	b3f4 <net_if_need_calc_tx_checksum>
   14ebc:	b120      	cbz	r0, 14ec8 <net_tcp_finalize+0x30>
	return net_calc_chksum(pkt, IPPROTO_TCP);
   14ebe:	2106      	movs	r1, #6
   14ec0:	4628      	mov	r0, r5
   14ec2:	f7ff fa16 	bl	142f2 <net_calc_chksum>
		tcp_hdr->chksum = net_calc_chksum_tcp(pkt);
   14ec6:	8220      	strh	r0, [r4, #16]
	return net_pkt_set_data(pkt, &tcp_access);
   14ec8:	a901      	add	r1, sp, #4
   14eca:	4628      	mov	r0, r5
   14ecc:	f7ff f8fa 	bl	140c4 <net_pkt_set_data>
}
   14ed0:	b009      	add	sp, #36	; 0x24
   14ed2:	bd30      	pop	{r4, r5, pc}
		return -ENOBUFS;
   14ed4:	f06f 0068 	mvn.w	r0, #104	; 0x68
   14ed8:	e7fa      	b.n	14ed0 <net_tcp_finalize+0x38>

00014eda <net_tcp_recv>:
{
   14eda:	b530      	push	{r4, r5, lr}
	if (context->tcp->flags & NET_TCP_IS_SHUTDOWN) {
   14edc:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
   14ede:	f8b5 30bc 	ldrh.w	r3, [r5, #188]	; 0xbc
   14ee2:	f3c3 1347 	ubfx	r3, r3, #5, #8
   14ee6:	f013 0308 	ands.w	r3, r3, #8
   14eea:	d109      	bne.n	14f00 <net_tcp_recv+0x26>
   14eec:	f8b0 406e 	ldrh.w	r4, [r0, #110]	; 0x6e
	} else if (net_context_get_state(context) != NET_CONTEXT_CONNECTED) {
   14ef0:	f3c4 0441 	ubfx	r4, r4, #1, #2
   14ef4:	2c02      	cmp	r4, #2
   14ef6:	d106      	bne.n	14f06 <net_tcp_recv+0x2c>
	context->recv_cb = cb;
   14ef8:	6301      	str	r1, [r0, #48]	; 0x30
	context->tcp->recv_user_data = user_data;
   14efa:	606a      	str	r2, [r5, #4]
	return 0;
   14efc:	4618      	mov	r0, r3
}
   14efe:	bd30      	pop	{r4, r5, pc}
		return -ESHUTDOWN;
   14f00:	f06f 006d 	mvn.w	r0, #109	; 0x6d
   14f04:	e7fb      	b.n	14efe <net_tcp_recv+0x24>
		return -ENOTCONN;
   14f06:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   14f0a:	e7f8      	b.n	14efe <net_tcp_recv+0x24>

00014f0c <net_tcp_put>:
{
   14f0c:	b530      	push	{r4, r5, lr}
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   14f0e:	f8b0 306c 	ldrh.w	r3, [r0, #108]	; 0x6c
   14f12:	2b06      	cmp	r3, #6
{
   14f14:	b087      	sub	sp, #28
   14f16:	4605      	mov	r5, r0
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   14f18:	d138      	bne.n	14f8c <net_tcp_put+0x80>
   14f1a:	f8b5 306e 	ldrh.w	r3, [r5, #110]	; 0x6e
   14f1e:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
	return (enum net_context_state)
   14f20:	f3c3 0341 	ubfx	r3, r3, #1, #2
		if ((net_context_get_state(context) == NET_CONTEXT_CONNECTED ||
   14f24:	3b02      	subs	r3, #2
   14f26:	2b01      	cmp	r3, #1
   14f28:	d823      	bhi.n	14f72 <net_tcp_put+0x66>
		    && !context->tcp->fin_rcvd) {
   14f2a:	f890 40be 	ldrb.w	r4, [r0, #190]	; 0xbe
   14f2e:	f014 0404 	ands.w	r4, r4, #4
   14f32:	d11f      	bne.n	14f74 <net_tcp_put+0x68>
			k_delayed_work_submit(&context->tcp->fin_timer,
   14f34:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   14f38:	3028      	adds	r0, #40	; 0x28
   14f3a:	f7f7 f9c3 	bl	c2c4 <k_delayed_work_submit>
	ret = net_tcp_prepare_segment(ctx->tcp, NET_TCP_FIN, NULL, 0,
   14f3e:	ab05      	add	r3, sp, #20
   14f40:	9302      	str	r3, [sp, #8]
				      NULL, &ctx->remote, &pkt);
   14f42:	f105 0324 	add.w	r3, r5, #36	; 0x24
	ret = net_tcp_prepare_segment(ctx->tcp, NET_TCP_FIN, NULL, 0,
   14f46:	e9cd 4300 	strd	r4, r3, [sp]
   14f4a:	4622      	mov	r2, r4
   14f4c:	4623      	mov	r3, r4
   14f4e:	2101      	movs	r1, #1
   14f50:	6be8      	ldr	r0, [r5, #60]	; 0x3c
	struct net_pkt *pkt = NULL;
   14f52:	9405      	str	r4, [sp, #20]
	ret = net_tcp_prepare_segment(ctx->tcp, NET_TCP_FIN, NULL, 0,
   14f54:	f7ff fe38 	bl	14bc8 <net_tcp_prepare_segment>
	if (ret || !pkt) {
   14f58:	4604      	mov	r4, r0
   14f5a:	b908      	cbnz	r0, 14f60 <net_tcp_put+0x54>
   14f5c:	9905      	ldr	r1, [sp, #20]
   14f5e:	b919      	cbnz	r1, 14f68 <net_tcp_put+0x5c>
			return 0;
   14f60:	2400      	movs	r4, #0
}
   14f62:	4620      	mov	r0, r4
   14f64:	b007      	add	sp, #28
   14f66:	bd30      	pop	{r4, r5, pc}
	net_tcp_queue_pkt(ctx, pkt);
   14f68:	f105 003c 	add.w	r0, r5, #60	; 0x3c
   14f6c:	f7ff fbdf 	bl	1472e <net_tcp_queue_pkt.isra.27>
   14f70:	e7f7      	b.n	14f62 <net_tcp_put+0x56>
		if (context->tcp &&
   14f72:	b140      	cbz	r0, 14f86 <net_tcp_put+0x7a>
   14f74:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
   14f78:	f3c3 3343 	ubfx	r3, r3, #13, #4
   14f7c:	2b02      	cmp	r3, #2
   14f7e:	d102      	bne.n	14f86 <net_tcp_put+0x7a>
			net_context_unref(context);
   14f80:	4628      	mov	r0, r5
   14f82:	f7fe faae 	bl	134e2 <net_context_unref>
		return -ENOTCONN;
   14f86:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   14f8a:	e7ea      	b.n	14f62 <net_tcp_put+0x56>
	return -EOPNOTSUPP;
   14f8c:	f06f 045e 	mvn.w	r4, #94	; 0x5e
   14f90:	e7e7      	b.n	14f62 <net_tcp_put+0x56>

00014f92 <net_tcp_listen>:
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   14f92:	f8b0 306c 	ldrh.w	r3, [r0, #108]	; 0x6c
   14f96:	2b06      	cmp	r3, #6
{
   14f98:	b510      	push	{r4, lr}
   14f9a:	4604      	mov	r4, r0
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   14f9c:	d10b      	bne.n	14fb6 <net_tcp_listen+0x24>
		net_tcp_change_state(context->tcp, NET_TCP_LISTEN);
   14f9e:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
   14fa0:	2101      	movs	r1, #1
   14fa2:	f7ff fdec 	bl	14b7e <net_tcp_change_state>
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
   14fa6:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
   14faa:	f043 0306 	orr.w	r3, r3, #6
   14fae:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
		return 0;
   14fb2:	2000      	movs	r0, #0
}
   14fb4:	bd10      	pop	{r4, pc}
	return -EOPNOTSUPP;
   14fb6:	f06f 005e 	mvn.w	r0, #94	; 0x5e
   14fba:	e7fb      	b.n	14fb4 <net_tcp_listen+0x22>

00014fbc <net_tcp_input>:

struct net_tcp_hdr *net_tcp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *tcp_access)
{
   14fbc:	b570      	push	{r4, r5, r6, lr}
   14fbe:	4604      	mov	r4, r0
	struct net_tcp_hdr *tcp_hdr;

	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   14fc0:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
   14fc2:	460e      	mov	r6, r1
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   14fc4:	f7f6 fa22 	bl	b40c <net_if_need_calc_rx_checksum>
	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
   14fc8:	b940      	cbnz	r0, 14fdc <net_tcp_input+0x20>
	    net_calc_chksum_tcp(pkt) != 0U) {
		NET_DBG("DROP: checksum mismatch");
		goto drop;
	}

	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, tcp_access);
   14fca:	4631      	mov	r1, r6
   14fcc:	4620      	mov	r0, r4
   14fce:	f7f6 fbe7 	bl	b7a0 <net_pkt_get_data>
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
   14fd2:	4605      	mov	r5, r0
   14fd4:	b948      	cbnz	r0, 14fea <net_tcp_input+0x2e>
		return tcp_hdr;
	}

drop:
	net_stats_update_tcp_seg_chkerr(net_pkt_iface(pkt));
	return NULL;
   14fd6:	2500      	movs	r5, #0
}
   14fd8:	4628      	mov	r0, r5
   14fda:	bd70      	pop	{r4, r5, r6, pc}
   14fdc:	2106      	movs	r1, #6
   14fde:	4620      	mov	r0, r4
   14fe0:	f7ff f987 	bl	142f2 <net_calc_chksum>
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   14fe4:	2800      	cmp	r0, #0
   14fe6:	d0f0      	beq.n	14fca <net_tcp_input+0xe>
   14fe8:	e7f5      	b.n	14fd6 <net_tcp_input+0x1a>
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
   14fea:	4631      	mov	r1, r6
   14fec:	4620      	mov	r0, r4
   14fee:	f7ff f869 	bl	140c4 <net_pkt_set_data>
   14ff2:	2800      	cmp	r0, #0
   14ff4:	d0f0      	beq.n	14fd8 <net_tcp_input+0x1c>
drop:
   14ff6:	e7ee      	b.n	14fd6 <net_tcp_input+0x1a>

00014ff8 <net_udp_create>:
#include "net_stats.h"

#define PKT_WAIT_TIME K_SECONDS(1)

int net_udp_create(struct net_pkt *pkt, u16_t src_port, u16_t dst_port)
{
   14ff8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   14ffa:	2308      	movs	r3, #8
{
   14ffc:	460e      	mov	r6, r1
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   14ffe:	eb0d 0103 	add.w	r1, sp, r3
{
   15002:	4604      	mov	r4, r0
   15004:	4615      	mov	r5, r2
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   15006:	f8cd d008 	str.w	sp, [sp, #8]
   1500a:	9303      	str	r3, [sp, #12]
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   1500c:	f7f6 fbc8 	bl	b7a0 <net_pkt_get_data>
	if (!udp_hdr) {
   15010:	b160      	cbz	r0, 1502c <net_udp_create+0x34>
		return -ENOBUFS;
	}

	udp_hdr->src_port = src_port;
	udp_hdr->dst_port = dst_port;
	udp_hdr->len      = 0U;
   15012:	2300      	movs	r3, #0
	udp_hdr->src_port = src_port;
   15014:	8006      	strh	r6, [r0, #0]
	udp_hdr->dst_port = dst_port;
   15016:	8045      	strh	r5, [r0, #2]
	udp_hdr->len      = 0U;
   15018:	7103      	strb	r3, [r0, #4]
   1501a:	7143      	strb	r3, [r0, #5]
	udp_hdr->chksum   = 0U;
   1501c:	7183      	strb	r3, [r0, #6]
   1501e:	71c3      	strb	r3, [r0, #7]

	return net_pkt_set_data(pkt, &udp_access);
   15020:	a902      	add	r1, sp, #8
   15022:	4620      	mov	r0, r4
   15024:	f7ff f84e 	bl	140c4 <net_pkt_set_data>
}
   15028:	b004      	add	sp, #16
   1502a:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   1502c:	f06f 0068 	mvn.w	r0, #104	; 0x68
   15030:	e7fa      	b.n	15028 <net_udp_create+0x30>

00015032 <net_udp_finalize>:

int net_udp_finalize(struct net_pkt *pkt)
{
   15032:	b530      	push	{r4, r5, lr}
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   15034:	2308      	movs	r3, #8
{
   15036:	b085      	sub	sp, #20
	struct net_udp_hdr *udp_hdr;
	u16_t length;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   15038:	eb0d 0103 	add.w	r1, sp, r3
{
   1503c:	4604      	mov	r4, r0
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   1503e:	f8cd d008 	str.w	sp, [sp, #8]
   15042:	9303      	str	r3, [sp, #12]
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   15044:	f7f6 fbac 	bl	b7a0 <net_pkt_get_data>
	if (!udp_hdr) {
   15048:	4605      	mov	r5, r0
   1504a:	b1f8      	cbz	r0, 1508c <net_udp_finalize+0x5a>
		return -ENOBUFS;
	}

	length = net_pkt_get_len(pkt) -
   1504c:	6962      	ldr	r2, [r4, #20]
	size_t bytes = 0;
   1504e:	2300      	movs	r3, #0
	while (buf) {
   15050:	b9c2      	cbnz	r2, 15084 <net_udp_finalize+0x52>
		net_pkt_ip_hdr_len(pkt) -
   15052:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
		net_pkt_ipv6_ext_len(pkt);
	udp_hdr->len = htons(length);

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
   15056:	6a60      	ldr	r0, [r4, #36]	; 0x24
	length = net_pkt_get_len(pkt) -
   15058:	1a9b      	subs	r3, r3, r2
	udp_hdr->len = htons(length);
   1505a:	ba5b      	rev16	r3, r3
   1505c:	80ab      	strh	r3, [r5, #4]
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
   1505e:	f7f6 f9c9 	bl	b3f4 <net_if_need_calc_tx_checksum>
   15062:	b148      	cbz	r0, 15078 <net_udp_finalize+0x46>
	u16_t chksum = net_calc_chksum(pkt, IPPROTO_UDP);
   15064:	2111      	movs	r1, #17
   15066:	4620      	mov	r0, r4
   15068:	f7ff f943 	bl	142f2 <net_calc_chksum>
		udp_hdr->chksum = net_calc_chksum_udp(pkt);
   1506c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   15070:	2800      	cmp	r0, #0
   15072:	bf08      	it	eq
   15074:	4618      	moveq	r0, r3
   15076:	80e8      	strh	r0, [r5, #6]
	}

	return net_pkt_set_data(pkt, &udp_access);
   15078:	a902      	add	r1, sp, #8
   1507a:	4620      	mov	r0, r4
   1507c:	f7ff f822 	bl	140c4 <net_pkt_set_data>
}
   15080:	b005      	add	sp, #20
   15082:	bd30      	pop	{r4, r5, pc}
		bytes += buf->len;
   15084:	8991      	ldrh	r1, [r2, #12]
		buf = buf->frags;
   15086:	6812      	ldr	r2, [r2, #0]
		bytes += buf->len;
   15088:	440b      	add	r3, r1
		buf = buf->frags;
   1508a:	e7e1      	b.n	15050 <net_udp_finalize+0x1e>
		return -ENOBUFS;
   1508c:	f06f 0068 	mvn.w	r0, #104	; 0x68
   15090:	e7f6      	b.n	15080 <net_udp_finalize+0x4e>

00015092 <net_udp_input>:
	return net_conn_unregister(handle);
}

struct net_udp_hdr *net_udp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *udp_access)
{
   15092:	b570      	push	{r4, r5, r6, lr}
   15094:	4605      	mov	r5, r0
   15096:	460e      	mov	r6, r1
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
   15098:	f7f6 fb82 	bl	b7a0 <net_pkt_get_data>
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
   1509c:	4604      	mov	r4, r0
   1509e:	b168      	cbz	r0, 150bc <net_udp_input+0x2a>
   150a0:	4631      	mov	r1, r6
   150a2:	4628      	mov	r0, r5
   150a4:	f7ff f80e 	bl	140c4 <net_pkt_set_data>
   150a8:	b940      	cbnz	r0, 150bc <net_udp_input+0x2a>
		NET_DBG("DROP: corrupted header");
		goto drop;
	}

	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
   150aa:	6a68      	ldr	r0, [r5, #36]	; 0x24
   150ac:	f7f6 f9ae 	bl	b40c <net_if_need_calc_rx_checksum>
	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
   150b0:	b128      	cbz	r0, 150be <net_udp_input+0x2c>
	return net_calc_chksum(pkt, IPPROTO_UDP);
   150b2:	2111      	movs	r1, #17
   150b4:	4628      	mov	r0, r5
   150b6:	f7ff f91c 	bl	142f2 <net_calc_chksum>
		if (IS_ENABLED(CONFIG_NET_UDP_MISSING_CHECKSUM) &&
		    net_pkt_family(pkt) == AF_INET && !udp_hdr->chksum) {
			goto out;
		}

		if (net_calc_verify_chksum_udp(pkt) != 0U) {
   150ba:	b100      	cbz	r0, 150be <net_udp_input+0x2c>
	}
out:
	return udp_hdr;
drop:
	net_stats_update_udp_chkerr(net_pkt_iface(pkt));
	return NULL;
   150bc:	2400      	movs	r4, #0
}
   150be:	4620      	mov	r0, r4
   150c0:	bd70      	pop	{r4, r5, r6, pc}

000150c2 <unpack_uint16>:
 */
static int unpack_uint16(struct buf_ctx *buf, u16_t *val)
{
	MQTT_TRC(">> cur:%p, end:%p", buf->cur, buf->end);

	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   150c2:	e9d0 2300 	ldrd	r2, r3, [r0]
   150c6:	1a9b      	subs	r3, r3, r2
   150c8:	2b01      	cmp	r3, #1
{
   150ca:	b510      	push	{r4, lr}
	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   150cc:	d90c      	bls.n	150e8 <unpack_uint16+0x26>
		return -EINVAL;
	}

	*val = *(buf->cur++) << 8; /* MSB */
   150ce:	1c53      	adds	r3, r2, #1
   150d0:	4614      	mov	r4, r2
   150d2:	6003      	str	r3, [r0, #0]
   150d4:	f814 3b02 	ldrb.w	r3, [r4], #2
   150d8:	021b      	lsls	r3, r3, #8
   150da:	800b      	strh	r3, [r1, #0]
	*val |= *(buf->cur++); /* LSB */
   150dc:	6004      	str	r4, [r0, #0]
   150de:	7852      	ldrb	r2, [r2, #1]
   150e0:	4313      	orrs	r3, r2
   150e2:	800b      	strh	r3, [r1, #0]

	MQTT_TRC("<< val:%04x", *val);

	return 0;
   150e4:	2000      	movs	r0, #0
}
   150e6:	bd10      	pop	{r4, pc}
		return -EINVAL;
   150e8:	f06f 0015 	mvn.w	r0, #21
   150ec:	e7fb      	b.n	150e6 <unpack_uint16+0x24>

000150ee <packet_length_decode>:
 * @retval 0 if the procedure is successful.
 * @retval -EINVAL if the length decoding would use more that 4 bytes.
 * @retval -EAGAIN if the buffer would be exceeded during the read.
 */
int packet_length_decode(struct buf_ctx *buf, u32_t *length)
{
   150ee:	b5f0      	push	{r4, r5, r6, r7, lr}
	u8_t shift = 0U;
	u8_t bytes = 0U;

	*length = 0U;
   150f0:	2300      	movs	r3, #0
	do {
		if (bytes > MQTT_MAX_LENGTH_BYTES) {
			return -EINVAL;
		}

		if (buf->cur >= buf->end) {
   150f2:	6847      	ldr	r7, [r0, #4]
	*length = 0U;
   150f4:	600b      	str	r3, [r1, #0]
		if (buf->cur >= buf->end) {
   150f6:	6804      	ldr	r4, [r0, #0]
   150f8:	42bc      	cmp	r4, r7
   150fa:	d215      	bcs.n	15128 <packet_length_decode+0x3a>
			return -EAGAIN;
		}

		*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
   150fc:	4625      	mov	r5, r4
   150fe:	680e      	ldr	r6, [r1, #0]
   15100:	f815 2b01 	ldrb.w	r2, [r5], #1
   15104:	f002 027f 	and.w	r2, r2, #127	; 0x7f
								<< shift;
   15108:	409a      	lsls	r2, r3
		*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
   1510a:	4432      	add	r2, r6
   1510c:	600a      	str	r2, [r1, #0]
		shift += MQTT_LENGTH_SHIFT;
		bytes++;
	} while ((*(buf->cur++) & MQTT_LENGTH_CONTINUATION_BIT) != 0U);
   1510e:	6005      	str	r5, [r0, #0]
   15110:	f994 2000 	ldrsb.w	r2, [r4]
   15114:	2a00      	cmp	r2, #0
   15116:	db01      	blt.n	1511c <packet_length_decode+0x2e>

	MQTT_TRC("length:0x%08x", *length);

	return 0;
   15118:	2000      	movs	r0, #0
}
   1511a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (bytes > MQTT_MAX_LENGTH_BYTES) {
   1511c:	3307      	adds	r3, #7
   1511e:	2b23      	cmp	r3, #35	; 0x23
   15120:	d1e9      	bne.n	150f6 <packet_length_decode+0x8>
			return -EINVAL;
   15122:	f06f 0015 	mvn.w	r0, #21
   15126:	e7f8      	b.n	1511a <packet_length_decode+0x2c>
			return -EAGAIN;
   15128:	f06f 000a 	mvn.w	r0, #10
   1512c:	e7f5      	b.n	1511a <packet_length_decode+0x2c>

0001512e <fixed_header_decode>:

int fixed_header_decode(struct buf_ctx *buf, u8_t *type_and_flags,
			u32_t *length)
{
   1512e:	b430      	push	{r4, r5}
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   15130:	e9d0 3500 	ldrd	r3, r5, [r0]
   15134:	429d      	cmp	r5, r3
   15136:	d007      	beq.n	15148 <fixed_header_decode+0x1a>
	*val = *(buf->cur++);
   15138:	1c5d      	adds	r5, r3, #1
   1513a:	6005      	str	r5, [r0, #0]
   1513c:	781b      	ldrb	r3, [r3, #0]
   1513e:	700b      	strb	r3, [r1, #0]
	if (err_code != 0) {
		return err_code;
	}

	return packet_length_decode(buf, length);
}
   15140:	bc30      	pop	{r4, r5}
	return packet_length_decode(buf, length);
   15142:	4611      	mov	r1, r2
   15144:	f7ff bfd3 	b.w	150ee <packet_length_decode>
}
   15148:	f06f 0015 	mvn.w	r0, #21
   1514c:	bc30      	pop	{r4, r5}
   1514e:	4770      	bx	lr

00015150 <connect_ack_decode>:

int connect_ack_decode(const struct mqtt_client *client, struct buf_ctx *buf,
		       struct mqtt_connack_param *param)
{
   15150:	b530      	push	{r4, r5, lr}
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   15152:	e9d1 3500 	ldrd	r3, r5, [r1]
   15156:	429d      	cmp	r5, r3
   15158:	d102      	bne.n	15160 <connect_ack_decode+0x10>
		return -EINVAL;
   1515a:	f06f 0015 	mvn.w	r0, #21
	}

	param->return_code = (enum mqtt_conn_return_code)ret_code;

	return 0;
}
   1515e:	bd30      	pop	{r4, r5, pc}
	*val = *(buf->cur++);
   15160:	1c5c      	adds	r4, r3, #1
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   15162:	42a5      	cmp	r5, r4
	*val = *(buf->cur++);
   15164:	600c      	str	r4, [r1, #0]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   15166:	d0f8      	beq.n	1515a <connect_ack_decode+0xa>
	*val = *(buf->cur++);
   15168:	461d      	mov	r5, r3
   1516a:	f815 4b02 	ldrb.w	r4, [r5], #2
   1516e:	600d      	str	r5, [r1, #0]
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   15170:	f890 105c 	ldrb.w	r1, [r0, #92]	; 0x5c
	*val = *(buf->cur++);
   15174:	785b      	ldrb	r3, [r3, #1]
	param->return_code = (enum mqtt_conn_return_code)ret_code;
   15176:	7053      	strb	r3, [r2, #1]
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   15178:	2904      	cmp	r1, #4
			flags & MQTT_CONNACK_FLAG_SESSION_PRESENT;
   1517a:	bf04      	itt	eq
   1517c:	f004 0401 	andeq.w	r4, r4, #1
		param->session_present_flag =
   15180:	7014      	strbeq	r4, [r2, #0]
	return 0;
   15182:	2000      	movs	r0, #0
   15184:	e7eb      	b.n	1515e <connect_ack_decode+0xe>

00015186 <publish_decode>:

int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf,
		   struct mqtt_publish_param *param)
{
   15186:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1518a:	461c      	mov	r4, r3
	int err_code;
	u32_t var_header_length;

	param->dup_flag = flags & MQTT_HEADER_DUP_MASK;
   1518c:	7d9b      	ldrb	r3, [r3, #22]
	param->retain_flag = flags & MQTT_HEADER_RETAIN_MASK;
   1518e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   15192:	f360 0341 	bfi	r3, r0, #1, #1
	param->message.topic.qos = ((flags & MQTT_HEADER_QOS_MASK) >> 1);
   15196:	f3c0 0041 	ubfx	r0, r0, #1, #2
   1519a:	7220      	strb	r0, [r4, #8]
{
   1519c:	4688      	mov	r8, r1
	param->retain_flag = flags & MQTT_HEADER_RETAIN_MASK;
   1519e:	75a3      	strb	r3, [r4, #22]
	err_code = unpack_uint16(buf, &utf8_strlen);
   151a0:	f10d 0106 	add.w	r1, sp, #6
   151a4:	4610      	mov	r0, r2
{
   151a6:	4616      	mov	r6, r2
	err_code = unpack_uint16(buf, &utf8_strlen);
   151a8:	f7ff ff8b 	bl	150c2 <unpack_uint16>
	if (err_code != 0) {
   151ac:	4607      	mov	r7, r0
   151ae:	b940      	cbnz	r0, 151c2 <publish_decode+0x3c>
	if ((buf->end - buf->cur) < utf8_strlen) {
   151b0:	6833      	ldr	r3, [r6, #0]
   151b2:	6872      	ldr	r2, [r6, #4]
   151b4:	f8bd 5006 	ldrh.w	r5, [sp, #6]
   151b8:	1ad2      	subs	r2, r2, r3
   151ba:	42aa      	cmp	r2, r5
   151bc:	da05      	bge.n	151ca <publish_decode+0x44>
		return -EINVAL;
   151be:	f06f 0715 	mvn.w	r7, #21

	param->message.payload.data = NULL;
	param->message.payload.len = var_length - var_header_length;

	return 0;
}
   151c2:	4638      	mov	r0, r7
   151c4:	b002      	add	sp, #8
   151c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	str->size = utf8_strlen;
   151ca:	6065      	str	r5, [r4, #4]
	if (utf8_strlen) {
   151cc:	b15d      	cbz	r5, 151e6 <publish_decode+0x60>
		str->utf8 = buf->cur;
   151ce:	6023      	str	r3, [r4, #0]
		buf->cur += utf8_strlen;
   151d0:	442b      	add	r3, r5
   151d2:	6033      	str	r3, [r6, #0]
	if (param->message.topic.qos > MQTT_QOS_0_AT_MOST_ONCE) {
   151d4:	7a23      	ldrb	r3, [r4, #8]
   151d6:	b943      	cbnz	r3, 151ea <publish_decode+0x64>
	var_header_length = param->message.topic.topic.size + sizeof(u16_t);
   151d8:	3502      	adds	r5, #2
	param->message.payload.data = NULL;
   151da:	2300      	movs	r3, #0
	param->message.payload.len = var_length - var_header_length;
   151dc:	eba8 0505 	sub.w	r5, r8, r5
	param->message.payload.data = NULL;
   151e0:	60e3      	str	r3, [r4, #12]
	param->message.payload.len = var_length - var_header_length;
   151e2:	6125      	str	r5, [r4, #16]
	return 0;
   151e4:	e7ed      	b.n	151c2 <publish_decode+0x3c>
		str->utf8 = NULL;
   151e6:	6025      	str	r5, [r4, #0]
	if (err_code != 0) {
   151e8:	e7f4      	b.n	151d4 <publish_decode+0x4e>
		err_code = unpack_uint16(buf, &param->message_id);
   151ea:	f104 0114 	add.w	r1, r4, #20
   151ee:	4630      	mov	r0, r6
   151f0:	f7ff ff67 	bl	150c2 <unpack_uint16>
		if (err_code != 0) {
   151f4:	b908      	cbnz	r0, 151fa <publish_decode+0x74>
		var_header_length += sizeof(u16_t);
   151f6:	3504      	adds	r5, #4
   151f8:	e7ef      	b.n	151da <publish_decode+0x54>
   151fa:	4607      	mov	r7, r0
   151fc:	e7e1      	b.n	151c2 <publish_decode+0x3c>

000151fe <publish_ack_decode>:

int publish_ack_decode(struct buf_ctx *buf, struct mqtt_puback_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   151fe:	f7ff bf60 	b.w	150c2 <unpack_uint16>

00015202 <publish_receive_decode>:
}

int publish_receive_decode(struct buf_ctx *buf, struct mqtt_pubrec_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   15202:	f7ff bf5e 	b.w	150c2 <unpack_uint16>

00015206 <publish_release_decode>:
}

int publish_release_decode(struct buf_ctx *buf, struct mqtt_pubrel_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   15206:	f7ff bf5c 	b.w	150c2 <unpack_uint16>

0001520a <publish_complete_decode>:
}

int publish_complete_decode(struct buf_ctx *buf,
			    struct mqtt_pubcomp_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   1520a:	f7ff bf5a 	b.w	150c2 <unpack_uint16>

0001520e <subscribe_ack_decode>:
}

int subscribe_ack_decode(struct buf_ctx *buf, struct mqtt_suback_param *param)
{
   1520e:	b538      	push	{r3, r4, r5, lr}
   15210:	4605      	mov	r5, r0
   15212:	460c      	mov	r4, r1
	int err_code;

	err_code = unpack_uint16(buf, &param->message_id);
   15214:	f7ff ff55 	bl	150c2 <unpack_uint16>
	if (err_code != 0) {
   15218:	b930      	cbnz	r0, 15228 <subscribe_ack_decode+0x1a>
		return err_code;
	}

	return unpack_data(buf->end - buf->cur, buf, &param->return_codes);
   1521a:	e9d5 2300 	ldrd	r2, r3, [r5]
   1521e:	1a99      	subs	r1, r3, r2
	str->len = length;
   15220:	60a1      	str	r1, [r4, #8]
	if (length > 0) {
   15222:	b111      	cbz	r1, 1522a <subscribe_ack_decode+0x1c>
		str->data = buf->cur;
   15224:	6062      	str	r2, [r4, #4]
		buf->cur += length;
   15226:	602b      	str	r3, [r5, #0]
}
   15228:	bd38      	pop	{r3, r4, r5, pc}
		str->data = NULL;
   1522a:	6060      	str	r0, [r4, #4]
   1522c:	e7fc      	b.n	15228 <subscribe_ack_decode+0x1a>

0001522e <unsubscribe_ack_decode>:

int unsubscribe_ack_decode(struct buf_ctx *buf,
			   struct mqtt_unsuback_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   1522e:	f7ff bf48 	b.w	150c2 <unpack_uint16>

00015232 <pack_uint16>:
	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   15232:	e9d1 3200 	ldrd	r3, r2, [r1]
   15236:	1ad2      	subs	r2, r2, r3
   15238:	2a01      	cmp	r2, #1
   1523a:	d909      	bls.n	15250 <pack_uint16+0x1e>
	*(buf->cur++) = (val >> 8) & 0xFF;
   1523c:	1c5a      	adds	r2, r3, #1
   1523e:	600a      	str	r2, [r1, #0]
   15240:	0a02      	lsrs	r2, r0, #8
   15242:	701a      	strb	r2, [r3, #0]
	*(buf->cur++) = val & 0xFF;
   15244:	680b      	ldr	r3, [r1, #0]
   15246:	1c5a      	adds	r2, r3, #1
   15248:	600a      	str	r2, [r1, #0]
   1524a:	7018      	strb	r0, [r3, #0]
	return 0;
   1524c:	2000      	movs	r0, #0
   1524e:	4770      	bx	lr
		return -ENOMEM;
   15250:	f06f 000b 	mvn.w	r0, #11
}
   15254:	4770      	bx	lr

00015256 <pack_utf8_str>:
{
   15256:	b538      	push	{r3, r4, r5, lr}
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   15258:	e9d1 2300 	ldrd	r2, r3, [r1]
{
   1525c:	4605      	mov	r5, r0
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   1525e:	6840      	ldr	r0, [r0, #4]
   15260:	1a9b      	subs	r3, r3, r2
   15262:	1c82      	adds	r2, r0, #2
   15264:	4293      	cmp	r3, r2
{
   15266:	460c      	mov	r4, r1
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   15268:	d30d      	bcc.n	15286 <pack_utf8_str+0x30>
	(void)pack_uint16(str->size, buf);
   1526a:	b280      	uxth	r0, r0
   1526c:	f7ff ffe1 	bl	15232 <pack_uint16>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   15270:	e9d5 1200 	ldrd	r1, r2, [r5]
   15274:	6820      	ldr	r0, [r4, #0]
   15276:	f7ec ff7d 	bl	2174 <memcpy>
	buf->cur += str->size;
   1527a:	6823      	ldr	r3, [r4, #0]
   1527c:	686a      	ldr	r2, [r5, #4]
   1527e:	4413      	add	r3, r2
   15280:	6023      	str	r3, [r4, #0]
	return 0;
   15282:	2000      	movs	r0, #0
}
   15284:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOMEM;
   15286:	f06f 000b 	mvn.w	r0, #11
   1528a:	e7fb      	b.n	15284 <pack_utf8_str+0x2e>

0001528c <mqtt_encode_fixed_header>:
{
   1528c:	b570      	push	{r4, r5, r6, lr}
	u32_t length = buf->cur - start;
   1528e:	6815      	ldr	r5, [r2, #0]
   15290:	1a6d      	subs	r5, r5, r1
	if (length > MQTT_MAX_PAYLOAD_SIZE) {
   15292:	f1b5 5f80 	cmp.w	r5, #268435456	; 0x10000000
   15296:	d227      	bcs.n	152e8 <mqtt_encode_fixed_header+0x5c>
   15298:	462c      	mov	r4, r5
   1529a:	2600      	movs	r6, #0
	} while (length > 0);
   1529c:	09e4      	lsrs	r4, r4, #7
   1529e:	b2f3      	uxtb	r3, r6
		if (buf != NULL) {
   152a0:	f106 0601 	add.w	r6, r6, #1
	} while (length > 0);
   152a4:	d1fa      	bne.n	1529c <mqtt_encode_fixed_header+0x10>
	fixed_header_length += sizeof(u8_t);
   152a6:	3302      	adds	r3, #2
	buf->cur = start - fixed_header_length;
   152a8:	b2db      	uxtb	r3, r3
   152aa:	425b      	negs	r3, r3
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   152ac:	6856      	ldr	r6, [r2, #4]
	buf->cur = start - fixed_header_length;
   152ae:	18cc      	adds	r4, r1, r3
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   152b0:	42b4      	cmp	r4, r6
	buf->cur = start - fixed_header_length;
   152b2:	6014      	str	r4, [r2, #0]
	*(buf->cur++) = val;
   152b4:	bf1e      	ittt	ne
   152b6:	3401      	addne	r4, #1
   152b8:	6014      	strne	r4, [r2, #0]
   152ba:	54c8      	strbne	r0, [r1, r3]
	return 0;
   152bc:	4628      	mov	r0, r5
			*(buf->cur) = length & MQTT_LENGTH_VALUE_MASK;
   152be:	6811      	ldr	r1, [r2, #0]
   152c0:	f000 047f 	and.w	r4, r0, #127	; 0x7f
   152c4:	700c      	strb	r4, [r1, #0]
			if (length > 0) {
   152c6:	09c0      	lsrs	r0, r0, #7
				*(buf->cur) |= MQTT_LENGTH_CONTINUATION_BIT;
   152c8:	bf1f      	itttt	ne
   152ca:	6814      	ldrne	r4, [r2, #0]
   152cc:	7821      	ldrbne	r1, [r4, #0]
   152ce:	f061 017f 	ornne	r1, r1, #127	; 0x7f
   152d2:	7021      	strbne	r1, [r4, #0]
			buf->cur++;
   152d4:	6811      	ldr	r1, [r2, #0]
   152d6:	3101      	adds	r1, #1
   152d8:	6011      	str	r1, [r2, #0]
	} while (length > 0);
   152da:	2800      	cmp	r0, #0
   152dc:	d1ef      	bne.n	152be <mqtt_encode_fixed_header+0x32>
	buf->cur = buf->cur - fixed_header_length;
   152de:	440b      	add	r3, r1
	buf->end = buf->cur + length + fixed_header_length;
   152e0:	4429      	add	r1, r5
	buf->cur = buf->cur - fixed_header_length;
   152e2:	6013      	str	r3, [r2, #0]
	buf->end = buf->cur + length + fixed_header_length;
   152e4:	6051      	str	r1, [r2, #4]
}
   152e6:	bd70      	pop	{r4, r5, r6, pc}
		return -EMSGSIZE;
   152e8:	f06f 0079 	mvn.w	r0, #121	; 0x79
   152ec:	e7fb      	b.n	152e6 <mqtt_encode_fixed_header+0x5a>

000152ee <mqtt_message_id_only_enc>:
{
   152ee:	b570      	push	{r4, r5, r6, lr}
   152f0:	4606      	mov	r6, r0
   152f2:	4615      	mov	r5, r2
	if (message_id == 0U) {
   152f4:	4608      	mov	r0, r1
   152f6:	b169      	cbz	r1, 15314 <mqtt_message_id_only_enc+0x26>
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   152f8:	6814      	ldr	r4, [r2, #0]
   152fa:	3405      	adds	r4, #5
   152fc:	6014      	str	r4, [r2, #0]
	err_code = pack_uint16(message_id, buf);
   152fe:	4611      	mov	r1, r2
   15300:	f7ff ff97 	bl	15232 <pack_uint16>
	if (err_code != 0) {
   15304:	b940      	cbnz	r0, 15318 <mqtt_message_id_only_enc+0x2a>
	return mqtt_encode_fixed_header(message_type, start, buf);
   15306:	462a      	mov	r2, r5
   15308:	4621      	mov	r1, r4
   1530a:	4630      	mov	r0, r6
}
   1530c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   15310:	f7ff bfbc 	b.w	1528c <mqtt_encode_fixed_header>
		return -EINVAL;
   15314:	f06f 0015 	mvn.w	r0, #21
}
   15318:	bd70      	pop	{r4, r5, r6, pc}

0001531a <publish_ack_encode>:
		       struct buf_ctx *buf)
{
	const u8_t message_type =
		MQTT_MESSAGES_OPTIONS(MQTT_PKT_TYPE_PUBACK, 0, 0, 0);

	return mqtt_message_id_only_enc(message_type, param->message_id, buf);
   1531a:	460a      	mov	r2, r1
   1531c:	8801      	ldrh	r1, [r0, #0]
   1531e:	2040      	movs	r0, #64	; 0x40
   15320:	f7ff bfe5 	b.w	152ee <mqtt_message_id_only_enc>

00015324 <publish_release_encode>:
			   struct buf_ctx *buf)
{
	const u8_t message_type =
		MQTT_MESSAGES_OPTIONS(MQTT_PKT_TYPE_PUBREL, 0, 1, 0);

	return mqtt_message_id_only_enc(message_type, param->message_id, buf);
   15324:	460a      	mov	r2, r1
   15326:	8801      	ldrh	r1, [r0, #0]
   15328:	2062      	movs	r0, #98	; 0x62
   1532a:	f7ff bfe0 	b.w	152ee <mqtt_message_id_only_enc>

0001532e <subscribe_encode>:
	return 0;
}

int subscribe_encode(const struct mqtt_subscription_list *param,
		     struct buf_ctx *buf)
{
   1532e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   15332:	4607      	mov	r7, r0
			MQTT_PKT_TYPE_SUBSCRIBE, 0, 1, 0);
	int err_code, i;
	u8_t *start;

	/* Message id zero is not permitted by spec. */
	if (param->message_id == 0U) {
   15334:	88c0      	ldrh	r0, [r0, #6]
{
   15336:	460d      	mov	r5, r1
	if (param->message_id == 0U) {
   15338:	b330      	cbz	r0, 15388 <subscribe_encode+0x5a>
		return -EINVAL;
	}

	/* Reserve space for fixed header. */
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   1533a:	680e      	ldr	r6, [r1, #0]
   1533c:	3605      	adds	r6, #5
   1533e:	600e      	str	r6, [r1, #0]
	start = buf->cur;

	err_code = pack_uint16(param->message_id, buf);
   15340:	f7ff ff77 	bl	15232 <pack_uint16>
	if (err_code != 0) {
   15344:	4604      	mov	r4, r0
   15346:	bb08      	cbnz	r0, 1538c <subscribe_encode+0x5e>
   15348:	f04f 090c 	mov.w	r9, #12
		return err_code;
	}

	for (i = 0; i < param->list_count; i++) {
   1534c:	88bb      	ldrh	r3, [r7, #4]
   1534e:	42a3      	cmp	r3, r4
   15350:	dc06      	bgt.n	15360 <subscribe_encode+0x32>
		if (err_code != 0) {
			return err_code;
		}
	}

	return mqtt_encode_fixed_header(message_type, start, buf);
   15352:	462a      	mov	r2, r5
   15354:	4631      	mov	r1, r6
   15356:	2082      	movs	r0, #130	; 0x82
}
   15358:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   1535c:	f7ff bf96 	b.w	1528c <mqtt_encode_fixed_header>
		err_code = pack_utf8_str(&param->list[i].topic, buf);
   15360:	6838      	ldr	r0, [r7, #0]
   15362:	fb09 f804 	mul.w	r8, r9, r4
   15366:	4629      	mov	r1, r5
   15368:	4440      	add	r0, r8
   1536a:	f7ff ff74 	bl	15256 <pack_utf8_str>
		if (err_code != 0) {
   1536e:	b980      	cbnz	r0, 15392 <subscribe_encode+0x64>
		err_code = pack_uint8(param->list[i].qos, buf);
   15370:	683b      	ldr	r3, [r7, #0]
   15372:	4443      	add	r3, r8
   15374:	7a1a      	ldrb	r2, [r3, #8]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   15376:	e9d5 3100 	ldrd	r3, r1, [r5]
   1537a:	4299      	cmp	r1, r3
   1537c:	d00b      	beq.n	15396 <subscribe_encode+0x68>
	*(buf->cur++) = val;
   1537e:	1c59      	adds	r1, r3, #1
   15380:	6029      	str	r1, [r5, #0]
	for (i = 0; i < param->list_count; i++) {
   15382:	3401      	adds	r4, #1
	*(buf->cur++) = val;
   15384:	701a      	strb	r2, [r3, #0]
		if (err_code != 0) {
   15386:	e7e1      	b.n	1534c <subscribe_encode+0x1e>
		return -EINVAL;
   15388:	f06f 0415 	mvn.w	r4, #21
}
   1538c:	4620      	mov	r0, r4
   1538e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		err_code = pack_utf8_str(&param->list[i].topic, buf);
   15392:	4604      	mov	r4, r0
   15394:	e7fa      	b.n	1538c <subscribe_encode+0x5e>
		return -ENOMEM;
   15396:	f06f 040b 	mvn.w	r4, #11
   1539a:	e7f7      	b.n	1538c <subscribe_encode+0x5e>

0001539c <mqtt_client_tcp_connect>:
 * @param[in] client Identifies the client on which the procedure is requested.
 *
 * @retval 0 or an error code indicating reason for failure.
 */
int mqtt_client_tcp_connect(struct mqtt_client *client)
{
   1539c:	b538      	push	{r3, r4, r5, lr}
	const struct sockaddr *broker = client->broker;
   1539e:	6b45      	ldr	r5, [r0, #52]	; 0x34
{
   153a0:	4604      	mov	r4, r0
K_SYSCALL_DECLARE3(K_SYSCALL_ZSOCK_SOCKET, zsock_socket, int, int, family, int, type, int, proto)
   153a2:	2206      	movs	r2, #6
   153a4:	2101      	movs	r1, #1
   153a6:	8828      	ldrh	r0, [r5, #0]
   153a8:	f7fd faee 	bl	12988 <z_impl_zsock_socket>
	int ret;

	client->transport.tcp.sock = socket(broker->sa_family, SOCK_STREAM,
					    IPPROTO_TCP);
	if (client->transport.tcp.sock < 0) {
   153ac:	2800      	cmp	r0, #0
	client->transport.tcp.sock = socket(broker->sa_family, SOCK_STREAM,
   153ae:	62a0      	str	r0, [r4, #40]	; 0x28
	if (client->transport.tcp.sock < 0) {
   153b0:	da04      	bge.n	153bc <mqtt_client_tcp_connect+0x20>

	ret = connect(client->transport.tcp.sock, client->broker,
		      peer_addr_size);
	if (ret < 0) {
		(void)close(client->transport.tcp.sock);
		return -errno;
   153b2:	f7fd fe60 	bl	13076 <__errno>
   153b6:	6800      	ldr	r0, [r0, #0]
   153b8:	4240      	negs	r0, r0
	}

	MQTT_TRC("Connect completed");
	return 0;
}
   153ba:	bd38      	pop	{r3, r4, r5, pc}
	if (broker->sa_family == AF_INET) {
   153bc:	882b      	ldrh	r3, [r5, #0]
K_SYSCALL_DECLARE3(K_SYSCALL_ZSOCK_CONNECT, zsock_connect, int, int, sock, const struct sockaddr *, addr, socklen_t, addrlen)
   153be:	6b61      	ldr	r1, [r4, #52]	; 0x34
   153c0:	2b01      	cmp	r3, #1
   153c2:	bf14      	ite	ne
   153c4:	2218      	movne	r2, #24
   153c6:	2208      	moveq	r2, #8
   153c8:	f7fd fba4 	bl	12b14 <z_impl_zsock_connect>
	if (ret < 0) {
   153cc:	2800      	cmp	r0, #0
   153ce:	da03      	bge.n	153d8 <mqtt_client_tcp_connect+0x3c>
K_SYSCALL_DECLARE1(K_SYSCALL_ZSOCK_CLOSE, zsock_close, int, int, sock)
   153d0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   153d2:	f7fd fb86 	bl	12ae2 <z_impl_zsock_close>
   153d6:	e7ec      	b.n	153b2 <mqtt_client_tcp_connect+0x16>
	return 0;
   153d8:	2000      	movs	r0, #0
   153da:	e7ee      	b.n	153ba <mqtt_client_tcp_connect+0x1e>

000153dc <mqtt_client_tcp_write>:
 *
 * @retval 0 or an error code indicating reason for failure.
 */
int mqtt_client_tcp_write(struct mqtt_client *client, const u8_t *data,
			  u32_t datalen)
{
   153dc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	u32_t offset = 0U;
   153e0:	2400      	movs	r4, #0
{
   153e2:	4607      	mov	r7, r0
   153e4:	4688      	mov	r8, r1
   153e6:	4615      	mov	r5, r2
   153e8:	4626      	mov	r6, r4
	int ret;

	while (offset < datalen) {
   153ea:	42ac      	cmp	r4, r5
   153ec:	d301      	bcc.n	153f2 <mqtt_client_tcp_write+0x16>
		}

		offset += ret;
	}

	return 0;
   153ee:	2000      	movs	r0, #0
   153f0:	e00e      	b.n	15410 <mqtt_client_tcp_write+0x34>
K_SYSCALL_DECLARE6(K_SYSCALL_ZSOCK_SENDTO, zsock_sendto, ssize_t, int, sock, const void *, buf, size_t, len, int, flags, const struct sockaddr *, dest_addr, socklen_t, addrlen)
   153f2:	e9cd 6600 	strd	r6, r6, [sp]
   153f6:	2300      	movs	r3, #0
   153f8:	1b2a      	subs	r2, r5, r4
   153fa:	eb08 0104 	add.w	r1, r8, r4
   153fe:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   15400:	f7fd fba9 	bl	12b56 <z_impl_zsock_sendto>
		if (ret < 0) {
   15404:	2800      	cmp	r0, #0
   15406:	da06      	bge.n	15416 <mqtt_client_tcp_write+0x3a>
			return -errno;
   15408:	f7fd fe35 	bl	13076 <__errno>
   1540c:	6800      	ldr	r0, [r0, #0]
   1540e:	4240      	negs	r0, r0
}
   15410:	b002      	add	sp, #8
   15412:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		offset += ret;
   15416:	4404      	add	r4, r0
   15418:	e7e7      	b.n	153ea <mqtt_client_tcp_write+0xe>

0001541a <mqtt_client_tcp_read>:
 *
 * @retval Number of bytes read or an error code indicating reason for failure.
 *         0 if connection was closed.
 */
int mqtt_client_tcp_read(struct mqtt_client *client, u8_t *data, u32_t buflen)
{
   1541a:	b507      	push	{r0, r1, r2, lr}
K_SYSCALL_DECLARE6(K_SYSCALL_ZSOCK_RECVFROM, zsock_recvfrom, ssize_t, int, sock, void *, buf, size_t, max_len, int, flags, struct sockaddr *, src_addr, socklen_t *, addrlen)
   1541c:	2300      	movs	r3, #0
   1541e:	e9cd 3300 	strd	r3, r3, [sp]
   15422:	2340      	movs	r3, #64	; 0x40
   15424:	6a80      	ldr	r0, [r0, #40]	; 0x28
   15426:	f7fd fd07 	bl	12e38 <z_impl_zsock_recvfrom>
	int ret;

	ret = recv(client->transport.tcp.sock, data, buflen, MSG_DONTWAIT);
	if (ret < 0) {
   1542a:	2800      	cmp	r0, #0
   1542c:	da03      	bge.n	15436 <mqtt_client_tcp_read+0x1c>
		return -errno;
   1542e:	f7fd fe22 	bl	13076 <__errno>
   15432:	6800      	ldr	r0, [r0, #0]
   15434:	4240      	negs	r0, r0
	}

	return ret;
}
   15436:	b003      	add	sp, #12
   15438:	f85d fb04 	ldr.w	pc, [sp], #4

0001543c <mqtt_client_tcp_disconnect>:
 * @param[in] client Identifies the client on which the procedure is requested.
 *
 * @retval 0 or an error code indicating reason for failure.
 */
int mqtt_client_tcp_disconnect(struct mqtt_client *client)
{
   1543c:	b508      	push	{r3, lr}
K_SYSCALL_DECLARE1(K_SYSCALL_ZSOCK_CLOSE, zsock_close, int, int, sock)
   1543e:	6a80      	ldr	r0, [r0, #40]	; 0x28
   15440:	f7fd fb4f 	bl	12ae2 <z_impl_zsock_close>
	int ret;

	MQTT_TRC("Closing socket %d", client->transport.tcp.sock);

	ret = close(client->transport.tcp.sock);
	if (ret < 0) {
   15444:	2800      	cmp	r0, #0
   15446:	da04      	bge.n	15452 <mqtt_client_tcp_disconnect+0x16>
		return -errno;
   15448:	f7fd fe15 	bl	13076 <__errno>
   1544c:	6800      	ldr	r0, [r0, #0]
   1544e:	4240      	negs	r0, r0
	}

	return 0;
}
   15450:	bd08      	pop	{r3, pc}
	return 0;
   15452:	2000      	movs	r0, #0
   15454:	e7fc      	b.n	15450 <mqtt_client_tcp_disconnect+0x14>

00015456 <mqtt_transport_disconnect>:

int mqtt_transport_disconnect(struct mqtt_client *client)
{
	return transport_fn[client->transport.type].disconnect(client);
   15456:	f7ff bff1 	b.w	1543c <mqtt_client_tcp_disconnect>

0001545a <mqtt_mutex_lock>:
K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
   1545a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1545e:	f7f9 bd05 	b.w	ee6c <z_impl_k_mutex_lock>

00015462 <tx_buf_init>:
{
   15462:	b538      	push	{r3, r4, r5, lr}
   15464:	4604      	mov	r4, r0
   15466:	460d      	mov	r5, r1
__ssp_bos_icheck3(memset, void *, int)
   15468:	6d82      	ldr	r2, [r0, #88]	; 0x58
   1546a:	6d40      	ldr	r0, [r0, #84]	; 0x54
   1546c:	2100      	movs	r1, #0
   1546e:	f7ec febc 	bl	21ea <memset>
	buf->cur = client->tx_buf;
   15472:	6d63      	ldr	r3, [r4, #84]	; 0x54
	buf->end = client->tx_buf + client->tx_buf_size;
   15474:	6da2      	ldr	r2, [r4, #88]	; 0x58
	buf->cur = client->tx_buf;
   15476:	602b      	str	r3, [r5, #0]
	buf->end = client->tx_buf + client->tx_buf_size;
   15478:	4413      	add	r3, r2
   1547a:	606b      	str	r3, [r5, #4]
}
   1547c:	bd38      	pop	{r3, r4, r5, pc}

0001547e <event_notify>:
{
   1547e:	b538      	push	{r3, r4, r5, lr}
	if (client->evt_cb != NULL) {
   15480:	6c83      	ldr	r3, [r0, #72]	; 0x48
{
   15482:	4604      	mov	r4, r0
   15484:	460d      	mov	r5, r1
	if (client->evt_cb != NULL) {
   15486:	b153      	cbz	r3, 1549e <event_notify+0x20>

/**@brief Release the lock on the module specific mutex, if any.
 */
static inline void mqtt_mutex_unlock(struct mqtt_client *client)
{
	int ret = sys_mutex_unlock(&client->internal.mutex);
   15488:	f7f8 f96c 	bl	d764 <sys_mutex_unlock>
		client->evt_cb(client, evt);
   1548c:	4620      	mov	r0, r4
   1548e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   15490:	4629      	mov	r1, r5
   15492:	4798      	blx	r3
		mqtt_mutex_lock(client);
   15494:	4620      	mov	r0, r4
}
   15496:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		mqtt_mutex_lock(client);
   1549a:	f7ff bfde 	b.w	1545a <mqtt_mutex_lock>
}
   1549e:	bd38      	pop	{r3, r4, r5, pc}

000154a0 <client_write>:
	return err_code;
}

static int client_write(struct mqtt_client *client, const u8_t *data,
			u32_t datalen)
{
   154a0:	b538      	push	{r3, r4, r5, lr}
   154a2:	4605      	mov	r5, r0
	int err_code;

	MQTT_TRC("[%p]: Transport writing %d bytes.", client, datalen);

	err_code = mqtt_transport_write(client, data, datalen);
   154a4:	f7f8 f946 	bl	d734 <mqtt_transport_write>
	if (err_code < 0) {
   154a8:	1e04      	subs	r4, r0, #0
   154aa:	da05      	bge.n	154b8 <client_write+0x18>
		MQTT_TRC("TCP write failed, errno = %d, "
			 "closing connection", errno);
		client_disconnect(client, err_code);
   154ac:	4621      	mov	r1, r4
   154ae:	4628      	mov	r0, r5
   154b0:	f7f8 f96c 	bl	d78c <client_disconnect>

	MQTT_TRC("[%p]: Transport write complete.", client);
	client->internal.last_activity = mqtt_sys_tick_in_ms_get();

	return 0;
}
   154b4:	4620      	mov	r0, r4
   154b6:	bd38      	pop	{r3, r4, r5, pc}
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
   154b8:	f000 fd6e 	bl	15f98 <z_impl_k_uptime_get>
	return 0;
   154bc:	2400      	movs	r4, #0
	return (u32_t)k_uptime_get();
   154be:	6168      	str	r0, [r5, #20]
   154c0:	e7f8      	b.n	154b4 <client_write+0x14>

000154c2 <mqtt_client_init>:

void mqtt_client_init(struct mqtt_client *client)
{
   154c2:	b510      	push	{r4, lr}
	NULL_PARAM_CHECK_VOID(client);
   154c4:	4604      	mov	r4, r0
   154c6:	b180      	cbz	r0, 154ea <mqtt_client_init+0x28>
   154c8:	2260      	movs	r2, #96	; 0x60
   154ca:	2100      	movs	r1, #0
   154cc:	f7ec fe8d 	bl	21ea <memset>

	memset(client, 0, sizeof(*client));

	MQTT_STATE_INIT(client);
   154d0:	2300      	movs	r3, #0
   154d2:	61a3      	str	r3, [r4, #24]
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_INIT, k_mutex_init, struct k_mutex *, mutex)
   154d4:	4620      	mov	r0, r4
   154d6:	f000 fa8a 	bl	159ee <z_impl_k_mutex_init>
	mqtt_mutex_init(client);

	client->protocol_version = MQTT_VERSION_3_1_1;
   154da:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
   154de:	f403 437d 	and.w	r3, r3, #64768	; 0xfd00
   154e2:	f443 7301 	orr.w	r3, r3, #516	; 0x204
   154e6:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
	client->clean_session = 1U;
}
   154ea:	bd10      	pop	{r4, pc}

000154ec <mqtt_connect>:

int mqtt_connect(struct mqtt_client *client)
{
   154ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
	int err_code;

	NULL_PARAM_CHECK(client);
   154ee:	4604      	mov	r4, r0
   154f0:	2800      	cmp	r0, #0
   154f2:	d03a      	beq.n	1556a <mqtt_connect+0x7e>
	NULL_PARAM_CHECK(client->client_id.utf8);
   154f4:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   154f6:	2b00      	cmp	r3, #0
   154f8:	d037      	beq.n	1556a <mqtt_connect+0x7e>

	mqtt_mutex_lock(client);
   154fa:	f7ff ffae 	bl	1545a <mqtt_mutex_lock>

	if ((client->tx_buf == NULL) || (client->rx_buf == NULL)) {
   154fe:	6d63      	ldr	r3, [r4, #84]	; 0x54
   15500:	b383      	cbz	r3, 15564 <mqtt_connect+0x78>
   15502:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   15504:	b373      	cbz	r3, 15564 <mqtt_connect+0x78>
	err_code = mqtt_transport_connect(client);
   15506:	4620      	mov	r0, r4
   15508:	f7f8 f90c 	bl	d724 <mqtt_transport_connect>
	if (err_code < 0) {
   1550c:	1e05      	subs	r5, r0, #0
   1550e:	db23      	blt.n	15558 <mqtt_connect+0x6c>
	tx_buf_init(client, &packet);
   15510:	4669      	mov	r1, sp
   15512:	4620      	mov	r0, r4
   15514:	f7ff ffa5 	bl	15462 <tx_buf_init>
	MQTT_SET_STATE(client, MQTT_STATE_TCP_CONNECTED);
   15518:	69a3      	ldr	r3, [r4, #24]
   1551a:	f043 0302 	orr.w	r3, r3, #2
   1551e:	61a3      	str	r3, [r4, #24]
	err_code = connect_request_encode(client, &packet);
   15520:	4669      	mov	r1, sp
   15522:	4620      	mov	r0, r4
   15524:	f7f7 fe1c 	bl	d160 <connect_request_encode>
	if (err_code < 0) {
   15528:	1e05      	subs	r5, r0, #0
   1552a:	db11      	blt.n	15550 <mqtt_connect+0x64>
	err_code = mqtt_transport_write(client, packet.cur,
   1552c:	e9dd 1200 	ldrd	r1, r2, [sp]
   15530:	4620      	mov	r0, r4
   15532:	1a52      	subs	r2, r2, r1
   15534:	f7f8 f8fe 	bl	d734 <mqtt_transport_write>
	if (err_code < 0) {
   15538:	1e05      	subs	r5, r0, #0
   1553a:	db09      	blt.n	15550 <mqtt_connect+0x64>
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
   1553c:	f000 fd2c 	bl	15f98 <z_impl_k_uptime_get>
	return 0;
   15540:	2500      	movs	r5, #0
   15542:	6160      	str	r0, [r4, #20]
   15544:	4620      	mov	r0, r4
   15546:	f7f8 f90d 	bl	d764 <sys_mutex_unlock>
	}

	mqtt_mutex_unlock(client);

	return err_code;
}
   1554a:	4628      	mov	r0, r5
   1554c:	b003      	add	sp, #12
   1554e:	bd30      	pop	{r4, r5, pc}
	client_disconnect(client, err_code);
   15550:	4629      	mov	r1, r5
   15552:	4620      	mov	r0, r4
   15554:	f7f8 f91a 	bl	d78c <client_disconnect>
	MQTT_STATE_INIT(client);
   15558:	2300      	movs	r3, #0
	client->internal.last_activity = 0U;
   1555a:	e9c4 3305 	strd	r3, r3, [r4, #20]
	client->internal.remaining_payload = 0U;
   1555e:	e9c4 3307 	strd	r3, r3, [r4, #28]
   15562:	e7ef      	b.n	15544 <mqtt_connect+0x58>
		err_code = -ENOMEM;
   15564:	f06f 050b 	mvn.w	r5, #11
   15568:	e7f6      	b.n	15558 <mqtt_connect+0x6c>
	NULL_PARAM_CHECK(client);
   1556a:	f06f 0515 	mvn.w	r5, #21
   1556e:	e7ec      	b.n	1554a <mqtt_connect+0x5e>

00015570 <mqtt_publish_qos1_ack>:
	return err_code;
}

int mqtt_publish_qos1_ack(struct mqtt_client *client,
			  const struct mqtt_puback_param *param)
{
   15570:	b537      	push	{r0, r1, r2, r4, r5, lr}
   15572:	460c      	mov	r4, r1
	int err_code;
	struct buf_ctx packet;

	NULL_PARAM_CHECK(client);
   15574:	4605      	mov	r5, r0
   15576:	b1f8      	cbz	r0, 155b8 <mqtt_publish_qos1_ack+0x48>
	NULL_PARAM_CHECK(param);
   15578:	b1f1      	cbz	r1, 155b8 <mqtt_publish_qos1_ack+0x48>

	MQTT_TRC("[CID %p]:[State 0x%02x]: >> Message id 0x%04x",
		 client, client->internal.state, param->message_id);

	mqtt_mutex_lock(client);
   1557a:	f7ff ff6e 	bl	1545a <mqtt_mutex_lock>

	tx_buf_init(client, &packet);
   1557e:	4669      	mov	r1, sp
   15580:	4628      	mov	r0, r5
   15582:	f7ff ff6e 	bl	15462 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   15586:	69ab      	ldr	r3, [r5, #24]
   15588:	075b      	lsls	r3, r3, #29
   1558a:	d512      	bpl.n	155b2 <mqtt_publish_qos1_ack+0x42>
	err_code = verify_tx_state(client);
	if (err_code < 0) {
		goto error;
	}

	err_code = publish_ack_encode(param, &packet);
   1558c:	4620      	mov	r0, r4
   1558e:	4669      	mov	r1, sp
   15590:	f7ff fec3 	bl	1531a <publish_ack_encode>
	if (err_code < 0) {
   15594:	1e04      	subs	r4, r0, #0
   15596:	db06      	blt.n	155a6 <mqtt_publish_qos1_ack+0x36>
		goto error;
	}

	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   15598:	e9dd 1200 	ldrd	r1, r2, [sp]
   1559c:	4628      	mov	r0, r5
   1559e:	1a52      	subs	r2, r2, r1
   155a0:	f7ff ff7e 	bl	154a0 <client_write>
   155a4:	4604      	mov	r4, r0
   155a6:	4628      	mov	r0, r5
   155a8:	f7f8 f8dc 	bl	d764 <sys_mutex_unlock>
		 client, client->internal.state, err_code);

	mqtt_mutex_unlock(client);

	return err_code;
}
   155ac:	4620      	mov	r0, r4
   155ae:	b003      	add	sp, #12
   155b0:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   155b2:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   155b6:	e7f6      	b.n	155a6 <mqtt_publish_qos1_ack+0x36>
	NULL_PARAM_CHECK(client);
   155b8:	f06f 0415 	mvn.w	r4, #21
   155bc:	e7f6      	b.n	155ac <mqtt_publish_qos1_ack+0x3c>

000155be <mqtt_publish_qos2_release>:
	return err_code;
}

int mqtt_publish_qos2_release(struct mqtt_client *client,
			      const struct mqtt_pubrel_param *param)
{
   155be:	b537      	push	{r0, r1, r2, r4, r5, lr}
   155c0:	460c      	mov	r4, r1
	int err_code;
	struct buf_ctx packet;

	NULL_PARAM_CHECK(client);
   155c2:	4605      	mov	r5, r0
   155c4:	b1f8      	cbz	r0, 15606 <mqtt_publish_qos2_release+0x48>
	NULL_PARAM_CHECK(param);
   155c6:	b1f1      	cbz	r1, 15606 <mqtt_publish_qos2_release+0x48>

	MQTT_TRC("[CID %p]:[State 0x%02x]: >> Message id 0x%04x",
		 client, client->internal.state, param->message_id);

	mqtt_mutex_lock(client);
   155c8:	f7ff ff47 	bl	1545a <mqtt_mutex_lock>

	tx_buf_init(client, &packet);
   155cc:	4669      	mov	r1, sp
   155ce:	4628      	mov	r0, r5
   155d0:	f7ff ff47 	bl	15462 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   155d4:	69ab      	ldr	r3, [r5, #24]
   155d6:	075b      	lsls	r3, r3, #29
   155d8:	d512      	bpl.n	15600 <mqtt_publish_qos2_release+0x42>
	err_code = verify_tx_state(client);
	if (err_code < 0) {
		goto error;
	}

	err_code = publish_release_encode(param, &packet);
   155da:	4620      	mov	r0, r4
   155dc:	4669      	mov	r1, sp
   155de:	f7ff fea1 	bl	15324 <publish_release_encode>
	if (err_code < 0) {
   155e2:	1e04      	subs	r4, r0, #0
   155e4:	db06      	blt.n	155f4 <mqtt_publish_qos2_release+0x36>
		goto error;
	}

	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   155e6:	e9dd 1200 	ldrd	r1, r2, [sp]
   155ea:	4628      	mov	r0, r5
   155ec:	1a52      	subs	r2, r2, r1
   155ee:	f7ff ff57 	bl	154a0 <client_write>
   155f2:	4604      	mov	r4, r0
   155f4:	4628      	mov	r0, r5
   155f6:	f7f8 f8b5 	bl	d764 <sys_mutex_unlock>
		 client, client->internal.state, err_code);

	mqtt_mutex_unlock(client);

	return err_code;
}
   155fa:	4620      	mov	r0, r4
   155fc:	b003      	add	sp, #12
   155fe:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   15600:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   15604:	e7f6      	b.n	155f4 <mqtt_publish_qos2_release+0x36>
	NULL_PARAM_CHECK(client);
   15606:	f06f 0415 	mvn.w	r4, #21
   1560a:	e7f6      	b.n	155fa <mqtt_publish_qos2_release+0x3c>

0001560c <mqtt_subscribe>:
	return err_code;
}

int mqtt_subscribe(struct mqtt_client *client,
		   const struct mqtt_subscription_list *param)
{
   1560c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1560e:	460c      	mov	r4, r1
	int err_code;
	struct buf_ctx packet;

	NULL_PARAM_CHECK(client);
   15610:	4605      	mov	r5, r0
   15612:	b1f8      	cbz	r0, 15654 <mqtt_subscribe+0x48>
	NULL_PARAM_CHECK(param);
   15614:	b1f1      	cbz	r1, 15654 <mqtt_subscribe+0x48>

	MQTT_TRC("[CID %p]:[State 0x%02x]: >> message id 0x%04x "
		 "topic count 0x%04x", client, client->internal.state,
		 param->message_id, param->list_count);

	mqtt_mutex_lock(client);
   15616:	f7ff ff20 	bl	1545a <mqtt_mutex_lock>

	tx_buf_init(client, &packet);
   1561a:	4669      	mov	r1, sp
   1561c:	4628      	mov	r0, r5
   1561e:	f7ff ff20 	bl	15462 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   15622:	69ab      	ldr	r3, [r5, #24]
   15624:	075b      	lsls	r3, r3, #29
   15626:	d512      	bpl.n	1564e <mqtt_subscribe+0x42>
	err_code = verify_tx_state(client);
	if (err_code < 0) {
		goto error;
	}

	err_code = subscribe_encode(param, &packet);
   15628:	4620      	mov	r0, r4
   1562a:	4669      	mov	r1, sp
   1562c:	f7ff fe7f 	bl	1532e <subscribe_encode>
	if (err_code < 0) {
   15630:	1e04      	subs	r4, r0, #0
   15632:	db06      	blt.n	15642 <mqtt_subscribe+0x36>
		goto error;
	}

	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   15634:	e9dd 1200 	ldrd	r1, r2, [sp]
   15638:	4628      	mov	r0, r5
   1563a:	1a52      	subs	r2, r2, r1
   1563c:	f7ff ff30 	bl	154a0 <client_write>
   15640:	4604      	mov	r4, r0
   15642:	4628      	mov	r0, r5
   15644:	f7f8 f88e 	bl	d764 <sys_mutex_unlock>
		 client, client->internal.state, err_code);

	mqtt_mutex_unlock(client);

	return err_code;
}
   15648:	4620      	mov	r0, r4
   1564a:	b003      	add	sp, #12
   1564c:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   1564e:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   15652:	e7f6      	b.n	15642 <mqtt_subscribe+0x36>
	NULL_PARAM_CHECK(client);
   15654:	f06f 0415 	mvn.w	r4, #21
   15658:	e7f6      	b.n	15648 <mqtt_subscribe+0x3c>

0001565a <mqtt_abort>:

	return err_code;
}

int mqtt_abort(struct mqtt_client *client)
{
   1565a:	b510      	push	{r4, lr}
   1565c:	4604      	mov	r4, r0
	mqtt_mutex_lock(client);
   1565e:	f7ff fefc 	bl	1545a <mqtt_mutex_lock>

	NULL_PARAM_CHECK(client);
   15662:	b15c      	cbz	r4, 1567c <mqtt_abort+0x22>

	if (client->internal.state != MQTT_STATE_IDLE) {
   15664:	69a3      	ldr	r3, [r4, #24]
   15666:	b123      	cbz	r3, 15672 <mqtt_abort+0x18>
		client_disconnect(client, -ECONNABORTED);
   15668:	f06f 0170 	mvn.w	r1, #112	; 0x70
   1566c:	4620      	mov	r0, r4
   1566e:	f7f8 f88d 	bl	d78c <client_disconnect>
   15672:	4620      	mov	r0, r4
   15674:	f7f8 f876 	bl	d764 <sys_mutex_unlock>
	}

	mqtt_mutex_unlock(client);

	return 0;
   15678:	2000      	movs	r0, #0
}
   1567a:	bd10      	pop	{r4, pc}
	NULL_PARAM_CHECK(client);
   1567c:	f06f 0015 	mvn.w	r0, #21
   15680:	e7fb      	b.n	1567a <mqtt_abort+0x20>

00015682 <mqtt_input>:

	return 0;
}

int mqtt_input(struct mqtt_client *client)
{
   15682:	b538      	push	{r3, r4, r5, lr}
	int err_code = 0;

	NULL_PARAM_CHECK(client);
   15684:	4605      	mov	r5, r0
   15686:	b310      	cbz	r0, 156ce <mqtt_input+0x4c>

	mqtt_mutex_lock(client);
   15688:	f7ff fee7 	bl	1545a <mqtt_mutex_lock>

	MQTT_TRC("state:0x%08x", client->internal.state);

	if (MQTT_HAS_STATE(client, MQTT_STATE_DISCONNECTING)) {
   1568c:	69ab      	ldr	r3, [r5, #24]
   1568e:	071a      	lsls	r2, r3, #28
   15690:	d509      	bpl.n	156a6 <mqtt_input+0x24>
		client_disconnect(client, 0);
   15692:	2100      	movs	r1, #0
   15694:	4628      	mov	r0, r5
   15696:	f7f8 f879 	bl	d78c <client_disconnect>
	int err_code = 0;
   1569a:	2400      	movs	r4, #0
   1569c:	4628      	mov	r0, r5
   1569e:	f7f8 f861 	bl	d764 <sys_mutex_unlock>
	}

	mqtt_mutex_unlock(client);

	return err_code;
}
   156a2:	4620      	mov	r0, r4
   156a4:	bd38      	pop	{r3, r4, r5, pc}
	} else if (MQTT_HAS_STATE(client, MQTT_STATE_TCP_CONNECTED)) {
   156a6:	079b      	lsls	r3, r3, #30
   156a8:	d50b      	bpl.n	156c2 <mqtt_input+0x40>
	if (client->internal.remaining_payload > 0) {
   156aa:	6a2b      	ldr	r3, [r5, #32]
   156ac:	b963      	cbnz	r3, 156c8 <mqtt_input+0x46>
	err_code = mqtt_handle_rx(client);
   156ae:	4628      	mov	r0, r5
   156b0:	f7f7 fe62 	bl	d378 <mqtt_handle_rx>
	if (err_code < 0) {
   156b4:	1e04      	subs	r4, r0, #0
   156b6:	daf1      	bge.n	1569c <mqtt_input+0x1a>
		client_disconnect(client, err_code);
   156b8:	4621      	mov	r1, r4
   156ba:	4628      	mov	r0, r5
   156bc:	f7f8 f866 	bl	d78c <client_disconnect>
   156c0:	e7ec      	b.n	1569c <mqtt_input+0x1a>
		err_code = -EACCES;
   156c2:	f06f 040c 	mvn.w	r4, #12
   156c6:	e7e9      	b.n	1569c <mqtt_input+0x1a>
		return -EBUSY;
   156c8:	f06f 040f 	mvn.w	r4, #15
   156cc:	e7e6      	b.n	1569c <mqtt_input+0x1a>
	NULL_PARAM_CHECK(client);
   156ce:	f06f 0415 	mvn.w	r4, #21
   156d2:	e7e6      	b.n	156a2 <mqtt_input+0x20>

000156d4 <mqtt_read_publish_payload>:

int mqtt_read_publish_payload(struct mqtt_client *client, void *buffer,
			      size_t length)
{
   156d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   156d6:	460e      	mov	r6, r1
   156d8:	4617      	mov	r7, r2
	int ret;

	NULL_PARAM_CHECK(client);
   156da:	4605      	mov	r5, r0
   156dc:	b308      	cbz	r0, 15722 <mqtt_read_publish_payload+0x4e>

	mqtt_mutex_lock(client);
   156de:	f7ff febc 	bl	1545a <mqtt_mutex_lock>

	if (client->internal.remaining_payload == 0U) {
   156e2:	6a2c      	ldr	r4, [r5, #32]
   156e4:	b1a4      	cbz	r4, 15710 <mqtt_read_publish_payload+0x3c>

	if (client->internal.remaining_payload < length) {
		length = client->internal.remaining_payload;
	}

	ret = mqtt_transport_read(client, buffer, length);
   156e6:	42bc      	cmp	r4, r7
   156e8:	4622      	mov	r2, r4
   156ea:	4631      	mov	r1, r6
   156ec:	bf28      	it	cs
   156ee:	463a      	movcs	r2, r7
   156f0:	4628      	mov	r0, r5
   156f2:	f7f8 f82b 	bl	d74c <mqtt_transport_read>
	if (ret == -EAGAIN) {
   156f6:	f110 0f0b 	cmn.w	r0, #11
	ret = mqtt_transport_read(client, buffer, length);
   156fa:	4604      	mov	r4, r0
	if (ret == -EAGAIN) {
   156fc:	d008      	beq.n	15710 <mqtt_read_publish_payload+0x3c>
		goto exit;
	}

	if (ret <= 0) {
   156fe:	2800      	cmp	r0, #0
   15700:	dc0b      	bgt.n	1571a <mqtt_read_publish_payload+0x46>
		if (ret == 0) {
			ret = -ENOTCONN;
   15702:	bf08      	it	eq
   15704:	f06f 047f 	mvneq.w	r4, #127	; 0x7f
		}

		client_disconnect(client, ret);
   15708:	4621      	mov	r1, r4
   1570a:	4628      	mov	r0, r5
   1570c:	f7f8 f83e 	bl	d78c <client_disconnect>
   15710:	4628      	mov	r0, r5
   15712:	f7f8 f827 	bl	d764 <sys_mutex_unlock>

exit:
	mqtt_mutex_unlock(client);

	return ret;
}
   15716:	4620      	mov	r0, r4
   15718:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	client->internal.remaining_payload -= ret;
   1571a:	6a2b      	ldr	r3, [r5, #32]
   1571c:	1a1b      	subs	r3, r3, r0
   1571e:	622b      	str	r3, [r5, #32]
   15720:	e7f6      	b.n	15710 <mqtt_read_publish_payload+0x3c>
	NULL_PARAM_CHECK(client);
   15722:	f06f 0415 	mvn.w	r4, #21
   15726:	e7f6      	b.n	15716 <mqtt_read_publish_payload+0x42>

00015728 <netusb_init_dev>:

static int netusb_init_dev(struct device *dev)
{
	ARG_UNUSED(dev);
	return 0;
}
   15728:	2000      	movs	r0, #0
   1572a:	4770      	bx	lr

0001572c <ecm_int_in>:
}
   1572c:	4770      	bx	lr

0001572e <gpio_fire_callbacks>:
 * @param pins The actual pin mask that triggered the interrupt
 */
static inline void gpio_fire_callbacks(sys_slist_t *list,
					struct device *port,
					u32_t pins)
{
   1572e:	b570      	push	{r4, r5, r6, lr}
   15730:	460e      	mov	r6, r1
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   15732:	6801      	ldr	r1, [r0, #0]
{
   15734:	4615      	mov	r5, r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   15736:	b159      	cbz	r1, 15750 <gpio_fire_callbacks+0x22>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   15738:	680c      	ldr	r4, [r1, #0]
		if (cb->pin_mask & pins) {
   1573a:	688b      	ldr	r3, [r1, #8]
   1573c:	421d      	tst	r5, r3
   1573e:	d003      	beq.n	15748 <gpio_fire_callbacks+0x1a>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
   15740:	684b      	ldr	r3, [r1, #4]
   15742:	462a      	mov	r2, r5
   15744:	4630      	mov	r0, r6
   15746:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   15748:	b114      	cbz	r4, 15750 <gpio_fire_callbacks+0x22>
   1574a:	4621      	mov	r1, r4
   1574c:	6824      	ldr	r4, [r4, #0]
   1574e:	e7f4      	b.n	1573a <gpio_fire_callbacks+0xc>
		}
	}
}
   15750:	bd70      	pop	{r4, r5, r6, pc}

00015752 <gpio_nrfx_write>:
{
   15752:	b510      	push	{r4, lr}
	return port->config->config_info;
   15754:	6804      	ldr	r4, [r0, #0]
   15756:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   15758:	68a4      	ldr	r4, [r4, #8]
   1575a:	69c0      	ldr	r0, [r0, #28]
   1575c:	6824      	ldr	r4, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   1575e:	2901      	cmp	r1, #1
   15760:	d104      	bne.n	1576c <gpio_nrfx_write+0x1a>
		nrf_gpio_port_out_write(reg, value ^ data->inverted);
   15762:	4058      	eors	r0, r3
    p_reg->OUT = value;
   15764:	f8c4 0504 	str.w	r0, [r4, #1284]	; 0x504
}
   15768:	2000      	movs	r0, #0
   1576a:	bd10      	pop	{r4, pc}
		if ((value > 0) ^ ((BIT(pin) & data->inverted) != 0)) {
   1576c:	3300      	adds	r3, #0
   1576e:	fa20 f002 	lsr.w	r0, r0, r2
   15772:	f04f 0101 	mov.w	r1, #1
   15776:	bf18      	it	ne
   15778:	2301      	movne	r3, #1
   1577a:	f000 0001 	and.w	r0, r0, #1
   1577e:	4091      	lsls	r1, r2
   15780:	4283      	cmp	r3, r0
    p_reg->OUTSET = set_mask;
   15782:	bf14      	ite	ne
   15784:	f8c4 1508 	strne.w	r1, [r4, #1288]	; 0x508
}


__STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
   15788:	f8c4 150c 	streq.w	r1, [r4, #1292]	; 0x50c
   1578c:	e7ec      	b.n	15768 <gpio_nrfx_write+0x16>

0001578e <gpio_nrfx_read>:
{
   1578e:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
   15790:	6804      	ldr	r4, [r0, #0]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   15792:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   15794:	68a4      	ldr	r4, [r4, #8]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   15796:	69c0      	ldr	r0, [r0, #28]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   15798:	6825      	ldr	r5, [r4, #0]
    return p_reg->DIR;
   1579a:	f8d5 6514 	ldr.w	r6, [r5, #1300]	; 0x514
    return p_reg->IN;
   1579e:	f8d5 4510 	ldr.w	r4, [r5, #1296]	; 0x510
    return p_reg->OUT;
   157a2:	f8d5 5504 	ldr.w	r5, [r5, #1284]	; 0x504
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   157a6:	4060      	eors	r0, r4
   157a8:	406c      	eors	r4, r5
   157aa:	4034      	ands	r4, r6
   157ac:	4060      	eors	r0, r4
	if (access_op == GPIO_ACCESS_BY_PORT) {
   157ae:	2901      	cmp	r1, #1
		*value = (port_val & BIT(pin)) ? 1 : 0;
   157b0:	bf1c      	itt	ne
   157b2:	40d0      	lsrne	r0, r2
   157b4:	f000 0001 	andne.w	r0, r0, #1
   157b8:	6018      	str	r0, [r3, #0]
}
   157ba:	2000      	movs	r0, #0
   157bc:	bd70      	pop	{r4, r5, r6, pc}

000157be <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   157be:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_IS_EMPTY(slist)
   157c0:	6818      	ldr	r0, [r3, #0]
{
   157c2:	b530      	push	{r4, r5, lr}
	if (!sys_slist_is_empty(callbacks)) {
   157c4:	b158      	cbz	r0, 157de <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   157c6:	2400      	movs	r4, #0
   157c8:	4281      	cmp	r1, r0
   157ca:	d113      	bne.n	157f4 <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   157cc:	6808      	ldr	r0, [r1, #0]
   157ce:	b95c      	cbnz	r4, 157e8 <gpio_nrfx_manage_callback+0x2a>
   157d0:	685c      	ldr	r4, [r3, #4]
	list->head = node;
   157d2:	6018      	str	r0, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   157d4:	42a1      	cmp	r1, r4
   157d6:	d100      	bne.n	157da <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   157d8:	6058      	str	r0, [r3, #4]
	parent->next = child;
   157da:	2000      	movs	r0, #0
   157dc:	6008      	str	r0, [r1, #0]
	if (set) {
   157de:	b972      	cbnz	r2, 157fe <gpio_nrfx_manage_callback+0x40>
	return 0;
   157e0:	2000      	movs	r0, #0
}
   157e2:	bd30      	pop	{r4, r5, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   157e4:	4628      	mov	r0, r5
   157e6:	e7ef      	b.n	157c8 <gpio_nrfx_manage_callback+0xa>
	parent->next = child;
   157e8:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   157ea:	6858      	ldr	r0, [r3, #4]
   157ec:	4281      	cmp	r1, r0
	list->tail = node;
   157ee:	bf08      	it	eq
   157f0:	605c      	streq	r4, [r3, #4]
   157f2:	e7f2      	b.n	157da <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   157f4:	6805      	ldr	r5, [r0, #0]
	return node->next;
   157f6:	4604      	mov	r4, r0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   157f8:	2d00      	cmp	r5, #0
   157fa:	d1f3      	bne.n	157e4 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   157fc:	b13a      	cbz	r2, 1580e <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   157fe:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
   15800:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   15802:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   15804:	6019      	str	r1, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
   15806:	2800      	cmp	r0, #0
   15808:	d1ea      	bne.n	157e0 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   1580a:	6059      	str	r1, [r3, #4]
   1580c:	e7e9      	b.n	157e2 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   1580e:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   15812:	e7e6      	b.n	157e2 <gpio_nrfx_manage_callback+0x24>

00015814 <check_level_trigger_pins>:
	struct gpio_nrfx_data *data = get_port_data(port);
   15814:	6883      	ldr	r3, [r0, #8]
	return port->config->config_info;
   15816:	6802      	ldr	r2, [r0, #0]
{
   15818:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return port->config->config_info;
   1581c:	f8d2 8008 	ldr.w	r8, [r2, #8]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   15820:	69dd      	ldr	r5, [r3, #28]
	u32_t out = data->int_en & data->pin_int_en;
   15822:	e9d3 2402 	ldrd	r2, r4, [r3, #8]
   15826:	4014      	ands	r4, r2
	out &= ~data->trig_edge & ~data->double_edge;
   15828:	e9d3 2105 	ldrd	r2, r1, [r3, #20]
   1582c:	430a      	orrs	r2, r1
   1582e:	ea24 0402 	bic.w	r4, r4, r2
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
   15832:	f8d8 2000 	ldr.w	r2, [r8]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   15836:	691b      	ldr	r3, [r3, #16]
    return p_reg->IN;
   15838:	f8d2 2510 	ldr.w	r2, [r2, #1296]	; 0x510
   1583c:	405d      	eors	r5, r3
   1583e:	4055      	eors	r5, r2
	u32_t out = pin_states & level_pins;
   15840:	ea24 0505 	bic.w	r5, r4, r5
	u32_t bit = 1U << pin;
   15844:	2601      	movs	r6, #1
	u32_t pin = 0U;
   15846:	2700      	movs	r7, #0
	while (level_pins) {
   15848:	b914      	cbnz	r4, 15850 <check_level_trigger_pins+0x3c>
}
   1584a:	4628      	mov	r0, r5
   1584c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   15850:	4234      	tst	r4, r6
   15852:	d00a      	beq.n	1586a <check_level_trigger_pins+0x56>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   15854:	f898 3004 	ldrb.w	r3, [r8, #4]
   15858:	f007 001f 	and.w	r0, r7, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   1585c:	2100      	movs	r1, #0
   1585e:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   15862:	f7f8 fb1d 	bl	dea0 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   15866:	ea24 0406 	bic.w	r4, r4, r6
		++pin;
   1586a:	3701      	adds	r7, #1
		bit <<= 1;
   1586c:	0076      	lsls	r6, r6, #1
   1586e:	e7eb      	b.n	15848 <check_level_trigger_pins+0x34>

00015870 <cfg_level_pins>:
{
   15870:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return port->config->config_info;
   15874:	6803      	ldr	r3, [r0, #0]
	const struct gpio_nrfx_data *data = get_port_data(port);
   15876:	6885      	ldr	r5, [r0, #8]
	return port->config->config_info;
   15878:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
   1587a:	e9d5 3402 	ldrd	r3, r4, [r5, #8]
   1587e:	401c      	ands	r4, r3
	out &= ~data->trig_edge & ~data->double_edge;
   15880:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
   15884:	4313      	orrs	r3, r2
   15886:	ea24 0403 	bic.w	r4, r4, r3
	u32_t bit = 1U << pin;
   1588a:	f04f 0801 	mov.w	r8, #1
	u32_t pin = 0U;
   1588e:	2700      	movs	r7, #0
	while (level_pins) {
   15890:	b90c      	cbnz	r4, 15896 <cfg_level_pins+0x26>
}
   15892:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   15896:	ea18 0f04 	tst.w	r8, r4
   1589a:	d012      	beq.n	158c2 <cfg_level_pins+0x52>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   1589c:	692b      	ldr	r3, [r5, #16]
   1589e:	69ea      	ldr	r2, [r5, #28]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   158a0:	f896 c004 	ldrb.w	ip, [r6, #4]
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   158a4:	4053      	eors	r3, r2
   158a6:	40fb      	lsrs	r3, r7
		return NRF_GPIO_PIN_SENSE_HIGH;
   158a8:	f013 0f01 	tst.w	r3, #1
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   158ac:	f007 001f 	and.w	r0, r7, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   158b0:	bf0c      	ite	eq
   158b2:	2103      	moveq	r1, #3
   158b4:	2102      	movne	r1, #2
   158b6:	ea40 104c 	orr.w	r0, r0, ip, lsl #5
   158ba:	f7f8 faf1 	bl	dea0 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   158be:	ea24 0408 	bic.w	r4, r4, r8
		++pin;
   158c2:	3701      	adds	r7, #1
		bit <<= 1;
   158c4:	ea4f 0848 	mov.w	r8, r8, lsl #1
   158c8:	e7e2      	b.n	15890 <cfg_level_pins+0x20>

000158ca <gpio_nrfx_pin_disable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   158ca:	2901      	cmp	r1, #1
{
   158cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   158d0:	bf18      	it	ne
   158d2:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
   158d4:	6887      	ldr	r7, [r0, #8]
{
   158d6:	4606      	mov	r6, r0
		to_pin   = pin;
   158d8:	bf12      	itee	ne
   158da:	4625      	movne	r5, r4
		to_pin   = 31U;
   158dc:	251f      	moveq	r5, #31
		from_pin = 0U;
   158de:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   158e0:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   158e4:	42ac      	cmp	r4, r5
   158e6:	d902      	bls.n	158ee <gpio_nrfx_pin_disable_callback+0x24>
	return res;
   158e8:	2000      	movs	r0, #0
}
   158ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   158ee:	68fb      	ldr	r3, [r7, #12]
   158f0:	fa08 f204 	lsl.w	r2, r8, r4
   158f4:	ea23 0302 	bic.w	r3, r3, r2
   158f8:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   158fa:	4621      	mov	r1, r4
   158fc:	4630      	mov	r0, r6
   158fe:	f7f8 fb05 	bl	df0c <gpiote_pin_int_cfg>
		if (res != 0) {
   15902:	2800      	cmp	r0, #0
   15904:	d1f1      	bne.n	158ea <gpio_nrfx_pin_disable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   15906:	3401      	adds	r4, #1
   15908:	b2e4      	uxtb	r4, r4
   1590a:	e7eb      	b.n	158e4 <gpio_nrfx_pin_disable_callback+0x1a>

0001590c <gpio_nrfx_pin_enable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   1590c:	2901      	cmp	r1, #1
{
   1590e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   15912:	bf18      	it	ne
   15914:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
   15916:	6887      	ldr	r7, [r0, #8]
{
   15918:	4606      	mov	r6, r0
		to_pin   = pin;
   1591a:	bf12      	itee	ne
   1591c:	4625      	movne	r5, r4
		to_pin   = 31U;
   1591e:	251f      	moveq	r5, #31
		from_pin = 0U;
   15920:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   15922:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   15926:	42ac      	cmp	r4, r5
   15928:	d902      	bls.n	15930 <gpio_nrfx_pin_enable_callback+0x24>
	return res;
   1592a:	2000      	movs	r0, #0
}
   1592c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   15930:	68fb      	ldr	r3, [r7, #12]
   15932:	fa08 f204 	lsl.w	r2, r8, r4
   15936:	4313      	orrs	r3, r2
   15938:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   1593a:	4621      	mov	r1, r4
   1593c:	4630      	mov	r0, r6
   1593e:	f7f8 fae5 	bl	df0c <gpiote_pin_int_cfg>
		if (res != 0) {
   15942:	2800      	cmp	r0, #0
   15944:	d1f2      	bne.n	1592c <gpio_nrfx_pin_enable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   15946:	3401      	adds	r4, #1
   15948:	b2e4      	uxtb	r4, r4
   1594a:	e7ec      	b.n	15926 <gpio_nrfx_pin_enable_callback+0x1a>

0001594c <uart_nrfx_config_get>:
	*cfg = get_dev_data(dev)->uart_config;
   1594c:	6882      	ldr	r2, [r0, #8]
{
   1594e:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   15950:	e892 0003 	ldmia.w	r2, {r0, r1}
   15954:	e883 0003 	stmia.w	r3, {r0, r1}
}
   15958:	2000      	movs	r0, #0
   1595a:	4770      	bx	lr

0001595c <uart_nrfx_irq_tx_ready_complete>:
{
   1595c:	b508      	push	{r3, lr}
	return event_txdrdy_check();
   1595e:	f7f8 fc77 	bl	e250 <event_txdrdy_check>
}
   15962:	bd08      	pop	{r3, pc}

00015964 <uart_nrfx_irq_update>:
}
   15964:	2001      	movs	r0, #1
   15966:	4770      	bx	lr

00015968 <device_busy_set>:
	atomic_set_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
   15968:	4770      	bx	lr

0001596a <device_busy_clear>:
   1596a:	4770      	bx	lr

0001596c <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   1596c:	f7fd bb50 	b.w	13010 <z_clock_idle_exit>

00015970 <k_mem_slab_init>:
{
   15970:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   15972:	2400      	movs	r4, #0
	slab->block_size = block_size;
   15974:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->free_list = NULL;
   15978:	e9c0 4405 	strd	r4, r4, [r0, #20]
	slab->buffer = buffer;
   1597c:	6101      	str	r1, [r0, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
   1597e:	42a3      	cmp	r3, r4
   15980:	d102      	bne.n	15988 <k_mem_slab_init+0x18>
	list->tail = (sys_dnode_t *)list;
   15982:	e9c0 0000 	strd	r0, r0, [r0]
}
   15986:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   15988:	6945      	ldr	r5, [r0, #20]
   1598a:	600d      	str	r5, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
   1598c:	3401      	adds	r4, #1
		slab->free_list = p;
   1598e:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   15990:	4411      	add	r1, r2
   15992:	e7f4      	b.n	1597e <k_mem_slab_init+0xe>

00015994 <k_mem_pool_free>:
	k_mem_pool_free_id(&block->id);
   15994:	3004      	adds	r0, #4
   15996:	f7f9 ba2d 	b.w	edf4 <k_mem_pool_free_id>

0001599a <k_mem_pool_malloc>:
{
   1599a:	b507      	push	{r0, r1, r2, lr}
	if (__builtin_add_overflow(size, sizeof(struct k_mem_block_id),
   1599c:	2204      	movs	r2, #4
   1599e:	188a      	adds	r2, r1, r2
   159a0:	d204      	bcs.n	159ac <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   159a2:	2300      	movs	r3, #0
   159a4:	4669      	mov	r1, sp
   159a6:	f7f9 f9c1 	bl	ed2c <k_mem_pool_alloc>
   159aa:	b118      	cbz	r0, 159b4 <k_mem_pool_malloc+0x1a>
		return NULL;
   159ac:	2000      	movs	r0, #0
}
   159ae:	b003      	add	sp, #12
   159b0:	f85d fb04 	ldr.w	pc, [sp], #4
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   159b4:	e9dd 3200 	ldrd	r3, r2, [sp]
   159b8:	601a      	str	r2, [r3, #0]
	return (char *)block.data + sizeof(struct k_mem_block_id);
   159ba:	9800      	ldr	r0, [sp, #0]
   159bc:	3004      	adds	r0, #4
   159be:	e7f6      	b.n	159ae <k_mem_pool_malloc+0x14>

000159c0 <k_free>:
	if (ptr != NULL) {
   159c0:	b110      	cbz	r0, 159c8 <k_free+0x8>
		k_mem_pool_free_id(ptr);
   159c2:	3804      	subs	r0, #4
   159c4:	f7f9 ba16 	b.w	edf4 <k_mem_pool_free_id>
}
   159c8:	4770      	bx	lr

000159ca <k_calloc>:
{
   159ca:	b570      	push	{r4, r5, r6, lr}
	if (__builtin_mul_overflow(nmemb, size, &bounds)) {
   159cc:	fba0 4501 	umull	r4, r5, r0, r1
   159d0:	b935      	cbnz	r5, 159e0 <k_calloc+0x16>
	ret = k_malloc(bounds);
   159d2:	4620      	mov	r0, r4
   159d4:	f7f9 fa3a 	bl	ee4c <k_malloc>
	if (ret != NULL) {
   159d8:	4606      	mov	r6, r0
   159da:	b918      	cbnz	r0, 159e4 <k_calloc+0x1a>
}
   159dc:	4630      	mov	r0, r6
   159de:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
   159e0:	2600      	movs	r6, #0
   159e2:	e7fb      	b.n	159dc <k_calloc+0x12>
__ssp_bos_icheck3(memset, void *, int)
   159e4:	4622      	mov	r2, r4
   159e6:	4629      	mov	r1, r5
   159e8:	f7ec fbff 	bl	21ea <memset>
   159ec:	e7f6      	b.n	159dc <k_calloc+0x12>

000159ee <z_impl_k_mutex_init>:
	mutex->owner = NULL;
   159ee:	2300      	movs	r3, #0
	mutex->lock_count = 0U;
   159f0:	e9c0 3302 	strd	r3, r3, [r0, #8]
   159f4:	e9c0 0000 	strd	r0, r0, [r0]
}
   159f8:	4770      	bx	lr

000159fa <queue_insert>:
			       struct k_queue *);
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   159fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   159fe:	4604      	mov	r4, r0
   15a00:	460f      	mov	r7, r1
   15a02:	4690      	mov	r8, r2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   15a04:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   15a08:	f04f 0220 	mov.w	r2, #32
   15a0c:	f3ef 8611 	mrs	r6, BASEPRI
   15a10:	f382 8811 	msr	BASEPRI, r2
   15a14:	f3bf 8f6f 	isb	sy
		return 0;
	}
#endif /* !CONFIG_POLL */

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   15a18:	b1db      	cbz	r3, 15a52 <queue_insert+0x58>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
   15a1a:	2008      	movs	r0, #8
   15a1c:	f7f9 fa1c 	bl	ee58 <z_thread_malloc>
		if (anode == NULL) {
   15a20:	b938      	cbnz	r0, 15a32 <queue_insert+0x38>
	__asm__ volatile(
   15a22:	f386 8811 	msr	BASEPRI, r6
   15a26:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   15a2a:	f06f 000b 	mvn.w	r0, #11
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	z_reschedule(&queue->lock, key);
	return 0;
}
   15a2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	node->next_and_flags = flags;
   15a32:	2301      	movs	r3, #1
		anode->data = data;
   15a34:	f8c0 8004 	str.w	r8, [r0, #4]
   15a38:	6003      	str	r3, [r0, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   15a3a:	6803      	ldr	r3, [r0, #0]
   15a3c:	f003 0203 	and.w	r2, r3, #3
   15a40:	b95f      	cbnz	r7, 15a5a <queue_insert+0x60>
	parent->next_and_flags = cur_flags | (unative_t)child;
   15a42:	6823      	ldr	r3, [r4, #0]
   15a44:	4313      	orrs	r3, r2
   15a46:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   15a48:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   15a4a:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   15a4c:	b973      	cbnz	r3, 15a6c <queue_insert+0x72>
	list->tail = node;
   15a4e:	6060      	str	r0, [r4, #4]
   15a50:	e00c      	b.n	15a6c <queue_insert+0x72>
	node->next_and_flags = flags;
   15a52:	f8c8 3000 	str.w	r3, [r8]
   15a56:	4640      	mov	r0, r8
   15a58:	e7ef      	b.n	15a3a <queue_insert+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   15a5a:	683b      	ldr	r3, [r7, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   15a5c:	f033 0303 	bics.w	r3, r3, #3
   15a60:	d114      	bne.n	15a8c <queue_insert+0x92>
	parent->next_and_flags = cur_flags | (unative_t)child;
   15a62:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   15a64:	6862      	ldr	r2, [r4, #4]
   15a66:	b95a      	cbnz	r2, 15a80 <queue_insert+0x86>
	list->head = node;
   15a68:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   15a6c:	2104      	movs	r1, #4
   15a6e:	4628      	mov	r0, r5
   15a70:	f000 fb26 	bl	160c0 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   15a74:	4628      	mov	r0, r5
   15a76:	4631      	mov	r1, r6
   15a78:	f000 f8d3 	bl	15c22 <z_reschedule>
	return 0;
   15a7c:	2000      	movs	r0, #0
   15a7e:	e7d6      	b.n	15a2e <queue_insert+0x34>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   15a80:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   15a82:	f003 0303 	and.w	r3, r3, #3
   15a86:	4303      	orrs	r3, r0
   15a88:	6013      	str	r3, [r2, #0]
   15a8a:	e7e0      	b.n	15a4e <queue_insert+0x54>
   15a8c:	4313      	orrs	r3, r2
   15a8e:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   15a90:	683b      	ldr	r3, [r7, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   15a92:	f003 0303 	and.w	r3, r3, #3
   15a96:	4318      	orrs	r0, r3
   15a98:	6038      	str	r0, [r7, #0]
   15a9a:	e7e7      	b.n	15a6c <queue_insert+0x72>

00015a9c <z_queue_node_peek>:
{
   15a9c:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   15a9e:	4604      	mov	r4, r0
   15aa0:	b130      	cbz	r0, 15ab0 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   15aa2:	6802      	ldr	r2, [r0, #0]
   15aa4:	0793      	lsls	r3, r2, #30
   15aa6:	d003      	beq.n	15ab0 <z_queue_node_peek+0x14>
		ret = anode->data;
   15aa8:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   15aaa:	b109      	cbz	r1, 15ab0 <z_queue_node_peek+0x14>
			k_free(anode);
   15aac:	f7ff ff88 	bl	159c0 <k_free>
}
   15ab0:	4620      	mov	r0, r4
   15ab2:	bd10      	pop	{r4, pc}

00015ab4 <z_impl_k_queue_init>:
	list->head = NULL;
   15ab4:	2300      	movs	r3, #0
	list->tail = NULL;
   15ab6:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dlist_init(&queue->poll_events);
   15aba:	f100 0308 	add.w	r3, r0, #8
   15abe:	e9c0 3302 	strd	r3, r3, [r0, #8]
}
   15ac2:	4770      	bx	lr

00015ac4 <z_impl_k_queue_cancel_wait>:
{
   15ac4:	b538      	push	{r3, r4, r5, lr}
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   15ac6:	f100 0408 	add.w	r4, r0, #8
	__asm__ volatile(
   15aca:	f04f 0320 	mov.w	r3, #32
   15ace:	f3ef 8511 	mrs	r5, BASEPRI
   15ad2:	f383 8811 	msr	BASEPRI, r3
   15ad6:	f3bf 8f6f 	isb	sy
	z_handle_obj_poll_events(&queue->poll_events, state);
   15ada:	2108      	movs	r1, #8
   15adc:	4620      	mov	r0, r4
   15ade:	f000 faef 	bl	160c0 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   15ae2:	4629      	mov	r1, r5
   15ae4:	4620      	mov	r0, r4
}
   15ae6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&queue->lock, key);
   15aea:	f000 b89a 	b.w	15c22 <z_reschedule>

00015aee <k_queue_append>:
	(void)queue_insert(queue, prev, data, false);
}

void k_queue_append(struct k_queue *queue, void *data)
{
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   15aee:	460a      	mov	r2, r1
   15af0:	2300      	movs	r3, #0
   15af2:	6841      	ldr	r1, [r0, #4]
   15af4:	f7ff bf81 	b.w	159fa <queue_insert>

00015af8 <k_queue_prepend>:
			   data, false);
}

void k_queue_prepend(struct k_queue *queue, void *data)
{
	(void)queue_insert(queue, NULL, data, false);
   15af8:	2300      	movs	r3, #0
   15afa:	460a      	mov	r2, r1
   15afc:	4619      	mov	r1, r3
   15afe:	f7ff bf7c 	b.w	159fa <queue_insert>

00015b02 <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, s32_t timeout)
{
   15b02:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15b06:	4604      	mov	r4, r0
   15b08:	b086      	sub	sp, #24
   15b0a:	460d      	mov	r5, r1
   15b0c:	f04f 0320 	mov.w	r3, #32
   15b10:	f3ef 8711 	mrs	r7, BASEPRI
   15b14:	f383 8811 	msr	BASEPRI, r3
   15b18:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(sflist)
   15b1c:	6800      	ldr	r0, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   15b1e:	b188      	cbz	r0, 15b44 <z_impl_k_queue_get+0x42>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   15b20:	6803      	ldr	r3, [r0, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   15b22:	6862      	ldr	r2, [r4, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   15b24:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   15b28:	4290      	cmp	r0, r2
	list->head = node;
   15b2a:	6023      	str	r3, [r4, #0]
	list->tail = node;
   15b2c:	bf08      	it	eq
   15b2e:	6063      	streq	r3, [r4, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   15b30:	2101      	movs	r1, #1
   15b32:	f7ff ffb3 	bl	15a9c <z_queue_node_peek>
	__asm__ volatile(
   15b36:	f387 8811 	msr	BASEPRI, r7
   15b3a:	f3bf 8f6f 	isb	sy
#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
   15b3e:	b006      	add	sp, #24
   15b40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (timeout == K_NO_WAIT) {
   15b44:	2900      	cmp	r1, #0
   15b46:	d0f6      	beq.n	15b36 <z_impl_k_queue_get+0x34>
   15b48:	f387 8811 	msr	BASEPRI, r7
   15b4c:	f3bf 8f6f 	isb	sy
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
   15b50:	2104      	movs	r1, #4
   15b52:	4602      	mov	r2, r0
   15b54:	4623      	mov	r3, r4
   15b56:	eb0d 0001 	add.w	r0, sp, r1
   15b5a:	f7fa f849 	bl	fbf0 <k_poll_event_init>
	if (timeout != K_FOREVER) {
   15b5e:	1c6a      	adds	r2, r5, #1
   15b60:	d002      	beq.n	15b68 <z_impl_k_queue_get+0x66>
   15b62:	f000 fa19 	bl	15f98 <z_impl_k_uptime_get>
   15b66:	4606      	mov	r6, r0
{
   15b68:	2700      	movs	r7, #0
		event.state = K_POLL_STATE_NOT_READY;
   15b6a:	9b04      	ldr	r3, [sp, #16]
K_SYSCALL_DECLARE3(K_SYSCALL_K_POLL, k_poll, int, struct k_poll_event *, events, int, num_events, s32_t, timeout)
   15b6c:	1bea      	subs	r2, r5, r7
   15b6e:	f36f 3310 	bfc	r3, #12, #5
   15b72:	2101      	movs	r1, #1
   15b74:	a801      	add	r0, sp, #4
   15b76:	9304      	str	r3, [sp, #16]
   15b78:	f7fa f84e 	bl	fc18 <z_impl_k_poll>
		if (err && err != -EAGAIN) {
   15b7c:	b118      	cbz	r0, 15b86 <z_impl_k_queue_get+0x84>
   15b7e:	300b      	adds	r0, #11
   15b80:	d001      	beq.n	15b86 <z_impl_k_queue_get+0x84>
			return NULL;
   15b82:	2000      	movs	r0, #0
   15b84:	e7db      	b.n	15b3e <z_impl_k_queue_get+0x3c>
	__asm__ volatile(
   15b86:	f04f 0320 	mov.w	r3, #32
   15b8a:	f3ef 8811 	mrs	r8, BASEPRI
   15b8e:	f383 8811 	msr	BASEPRI, r3
   15b92:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(sflist)
   15b96:	6820      	ldr	r0, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);

Z_GENLIST_GET(sflist, sfnode)
   15b98:	b138      	cbz	r0, 15baa <z_impl_k_queue_get+0xa8>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   15b9a:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   15b9c:	6862      	ldr	r2, [r4, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   15b9e:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   15ba2:	4290      	cmp	r0, r2
	list->head = node;
   15ba4:	6023      	str	r3, [r4, #0]
	list->tail = node;
   15ba6:	bf08      	it	eq
   15ba8:	6063      	streq	r3, [r4, #4]
		val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   15baa:	2101      	movs	r1, #1
   15bac:	f7ff ff76 	bl	15a9c <z_queue_node_peek>
	__asm__ volatile(
   15bb0:	f388 8811 	msr	BASEPRI, r8
   15bb4:	f3bf 8f6f 	isb	sy
		if ((val == NULL) && (timeout != K_FOREVER)) {
   15bb8:	2800      	cmp	r0, #0
   15bba:	d1c0      	bne.n	15b3e <z_impl_k_queue_get+0x3c>
   15bbc:	1c6b      	adds	r3, r5, #1
   15bbe:	d0d4      	beq.n	15b6a <z_impl_k_queue_get+0x68>
K_SYSCALL_DECLARE0_RET64(K_SYSCALL_K_UPTIME_GET, k_uptime_get, s64_t)
   15bc0:	f000 f9ea 	bl	15f98 <z_impl_k_uptime_get>
			elapsed = k_uptime_get_32() - start;
   15bc4:	1b87      	subs	r7, r0, r6
	} while (!val && !done);
   15bc6:	42bd      	cmp	r5, r7
   15bc8:	dacf      	bge.n	15b6a <z_impl_k_queue_get+0x68>
   15bca:	e7da      	b.n	15b82 <z_impl_k_queue_get+0x80>

00015bcc <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   15bcc:	7b43      	ldrb	r3, [r0, #13]
   15bce:	06db      	lsls	r3, r3, #27
   15bd0:	bf03      	ittte	eq
   15bd2:	6980      	ldreq	r0, [r0, #24]
   15bd4:	fab0 f080 	clzeq	r0, r0
   15bd8:	0940      	lsreq	r0, r0, #5
   15bda:	2000      	movne	r0, #0
}
   15bdc:	4770      	bx	lr

00015bde <z_is_t1_higher_prio_than_t2>:
	if (t1->base.prio < t2->base.prio) {
   15bde:	f990 000e 	ldrsb.w	r0, [r0, #14]
   15be2:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   15be6:	4298      	cmp	r0, r3
   15be8:	bfac      	ite	ge
   15bea:	2000      	movge	r0, #0
   15bec:	2001      	movlt	r0, #1
   15bee:	4770      	bx	lr

00015bf0 <z_unpend_thread_no_timeout>:
{
   15bf0:	b538      	push	{r3, r4, r5, lr}
   15bf2:	4604      	mov	r4, r0
	__asm__ volatile(
   15bf4:	f04f 0320 	mov.w	r3, #32
   15bf8:	f3ef 8511 	mrs	r5, BASEPRI
   15bfc:	f383 8811 	msr	BASEPRI, r3
   15c00:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   15c04:	4601      	mov	r1, r0
   15c06:	6880      	ldr	r0, [r0, #8]
   15c08:	f7f9 fa46 	bl	f098 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   15c0c:	7b63      	ldrb	r3, [r4, #13]
   15c0e:	f023 0302 	bic.w	r3, r3, #2
   15c12:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   15c14:	f385 8811 	msr	BASEPRI, r5
   15c18:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   15c1c:	2300      	movs	r3, #0
   15c1e:	60a3      	str	r3, [r4, #8]
}
   15c20:	bd38      	pop	{r3, r4, r5, pc}

00015c22 <z_reschedule>:
{
   15c22:	b508      	push	{r3, lr}
	if (resched()) {
   15c24:	f7f9 f9d2 	bl	efcc <resched>
   15c28:	b120      	cbz	r0, 15c34 <z_reschedule+0x12>
   15c2a:	4608      	mov	r0, r1
}
   15c2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   15c30:	f7f3 bf04 	b.w	9a3c <__swap>
   15c34:	f381 8811 	msr	BASEPRI, r1
   15c38:	f3bf 8f6f 	isb	sy
   15c3c:	bd08      	pop	{r3, pc}

00015c3e <z_reschedule_irqlock>:
{
   15c3e:	b508      	push	{r3, lr}
   15c40:	4602      	mov	r2, r0
	if (resched()) {
   15c42:	f7f9 f9c3 	bl	efcc <resched>
   15c46:	b120      	cbz	r0, 15c52 <z_reschedule_irqlock+0x14>
   15c48:	4610      	mov	r0, r2
}
   15c4a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   15c4e:	f7f3 bef5 	b.w	9a3c <__swap>
   15c52:	f382 8811 	msr	BASEPRI, r2
   15c56:	f3bf 8f6f 	isb	sy
   15c5a:	bd08      	pop	{r3, pc}

00015c5c <z_reschedule_unlocked>:
	__asm__ volatile(
   15c5c:	f04f 0320 	mov.w	r3, #32
   15c60:	f3ef 8011 	mrs	r0, BASEPRI
   15c64:	f383 8811 	msr	BASEPRI, r3
   15c68:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(z_arch_irq_lock());
   15c6c:	f7ff bfe7 	b.w	15c3e <z_reschedule_irqlock>

00015c70 <z_unpend_thread>:
{
   15c70:	b538      	push	{r3, r4, r5, lr}
   15c72:	4604      	mov	r4, r0
   15c74:	f04f 0320 	mov.w	r3, #32
   15c78:	f3ef 8511 	mrs	r5, BASEPRI
   15c7c:	f383 8811 	msr	BASEPRI, r3
   15c80:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   15c84:	4601      	mov	r1, r0
   15c86:	6880      	ldr	r0, [r0, #8]
   15c88:	f7f9 fa06 	bl	f098 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   15c8c:	7b63      	ldrb	r3, [r4, #13]
   15c8e:	f023 0302 	bic.w	r3, r3, #2
   15c92:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   15c94:	f385 8811 	msr	BASEPRI, r5
   15c98:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   15c9c:	2300      	movs	r3, #0
   15c9e:	60a3      	str	r3, [r4, #8]
	return z_abort_timeout(&thread->base.timeout);
   15ca0:	f104 0018 	add.w	r0, r4, #24
}
   15ca4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   15ca8:	f000 b932 	b.w	15f10 <z_abort_timeout>

00015cac <z_priq_dumb_best>:
	return list->head == list;
   15cac:	6803      	ldr	r3, [r0, #0]
}
   15cae:	4298      	cmp	r0, r3
   15cb0:	bf14      	ite	ne
   15cb2:	4618      	movne	r0, r3
   15cb4:	2000      	moveq	r0, #0
   15cb6:	4770      	bx	lr

00015cb8 <z_thread_timeout>:
	if (th->base.pended_on != NULL) {
   15cb8:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   15cbc:	b570      	push	{r4, r5, r6, lr}
   15cbe:	4604      	mov	r4, r0
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
   15cc0:	f1a0 0518 	sub.w	r5, r0, #24
	if (th->base.pended_on != NULL) {
   15cc4:	b1cb      	cbz	r3, 15cfa <z_thread_timeout+0x42>
	__asm__ volatile(
   15cc6:	f04f 0320 	mov.w	r3, #32
   15cca:	f3ef 8611 	mrs	r6, BASEPRI
   15cce:	f383 8811 	msr	BASEPRI, r3
   15cd2:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   15cd6:	4629      	mov	r1, r5
   15cd8:	f850 0c10 	ldr.w	r0, [r0, #-16]
   15cdc:	f7f9 f9dc 	bl	f098 <z_priq_dumb_remove>
   15ce0:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   15ce4:	f023 0302 	bic.w	r3, r3, #2
   15ce8:	f804 3c0b 	strb.w	r3, [r4, #-11]
	__asm__ volatile(
   15cec:	f386 8811 	msr	BASEPRI, r6
   15cf0:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   15cf4:	2300      	movs	r3, #0
   15cf6:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   15cfa:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   15cfe:	f023 0314 	bic.w	r3, r3, #20
   15d02:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   15d06:	4628      	mov	r0, r5
   15d08:	f7ff ff60 	bl	15bcc <z_is_thread_ready>
   15d0c:	b120      	cbz	r0, 15d18 <z_thread_timeout+0x60>
		z_add_thread_to_ready_q(thread);
   15d0e:	4628      	mov	r0, r5
}
   15d10:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   15d14:	f7f9 ba10 	b.w	f138 <z_add_thread_to_ready_q>
   15d18:	bd70      	pop	{r4, r5, r6, pc}

00015d1a <z_unpend_first_thread>:
{
   15d1a:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   15d1c:	f04f 0320 	mov.w	r3, #32
   15d20:	f3ef 8211 	mrs	r2, BASEPRI
   15d24:	f383 8811 	msr	BASEPRI, r3
   15d28:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   15d2c:	f7ff ffbe 	bl	15cac <z_priq_dumb_best>
   15d30:	4604      	mov	r4, r0
	__asm__ volatile(
   15d32:	f382 8811 	msr	BASEPRI, r2
   15d36:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   15d3a:	b1c8      	cbz	r0, 15d70 <z_unpend_first_thread+0x56>
	__asm__ volatile(
   15d3c:	f04f 0320 	mov.w	r3, #32
   15d40:	f3ef 8511 	mrs	r5, BASEPRI
   15d44:	f383 8811 	msr	BASEPRI, r3
   15d48:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   15d4c:	4601      	mov	r1, r0
   15d4e:	6880      	ldr	r0, [r0, #8]
   15d50:	f7f9 f9a2 	bl	f098 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   15d54:	7b63      	ldrb	r3, [r4, #13]
   15d56:	f023 0302 	bic.w	r3, r3, #2
   15d5a:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   15d5c:	f385 8811 	msr	BASEPRI, r5
   15d60:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   15d64:	2300      	movs	r3, #0
   15d66:	60a3      	str	r3, [r4, #8]
   15d68:	f104 0018 	add.w	r0, r4, #24
   15d6c:	f000 f8d0 	bl	15f10 <z_abort_timeout>
}
   15d70:	4620      	mov	r0, r4
   15d72:	bd38      	pop	{r3, r4, r5, pc}

00015d74 <z_unpend_all>:
{
   15d74:	b570      	push	{r4, r5, r6, lr}
   15d76:	4606      	mov	r6, r0
	int need_sched = 0;
   15d78:	2500      	movs	r5, #0
   15d7a:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   15d7c:	42a6      	cmp	r6, r4
   15d7e:	d000      	beq.n	15d82 <z_unpend_all+0xe>
	while ((th = z_waitq_head(wait_q)) != NULL) {
   15d80:	b90c      	cbnz	r4, 15d86 <z_unpend_all+0x12>
}
   15d82:	4628      	mov	r0, r5
   15d84:	bd70      	pop	{r4, r5, r6, pc}
		z_unpend_thread(th);
   15d86:	4620      	mov	r0, r4
   15d88:	f7ff ff72 	bl	15c70 <z_unpend_thread>
	if (z_is_thread_ready(thread)) {
   15d8c:	4620      	mov	r0, r4
   15d8e:	f7ff ff1d 	bl	15bcc <z_is_thread_ready>
		need_sched = 1;
   15d92:	2501      	movs	r5, #1
   15d94:	2800      	cmp	r0, #0
   15d96:	d0f0      	beq.n	15d7a <z_unpend_all+0x6>
		z_add_thread_to_ready_q(thread);
   15d98:	4620      	mov	r0, r4
   15d9a:	f7f9 f9cd 	bl	f138 <z_add_thread_to_ready_q>
   15d9e:	e7ec      	b.n	15d7a <z_unpend_all+0x6>

00015da0 <z_impl_k_sem_init>:
	sys_dlist_init(&sem->poll_events);
   15da0:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   15da4:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   15da8:	e9c0 0000 	strd	r0, r0, [r0]
   15dac:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
   15db0:	4770      	bx	lr

00015db2 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   15db2:	7b43      	ldrb	r3, [r0, #13]
   15db4:	06db      	lsls	r3, r3, #27
   15db6:	bf03      	ittte	eq
   15db8:	6980      	ldreq	r0, [r0, #24]
   15dba:	fab0 f080 	clzeq	r0, r0
   15dbe:	0940      	lsreq	r0, r0, #5
   15dc0:	2000      	movne	r0, #0
}
   15dc2:	4770      	bx	lr

00015dc4 <z_impl_k_thread_name_set>:
}
   15dc4:	f06f 0057 	mvn.w	r0, #87	; 0x57
   15dc8:	4770      	bx	lr

00015dca <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   15dca:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   15dcc:	b510      	push	{r4, lr}
   15dce:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   15dd0:	b103      	cbz	r3, 15dd4 <z_thread_single_abort+0xa>
		thread->fn_abort();
   15dd2:	4798      	blx	r3
	if (z_is_thread_ready(thread)) {
   15dd4:	4620      	mov	r0, r4
   15dd6:	f7ff ffec 	bl	15db2 <z_is_thread_ready>
   15dda:	b138      	cbz	r0, 15dec <z_thread_single_abort+0x22>
		z_remove_thread_from_ready_q(thread);
   15ddc:	4620      	mov	r0, r4
   15dde:	f7f9 fa59 	bl	f294 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_DEAD;
   15de2:	7b63      	ldrb	r3, [r4, #13]
   15de4:	f043 0308 	orr.w	r3, r3, #8
   15de8:	7363      	strb	r3, [r4, #13]
}
   15dea:	bd10      	pop	{r4, pc}
		if (z_is_thread_pending(thread)) {
   15dec:	7b63      	ldrb	r3, [r4, #13]
   15dee:	079b      	lsls	r3, r3, #30
   15df0:	d502      	bpl.n	15df8 <z_thread_single_abort+0x2e>
			z_unpend_thread_no_timeout(thread);
   15df2:	4620      	mov	r0, r4
   15df4:	f7ff fefc 	bl	15bf0 <z_unpend_thread_no_timeout>
		if (z_is_thread_timeout_active(thread)) {
   15df8:	69a3      	ldr	r3, [r4, #24]
   15dfa:	2b00      	cmp	r3, #0
   15dfc:	d0f1      	beq.n	15de2 <z_thread_single_abort+0x18>
   15dfe:	f104 0018 	add.w	r0, r4, #24
   15e02:	f000 f885 	bl	15f10 <z_abort_timeout>
   15e06:	e7ec      	b.n	15de2 <z_thread_single_abort+0x18>

00015e08 <z_init_thread_base>:
	thread_base->user_options = (u8_t)options;
   15e08:	7303      	strb	r3, [r0, #12]
	thread_base->sched_locked = 0U;
   15e0a:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
   15e0c:	7342      	strb	r2, [r0, #13]
	thread_base->prio = priority;
   15e0e:	7381      	strb	r1, [r0, #14]
	thread_base->sched_locked = 0U;
   15e10:	73c3      	strb	r3, [r0, #15]
	node->prev = NULL;
   15e12:	e9c0 3306 	strd	r3, r3, [r0, #24]
}
   15e16:	4770      	bx	lr

00015e18 <k_work_submit_to_queue>:
{
   15e18:	b500      	push	{lr}
   15e1a:	f101 0308 	add.w	r3, r1, #8
   15e1e:	f3bf 8f5b 	dmb	ish
   15e22:	e853 2f00 	ldrex	r2, [r3]
   15e26:	f042 0c01 	orr.w	ip, r2, #1
   15e2a:	e843 ce00 	strex	lr, ip, [r3]
   15e2e:	f1be 0f00 	cmp.w	lr, #0
   15e32:	d1f6      	bne.n	15e22 <k_work_submit_to_queue+0xa>
   15e34:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   15e38:	07d3      	lsls	r3, r2, #31
   15e3a:	d403      	bmi.n	15e44 <k_work_submit_to_queue+0x2c>
}
   15e3c:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   15e40:	f7ff be55 	b.w	15aee <k_queue_append>
}
   15e44:	f85d fb04 	ldr.w	pc, [sp], #4

00015e48 <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
   15e48:	f1a0 010c 	sub.w	r1, r0, #12
   15e4c:	6900      	ldr	r0, [r0, #16]
   15e4e:	f7ff bfe3 	b.w	15e18 <k_work_submit_to_queue>

00015e52 <work_cancel>:
{
   15e52:	b570      	push	{r4, r5, r6, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   15e54:	f3bf 8f5b 	dmb	ish
   15e58:	6883      	ldr	r3, [r0, #8]
   15e5a:	f3bf 8f5b 	dmb	ish
	if (k_work_pending(&work->work)) {
   15e5e:	07db      	lsls	r3, r3, #31
{
   15e60:	4604      	mov	r4, r0
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   15e62:	f100 0508 	add.w	r5, r0, #8
	if (k_work_pending(&work->work)) {
   15e66:	d532      	bpl.n	15ece <work_cancel+0x7c>
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   15e68:	69c2      	ldr	r2, [r0, #28]
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   15e6a:	6813      	ldr	r3, [r2, #0]
   15e6c:	2100      	movs	r1, #0
   15e6e:	b913      	cbnz	r3, 15e76 <work_cancel+0x24>
			return -EINVAL;
   15e70:	f06f 0015 	mvn.w	r0, #21
}
   15e74:	bd70      	pop	{r4, r5, r6, pc}
   15e76:	429c      	cmp	r4, r3
   15e78:	d124      	bne.n	15ec4 <work_cancel+0x72>
Z_GENLIST_REMOVE(sflist, sfnode)
   15e7a:	6823      	ldr	r3, [r4, #0]
   15e7c:	6856      	ldr	r6, [r2, #4]
   15e7e:	f023 0003 	bic.w	r0, r3, #3
   15e82:	b9b1      	cbnz	r1, 15eb2 <work_cancel+0x60>
   15e84:	42b4      	cmp	r4, r6
	list->head = node;
   15e86:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   15e88:	d100      	bne.n	15e8c <work_cancel+0x3a>
	list->tail = node;
   15e8a:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   15e8c:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   15e8e:	f003 0303 	and.w	r3, r3, #3
   15e92:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
   15e94:	2000      	movs	r0, #0
   15e96:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   15e98:	f3bf 8f5b 	dmb	ish
   15e9c:	e855 3f00 	ldrex	r3, [r5]
   15ea0:	f023 0301 	bic.w	r3, r3, #1
   15ea4:	e845 3200 	strex	r2, r3, [r5]
   15ea8:	2a00      	cmp	r2, #0
   15eaa:	d1f7      	bne.n	15e9c <work_cancel+0x4a>
   15eac:	f3bf 8f5b 	dmb	ish
   15eb0:	e7e0      	b.n	15e74 <work_cancel+0x22>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   15eb2:	680b      	ldr	r3, [r1, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   15eb4:	f003 0303 	and.w	r3, r3, #3
   15eb8:	4303      	orrs	r3, r0
Z_GENLIST_REMOVE(sflist, sfnode)
   15eba:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
   15ebc:	600b      	str	r3, [r1, #0]
	list->tail = node;
   15ebe:	bf08      	it	eq
   15ec0:	6051      	streq	r1, [r2, #4]
   15ec2:	e7e3      	b.n	15e8c <work_cancel+0x3a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   15ec4:	6818      	ldr	r0, [r3, #0]
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   15ec6:	4619      	mov	r1, r3
   15ec8:	f020 0303 	bic.w	r3, r0, #3
   15ecc:	e7cf      	b.n	15e6e <work_cancel+0x1c>
		(void)z_abort_timeout(&work->timeout);
   15ece:	300c      	adds	r0, #12
   15ed0:	f000 f81e 	bl	15f10 <z_abort_timeout>
   15ed4:	e7de      	b.n	15e94 <work_cancel+0x42>

00015ed6 <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   15ed6:	2300      	movs	r3, #0
   15ed8:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
   15edc:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
   15ee0:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
   15ee2:	61c3      	str	r3, [r0, #28]
}
   15ee4:	4770      	bx	lr

00015ee6 <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
	if (!work->work_q) {
   15ee6:	69c3      	ldr	r3, [r0, #28]
{
   15ee8:	b510      	push	{r4, lr}
	if (!work->work_q) {
   15eea:	b173      	cbz	r3, 15f0a <k_delayed_work_cancel+0x24>
	__asm__ volatile(
   15eec:	f04f 0320 	mov.w	r3, #32
   15ef0:	f3ef 8411 	mrs	r4, BASEPRI
   15ef4:	f383 8811 	msr	BASEPRI, r3
   15ef8:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = work_cancel(work);
   15efc:	f7ff ffa9 	bl	15e52 <work_cancel>
	__asm__ volatile(
   15f00:	f384 8811 	msr	BASEPRI, r4
   15f04:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   15f08:	bd10      	pop	{r4, pc}
		return -EINVAL;
   15f0a:	f06f 0015 	mvn.w	r0, #21
   15f0e:	e7fb      	b.n	15f08 <k_delayed_work_cancel+0x22>

00015f10 <z_abort_timeout>:
{
   15f10:	b510      	push	{r4, lr}
	__asm__ volatile(
   15f12:	f04f 0220 	mov.w	r2, #32
   15f16:	f3ef 8411 	mrs	r4, BASEPRI
   15f1a:	f382 8811 	msr	BASEPRI, r2
   15f1e:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   15f22:	6803      	ldr	r3, [r0, #0]
   15f24:	b13b      	cbz	r3, 15f36 <z_abort_timeout+0x26>
			remove_timeout(to);
   15f26:	f7f9 fd47 	bl	f9b8 <remove_timeout>
			ret = 0;
   15f2a:	2000      	movs	r0, #0
	__asm__ volatile(
   15f2c:	f384 8811 	msr	BASEPRI, r4
   15f30:	f3bf 8f6f 	isb	sy
}
   15f34:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   15f36:	f06f 0015 	mvn.w	r0, #21
   15f3a:	e7f7      	b.n	15f2c <z_abort_timeout+0x1c>

00015f3c <z_get_next_timeout_expiry>:
{
   15f3c:	b510      	push	{r4, lr}
	__asm__ volatile(
   15f3e:	f04f 0320 	mov.w	r3, #32
   15f42:	f3ef 8411 	mrs	r4, BASEPRI
   15f46:	f383 8811 	msr	BASEPRI, r3
   15f4a:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   15f4e:	f7f9 fd47 	bl	f9e0 <next_timeout>
	__asm__ volatile(
   15f52:	f384 8811 	msr	BASEPRI, r4
   15f56:	f3bf 8f6f 	isb	sy
}
   15f5a:	bd10      	pop	{r4, pc}

00015f5c <z_set_timeout_expiry>:
{
   15f5c:	b570      	push	{r4, r5, r6, lr}
   15f5e:	4604      	mov	r4, r0
   15f60:	460e      	mov	r6, r1
	__asm__ volatile(
   15f62:	f04f 0320 	mov.w	r3, #32
   15f66:	f3ef 8511 	mrs	r5, BASEPRI
   15f6a:	f383 8811 	msr	BASEPRI, r3
   15f6e:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
   15f72:	f7f9 fd35 	bl	f9e0 <next_timeout>
		if (sooner && !imminent) {
   15f76:	42a0      	cmp	r0, r4
   15f78:	dd05      	ble.n	15f86 <z_set_timeout_expiry+0x2a>
   15f7a:	2801      	cmp	r0, #1
   15f7c:	dd03      	ble.n	15f86 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
   15f7e:	4631      	mov	r1, r6
   15f80:	4620      	mov	r0, r4
   15f82:	f7f3 fccd 	bl	9920 <z_clock_set_timeout>
	__asm__ volatile(
   15f86:	f385 8811 	msr	BASEPRI, r5
   15f8a:	f3bf 8f6f 	isb	sy
}
   15f8e:	bd70      	pop	{r4, r5, r6, pc}

00015f90 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   15f90:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   15f92:	f7f9 fe0f 	bl	fbb4 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   15f96:	bd08      	pop	{r3, pc}

00015f98 <z_impl_k_uptime_get>:

s64_t z_impl_k_uptime_get(void)
{
   15f98:	b538      	push	{r3, r4, r5, lr}
	return __ticks_to_ms(z_tick_get());
   15f9a:	f7f9 fe0b 	bl	fbb4 <z_tick_get>
   15f9e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   15fa2:	fba0 4503 	umull	r4, r5, r0, r3
   15fa6:	fb03 5501 	mla	r5, r3, r1, r5
   15faa:	2264      	movs	r2, #100	; 0x64
   15fac:	2300      	movs	r3, #0
   15fae:	4620      	mov	r0, r4
   15fb0:	4629      	mov	r1, r5
   15fb2:	f7ea fbc9 	bl	748 <__aeabi_uldivmod>
}
   15fb6:	bd38      	pop	{r3, r4, r5, pc}

00015fb8 <clear_event_registrations>:
	for (; last_registered >= 0; last_registered--) {
   15fb8:	2314      	movs	r3, #20
{
   15fba:	b570      	push	{r4, r5, r6, lr}
   15fbc:	fb03 0001 	mla	r0, r3, r1, r0
	event->poller = NULL;
   15fc0:	2400      	movs	r4, #0
   15fc2:	2601      	movs	r6, #1
	for (; last_registered >= 0; last_registered--) {
   15fc4:	2900      	cmp	r1, #0
   15fc6:	da00      	bge.n	15fca <clear_event_registrations+0x12>
}
   15fc8:	bd70      	pop	{r4, r5, r6, pc}
	switch (event->type) {
   15fca:	7b43      	ldrb	r3, [r0, #13]
	event->poller = NULL;
   15fcc:	6084      	str	r4, [r0, #8]
	switch (event->type) {
   15fce:	f003 030f 	and.w	r3, r3, #15
   15fd2:	2b04      	cmp	r3, #4
   15fd4:	d80b      	bhi.n	15fee <clear_event_registrations+0x36>
   15fd6:	fa06 f303 	lsl.w	r3, r6, r3
   15fda:	f013 0f16 	tst.w	r3, #22
   15fde:	d006      	beq.n	15fee <clear_event_registrations+0x36>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   15fe0:	6803      	ldr	r3, [r0, #0]
   15fe2:	b123      	cbz	r3, 15fee <clear_event_registrations+0x36>
	node->prev->next = node->next;
   15fe4:	6845      	ldr	r5, [r0, #4]
   15fe6:	602b      	str	r3, [r5, #0]
	node->next->prev = node->prev;
   15fe8:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
   15fea:	e9c0 4400 	strd	r4, r4, [r0]
   15fee:	f382 8811 	msr	BASEPRI, r2
   15ff2:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   15ff6:	f04f 0320 	mov.w	r3, #32
   15ffa:	f3ef 8211 	mrs	r2, BASEPRI
   15ffe:	f383 8811 	msr	BASEPRI, r3
   16002:	f3bf 8f6f 	isb	sy
	for (; last_registered >= 0; last_registered--) {
   16006:	3901      	subs	r1, #1
   16008:	3814      	subs	r0, #20
   1600a:	e7db      	b.n	15fc4 <clear_event_registrations+0xc>

0001600c <signal_poll_event>:
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, u32_t state)
{
	if (!event->poller) {
   1600c:	6883      	ldr	r3, [r0, #8]
{
   1600e:	b570      	push	{r4, r5, r6, lr}
   16010:	4605      	mov	r5, r0
   16012:	460e      	mov	r6, r1
	if (!event->poller) {
   16014:	b1cb      	cbz	r3, 1604a <signal_poll_event+0x3e>
	struct k_thread *thread = event->poller->thread;

	__ASSERT(event->poller->thread != NULL,
		 "poller should have a thread\n");

	event->poller->is_polling = false;
   16016:	2200      	movs	r2, #0
	struct k_thread *thread = event->poller->thread;
   16018:	681c      	ldr	r4, [r3, #0]
	event->poller->is_polling = false;
   1601a:	711a      	strb	r2, [r3, #4]

	if (!z_is_thread_pending(thread)) {
   1601c:	7b63      	ldrb	r3, [r4, #13]
   1601e:	079a      	lsls	r2, r3, #30
   16020:	d513      	bpl.n	1604a <signal_poll_event+0x3e>
		goto ready_event;
	}

	if (z_is_thread_timeout_expired(thread)) {
   16022:	6a23      	ldr	r3, [r4, #32]
   16024:	3302      	adds	r3, #2
   16026:	d01a      	beq.n	1605e <signal_poll_event+0x52>
		return -EAGAIN;
	}

	z_unpend_thread(thread);
   16028:	4620      	mov	r0, r4
   1602a:	f7ff fe21 	bl	15c70 <z_unpend_thread>
	z_set_thread_return_value(thread,
   1602e:	2e08      	cmp	r6, #8
   16030:	bf0c      	ite	eq
   16032:	f06f 0303 	mvneq.w	r3, #3
   16036:	2300      	movne	r3, #0
   16038:	66a3      	str	r3, [r4, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1603a:	7b63      	ldrb	r3, [r4, #13]
   1603c:	06db      	lsls	r3, r3, #27
   1603e:	d104      	bne.n	1604a <signal_poll_event+0x3e>
				 state == K_POLL_STATE_CANCELLED ? -EINTR : 0);

	if (!z_is_thread_ready(thread)) {
   16040:	69a3      	ldr	r3, [r4, #24]
   16042:	b913      	cbnz	r3, 1604a <signal_poll_event+0x3e>
		z_add_thread_to_ready_q(thread);
   16044:	4620      	mov	r0, r4
   16046:	f7f9 f877 	bl	f138 <z_add_thread_to_ready_q>
	event->state |= state;
   1604a:	68eb      	ldr	r3, [r5, #12]
   1604c:	f3c3 3204 	ubfx	r2, r3, #12, #5
   16050:	4316      	orrs	r6, r2
	event->poller = NULL;
   16052:	2000      	movs	r0, #0
	event->state |= state;
   16054:	f366 3310 	bfi	r3, r6, #12, #5
	event->poller = NULL;
   16058:	60a8      	str	r0, [r5, #8]
	event->state |= state;
   1605a:	60eb      	str	r3, [r5, #12]
	z_ready_thread(thread);

ready_event:
	set_event_ready(event, state);
	return 0;
}
   1605c:	bd70      	pop	{r4, r5, r6, pc}
		return -EAGAIN;
   1605e:	f06f 000a 	mvn.w	r0, #10
   16062:	e7fb      	b.n	1605c <signal_poll_event+0x50>

00016064 <add_event>:
{
   16064:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16066:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   16068:	e9d0 2300 	ldrd	r2, r3, [r0]
   1606c:	4290      	cmp	r0, r2
   1606e:	4604      	mov	r4, r0
   16070:	460d      	mov	r5, r1
   16072:	d106      	bne.n	16082 <add_event+0x1e>
	node->prev = list->tail;
   16074:	6863      	ldr	r3, [r4, #4]
   16076:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   16078:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   1607a:	602c      	str	r4, [r5, #0]
	list->tail->next = node;
   1607c:	601d      	str	r5, [r3, #0]
	list->tail = node;
   1607e:	6065      	str	r5, [r4, #4]
}
   16080:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   16082:	2b00      	cmp	r3, #0
   16084:	d0f6      	beq.n	16074 <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   16086:	689b      	ldr	r3, [r3, #8]
   16088:	6839      	ldr	r1, [r7, #0]
   1608a:	6818      	ldr	r0, [r3, #0]
   1608c:	f7ff fda7 	bl	15bde <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   16090:	2800      	cmp	r0, #0
   16092:	d1ef      	bne.n	16074 <add_event+0x10>
	return list->head == list;
   16094:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   16096:	42b4      	cmp	r4, r6
   16098:	d0ec      	beq.n	16074 <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   1609a:	2e00      	cmp	r6, #0
   1609c:	d0ea      	beq.n	16074 <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   1609e:	68b3      	ldr	r3, [r6, #8]
   160a0:	6838      	ldr	r0, [r7, #0]
   160a2:	6819      	ldr	r1, [r3, #0]
   160a4:	f7ff fd9b 	bl	15bde <z_is_t1_higher_prio_than_t2>
   160a8:	b128      	cbz	r0, 160b6 <add_event+0x52>
	node->prev = successor->prev;
   160aa:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   160ac:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   160b0:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   160b2:	6075      	str	r5, [r6, #4]
			return;
   160b4:	e7e4      	b.n	16080 <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   160b6:	6863      	ldr	r3, [r4, #4]
   160b8:	429e      	cmp	r6, r3
   160ba:	d0db      	beq.n	16074 <add_event+0x10>
   160bc:	6836      	ldr	r6, [r6, #0]
   160be:	e7ec      	b.n	1609a <add_event+0x36>

000160c0 <z_handle_obj_poll_events>:
	return list->head == list;
   160c0:	6803      	ldr	r3, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   160c2:	4298      	cmp	r0, r3
   160c4:	d009      	beq.n	160da <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   160c6:	e9d3 2000 	ldrd	r2, r0, [r3]
   160ca:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   160cc:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   160ce:	2200      	movs	r2, #0
	node->prev = NULL;
   160d0:	e9c3 2200 	strd	r2, r2, [r3]
{
	struct k_poll_event *poll_event;

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
		(void) signal_poll_event(poll_event, state);
   160d4:	4618      	mov	r0, r3
   160d6:	f7ff bf99 	b.w	1600c <signal_poll_event>
	}
}
   160da:	4770      	bx	lr

000160dc <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
   160dc:	4770      	bx	lr
